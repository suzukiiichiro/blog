---
title: "Ｎクイーン問題（２）ブルートフォース前前夜"
date: 2023-02-14T14:56:53+09:00
draft: false
authors: suzuki
image: shellscript.jpg
categories:
  - programming
tags:
  - エイト・クイーン
  - シェルスクリプト
  - Bash
  - アルゴリズム
  - 鈴木維一郎
---

前回の記事
N-Queens問題：Ｎクイーン問題（１）
https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/


エイト・クイーンのソース置き場 BashもJavaもPythonも！
https://github.com/suzukiiichiro/N-Queens


## ブルートフォース前前夜
ではさっそくＮクイーン問題を考えてみましょう。
この章では、可能性のあるすべての解を体系的に数え上げる方法を考えてみます。

まず、効き筋について。
```
        column(列)
   _4___3___2___1___0_
  |---|-*-|---|-*-|---|0
  +-------------------+
  |---|---|-*-|-*-|-*-|1
  +-------------------+ 
  |-*-|-*-|-*-|-Q-|-*-|2 row(行) 
  +-------------------+ 
  |---|---|-*-|-*-|-*-|3
  +-------------------+
  |---|-*-|---|-*-|---|4
  +-------------------+
```

チェスで言うところのクイーンの動きは、縦、横、斜めに直線の効き筋を持っています。
将棋の飛車と角を足した動きがクイーンです。

チェス盤は縦８ｘ横８のサイズなのですが、この章では少し小さめの５ｘ５で考えてみます。
この場合、Ｎが５ということで「５クイーン」と言われることが多いです。
さて５クイーンのルールは、

１．各縦（列）に一つのクイーンがあります。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

この場合、横の効き筋が効いてしまいますね。
横一列はエイトクイーンではありえません。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-*-|-*-|-*-|-*-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```
ということで、エイト・クイーンは、
１．縦に一つだけのクイーン
２．横に一つだけのクイーン
３．斜めに一つだけのクイーン
の３つを満たしている必要があります。

とはいえ、この章では、「縦の効き筋」のことだけを考えて作っていきます。
ですので「横の効き筋」と「斜めの効き筋」のことは一旦忘れてください。

では、まずは`0,0`のクイーンをひとつ下に移動します。
`col0,row0`のクイーンは`col0,row1`に移動しました。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|-Q-|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらにクイーンをひとつ下に移動します。
`col0,row1`から`col0,row2`へ移動しました。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|-Q-|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらにひとつ下に移動します。
`col0,row3`へ移動しました。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|-Q-|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらにひとつ下に移動します。
`col0,row4`へ移動しました。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|-Q-|4
  +-------------------+
```

ここで`col0,row4`のクイーンは一番下まできたわけです。
こうなると`col0,row4`のクイーンは最下部へ到達し、もう下にはいけなくなりました。
ここで桁上りの処理で、col0列のクイーンは`col0,row0`へ戻り、`col1,row0`のクイーンがひとつ下に移動します。
図で表すと以下のようになります。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

ここからは先程の動きの繰り返しで、`col0`列のクイーンは一つずつ下に最下部へ到達するまでおりていきます。

`col0,row1`へ移動しました。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|-Q-|-Q-|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらに下に移動します。
`col0,row2`へ移動しました。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|-Q-|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらに下に移動します。
`col0,row3`へ移動しました。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|-Q-|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

さらに下に移動します。
`col0,row4`へ移動しました。
`col0`列のクイーンは最下部へ到達しました。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|-Q-|4
  +-------------------+
```

こうなると`col0,row4`のクイーンはまた`col0,row0`へ戻り、`col1,row1`のクイーンもひとつ下におります。
図で表すと以下のようになります。
`col0,row4`のクイーンは`col0,row0`へ戻り、col1列のクイーンは`col1,row2`へ移動します。
```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|-Q-|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

クイーンは、最下部へ到達すると、最上部へ戻り、隣のクイーンがひとつ下に降ります。
以下の場合はどうなりますか？

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|-Q-|-Q-|4
  +-------------------+
```

この場合は、`col1,row4`のクイーンと、`col0,row4`のクイーンは最上部にもどり、`col2`列のクイーンが`col2,row1`へ移動します。
図で表すと以下のとおりです。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|---|-Q-|-Q-|0
  +-------------------+
  |---|---|-Q-|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

こうしたことからわかることは、`col0`列のクイーンは最も反復が多く、次に`col1`列目、`col2`列目、`col3`列目のクイーンが忙しく動くことがわかります。

処理が終わる直前の状態として以下の場合は考えてみます。
`col4`列目、`col3`列目、`col2`列目、`col1`列目のクイーンが最下部にあるとします。
`col0`列目のクイーンが順を追って最下部へ向かって移動を繰り返します。

```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |-Q-|-Q-|-Q-|-Q-|---|4
  +-------------------+
```


`col0`列目のクイーンが最下部へ到達すると処理は終了します。
処理が終了したときのボード画面は以下のとおりです。


```
        column(列)
   _4___3___2___1___0_
  |---|---|---|---|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |-Q-|-Q-|-Q-|-Q-|-Q-|4
  +-------------------+
```


## ボードの動きを数値で表す

プログラムで処理するので、ボードの盤面を数字で表すことにします。
例えば下のボード画面は、`col4` `col3` `col2` `col1` `col0` の row の場所を使って
`0,0,0,0,0` とします。

```
0,0,0,0,0

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

以下の場合は、`0,0,0,0,1`となります。

```
0,0,0,0,1

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|-Q-|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

以下は、`0,0,0,0,2` となります。
```
0,0,0,0,2

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|-Q-|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

以下は、`0,0,0,1,0`となります。
```
0,0,0,1,0

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|-Q-|0
  +-------------------+
  |---|---|---|-Q-|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

以下はどうなりますか？

```
0,0,0,4,4

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|---|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|-Q-|-Q-|4
  +-------------------+
```
`0,0,0,4,4`となります。
処理終了直前のボード画面が以下の通りだったとします。
```
0,4,4,4,4

        column(列)
   _4___3___2___1___0_
  |-Q-|---|---|---|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|-Q-|-Q-|-Q-|-Q-|4
  +-------------------+
```

`0,4,4,4,4` ですね。
処理が終了した段階で`4,4,4,4,4` となります。

```
0,4,4,4,4

        column(列)
   _4___3___2___1___0_
  |---|---|---|---|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |-Q-|-Q-|-Q-|-Q-|-Q-|4
  +-------------------+
```



## 挙動をプログラムに置き換えてみます。
(※)この章の挙動は、各行に１個の王妃を配置する組み合わせを、列挙するだけで、Ｎクイーン問題を解いているわけではありません。
なんと言ってもエイト・クイーンにある３つのルール
１．縦列に一つだけのクイーン
２．横列に一つだけのクイーン
３．斜め列に一つだけのクイーン

の１を満たしているに過ぎません。

ということで、気を取り直して
`NQueen.sh` ファイルを作成してください。

``` bash:NQueen.sh
#!/usr/bin/bash

function N-Queen01(){
 : # まだなにもない
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```

ファイルを実行するとファイル最下部の `NQ`が実行され、`function NQ()`が呼び出されます。
現在の`function NQ()`は`echo`と `N-Queen01`関数の呼び出しがあるだけです。
```
  N-Queen01 0 5;
```
にあるとおり、`N-Queen01()`関数に、２つのパラメータ `0 8` を渡しています。

`function N-Queen01()`関数の中身はまだなにもありませんが、渡された２つのパラメータを、`N-Queen01()`関数の冒頭で明示的に変数へ代入しています。

``` bash
function N-Queen01(){
  local -i min="$1";
  local -i size="$2";

```
２つの変数 `min` と `size` は、この関数でしか使わないローカル変数なので、明示的に`local`としておきます。
`local` の後ろに続く `-i` は、代入される値が数値であることを定義しています。
関数パラメータの `$1` や `$2` といった変数は、関数の冒頭で必ずダブルクォーテーションで囲みましょう。
ここまでのソースは以下のとおりです。

``` bash:NQueen.sh
#!/usr/bin/bash

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```


次は、`for`ループ部分についてです。
もっとも激しく動いていたクイーンは`col0`列のクイーンでした。
逆に、もっとも動きの小さなクイーンは`col4`列のクイーンでしたね。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|---|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|-Q-|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

この場合、２つの`for`ループで表現します。
外側の`for`ループは`col`の横移動を表します。
内側の`for`ループは`row`の縦移動を表すことにしましょう。

５ｘ５の５クイーンをプログラム化します。
外側の `for` ループは以下の通りとなります。
`col0` 列目から順を追って`col1`，`col2`，`col3`，`col4` 列目までたどっていきます。


``` bash
  for((col=0;col<size;col++)){
    : # まだなにもない
  }
```


さて、デバッグも兼ねて動きをひとつひとつ見ていくことにします。
良い方法として、実行して処理のステップを順を追って目視で確認していきたいところです。

```
read -p "なにかキーを入力してください"
```

こんなコマンドをソースに埋め込んでみます。
さらにコメント部分に、ウォッチしておきたい変数を埋め込みます。

``` bash:NQueen.sh
#!/usr/bin/bash

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     read -p "col: $col size: $size min: $min";
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```

実行結果は以下のとおりです。
```
bash-3.2$ bash N-Queens.sh
<>１．ブルートフォース（力まかせ探索） N-Queen01()
col: 0 size: 5 min: 0
col: 1 size: 5 min: 0
col: 2 size: 5 min: 0
col: 3 size: 5 min: 0
col: 4 size: 5 min: 0
bash-3.2$
```


```
      外側のループ `col` は左方向へたどります。

    ←　←　←　←　←

        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|-Q-|0
  +-------------------+
  |---|---|---|---|---|1
  +-------------------+ 
  |---|---|---|---|---|2 row(行) 
  +-------------------+ 
  |---|---|---|---|---|3
  +-------------------+
  |---|---|---|---|---|4
  +-------------------+
```

次は`row`列の縦移動を作ってみます。
この動きは外側の`for`ループの内側にもう一つ`for`ループをおいて、クイーンの縦の動きを表現すると良さそうです。

```
        column(列)
   _4___3___2___1___0_
  |-Q-|-Q-|-Q-|-Q-|-Q-|0        ↓   
  +-------------------+             
  |---|---|---|---|---|1        ↓  
  +-------------------+             
  |---|---|---|---|---|2 row(行)↓   
  +-------------------+             
  |---|---|---|---|---|3        ↓  
  +-------------------+             
  |---|---|---|---|---|4        ↓  
  +-------------------+             
```

ソースは以下のとおりです。
`read -p` で出力を確認することができてとても便利です。

``` bash:N-Queens.sh
#!/usr/bin/bash

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     for((row=0;row<size;row++)){
        read -p "col: $col row: $row size: $size min: $min";
     }
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```

実行結果は以下のとおりです。
```
bash-3.2$ bash N-Queens.sh
<>１．ブルートフォース（力まかせ探索） N-Queen01()
col: 0 row: 0 size: 5 min: 0
col: 0 row: 1 size: 5 min: 0
col: 0 row: 2 size: 5 min: 0
col: 0 row: 3 size: 5 min: 0
col: 0 row: 4 size: 5 min: 0
col: 1 row: 0 size: 5 min: 0
col: 1 row: 1 size: 5 min: 0
col: 1 row: 2 size: 5 min: 0
col: 1 row: 3 size: 5 min: 0
col: 1 row: 4 size: 5 min: 0
col: 2 row: 0 size: 5 min: 0
col: 2 row: 1 size: 5 min: 0
col: 2 row: 2 size: 5 min: 0
col: 2 row: 3 size: 5 min: 0
col: 2 row: 4 size: 5 min: 0
col: 3 row: 0 size: 5 min: 0
col: 3 row: 1 size: 5 min: 0
col: 3 row: 2 size: 5 min: 0
col: 3 row: 3 size: 5 min: 0
col: 3 row: 4 size: 5 min: 0
col: 4 row: 0 size: 5 min: 0
col: 4 row: 1 size: 5 min: 0
col: 4 row: 2 size: 5 min: 0
col: 4 row: 3 size: 5 min: 0
col: 4 row: 4 size: 5 min: 0
bash-3.2$
```

`row` が 0から4まで行きつくと、`col`が一つインクリメントしていく挙動が見て取れますね。


さて、`col0` が最下部へ達したら `col1` へ。その次は `col2` へと桁上りするプログラムを書いてみます。
細かいところがわからないと思いますが、ここでは気にせずに先に進んでください。
ここで大事なことは `col0` から桁上りしない　ということです。
なぜでしょうか。まず実行結果も含めてみてください。

``` bash N-Queens.sh
#!/usr/bin/bash

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     if((min==size-1));then
       for((row=0;row<size;row++)){
          echo -n " ${pos[row]} "
       }
       echo "";  # 改行
      else
        N-Queen01 "$((min+1))" "$size"; 
     fi
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```



実行結果は以下のとおりです。
```
bash-3.2$ bash N-Queens.sh
 0  0  0  0  1
 0  0  0  0  2
 0  0  0  0  3
 0  0  0  0  4
bash-3.2$
```

`col0` の処理で終わってしまっています。
この理由は再帰処理に使われる変数の定義が原因なのです。
以下の２行を関数の冒頭に加えるだけで動くようになります。

```
  local -i col=0;         # 再帰に必要
  local -i row=0;         # 再帰に必要
```

ここも少しだけ言及しておきます。

```
        N-Queen01 "$((min+1))" "$size"; 
```

`$((min+1))` の部分はインクリメントしているわけですが、`$((min++))` ではきちんと処理はなされません。
明示的に `min+1` とする必要があります。
再帰に関していくつか注意しなければいけないこともありますが、まずは動かしてみて、自分が自分を呼び出すときに `min+1` のように一つ値を加算して、`min==size-1` のように基底条件を
わすれずに添えることを忘れないでください。

上記のことを含めたソースは以下のとおりです。

``` bash:N-Queens.sh
#!/usr/bin/bash

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  local -i col=0;         # 再帰に必要
  local -i row=0;         # 再帰に必要
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     if((min==size-1));then
       for((row=0;row<size;row++)){
          #read -p "col: $col row: $row size: $size min: $min";
          echo -n " ${pos[row]} "
       }
       echo "";  # 改行
      else
        N-Queen01 "$((min+1))" "$size"; 
     fi
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```


実行結果
```
<>１．ブルートフォース（力まかせ探索） N-Queen01()
 0  0  0  0  0 
 0  0  0  0  1 
 0  0  0  0  2 
 0  0  0  0  3 
 0  0  0  0  4 
 0  0  0  1  0 
 0  0  0  1  1 
 0  0  0  1  2 
 0  0  0  1  3 
:
:
:
 4  4  4  1  2 
 4  4  4  1  3 
 4  4  4  1  4 
 4  4  4  2  0 
 4  4  4  2  1 
 4  4  4  2  2 
 4  4  4  2  3 
 4  4  4  2  4 
 4  4  4  3  0 
 4  4  4  3  1 
 4  4  4  3  2 
 4  4  4  3  3 
 4  4  4  3  4 
 4  4  4  4  0 
 4  4  4  4  1 
 4  4  4  4  2 
 4  4  4  4  3 
 4  4  4  4  4 
```

なんか動くようになりました!


`echo -n` は、出力する際に改行を行わないオプションです。
連続して出力されますので、空白を含めています。
`else` の直前で `echo ""` を使って改行を行っています。

さて、どのくらいのステップが必要となるのかも知りたいところです。
カウンターとして変数 `COUNT` をソースの冒頭で宣言してみます。

``` bash
declare -i COUNT=0;
```

`if` 文の直後で `COUNT` をインクリメントしています。
インクリメントは ((COUNT++)) で実行できますが、実行の値を引き出すために、$((COUNT++)) と `$` をつけています。
`echo -n` で出力しつつ $((COUNT++)) でインクリメントしているわけですが、分割して書くと以下のようになります。

``` bash
((COUNT++));
echo -n "$COUNT: "; 
```


ソースは以下のとおりです。

``` bash:N-Queens.sh
#!/usr/bin/bash

declare -i COUNT=0;

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  local -i col=0;         # 再帰に必要
  local -i row=0;         # 再帰に必要
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     if((min==size-1));then
       echo -n "$((COUNT++)): "
       for((row=0;row<size;row++)){
          echo -n " ${pos[row]} "
       }
       echo "";  # 改行
      else
        N-Queen01 "$((min+1))" "$size"; 
     fi
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```

実行結果は以下のとおりです。

```
3106:  4  4  4  1  1 
3107:  4  4  4  1  2 
3108:  4  4  4  1  3 
3109:  4  4  4  1  4 
3110:  4  4  4  2  0 
3111:  4  4  4  2  1 
3112:  4  4  4  2  2 
3113:  4  4  4  2  3 
3114:  4  4  4  2  4 
3115:  4  4  4  3  0 
3116:  4  4  4  3  1 
3117:  4  4  4  3  2 
3118:  4  4  4  3  3 
3119:  4  4  4  3  4 
3120:  4  4  4  4  0 
3121:  4  4  4  4  1 
3122:  4  4  4  4  2 
3123:  4  4  4  4  3 
3124:  4  4  4  4  4 
```

## 速度の最適化
やっぱり処理時間は速いに越したことはありませんね。
処理速度のボトルネックの多くはファイルや画面への出力になります。
`echo -n` は 外側の `for` でも出力していますが、もっとも回転回数の多い内側の `for` でも使われています。
この２箇所の出力は画面に出力することなく、変数に入れるだけにして、内側の `for` を抜けたときにまとめて画面出力することが速度改善に繋がります。

``` bash:N-Queen.sh
#!/usr/bin/bash

declare -i COUNT=0;       # カウンター

function N-Queen01(){
  local -i min="$1";
  local -i size="$2";
  local -i col=0;         # 再帰に必要
  local -i row=0;         # 再帰に必要
  local sEcho="";         # 出力用変数
  for((col=0;col<size;col++)){
     pos[$min]="$col";
     if((min==size-1));then
       # echo -n "$((COUNT++)): "
       # 画面出力はせず変数に格納
       sEcho="$((COUNT++)): ";  
       for((row=0;row<size;row++)){
          #echo -n " ${pos[row]} "
          # 画面出力はせず変数に格納
          sEcho="${sEcho}${pos[j]} ";
       }
       # echo "";  # 改行
       # ここでまとめて画面に出力
       # -n オプションは付けずに改行付きで出力します。
       echo "$sEcho"     # flush出力
      else
        N-Queen01 "$((min+1))" "$size";  # 再帰
     fi
  }
}
#
function NQ(){
  echo "<>１．ブルートフォース（力まかせ探索） N-Queen01()";
  N-Queen01 0 5;
}
# 
NQ;
```


## ８ｘ８の出力結果
参考までに８ｘ８の実行結果は以下のとおりです。
以下の部分を８とすればよいですね。
``` bash
  # N-Queen01 0 5;
  N-Queen01 0 8;
```

実行方法
```
$ bash N-Queens.sh
```

```
:
:
:
:
16777193: 7 7 7 7 7 7 5 0
16777194: 7 7 7 7 7 7 5 1
16777195: 7 7 7 7 7 7 5 2
16777196: 7 7 7 7 7 7 5 3
16777197: 7 7 7 7 7 7 5 4
16777198: 7 7 7 7 7 7 5 5
16777199: 7 7 7 7 7 7 5 6
16777200: 7 7 7 7 7 7 5 7
16777201: 7 7 7 7 7 7 6 0
16777202: 7 7 7 7 7 7 6 1
16777203: 7 7 7 7 7 7 6 2
16777204: 7 7 7 7 7 7 6 3
16777205: 7 7 7 7 7 7 6 4
16777206: 7 7 7 7 7 7 6 5
16777207: 7 7 7 7 7 7 6 6
16777208: 7 7 7 7 7 7 6 7
16777209: 7 7 7 7 7 7 7 0
16777210: 7 7 7 7 7 7 7 1
16777211: 7 7 7 7 7 7 7 2
16777212: 7 7 7 7 7 7 7 3
16777213: 7 7 7 7 7 7 7 4
16777214: 7 7 7 7 7 7 7 5
16777215: 7 7 7 7 7 7 7 6
16777216: 7 7 7 7 7 7 7 7

real	43m42.887s
user	42m39.067s
sys	0m41.138s
bash-3.2$
```

４３分かかりました。^^;

16777216: 77777777
16,777,216 １千６百７７万ステップもかかりましたね。



## ひとこと
今回は、縦列に一つだけのクイーンを配置するという一つのルールで処理しました。
次回は、横行に一つだけのクイーンを配置するというルールを追加して処理してみます。

次回からは以下はだめで
```
  　　       column(列)
  row(行)_0___1___2___3___4_
       0|-Q-|-Q-|---|---|---|
        +-------------------+
       1|---|---|---|---|---|
        +-------------------+ 
       2|---|---|---|---|---| 
        +-------------------+ 
       3|---|---|---|---|---|
        +-------------------+
       4|---|---|---|---|---|
        +-------------------+
```

以下ならよし、という感じです。
では次回をお楽しみに。

```
  　　       column(列)
  row(行)_0___1___2___3___4_
       0|-Q-|---|---|---|---|
        +-------------------+
       1|---|-Q-|---|---|---|
        +-------------------+ 
       2|---|---|---|---|---| 
        +-------------------+ 
       3|---|---|---|---|---|
        +-------------------+
       4|---|---|---|---|---|
        +-------------------+
```


次の記事
Ｎクイーン問題（３）ブルートフォース前夜
https://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/
過去記事
N-Queens問題：Ｎクイーン問題（２）ブルートフォース前前夜
https://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（１）について
https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/


## 書籍の紹介
{{% amazon

title="詳解 シェルスクリプト 大型本  2006/1/16"

url="https://www.amazon.co.jp/gp/proteect/4873112672/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4873112672&linkCode=as2&tag=nlpqueens09-22&linkId=ef087fd92d3628bb94e1eb10cb202d43"

summary=`Unixのプログラムは「ツール」と呼ばれます。
Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。
そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。
また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。
つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。
本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。
標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、
目的の処理を実現するための方法を詳しく学ぶことができます。
`
imageUrl="https://m.media-amazon.com/images/I/51EAPCH56ML._SL250_.jpg"
%}}

{{% amazon

title="UNIXシェルスクリプト マスターピース132"

url="https://www.amazon.co.jp/gp/proteect/4797377623/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797377623&linkCode=as2&tag=nlpqueens09-22&linkId=3c8d4566263ae99374221c4f8f469154"

summary=`すべてのUNIXエンジニア必携!!

サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。
知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。
`
imageUrl="https://m.media-amazon.com/images/I/51R5SZKrEAL._SL250_.jpg"
%}}


{{% amazon

title="[改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB+DB PRESS plus) 単行本（ソフトカバー）  2017/1/20"

url="https://www.amazon.co.jp/gp/proteect/4774186945/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4774186945&linkCode=as2&tag=nlpqueens09-22&linkId=8ef3ff961c569212e910cf3d6e37dcb6"

summary=`定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。
シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。
本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、
基本から丁寧に解説。
第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。
合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。
ますますパワーアップした改訂版をお届けします。`
imageUrl="https://m.media-amazon.com/images/I/41i956UyusL._SL250_.jpg"
%}}

{{% amazon

title="新しいシェルプログラミングの教科書 単行本"

url="https://www.amazon.co.jp/gp/proteect/4797393106/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797393106&linkCode=as2&tag=nlpqueens09-22&linkId=f514a6378c1c10e59ab16275745c2439"

summary=`エキスパートを目指せ!!

システム管理やソフトウェア開発など、
実際の業務では欠かせないシェルスクリプトの知識を徹底解説

ほとんどのディストリビューションでデフォルトとなっているbashに特化することで、
類書と差別化を図るとともに、より実践的なプログラミングを紹介します。
またプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。
イマドキのエンジニア必携の一冊。

▼目次
CHAPTER01 シェルってなんだろう
CHAPTER02 シェルスクリプトとは何か
CHAPTER03 シェルスクリプトの基本
CHAPTER04 変数
CHAPTER05 クォーティング
CHAPTER06 制御構造
CHAPTER07 リダイレクトとパイプ
CHAPTER08 関数
CHAPTER09 組み込みコマンド
CHAPTER10 正規表現と文字列
CHAPTER11 シェルスクリプトの実行方法
CHAPTER12 シェルスクリプトのサンプルで学ぼう
CHAPTER13 シェルスクリプトの実用例
CHAPTER14 テストとデバッグ
CHAPTER15 読みやすいシェルスクリプト
`
imageUrl="https://m.media-amazon.com/images/I/41d1D6rgDiL._SL250_.jpg"
%}}



