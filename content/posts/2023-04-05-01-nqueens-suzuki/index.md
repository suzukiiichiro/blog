---
title: "Ｎクイーン問題（１３）第三章　ビットマップ"
date: 2023-04-05T19:08:30+09:00
draft: false
authors: suzuki
image: shellscript.jpg
categories:
  - programming
tags:
  - エイト・クイーン
  - シェルスクリプト
  - Bash
  - アルゴリズム
  - 鈴木維一郎
---

## ビットマップ
Ｎ×ＮのチェスボードのＮ個のクイーンの配置を、bitwise(ビット)で表したものが`bitmap`(ビットマップ)です。

## ビットマップの特徴
斜め方向にクイーンを配置したかどうかを、`left` `down` `right` といった `bit` フラグで表します。

大きなメリットは、
１．ビットマップであれば、シフト(`<<1` ,`>>1`)により高速にデータを移動できる。
２．配置フラグといったフラグ配列では、データの移動に O(N) の時間がかかるが、ビットマップであれば O(1)ですむ。
３．フラグ配列のように斜め方向に `2*N-1` の要素を用意する必要はなく `Nビット`で充分たりる。
４．ビットは初期値が０なので扱いやすい

デメリットとしては
２進数と１０進数により難読化が極まっている。


## 実践、ビットマップ！
Ｎ５のボードレイアウト
```
 4 2 0 3 1  ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| |O| | | | 01000
+-+-+-+-+-+
```

各行(row)の状態をbitwise（ビットワイズ）で表現します。
クイーンが置いてある位置の`bit`（ビット）をON（１）にします。

バックトラッキングは行(row=0)から下に向かって順に、クイーンが配置できた場所の`bit`をON（１）にして、その後rowが一つインクリメントします。

```
 4         ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```


```
 4 2       ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0     ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0 3   ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

```
 4 2 0 3 1  ↓ bitmapで表現
+-+-+-+-+-+
| | | | |O| 00001
+-+-+-+-+-+
| | |O| | | 00100
+-+-+-+-+-+
|O| | | | | 10000
+-+-+-+-+-+
| | | |O| | 00010
+-+-+-+-+-+
| |O| | | | 01000
+-+-+-+-+-+
```



## 効き筋
次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。

```
left
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | |L| | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

```
down
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | | |D| |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

```
right
+-+-+-+-+-+
| | | |Q| |
+-+-+-+-+-+
| | | | |R|
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

左下に効き筋が進む(left)、真下に効き筋が進む(down)、右下に効き筋が進む(right)３つです。
その３つのビットフィールドをそれぞれ、left, down, right と呼ぶことにします。

まずは `row0` にクイーンを配置します。

```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

次に、`row0` のビットフィールドから `row+1` 番目のビットフィールド、ようするにひとつ下の `row1` に探索を進め、

```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | | | ←ここ
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```

`row0`のビットフィールドでクイーンが配置されている `bit` と、
```
Qの配置
+-+-+-+-+-+
| | | |Q| | 00010 = bit
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
| | | | | |
+-+-+-+-+-+
```



３つのビット `left` `down` `right` を使って、効き筋をチェックします。

効き筋は「ＯＲ演算」を使います。

ビット演算に関しては以下のリンクがおすすめです。
[ビット演算入門](https://qiita.com/Ingward/items/43acda931c8a62c70d2f)



leftはひとつ左に
```
left
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | |L| | | 00100
+-+-+-+-+-+
```

downはそのまま下に、
```
down
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | |D| | 00010
+-+-+-+-+-+
```

rightはひとつ右へ
```
right
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | | |R| 00001
+-+-+-+-+-+
```

こういったロジックで `row+1` 番目の効き筋をチェックします。



## bit（ビット）
クイーンの位置は「Q」です。
Qを配置した場合、そのposition（場所）は`bit`で表します。
`bit`（ビット）には、クイーンが配置されるとその位置が格納されるわけです。

以下の場合、`bit`は `00010` となります。

`row0`にQが配置された
```
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
```

ここで`bit`の操作が複雑となる原因のひとつ、
「00010」というクイーンの位置情報は、そのまま`bit`に格納されるのではありません。

`bit`には`00010` という場所の情報が格納されるわけですが、

「00001」の場合は「 1」
「00010」の場合は「 2」
「00100」の場合は「 4」
「01000」の場合は「 8」
「10000」の場合は「16」

が格納されることになります。

「はぁ？」

まず、
「00001」という並びは０と１でなりたつ表現方法で「２進数」といいます。
また、１０で桁上りをする表現方法はおなじみの「１０進数」といいます。

```
00010   　２進数
    2   １０進数 (00010を１０進数にすると 2 になる）
```



２進数を１０進数に置き換える早見表
```
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   0   0   0   0   0   0
```

２進数 `00010` を１０進数に置き換えた値が知りたいは、早見表を使うと１０進数では `4` となります。

```
２進数を１０進数に置き換える早見表
10進数  16   8   4   2   1
 2進数   0   0   1   0   0
```

ということで、クイーンの位置が `00100` の場合は、`4` が `bit`に格納されます。

bashでは２進数を１０進数に変換して出力する方法が用意されています。
```
bash-3.2$ echo $(( 2#00001 ))
1
bash-3.2$ echo $(( 2#00010 ))
2
bash-3.2$ echo $(( 2#00100 ))
4
bash-3.2$ echo $(( 2#01000 ))
8
bash-3.2$ echo $(( 2#10000 ))
16
bash-3.2$
```

＃（シャープ）の前の数字は２進数であることを示しています。
２進数 `00100` の１０進数の値が知りたければ、次のようにします。
```
bash-3.2$ echo $(( 2#00100 ))
4
```


余談ですが（余談ということでもないのですが）、
Ｎが８の場合で、`00010000` というクイーン配置の場合
```
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   0   1   0   0   0   0
```

早見表の通り、１０進数では「16」となります。
当然、bashでも求めることができます。
```
bash-3.2$ echo $(( 2#00010000 ))
16
```

さらに余談ですが（これは本当に余談）、ビットフィールドに複数の`bit`がON（１）である場合、例えば「00101010」のような場合は、以下のように計算します。
（（一行にクイーンが３つもある！！）

```
00101010 
10進数  128  64  32  16   8   4   2   1
 2進数    0   0   1   0   1   0   1   0
```

この場合は、`bit`が立っている（と言います）10進数の値をを足し合わせることで表現できます。

ビットが立っている（１となっている）のは、３２と８と２ですから、
```
32 + 8 + 2 = 42
```
となります。

bashでも確認してみます。
```
bash-3.2$ echo $(( 2#00101010 ))
42
```

おお、いい感じですね。着いてきていますか？



## Qの位置を確認
では、まずはQのposition（位置）を確認します。

```
Q
+-+-+-+-+-+
| | | |Q| | 00010=bit といいます。
+-+-+-+-+-+
| | | | | | 
+-+-+-+-+-+
```

Qのpositionは `00010` です。
１０進数では以下の早見表で見つけると良いです。

Qが置かれている`bit`の値は「00010」です
```
10進数  16   8   4   2   1
 2進数   0   0   0   1   0
```

10進数では「2」ですね。

まず、Qのpositionがわかりました。
Qのpositionを`bit`と言います。
通常、`bit`は変数名も`bit`とします。
```
bit = Q = 2#00010 = 2
```


## row + 1 のleftの効き筋をチェック）してみます

```
left
+-+-+-+-+-+
| | | |Q| | 00010 (`bit`)
+-+-+-+-+-+
| | |L| | | ←ここ
+-+-+-+-+-+
```

「L」は「Q」の真下（`row+1`）を左に一つずらした位置となります。
ビット演算では以下のようになります。Lはleftを表しています。
```
( left | bit)<<1
```

`( left | bit)` といった表現を「ＯＲ演算」と言います。

`left` にはこの段階では値が何も入っていませんので「0」となります。
要するに初期値「０」のまま計算します。

前項で求めたとおり、Qである`bit`は以下の通りでした。
```
bit = Q = 2#00010 = 2
```

`left`は、初期値「０」な訳ですから、
```
( left | bit )
(   0  |  2  )
```

という計算式になります。
bashで計算してみましょう。
```
bash-3.2$ echo $(( (2|0) ))
2
bash-3.2$
```

「２」とでました。
さらに左に一つシフト（<<1）してみます。
こうなりますね。
```
( left | bit )<<1
(   0  |  2  )<<1
```

bashで計算してみます。
```
bash-3.2$ echo $(( (2|0)<<1 ))
4
bash-3.2$
```

「４」とでました。
「４」の２進数はなんでしょう？
さっそく早見表で確認しましょう。
```
10進数  16   8   4   2   1
 2進数   0   0   1   0   0
```

`00100` という事ですね。

Qが置かれている場所が「00010」で、
Lは「00100」となったわけです。
図で表すと以下のとおりです。

```
left
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | |L| | | 00100 (left|bit)<<1
+-+-+-+-+-+
```

ということで、Qの位置から左に一つずれているのがわかります。
Qを配置して`left`を使って左下の効きを簡単に求めることができました。
```
left  = ( left |  bit  )<<1
00100 = (  0   | 00010 )<<1
  4   = (  0   |   2   )<<1
```

`row0`にある Q の位置「00010」の、ひとつ下の `row1` の`left`の効き筋は `(left|bit)<<1` という計算式を用いて、「00100」となりました。
言い換えると、Qの位置を`bit`にして、`(left|bit)<<1`とすることで、ビットの位置を一つ左にシフトして、Qの`left`の効き筋を求めることができたということになります。


## row + 1 のdownの効き筋をチェック）してみます
leftの場合は、( left | bit )<<1 ということをしてQの位置から左に一つずらした位置を求めました。

downはleftのように左に一つずらしたりする必要はありません。
Qの位置からましたに下ろすだけですから値は同じなのです。
```
down
+-+-+-+-+-+
| | | |Q| | 00010
+-+-+-+-+-+
| | | |D| | 00010 (down|bit)
+-+-+-+-+-+
```

```
down  = ( down |  bit  )
00010 = (  0   | 00010 )
  2   = (  0   |   2   )
```

bashでも確認してみます。
``` 
bash-3.2$ echo $(( (0|2) ))
2
bash-3.2$
```

down は 2#00010 ですので 2 です。


ここまでをまとめると以下のとおりです。
```
bit = Q = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

left = (left|bit)<<1 = 2#00100 = 4
10進数  16   8   4   2   1
 2進数   0   0   1   0   0

down = (down|bit)    = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0
```

## row + 1 のrightの効き筋をチェック
rightはleft同様にシフトするわけですが、今度は右へシフトします。

```
right
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | | | |R| 00001 (R)  (right|bit)>>1
+-+-+-+-+-+
```

```
right = ( right |  bit  )>>1
00010 = (   0   | 00010 )>>1
  1   = (   0   |   2   )>>1
```

bashでも確認してみます。
```
bash-3.2$ echo $(( (0|2)>>1 ))
1
bash-3.2$
```

ここまでをまとめると以下のとおりです。
```
bit = Q = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

left = (left|bit)<<1 = 2#00100 = 4
10進数  16   8   4   2   1
 2進数   0   0   1   0   0

down = (down|bit)    = 2#00010 = 2
10進数  16   8   4   2   1
 2進数   0   0   0   1   0

right =(right|bit)>>1= 2#00001 = 1
10進数  16   8   4   2   1
 2進数   0   0   0   0   1
```


## mask（マスク）
ここまでで３つのフラグを用いてQの効き筋を求めてきました。
```
left+down+right
+-+-+-+-+-+
| | | |Q| | 00010 (bit)
+-+-+-+-+-+
| | |L|D|R| 00111 (left|down|right)
+-+-+-+-+-+
```

３箇所の効き筋を演算子を使うと
```
(left|down|right) 
```
となり、こうした表現を「ＯＲ演算」と言います。



さて、`row + 1` 番目のビットフィールドを探索して、`left` `down` `right` の３つのbitフラグを「ＯＲ演算」したビットフィールドを作りました。

ＯＮ（１）になっている位置は効き筋に当たるので置くことができません。

`row`にQを配置して、
```
+-+-+-+-+-+  row
| | | |Q| |   0  今、自分はここにいて
+-+-+-+-+-+
| | | | | |   1
+-+-+-+-+-+
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

自分がいる `row` の一つしたの「row+1」のビットフィールドを探索するために、
```
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+
|*|*|*|*|*|   1  この行(row)を順番に探索する
+-+-+-+-+-+
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

`left` `down` `right` の３つのフラグを使って、効きををチェックします。

`left` `down` `right` のいずれかがＯＮ（１）になっていたら効き筋に当たるから、その場所にはクイーンは配置できませんね。
という意味になります。

```
+-+-+-+-+-+  row
| | | |Q| |   0  bit  =      Q        = 2#00010 = 2
+-+-+-+-+-+      left = (left|bit)<<1 = 2#00100 = 4
|*|*|L|D|R|   1  down = (down|bit)    = 2#00010 = 2
+-+-+-+-+-+      right= (right|bit)>>1= 2#00001 = 1
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

そこで、上記の図の２箇所（アスタリスク＊の場所）がクイーンを配置することがが可能です。
この２箇所のアスタリスクは場所を簡単に得ることができます。

以下の通り、`left` は4 `down` は2 `right` は1 です。
```
bit  =      Q        = 2#00010 = 2

left = (left|bit)<<1 = 2#00100 = 4
down = (down|bit)    = 2#00010 = 2
right= (right|bit)>>1= 2#00001 = 1
```

効き筋 `(left|down|right)` は、次のように求めることができます。
``` 
(4|2|1)
```

と、なります。
bashで確認すると以下のとおりです。
```
bash-3.2$ echo $(( (4|2|1) ))
7
bash-3.2$
```

「７」となりました。これを２進数で表すと
```
bash-3.2$ bc <<<"ibase10;obase=2;7"
111
bash-3.2$
```

「１１１」ですから５ビットにすると
`2#00111` となります。

そこで、以下のアスタリスクの部分を求めるには「反転」という演算をおこないます。
```
+-+-+-+-+-+  row
| | | |Q| |   0  bit  =      Q        = 2#00010 = 2
+-+-+-+-+-+      left = (left|bit)<<1 = 2#00100 = 4
|*|*|L|D|R|   1  down = (down|bit)    = 2#00010 = 2
+-+-+-+-+-+      right= (right|bit)>>1= 2#00001 = 1
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

ここで、`2#11000`を求めることができれば、それがクイーンを配置することができる場所ということになります。

`2#11000` をbashで求めると`24`になります。
```
bash-3.2$ echo $(( 2#11000 ))
24
bash-3.2$
```

演算で求める場合は、「反転」という演算を使います。
(L|D|R) の 反転はチルダ「〜」を使います。
``` bash
~(L|D|R)
```

では、先に求めた「２４」になるかを確認してみましょう。

```
bash-3.2$ echo $(( (4|2|1) ))
7
bash-3.2$ echo $(( ~(4|2|1) ))
-8
bash-3.2$ 
```
なりませんね。。。

ここでmask(マスク）を使います。
maskとは、ビットフィールドのビットをすべて立てたものです。

```
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|M|M|M|M|M|   1  mask=2#11111
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

このmaskは簡単に求めることができます。

``` bash
mask=$(( (1<<size)-1 ));
```

Ｎ５の場合、２進数で求めると「３１」になります。
```
bash-3.2$ echo $(( 2#11111 ))
31
```

`mask`は、size=5 `( 1<<size )-1` という計算式で求めることができます。
```
bash-3.2$ echo $(( (1<<5)-1 ))
31
```

このmaskを使って
１．`left` `down` `right`の３つのビットを使って効きの場所を特定
```
(left|down|right)

+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
| | |L|D|R|   1  00111
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

２．反転させる 
```
~(left|down|right)
```

２．maskですべての配置箇所のビットをＯＮ（１）にする
```
maskを使ってすべてのビットを立てる

size=5;
mask=$(( (1<<size)-1 ));
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|M|M|M|M|M|   1  11111
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

３．maskから~(left|down|right)を間引いた値を`bitmap`に格納
```
bitmap=$(( mask&~(left|down|right) ))
+-+-+-+-+-+  row
| | | |Q| |   0  
+-+-+-+-+-+      
|1|1|0|0|0|   1  11000 = 31
+-+-+-+-+-+      
| | | | | |   2
+-+-+-+-+-+
| | | | | |   3
+-+-+-+-+-+
| | | | | |   4
+-+-+-+-+-+
```

これで効きのない場所を特定することができました。
１がクイーンを配置できる場所、いわゆる効き筋に当たらない場所ということになります。

あとは、効き筋に当たらない場所を順番にQを置いて行けばよいということになります。順番にひとつひとつつまみ出して行く方法は後述します。


ここまでの処理をbashで書くと以下の通りになります。
``` bash:masktest.sh
#!/usr/bin/bash

mask=31; # 2#11111
left=4;  # 2#00100
down=2;  # 2#00010
right=1; # 2#00001

# (left|down|right)を反転させてmaskで間引く
bitmap=$(( mask&~(left|down|right) ))

# 間引いた１０進数を２進数にして確認
bc<<<"ibase=10;obase=2;$bitmap"
```

実行結果は以下のとおりです。
```
bash-3.2$ bash masktest.sh
11000
```

## 斜めの効き筋
ビットマッププログラムのポイントは、斜めの利き筋のチェックをビット演算で行うことです。

```
    0 1 2 3 4
  *-------------
  | . . . . . .
  | . . . -3. .  0x02
  | . . -2. . .  0x04
  | . -1. . . .  0x08 (1 bit 右シフト)
  | Q . . . . .  0x10 (Q の位置は 4)
  | . +1. . . .  0x20 (1 bit 左シフト)  
  | . . +2. . .  0x40
  | . . . +3. .  0x80
  *-------------
```

ビットマップで肝となるところはここです。
``` bash
# 一番右のビットを取り出す
bit=$(( -bitmap & bitmap ));    

# 配置可能なパターンが一つずつ取り出される
bitmap=$((bitmap&~bit)) ;       
```

この演算式の意味を理解するには、負の値がコンピュータにおける２進法ではどのように表現されているのかを知る必要があります。

負の値を２進数で表すと次のようになります。
```
 00000011   3
 00000010   2
 00000001   1
 00000000   0
 11111111  -1
 11111110  -2
 11111101  -3
```

正の値を負の値（補数と言います）にするときは、Ｒをビット反転してから＋１します。
```

 00000001   1
 11111110   反転
 11111111   -1 （1を加える）

 00000010   2
 11111101  反転
 11111110  -2  （１を加える）
```

加えるところがわかりにくいですね。
```
 00000001   1
```
 に１を加えると
```
 00000010   2
```
さらに１を加えると
```
00000011   3
```

と、なります。
１０進数の足し算と２進数のインクリメントは異なるところに注意が必要です。

ここで、 正の値２２と−２２をＡＮＤ演算すると以下のようになります。
```
     00010110   22
 AND 11101010  -22
------------------
     00000010
```

Ｎを２進法で表したときの一番下位のＯＮビットがひとつだけ抽出される結果が得られ、極めて簡単な演算によって１ビット抽出を実現させていることが重要です。

余談ですが、
bashで２進数を１０進数に変換するには以下のようにしました。
```
bash-3.2$ echo $(( 2#01000 ));
8
```

bashで１０進数を２進数に変換するには以下のようにします。
```
bash-3.2$ bc <<<"ibase=10;obase=10;8"
1000
```
余談終わり。


そこで下のようなwhile文を書けば、ループが bitmap のONビットの数の回数だけループすることになり、配置可能なパターンをひとつずつ全く無駄がループがなく生成されることになります。

``` bash
  # 配置可能な場所を特定
  bitmap=$(( mask&~(left|down|right) ));
  while (( bitmap ));do
    bit=$((-bitmap&bitmap)) ;  # 一番右のビットを取り出す
    bitmap=$((bitmap&~bit)) ;  # 配置可能なパターンが一つずつ取り出される
    board[$row]="$bit";        # Qを配置
    bitmap_R "$size" "$((row+1))" "$(( (left|bit)<<1 ))" "$((down|bit))" "$(( (right|bit)>>1 ))";
  done
```

`left` `down` `right` は、Qが配置されるたびに、その効き筋を足し合わせ、すべてのrowの効き筋に対応します。

再帰では、こうしたことをプログラマが意識することなく実現できるわけですが、非再帰の場合は、`left` `down` `right` を配列などで効き筋を覚えておく必要が出てきます。

それはどうとして猛烈にわかりやすい図がありました。
<img src=bitmap.jpg width=80%>



## ソースコード
ソースの一番下で、再帰・非再帰を切換えて事項してください。

``` bash:bitmap.sh
#!/usr/bin/bash

declare -i TOTAL=0;     # カウンター
#
: 'ボードレイアウトを出力';
function printRecord()
{
  size="$1";
  flag="$2"; # bitmap版は1 それ以外は 0
  echo "$TOTAL";
  sEcho=" ";  
  : 'ビットマップ版
     ビットマップ版からは、左から数えます
     上下反転左右対称なので、これまでの上から数える手法と
     rowを下にたどって左から数える方法と解の数に変わりはありません。
     0 2 4 1 3 
    +-+-+-+-+-+
    |O| | | | | 0
    +-+-+-+-+-+
    | | |O| | | 2
    +-+-+-+-+-+
    | | | | |O| 4
    +-+-+-+-+-+
    | |O| | | | 1
    +-+-+-+-+-+
    | | | |O| | 3
    +-+-+-+-+-+
  ';
  if ((flag));then
    for((i=0;i<size;i++)){
      for((j=0;j<size;j++)){
        if (( board[i]&1<<j ));then
          sEcho="${sEcho}$((j)) ";
        fi 
      }
    }
  else 
  : 'ビットマップ版以外
     (ブルートフォース、バックトラック、配置フラグ)
     上から数えます
     0 2 4 1 3 
    +-+-+-+-+-+
    |O| | | | |
    +-+-+-+-+-+
    | | | |O| |
    +-+-+-+-+-+
    | |O| | | |
    +-+-+-+-+-+
    | | | | |O|
    +-+-+-+-+-+
    | | |O| | |
    +-+-+-+-+-+

     ';
    for((i=0;i<size;i++)){
      sEcho="${sEcho}${board[i]} ";
    }
  fi
  echo "$sEcho";

  echo -n "+";
  for((i=0;i<size;i++)){
    echo -n "-";
    if((i<(size-1)));then
      echo -n "+";
    fi
  }
  echo "+";
  for((i=0;i<size;i++)){
    echo -n "|";
    for((j=0;j<size;j++)){
      if ((flag));then
        if (( board[i]&1<<j ));then
          echo -n "O";
        else
          echo -n " ";
        fi
      else
        if((i==board[j]));then
          echo -n "O";
        else
          echo -n " ";
        fi
      fi
      if((j<(size-1)));then
        echo -n "|";
      fi
    }
  echo "|";
  if((i<(size-1)));then
    echo -n "+";
    for((j=0;j<size;j++)){
      echo -n "-";
      if((j<(size-1)));then
        echo -n "+";
      fi
    }
  echo "+";
  fi
  }
  echo -n "+";
  for((i=0;i<size;i++)){
    echo -n "-";
    if((i<(size-1)));then
      echo -n "+";
    fi
  }  
  echo "+";
  echo "";
}
#
: '非再帰版ビットマップ';
function bitmap_NR()
{
  local -i size="$1";
  local -i row="$2";
  local -i mask=$(( (1<<size)-1 ));
  local -i bitmap;
  local -i bit;
  local -a left[$size];
  local -a down[$size];
  local -a right[$size];
  local -a tmpBoard[$size];         #各rowのleft,right,downを足した配列
  local -a board[$size];            #クイーンを配置した場所を格納する配列
  bitmap=mask;
  while true ;do
    if (( bitmap ));then
      bit=$(( -bitmap&bitmap ));    # 一番右のビットを取り出す 
      bitmap=$(( bitmap^bit ));     # 配置可能なパターンが一つずつ取り出される
      board[$row]="$bit";           # Qを配置
      if (( row==(size-1) ));then
        ((TOTAL++));
        printRecord "$size" "1";    # 出力 1:bitmap版 0:それ以外
        bitmap=tmpBoard[row];
        ((--row));
        continue;
      else
        local -i n=$((row++));
        left[$row]=$(((  left[n]|bit)<<1 ));
        down[$row]=$((   down[n]|bit ));
        right[$row]=$(((right[n]|bit)>>1 ));
        tmpBoard[$row]=$bitmap;
        board[$row]="$bit";         # Qを配置
        bitmap=$(( mask&~(left[row]|down[row]|right[row]) ));
        continue;
      fi
    else
      bitmap=tmpBoard[row];
      if (( row==0));then
        break ;
      fi
      (( row-- ));
      continue
    fi
  done 
}
#
: '再帰版ビットマップ';
function bitmap_R()
{
  local -i size="$1"; local -i row="$2";
  local -i left="$3"; local -i down="$4"; local -i right="$5";
  local -i bitmap=;
  local -i bit=;
  local -i col=0;                     # 再帰に必要
  local -i mask=$(( (1<<size)-1 ));
  if (( row==size ));then
     ((TOTAL++));
     printRecord "$size" "1";         # 出力 1:bitmap版 0:それ以外
  else
    bitmap=$(( mask&~(left|down|right) ));
    while (( bitmap ));do
      bit=$((-bitmap&bitmap)) ;       # 一番右のビットを取り出す
      bitmap=$((bitmap&~bit)) ;       # 配置可能なパターンが一つずつ取り出される
      board[$row]="$bit";             # Qを配置
      bitmap_R "$size" "$((row+1))" "$(( (left|bit)<<1 ))" "$((down|bit))" "$(( (right|bit)>>1 ))";
    done
  fi
}
# 非再帰版ビットマップ
#time bitmap_NR 5 0;
#
# 再帰版ビットマップ
time bitmap_R 5 0 0 0 0;    
 echo "$TOTAL";
#
exit;
```


## 実行結果
実行結果は以下のとおりです。

```
1
 0 2 4 1 3 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

2
 0 3 1 4 2 
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

3
 1 3 0 2 4 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

4
 1 4 2 0 3 
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+

5
 2 0 3 1 4 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+

6
 2 4 1 3 0 
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

7
 3 0 2 4 1 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

8
 3 1 4 2 0 
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+

9
 4 1 3 0 2 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+

10
 4 2 0 3 1 
+-+-+-+-+-+
| | | | |O|
+-+-+-+-+-+
| | |O| | |
+-+-+-+-+-+
|O| | | | |
+-+-+-+-+-+
| | | |O| |
+-+-+-+-+-+
| |O| | | |
+-+-+-+-+-+

10

real	0m0.025s
user	0m0.022s
sys	0m0.002s

```  


## リンクと過去記事
N-Queens問題：Ｎクイーン問題（１２）第二章　まとめ
https://suzukiiichiro.github.io/posts/2023-03-17-02-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（１１）第二章　配置フラグの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-17-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（１０）第二章　バックトラックの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-16-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（９）第二章　ブルートフォースの再帰・非再帰
https://suzukiiichiro.github.io/posts/2023-03-14-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（８）第一章　まとめ
https://suzukiiichiro.github.io/posts/2023-03-09-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（７）第一章　ブルートフォース再び
https://suzukiiichiro.github.io/posts/2023-03-08-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（６）第一章　配置フラグ
https://suzukiiichiro.github.io/posts/2023-03-07-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（５）第一章　進捗表示テーブルの作成
https://suzukiiichiro.github.io/posts/2023-03-06-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（４）第一章　バックトラック
https://suzukiiichiro.github.io/posts/2023-02-21-01-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（３）第一章　バックトラック準備編
https://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（２）第一章　ブルートフォース
https://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/
N-Queens問題：Ｎクイーン問題（１）第一章　エイトクイーンについて
https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/

エイト・クイーンのソース置き場 BashもJavaもPythonも！
https://github.com/suzukiiichiro/N-Queens




## 書籍の紹介
{{% amazon

title="詳解 シェルスクリプト 大型本  2006/1/16"

url="https://www.amazon.co.jp/gp/proteect/4873112672/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4873112672&linkCode=as2&tag=nlpqueens09-22&linkId=ef087fd92d3628bb94e1eb10cb202d43"

summary=`Unixのプログラムは「ツール」と呼ばれます。
Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。
そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。
また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。
つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。
本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。
標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、
目的の処理を実現するための方法を詳しく学ぶことができます。
`
imageUrl="https://m.media-amazon.com/images/I/51EAPCH56ML._SL250_.jpg"
%}}

{{% amazon

title="UNIXシェルスクリプト マスターピース132"

url="https://www.amazon.co.jp/gp/proteect/4797377623/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797377623&linkCode=as2&tag=nlpqueens09-22&linkId=3c8d4566263ae99374221c4f8f469154"

summary=`すべてのUNIXエンジニア必携!!

サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。
知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。
`
imageUrl="https://m.media-amazon.com/images/I/51R5SZKrEAL._SL250_.jpg"
%}}


{{% amazon

title="[改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB+DB PRESS plus) 単行本（ソフトカバー）  2017/1/20"

url="https://www.amazon.co.jp/gp/proteect/4774186945/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4774186945&linkCode=as2&tag=nlpqueens09-22&linkId=8ef3ff961c569212e910cf3d6e37dcb6"

summary=`定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。
シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。
本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、
基本から丁寧に解説。
第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。
合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。
ますますパワーアップした改訂版をお届けします。`
imageUrl="https://m.media-amazon.com/images/I/41i956UyusL._SL250_.jpg"
%}}

{{% amazon

title="新しいシェルプログラミングの教科書 単行本"

url="https://www.amazon.co.jp/gp/proteect/4797393106/ref=as_li_tl?ie=UTF8&camp=247&creative=1211&creativeASIN=4797393106&linkCode=as2&tag=nlpqueens09-22&linkId=f514a6378c1c10e59ab16275745c2439"

summary=`エキスパートを目指せ!!

システム管理やソフトウェア開発など、
実際の業務では欠かせないシェルスクリプトの知識を徹底解説

ほとんどのディストリビューションでデフォルトとなっているbashに特化することで、
類書と差別化を図るとともに、より実践的なプログラミングを紹介します。
またプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。
イマドキのエンジニア必携の一冊。

▼目次
CHAPTER01 シェルってなんだろう
CHAPTER02 シェルスクリプトとは何か
CHAPTER03 シェルスクリプトの基本
CHAPTER04 変数
CHAPTER05 クォーティング
CHAPTER06 制御構造
CHAPTER07 リダイレクトとパイプ
CHAPTER08 関数
CHAPTER09 組み込みコマンド
CHAPTER10 正規表現と文字列
CHAPTER11 シェルスクリプトの実行方法
CHAPTER12 シェルスクリプトのサンプルで学ぼう
CHAPTER13 シェルスクリプトの実用例
CHAPTER14 テストとデバッグ
CHAPTER15 読みやすいシェルスクリプト
`
imageUrl="https://m.media-amazon.com/images/I/41d1D6rgDiL._SL250_.jpg"
%}}








